{"ast":null,"code":"import { FileLoader, Loader, Matrix4, Vector3 } from 'three';\nimport * as fflate from '../libs/fflate.module.js';\nimport { Volume } from '../misc/Volume.js';\n\n/**\n * A loader for the NRRD format.\n *\n * ```js\n * const loader = new NRRDLoader();\n * const volume = await loader.loadAsync( 'models/nrrd/I.nrrd' );\n * ```\n *\n * @augments Loader\n * @three_import import { NRRDLoader } from 'three/addons/loaders/NRRDLoader.js';\n */\nclass NRRDLoader extends Loader {\n  /**\n   * Constructs a new NRRD loader.\n   *\n   * @param {LoadingManager} [manager] - The loading manager.\n   */\n  constructor(manager) {\n    super(manager);\n  }\n\n  /**\n   * Starts loading from the given URL and passes the loaded NRRD asset\n   * to the `onLoad()` callback.\n   *\n   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n   * @param {function(Volume)} onLoad - Executed when the loading process has been finished.\n   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n   * @param {onErrorCallback} onError - Executed when errors occur.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (data) {\n      try {\n        onLoad(scope.parse(data));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  /**\n   * Toggles the segmentation mode.\n   *\n   * @param {boolean} segmentation - Whether to use segmentation mode or not.\n   */\n  setSegmentation(segmentation) {\n    this.segmentation = segmentation;\n  }\n\n  /**\n   * Parses the given NRRD data and returns the resulting volume data.\n   *\n   * @param {ArrayBuffer} data - The raw NRRD data as an array buffer.\n   * @return {Volume} The parsed volume.\n   */\n  parse(data) {\n    // this parser is largely inspired from the XTK NRRD parser : https://github.com/xtk/X\n\n    let _data = data;\n    let _dataPointer = 0;\n    const _nativeLittleEndian = new Int8Array(new Int16Array([1]).buffer)[0] > 0;\n    const _littleEndian = true;\n    const headerObject = {};\n    function scan(type, chunks) {\n      let _chunkSize = 1;\n      let _array_type = Uint8Array;\n      switch (type) {\n        // 1 byte data types\n        case 'uchar':\n          break;\n        case 'schar':\n          _array_type = Int8Array;\n          break;\n        // 2 byte data types\n        case 'ushort':\n          _array_type = Uint16Array;\n          _chunkSize = 2;\n          break;\n        case 'sshort':\n          _array_type = Int16Array;\n          _chunkSize = 2;\n          break;\n        // 4 byte data types\n        case 'uint':\n          _array_type = Uint32Array;\n          _chunkSize = 4;\n          break;\n        case 'sint':\n          _array_type = Int32Array;\n          _chunkSize = 4;\n          break;\n        case 'float':\n          _array_type = Float32Array;\n          _chunkSize = 4;\n          break;\n        case 'complex':\n          _array_type = Float64Array;\n          _chunkSize = 8;\n          break;\n        case 'double':\n          _array_type = Float64Array;\n          _chunkSize = 8;\n          break;\n      }\n\n      // increase the data pointer in-place\n      let _bytes = new _array_type(_data.slice(_dataPointer, _dataPointer += chunks * _chunkSize));\n\n      // if required, flip the endianness of the bytes\n      if (_nativeLittleEndian != _littleEndian) {\n        // we need to flip here since the format doesn't match the native endianness\n        _bytes = flipEndianness(_bytes, _chunkSize);\n      }\n\n      // return the byte array\n      return _bytes;\n    }\n\n    //Flips typed array endianness in-place. Based on https://github.com/kig/DataStream.js/blob/master/DataStream.js.\n\n    function flipEndianness(array, chunkSize) {\n      const u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n      for (let i = 0; i < array.byteLength; i += chunkSize) {\n        for (let j = i + chunkSize - 1, k = i; j > k; j--, k++) {\n          const tmp = u8[k];\n          u8[k] = u8[j];\n          u8[j] = tmp;\n        }\n      }\n      return array;\n    }\n\n    //parse the header\n    function parseHeader(header) {\n      let data, field, fn, i, l, m, _i, _len;\n      const lines = header.split(/\\r?\\n/);\n      for (_i = 0, _len = lines.length; _i < _len; _i++) {\n        l = lines[_i];\n        if (l.match(/NRRD\\d+/)) {\n          headerObject.isNrrd = true;\n        } else if (!l.match(/^#/) && (m = l.match(/(.*):(.*)/))) {\n          field = m[1].trim();\n          data = m[2].trim();\n          fn = _fieldFunctions[field];\n          if (fn) {\n            fn.call(headerObject, data);\n          } else {\n            headerObject[field] = data;\n          }\n        }\n      }\n      if (!headerObject.isNrrd) {\n        throw new Error('Not an NRRD file');\n      }\n      if (headerObject.encoding === 'bz2' || headerObject.encoding === 'bzip2') {\n        throw new Error('Bzip is not supported');\n      }\n      if (!headerObject.vectors) {\n        //if no space direction is set, let's use the identity\n        headerObject.vectors = [];\n        headerObject.vectors.push([1, 0, 0]);\n        headerObject.vectors.push([0, 1, 0]);\n        headerObject.vectors.push([0, 0, 1]);\n\n        //apply spacing if defined\n        if (headerObject.spacings) {\n          for (i = 0; i <= 2; i++) {\n            if (!isNaN(headerObject.spacings[i])) {\n              for (let j = 0; j <= 2; j++) {\n                headerObject.vectors[i][j] *= headerObject.spacings[i];\n              }\n            }\n          }\n        }\n      }\n    }\n\n    //parse the data when registered as one of this type : 'text', 'ascii', 'txt'\n    function parseDataAsText(data, start, end) {\n      let number = '';\n      start = start || 0;\n      end = end || data.length;\n      let value;\n      //length of the result is the product of the sizes\n      const lengthOfTheResult = headerObject.sizes.reduce(function (previous, current) {\n        return previous * current;\n      }, 1);\n      let base = 10;\n      if (headerObject.encoding === 'hex') {\n        base = 16;\n      }\n      const result = new headerObject.__array(lengthOfTheResult);\n      let resultIndex = 0;\n      let parsingFunction = parseInt;\n      if (headerObject.__array === Float32Array || headerObject.__array === Float64Array) {\n        parsingFunction = parseFloat;\n      }\n      for (let i = start; i < end; i++) {\n        value = data[i];\n        //if value is not a space\n        if ((value < 9 || value > 13) && value !== 32) {\n          number += String.fromCharCode(value);\n        } else {\n          if (number !== '') {\n            result[resultIndex] = parsingFunction(number, base);\n            resultIndex++;\n          }\n          number = '';\n        }\n      }\n      if (number !== '') {\n        result[resultIndex] = parsingFunction(number, base);\n        resultIndex++;\n      }\n      return result;\n    }\n    const _bytes = scan('uchar', data.byteLength);\n    const _length = _bytes.length;\n    let _header = null;\n    let _data_start = 0;\n    let i;\n    for (i = 1; i < _length; i++) {\n      if (_bytes[i - 1] == 10 && _bytes[i] == 10) {\n        // we found two line breaks in a row\n        // now we know what the header is\n        _header = this._parseChars(_bytes, 0, i - 2);\n        // this is were the data starts\n        _data_start = i + 1;\n        break;\n      }\n    }\n\n    // parse the header\n    parseHeader(_header);\n    _data = _bytes.subarray(_data_start); // the data without header\n    if (headerObject.encoding.substring(0, 2) === 'gz') {\n      // we need to decompress the datastream\n      // here we start the unzipping and get a typed Uint8Array back\n      _data = fflate.gunzipSync(new Uint8Array(_data));\n    } else if (headerObject.encoding === 'ascii' || headerObject.encoding === 'text' || headerObject.encoding === 'txt' || headerObject.encoding === 'hex') {\n      _data = parseDataAsText(_data);\n    } else if (headerObject.encoding === 'raw') {\n      //we need to copy the array to create a new array buffer, else we retrieve the original arraybuffer with the header\n      const _copy = new Uint8Array(_data.length);\n      for (let i = 0; i < _data.length; i++) {\n        _copy[i] = _data[i];\n      }\n      _data = _copy;\n    }\n\n    // .. let's use the underlying array buffer\n    _data = _data.buffer;\n    const volume = new Volume();\n    volume.header = headerObject;\n    volume.segmentation = this.segmentation;\n    //\n    // parse the (unzipped) data to a datastream of the correct type\n    //\n    volume.data = new headerObject.__array(_data);\n    // get the min and max intensities\n    const min_max = volume.computeMinMax();\n    const min = min_max[0];\n    const max = min_max[1];\n    // attach the scalar range to the volume\n    volume.windowLow = min;\n    volume.windowHigh = max;\n\n    // get the image dimensions\n    volume.dimensions = [headerObject.sizes[0], headerObject.sizes[1], headerObject.sizes[2]];\n    volume.xLength = volume.dimensions[0];\n    volume.yLength = volume.dimensions[1];\n    volume.zLength = volume.dimensions[2];\n\n    // Identify axis order in the space-directions matrix from the header if possible.\n    if (headerObject.vectors) {\n      const xIndex = headerObject.vectors.findIndex(vector => vector[0] !== 0);\n      const yIndex = headerObject.vectors.findIndex(vector => vector[1] !== 0);\n      const zIndex = headerObject.vectors.findIndex(vector => vector[2] !== 0);\n      const axisOrder = [];\n      if (xIndex !== yIndex && xIndex !== zIndex && yIndex !== zIndex) {\n        axisOrder[xIndex] = 'x';\n        axisOrder[yIndex] = 'y';\n        axisOrder[zIndex] = 'z';\n      } else {\n        axisOrder[0] = 'x';\n        axisOrder[1] = 'y';\n        axisOrder[2] = 'z';\n      }\n      volume.axisOrder = axisOrder;\n    } else {\n      volume.axisOrder = ['x', 'y', 'z'];\n    }\n\n    // spacing\n    const spacingX = new Vector3().fromArray(headerObject.vectors[0]).length();\n    const spacingY = new Vector3().fromArray(headerObject.vectors[1]).length();\n    const spacingZ = new Vector3().fromArray(headerObject.vectors[2]).length();\n    volume.spacing = [spacingX, spacingY, spacingZ];\n\n    // Create IJKtoRAS matrix\n    volume.matrix = new Matrix4();\n    const transitionMatrix = new Matrix4();\n    if (headerObject.space === 'left-posterior-superior') {\n      transitionMatrix.set(-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    } else if (headerObject.space === 'left-anterior-superior') {\n      transitionMatrix.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1);\n    }\n    if (!headerObject.vectors) {\n      volume.matrix.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    } else {\n      const v = headerObject.vectors;\n      const ijk_to_transition = new Matrix4().set(v[0][0], v[1][0], v[2][0], 0, v[0][1], v[1][1], v[2][1], 0, v[0][2], v[1][2], v[2][2], 0, 0, 0, 0, 1);\n      const transition_to_ras = new Matrix4().multiplyMatrices(ijk_to_transition, transitionMatrix);\n      volume.matrix = transition_to_ras;\n    }\n    volume.inverseMatrix = new Matrix4();\n    volume.inverseMatrix.copy(volume.matrix).invert();\n    volume.RASDimensions = [Math.floor(volume.xLength * spacingX), Math.floor(volume.yLength * spacingY), Math.floor(volume.zLength * spacingZ)];\n\n    // .. and set the default threshold\n    // only if the threshold was not already set\n    if (volume.lowerThreshold === -Infinity) {\n      volume.lowerThreshold = min;\n    }\n    if (volume.upperThreshold === Infinity) {\n      volume.upperThreshold = max;\n    }\n    return volume;\n  }\n  _parseChars(array, start, end) {\n    // without borders, use the whole array\n    if (start === undefined) {\n      start = 0;\n    }\n    if (end === undefined) {\n      end = array.length;\n    }\n    let output = '';\n    // create and append the chars\n    let i = 0;\n    for (i = start; i < end; ++i) {\n      output += String.fromCharCode(array[i]);\n    }\n    return output;\n  }\n}\nconst _fieldFunctions = {\n  type: function (data) {\n    switch (data) {\n      case 'uchar':\n      case 'unsigned char':\n      case 'uint8':\n      case 'uint8_t':\n        this.__array = Uint8Array;\n        break;\n      case 'signed char':\n      case 'int8':\n      case 'int8_t':\n        this.__array = Int8Array;\n        break;\n      case 'short':\n      case 'short int':\n      case 'signed short':\n      case 'signed short int':\n      case 'int16':\n      case 'int16_t':\n        this.__array = Int16Array;\n        break;\n      case 'ushort':\n      case 'unsigned short':\n      case 'unsigned short int':\n      case 'uint16':\n      case 'uint16_t':\n        this.__array = Uint16Array;\n        break;\n      case 'int':\n      case 'signed int':\n      case 'int32':\n      case 'int32_t':\n        this.__array = Int32Array;\n        break;\n      case 'uint':\n      case 'unsigned int':\n      case 'uint32':\n      case 'uint32_t':\n        this.__array = Uint32Array;\n        break;\n      case 'float':\n        this.__array = Float32Array;\n        break;\n      case 'double':\n        this.__array = Float64Array;\n        break;\n      default:\n        throw new Error('Unsupported NRRD data type: ' + data);\n    }\n    return this.type = data;\n  },\n  endian: function (data) {\n    return this.endian = data;\n  },\n  encoding: function (data) {\n    return this.encoding = data;\n  },\n  dimension: function (data) {\n    return this.dim = parseInt(data, 10);\n  },\n  sizes: function (data) {\n    let i;\n    return this.sizes = function () {\n      const _ref = data.split(/\\s+/);\n      const _results = [];\n      for (let _i = 0, _len = _ref.length; _i < _len; _i++) {\n        i = _ref[_i];\n        _results.push(parseInt(i, 10));\n      }\n      return _results;\n    }();\n  },\n  space: function (data) {\n    return this.space = data;\n  },\n  'space origin': function (data) {\n    return this.space_origin = data.split('(')[1].split(')')[0].split(',');\n  },\n  'space directions': function (data) {\n    let f, v;\n    const parts = data.match(/\\(.*?\\)/g);\n    return this.vectors = function () {\n      const _results = [];\n      for (let _i = 0, _len = parts.length; _i < _len; _i++) {\n        v = parts[_i];\n        _results.push(function () {\n          const _ref = v.slice(1, -1).split(/,/);\n          const _results2 = [];\n          for (let _j = 0, _len2 = _ref.length; _j < _len2; _j++) {\n            f = _ref[_j];\n            _results2.push(parseFloat(f));\n          }\n          return _results2;\n        }());\n      }\n      return _results;\n    }();\n  },\n  spacings: function (data) {\n    let f;\n    const parts = data.split(/\\s+/);\n    return this.spacings = function () {\n      const _results = [];\n      for (let _i = 0, _len = parts.length; _i < _len; _i++) {\n        f = parts[_i];\n        _results.push(parseFloat(f));\n      }\n      return _results;\n    }();\n  }\n};\nexport { NRRDLoader };","map":{"version":3,"names":["FileLoader","Loader","Matrix4","Vector3","fflate","Volume","NRRDLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","data","parse","e","console","error","itemError","setSegmentation","segmentation","_data","_dataPointer","_nativeLittleEndian","Int8Array","Int16Array","buffer","_littleEndian","headerObject","scan","type","chunks","_chunkSize","_array_type","Uint8Array","Uint16Array","Uint32Array","Int32Array","Float32Array","Float64Array","_bytes","slice","flipEndianness","array","chunkSize","u8","byteOffset","byteLength","i","j","k","tmp","parseHeader","header","field","fn","l","m","_i","_len","lines","split","length","match","isNrrd","trim","_fieldFunctions","call","Error","encoding","vectors","push","spacings","isNaN","parseDataAsText","start","end","number","value","lengthOfTheResult","sizes","reduce","previous","current","base","result","__array","resultIndex","parsingFunction","parseInt","parseFloat","String","fromCharCode","_length","_header","_data_start","_parseChars","subarray","substring","gunzipSync","_copy","volume","min_max","computeMinMax","min","max","windowLow","windowHigh","dimensions","xLength","yLength","zLength","xIndex","findIndex","vector","yIndex","zIndex","axisOrder","spacingX","fromArray","spacingY","spacingZ","spacing","matrix","transitionMatrix","space","set","v","ijk_to_transition","transition_to_ras","multiplyMatrices","inverseMatrix","copy","invert","RASDimensions","Math","floor","lowerThreshold","Infinity","upperThreshold","undefined","output","endian","dimension","dim","_ref","_results","space origin","space_origin","space directions","f","parts","_results2","_j","_len2"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/loaders/NRRDLoader.js"],"sourcesContent":["import {\n\tFileLoader,\n\tLoader,\n\tMatrix4,\n\tVector3\n} from 'three';\nimport * as fflate from '../libs/fflate.module.js';\nimport { Volume } from '../misc/Volume.js';\n\n/**\n * A loader for the NRRD format.\n *\n * ```js\n * const loader = new NRRDLoader();\n * const volume = await loader.loadAsync( 'models/nrrd/I.nrrd' );\n * ```\n *\n * @augments Loader\n * @three_import import { NRRDLoader } from 'three/addons/loaders/NRRDLoader.js';\n */\nclass NRRDLoader extends Loader {\n\n\t/**\n\t * Constructs a new NRRD loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded NRRD asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(Volume)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( data ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Toggles the segmentation mode.\n\t *\n\t * @param {boolean} segmentation - Whether to use segmentation mode or not.\n\t */\n\tsetSegmentation( segmentation ) {\n\n\t\tthis.segmentation = segmentation;\n\n\t}\n\n\t/**\n\t * Parses the given NRRD data and returns the resulting volume data.\n\t *\n\t * @param {ArrayBuffer} data - The raw NRRD data as an array buffer.\n\t * @return {Volume} The parsed volume.\n\t */\n\tparse( data ) {\n\n\t\t// this parser is largely inspired from the XTK NRRD parser : https://github.com/xtk/X\n\n\t\tlet _data = data;\n\n\t\tlet _dataPointer = 0;\n\n\t\tconst _nativeLittleEndian = new Int8Array( new Int16Array( [ 1 ] ).buffer )[ 0 ] > 0;\n\n\t\tconst _littleEndian = true;\n\n\t\tconst headerObject = {};\n\n\t\tfunction scan( type, chunks ) {\n\n\t\t\tlet _chunkSize = 1;\n\t\t\tlet _array_type = Uint8Array;\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\t// 1 byte data types\n\t\t\t\tcase 'uchar':\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'schar':\n\t\t\t\t\t_array_type = Int8Array;\n\t\t\t\t\tbreak;\n\t\t\t\t// 2 byte data types\n\t\t\t\tcase 'ushort':\n\t\t\t\t\t_array_type = Uint16Array;\n\t\t\t\t\t_chunkSize = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'sshort':\n\t\t\t\t\t_array_type = Int16Array;\n\t\t\t\t\t_chunkSize = 2;\n\t\t\t\t\tbreak;\n\t\t\t\t// 4 byte data types\n\t\t\t\tcase 'uint':\n\t\t\t\t\t_array_type = Uint32Array;\n\t\t\t\t\t_chunkSize = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'sint':\n\t\t\t\t\t_array_type = Int32Array;\n\t\t\t\t\t_chunkSize = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'float':\n\t\t\t\t\t_array_type = Float32Array;\n\t\t\t\t\t_chunkSize = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'complex':\n\t\t\t\t\t_array_type = Float64Array;\n\t\t\t\t\t_chunkSize = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'double':\n\t\t\t\t\t_array_type = Float64Array;\n\t\t\t\t\t_chunkSize = 8;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// increase the data pointer in-place\n\t\t\tlet _bytes = new _array_type( _data.slice( _dataPointer,\n\t\t\t\t_dataPointer += chunks * _chunkSize ) );\n\n\t\t\t// if required, flip the endianness of the bytes\n\t\t\tif ( _nativeLittleEndian != _littleEndian ) {\n\n\t\t\t\t// we need to flip here since the format doesn't match the native endianness\n\t\t\t\t_bytes = flipEndianness( _bytes, _chunkSize );\n\n\t\t\t}\n\n\t\t\t// return the byte array\n\t\t\treturn _bytes;\n\n\t\t}\n\n\t\t//Flips typed array endianness in-place. Based on https://github.com/kig/DataStream.js/blob/master/DataStream.js.\n\n\t\tfunction flipEndianness( array, chunkSize ) {\n\n\t\t\tconst u8 = new Uint8Array( array.buffer, array.byteOffset, array.byteLength );\n\t\t\tfor ( let i = 0; i < array.byteLength; i += chunkSize ) {\n\n\t\t\t\tfor ( let j = i + chunkSize - 1, k = i; j > k; j --, k ++ ) {\n\n\t\t\t\t\tconst tmp = u8[ k ];\n\t\t\t\t\tu8[ k ] = u8[ j ];\n\t\t\t\t\tu8[ j ] = tmp;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\t//parse the header\n\t\tfunction parseHeader( header ) {\n\n\t\t\tlet data, field, fn, i, l, m, _i, _len;\n\t\t\tconst lines = header.split( /\\r?\\n/ );\n\t\t\tfor ( _i = 0, _len = lines.length; _i < _len; _i ++ ) {\n\n\t\t\t\tl = lines[ _i ];\n\t\t\t\tif ( l.match( /NRRD\\d+/ ) ) {\n\n\t\t\t\t\theaderObject.isNrrd = true;\n\n\t\t\t\t} else if ( ! l.match( /^#/ ) && ( m = l.match( /(.*):(.*)/ ) ) ) {\n\n\t\t\t\t\tfield = m[ 1 ].trim();\n\t\t\t\t\tdata = m[ 2 ].trim();\n\t\t\t\t\tfn = _fieldFunctions[ field ];\n\t\t\t\t\tif ( fn ) {\n\n\t\t\t\t\t\tfn.call( headerObject, data );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\theaderObject[ field ] = data;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! headerObject.isNrrd ) {\n\n\t\t\t\tthrow new Error( 'Not an NRRD file' );\n\n\t\t\t}\n\n\t\t\tif ( headerObject.encoding === 'bz2' || headerObject.encoding === 'bzip2' ) {\n\n\t\t\t\tthrow new Error( 'Bzip is not supported' );\n\n\t\t\t}\n\n\t\t\tif ( ! headerObject.vectors ) {\n\n\t\t\t\t//if no space direction is set, let's use the identity\n\t\t\t\theaderObject.vectors = [ ];\n\t\t\t\theaderObject.vectors.push( [ 1, 0, 0 ] );\n\t\t\t\theaderObject.vectors.push( [ 0, 1, 0 ] );\n\t\t\t\theaderObject.vectors.push( [ 0, 0, 1 ] );\n\n\t\t\t\t//apply spacing if defined\n\t\t\t\tif ( headerObject.spacings ) {\n\n\t\t\t\t\tfor ( i = 0; i <= 2; i ++ ) {\n\n\t\t\t\t\t\tif ( ! isNaN( headerObject.spacings[ i ] ) ) {\n\n\t\t\t\t\t\t\tfor ( let j = 0; j <= 2; j ++ ) {\n\n\t\t\t\t\t\t\t\theaderObject.vectors[ i ][ j ] *= headerObject.spacings[ i ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t//parse the data when registered as one of this type : 'text', 'ascii', 'txt'\n\t\tfunction parseDataAsText( data, start, end ) {\n\n\t\t\tlet number = '';\n\t\t\tstart = start || 0;\n\t\t\tend = end || data.length;\n\t\t\tlet value;\n\t\t\t//length of the result is the product of the sizes\n\t\t\tconst lengthOfTheResult = headerObject.sizes.reduce( function ( previous, current ) {\n\n\t\t\t\treturn previous * current;\n\n\t\t\t}, 1 );\n\n\t\t\tlet base = 10;\n\t\t\tif ( headerObject.encoding === 'hex' ) {\n\n\t\t\t\tbase = 16;\n\n\t\t\t}\n\n\t\t\tconst result = new headerObject.__array( lengthOfTheResult );\n\t\t\tlet resultIndex = 0;\n\t\t\tlet parsingFunction = parseInt;\n\t\t\tif ( headerObject.__array === Float32Array || headerObject.__array === Float64Array ) {\n\n\t\t\t\tparsingFunction = parseFloat;\n\n\t\t\t}\n\n\t\t\tfor ( let i = start; i < end; i ++ ) {\n\n\t\t\t\tvalue = data[ i ];\n\t\t\t\t//if value is not a space\n\t\t\t\tif ( ( value < 9 || value > 13 ) && value !== 32 ) {\n\n\t\t\t\t\tnumber += String.fromCharCode( value );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( number !== '' ) {\n\n\t\t\t\t\t\tresult[ resultIndex ] = parsingFunction( number, base );\n\t\t\t\t\t\tresultIndex ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnumber = '';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( number !== '' ) {\n\n\t\t\t\tresult[ resultIndex ] = parsingFunction( number, base );\n\t\t\t\tresultIndex ++;\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tconst _bytes = scan( 'uchar', data.byteLength );\n\t\tconst _length = _bytes.length;\n\t\tlet _header = null;\n\t\tlet _data_start = 0;\n\t\tlet i;\n\t\tfor ( i = 1; i < _length; i ++ ) {\n\n\t\t\tif ( _bytes[ i - 1 ] == 10 && _bytes[ i ] == 10 ) {\n\n\t\t\t\t// we found two line breaks in a row\n\t\t\t\t// now we know what the header is\n\t\t\t\t_header = this._parseChars( _bytes, 0, i - 2 );\n\t\t\t\t// this is were the data starts\n\t\t\t\t_data_start = i + 1;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// parse the header\n\t\tparseHeader( _header );\n\n\t\t_data = _bytes.subarray( _data_start ); // the data without header\n\t\tif ( headerObject.encoding.substring( 0, 2 ) === 'gz' ) {\n\n\t\t\t// we need to decompress the datastream\n\t\t\t// here we start the unzipping and get a typed Uint8Array back\n\t\t\t_data = fflate.gunzipSync( new Uint8Array( _data ) );\n\n\t\t} else if ( headerObject.encoding === 'ascii' || headerObject.encoding === 'text' || headerObject.encoding === 'txt' || headerObject.encoding === 'hex' ) {\n\n\t\t\t_data = parseDataAsText( _data );\n\n\t\t} else if ( headerObject.encoding === 'raw' ) {\n\n\t\t\t//we need to copy the array to create a new array buffer, else we retrieve the original arraybuffer with the header\n\t\t\tconst _copy = new Uint8Array( _data.length );\n\n\t\t\tfor ( let i = 0; i < _data.length; i ++ ) {\n\n\t\t\t\t_copy[ i ] = _data[ i ];\n\n\t\t\t}\n\n\t\t\t_data = _copy;\n\n\t\t}\n\n\t\t// .. let's use the underlying array buffer\n\t\t_data = _data.buffer;\n\n\t\tconst volume = new Volume();\n\t\tvolume.header = headerObject;\n\t\tvolume.segmentation = this.segmentation;\n\t\t//\n\t\t// parse the (unzipped) data to a datastream of the correct type\n\t\t//\n\t\tvolume.data = new headerObject.__array( _data );\n\t\t// get the min and max intensities\n\t\tconst min_max = volume.computeMinMax();\n\t\tconst min = min_max[ 0 ];\n\t\tconst max = min_max[ 1 ];\n\t\t// attach the scalar range to the volume\n\t\tvolume.windowLow = min;\n\t\tvolume.windowHigh = max;\n\n\t\t// get the image dimensions\n\t\tvolume.dimensions = [ headerObject.sizes[ 0 ], headerObject.sizes[ 1 ], headerObject.sizes[ 2 ] ];\n\t\tvolume.xLength = volume.dimensions[ 0 ];\n\t\tvolume.yLength = volume.dimensions[ 1 ];\n\t\tvolume.zLength = volume.dimensions[ 2 ];\n\n\t\t// Identify axis order in the space-directions matrix from the header if possible.\n\t\tif ( headerObject.vectors ) {\n\n\t\t\tconst xIndex = headerObject.vectors.findIndex( vector => vector[ 0 ] !== 0 );\n\t\t\tconst yIndex = headerObject.vectors.findIndex( vector => vector[ 1 ] !== 0 );\n\t\t\tconst zIndex = headerObject.vectors.findIndex( vector => vector[ 2 ] !== 0 );\n\n\t\t\tconst axisOrder = [];\n\n\t\t\tif ( xIndex !== yIndex && xIndex !== zIndex && yIndex !== zIndex ) {\n\n\t\t\t\taxisOrder[ xIndex ] = 'x';\n\t\t\t\taxisOrder[ yIndex ] = 'y';\n\t\t\t\taxisOrder[ zIndex ] = 'z';\n\n\t\t\t} else {\n\n\t\t\t\taxisOrder[ 0 ] = 'x';\n\t\t\t\taxisOrder[ 1 ] = 'y';\n\t\t\t\taxisOrder[ 2 ] = 'z';\n\n\t\t\t}\n\n\t\t\tvolume.axisOrder = axisOrder;\n\n\t\t} else {\n\n\t\t\tvolume.axisOrder = [ 'x', 'y', 'z' ];\n\n\t\t}\n\n\t\t// spacing\n\t\tconst spacingX = new Vector3().fromArray( headerObject.vectors[ 0 ] ).length();\n\t\tconst spacingY = new Vector3().fromArray( headerObject.vectors[ 1 ] ).length();\n\t\tconst spacingZ = new Vector3().fromArray( headerObject.vectors[ 2 ] ).length();\n\t\tvolume.spacing = [ spacingX, spacingY, spacingZ ];\n\n\n\t\t// Create IJKtoRAS matrix\n\t\tvolume.matrix = new Matrix4();\n\n\t\tconst transitionMatrix = new Matrix4();\n\n\t\tif ( headerObject.space === 'left-posterior-superior' ) {\n\n\t\t\ttransitionMatrix.set(\n\t\t\t\t- 1, 0, 0, 0,\n\t\t\t\t0, - 1, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\t0, 0, 0, 1\n\t\t\t);\n\n\t\t} else if ( headerObject.space === 'left-anterior-superior' ) {\n\n\t\t\ttransitionMatrix.set(\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\t0, 0, - 1, 0,\n\t\t\t\t0, 0, 0, 1\n\t\t\t);\n\n\t\t}\n\n\n\t\tif ( ! headerObject.vectors ) {\n\n\t\t\tvolume.matrix.set(\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\t0, 0, 0, 1 );\n\n\t\t} else {\n\n\t\t\tconst v = headerObject.vectors;\n\n\t\t\tconst ijk_to_transition = new Matrix4().set(\n\t\t\t\tv[ 0 ][ 0 ], v[ 1 ][ 0 ], v[ 2 ][ 0 ], 0,\n\t\t\t\tv[ 0 ][ 1 ], v[ 1 ][ 1 ], v[ 2 ][ 1 ], 0,\n\t\t\t\tv[ 0 ][ 2 ], v[ 1 ][ 2 ], v[ 2 ][ 2 ], 0,\n\t\t\t\t0, 0, 0, 1\n\t\t\t);\n\n\t\t\tconst transition_to_ras = new Matrix4().multiplyMatrices( ijk_to_transition, transitionMatrix );\n\n\t\t\tvolume.matrix = transition_to_ras;\n\n\t\t}\n\n\t\tvolume.inverseMatrix = new Matrix4();\n\t\tvolume.inverseMatrix.copy( volume.matrix ).invert();\n\n\t\tvolume.RASDimensions = [\n\t\t\tMath.floor( volume.xLength * spacingX ),\n\t\t\tMath.floor( volume.yLength * spacingY ),\n\t\t\tMath.floor( volume.zLength * spacingZ )\n\t\t];\n\n\t\t// .. and set the default threshold\n\t\t// only if the threshold was not already set\n\t\tif ( volume.lowerThreshold === - Infinity ) {\n\n\t\t\tvolume.lowerThreshold = min;\n\n\t\t}\n\n\t\tif ( volume.upperThreshold === Infinity ) {\n\n\t\t\tvolume.upperThreshold = max;\n\n\t\t}\n\n\t\treturn volume;\n\n\t}\n\n\t_parseChars( array, start, end ) {\n\n\t\t// without borders, use the whole array\n\t\tif ( start === undefined ) {\n\n\t\t\tstart = 0;\n\n\t\t}\n\n\t\tif ( end === undefined ) {\n\n\t\t\tend = array.length;\n\n\t\t}\n\n\t\tlet output = '';\n\t\t// create and append the chars\n\t\tlet i = 0;\n\t\tfor ( i = start; i < end; ++ i ) {\n\n\t\t\toutput += String.fromCharCode( array[ i ] );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nconst _fieldFunctions = {\n\n\ttype: function ( data ) {\n\n\t\tswitch ( data ) {\n\n\t\t\tcase 'uchar':\n\t\t\tcase 'unsigned char':\n\t\t\tcase 'uint8':\n\t\t\tcase 'uint8_t':\n\t\t\t\tthis.__array = Uint8Array;\n\t\t\t\tbreak;\n\t\t\tcase 'signed char':\n\t\t\tcase 'int8':\n\t\t\tcase 'int8_t':\n\t\t\t\tthis.__array = Int8Array;\n\t\t\t\tbreak;\n\t\t\tcase 'short':\n\t\t\tcase 'short int':\n\t\t\tcase 'signed short':\n\t\t\tcase 'signed short int':\n\t\t\tcase 'int16':\n\t\t\tcase 'int16_t':\n\t\t\t\tthis.__array = Int16Array;\n\t\t\t\tbreak;\n\t\t\tcase 'ushort':\n\t\t\tcase 'unsigned short':\n\t\t\tcase 'unsigned short int':\n\t\t\tcase 'uint16':\n\t\t\tcase 'uint16_t':\n\t\t\t\tthis.__array = Uint16Array;\n\t\t\t\tbreak;\n\t\t\tcase 'int':\n\t\t\tcase 'signed int':\n\t\t\tcase 'int32':\n\t\t\tcase 'int32_t':\n\t\t\t\tthis.__array = Int32Array;\n\t\t\t\tbreak;\n\t\t\tcase 'uint':\n\t\t\tcase 'unsigned int':\n\t\t\tcase 'uint32':\n\t\t\tcase 'uint32_t':\n\t\t\t\tthis.__array = Uint32Array;\n\t\t\t\tbreak;\n\t\t\tcase 'float':\n\t\t\t\tthis.__array = Float32Array;\n\t\t\t\tbreak;\n\t\t\tcase 'double':\n\t\t\t\tthis.__array = Float64Array;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'Unsupported NRRD data type: ' + data );\n\n\t\t}\n\n\t\treturn this.type = data;\n\n\t},\n\n\tendian: function ( data ) {\n\n\t\treturn this.endian = data;\n\n\t},\n\n\tencoding: function ( data ) {\n\n\t\treturn this.encoding = data;\n\n\t},\n\n\tdimension: function ( data ) {\n\n\t\treturn this.dim = parseInt( data, 10 );\n\n\t},\n\n\tsizes: function ( data ) {\n\n\t\tlet i;\n\t\treturn this.sizes = ( function () {\n\n\t\t\tconst _ref = data.split( /\\s+/ );\n\t\t\tconst _results = [];\n\n\t\t\tfor ( let _i = 0, _len = _ref.length; _i < _len; _i ++ ) {\n\n\t\t\t\ti = _ref[ _i ];\n\t\t\t\t_results.push( parseInt( i, 10 ) );\n\n\t\t\t}\n\n\t\t\treturn _results;\n\n\t\t} )();\n\n\t},\n\n\tspace: function ( data ) {\n\n\t\treturn this.space = data;\n\n\t},\n\n\t'space origin': function ( data ) {\n\n\t\treturn this.space_origin = data.split( '(' )[ 1 ].split( ')' )[ 0 ].split( ',' );\n\n\t},\n\n\t'space directions': function ( data ) {\n\n\t\tlet f, v;\n\t\tconst parts = data.match( /\\(.*?\\)/g );\n\t\treturn this.vectors = ( function () {\n\n\t\t\tconst _results = [];\n\n\t\t\tfor ( let _i = 0, _len = parts.length; _i < _len; _i ++ ) {\n\n\t\t\t\tv = parts[ _i ];\n\t\t\t\t_results.push( ( function () {\n\n\t\t\t\t\tconst _ref = v.slice( 1, - 1 ).split( /,/ );\n\t\t\t\t\tconst _results2 = [];\n\n\t\t\t\t\tfor ( let _j = 0, _len2 = _ref.length; _j < _len2; _j ++ ) {\n\n\t\t\t\t\t\tf = _ref[ _j ];\n\t\t\t\t\t\t_results2.push( parseFloat( f ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn _results2;\n\n\t\t\t\t} )() );\n\n\t\t\t}\n\n\t\t\treturn _results;\n\n\t\t} )();\n\n\t},\n\n\tspacings: function ( data ) {\n\n\t\tlet f;\n\t\tconst parts = data.split( /\\s+/ );\n\t\treturn this.spacings = ( function () {\n\n\t\t\tconst _results = [];\n\n\t\t\tfor ( let _i = 0, _len = parts.length; _i < _len; _i ++ ) {\n\n\t\t\t\tf = parts[ _i ];\n\t\t\t\t_results.push( parseFloat( f ) );\n\n\t\t\t}\n\n\t\t\treturn _results;\n\n\t\t} )();\n\n\t}\n\n};\n\nexport { NRRDLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}