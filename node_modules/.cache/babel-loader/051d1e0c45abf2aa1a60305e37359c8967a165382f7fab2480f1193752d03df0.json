{"ast":null,"code":"import { ClampToEdgeWrapping, DataTexture, FloatType, NearestFilter, RGBAFormat, ShaderMaterial, WebGLRenderTarget } from 'three';\nimport { FullScreenQuad } from '../postprocessing/Pass.js';\n\n/**\n * GPUComputationRenderer, based on SimulationRenderer by @zz85.\n *\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\n * for each compute element (texel).\n *\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\n *\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\n * as inputs to render the textures of the next frame.\n *\n * The render targets of the variables can be used as input textures for your visualization shaders.\n *\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\n *\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\n * ```\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\n * ```\n * Basic use:\n * ```js\n * // Initialization...\n *\n * // Create computation renderer\n * const gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );\n *\n * // Create initial state float textures\n * const pos0 = gpuCompute.createTexture();\n * const vel0 = gpuCompute.createTexture();\n * // and fill in here the texture data...\n *\n * // Add texture variables\n * const velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, vel0 );\n * const posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, pos0 );\n *\n * // Add variable dependencies\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\n *\n * // Add custom uniforms\n * velVar.material.uniforms.time = { value: 0.0 };\n *\n * // Check for completeness\n * const error = gpuCompute.init();\n * if ( error !== null ) {\n *\t\tconsole.error( error );\n  * }\n *\n * // In each frame...\n *\n * // Compute!\n * gpuCompute.compute();\n *\n * // Update texture uniforms in your visualization materials with the gpu renderer output\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\n *\n * // Do your rendering\n * renderer.render( myScene, myCamera );\n * ```\n *\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\n * Note that the shaders can have multiple input textures.\n *\n * ```js\n * const myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\n * const myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\n *\n * const inputTexture = gpuCompute.createTexture();\n *\n * // Fill in here inputTexture...\n *\n * myFilter1.uniforms.theTexture.value = inputTexture;\n *\n * const myRenderTarget = gpuCompute.createRenderTarget();\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\n *\n * const outputRenderTarget = gpuCompute.createRenderTarget();\n *\n * // Now use the output texture where you want:\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\n *\n * // And compute each frame, before rendering to screen:\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\n * ```\n *\n * @three_import import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';\n */\nclass GPUComputationRenderer {\n  /**\n   * Constructs a new GPU computation renderer.\n   *\n   * @param {number} sizeX - Computation problem size is always 2d: sizeX * sizeY elements.\n  \t * @param {number} sizeY - Computation problem size is always 2d: sizeX * sizeY elements.\n  \t * @param {WebGLRenderer} renderer - The renderer.\n   */\n  constructor(sizeX, sizeY, renderer) {\n    this.variables = [];\n    this.currentTextureIndex = 0;\n    let dataType = FloatType;\n    const passThruUniforms = {\n      passThruTexture: {\n        value: null\n      }\n    };\n    const passThruShader = createShaderMaterial(getPassThroughFragmentShader(), passThruUniforms);\n    const quad = new FullScreenQuad(passThruShader);\n\n    /**\n     * Sets the data type of the internal textures.\n     *\n     * @param {(FloatType|HalfFloatType)} type - The type to set.\n     * @return {GPUComputationRenderer} A reference to this renderer.\n     */\n    this.setDataType = function (type) {\n      dataType = type;\n      return this;\n    };\n\n    /**\n     * Adds a compute variable to the renderer.\n     *\n     * @param {string} variableName - The variable name.\n     * @param {string} computeFragmentShader - The compute (fragment) shader source.\n     * @param {Texture} initialValueTexture - The initial value texture.\n     * @return {Object} The compute variable.\n     */\n    this.addVariable = function (variableName, computeFragmentShader, initialValueTexture) {\n      const material = this.createShaderMaterial(computeFragmentShader);\n      const variable = {\n        name: variableName,\n        initialValueTexture: initialValueTexture,\n        material: material,\n        dependencies: null,\n        renderTargets: [],\n        wrapS: null,\n        wrapT: null,\n        minFilter: NearestFilter,\n        magFilter: NearestFilter\n      };\n      this.variables.push(variable);\n      return variable;\n    };\n\n    /**\n     * Sets variable dependencies.\n     *\n     * @param {Object} variable - The compute variable.\n     * @param {Array<Object>} dependencies - Other compute variables that represents the dependencies.\n     */\n    this.setVariableDependencies = function (variable, dependencies) {\n      variable.dependencies = dependencies;\n    };\n\n    /**\n     * Initializes the renderer.\n     *\n     * @return {?string} Returns `null` if no errors are detected. Otherwise returns the error message.\n     */\n    this.init = function () {\n      if (renderer.capabilities.maxVertexTextures === 0) {\n        return 'No support for vertex shader textures.';\n      }\n      for (let i = 0; i < this.variables.length; i++) {\n        const variable = this.variables[i];\n\n        // Creates rendertargets and initialize them with input texture\n        variable.renderTargets[0] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);\n        variable.renderTargets[1] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);\n        this.renderTexture(variable.initialValueTexture, variable.renderTargets[0]);\n        this.renderTexture(variable.initialValueTexture, variable.renderTargets[1]);\n\n        // Adds dependencies uniforms to the ShaderMaterial\n        const material = variable.material;\n        const uniforms = material.uniforms;\n        if (variable.dependencies !== null) {\n          for (let d = 0; d < variable.dependencies.length; d++) {\n            const depVar = variable.dependencies[d];\n            if (depVar.name !== variable.name) {\n              // Checks if variable exists\n              let found = false;\n              for (let j = 0; j < this.variables.length; j++) {\n                if (depVar.name === this.variables[j].name) {\n                  found = true;\n                  break;\n                }\n              }\n              if (!found) {\n                return 'Variable dependency not found. Variable=' + variable.name + ', dependency=' + depVar.name;\n              }\n            }\n            uniforms[depVar.name] = {\n              value: null\n            };\n            material.fragmentShader = '\\nuniform sampler2D ' + depVar.name + ';\\n' + material.fragmentShader;\n          }\n        }\n      }\n      this.currentTextureIndex = 0;\n      return null;\n    };\n\n    /**\n     * Executes the compute. This method is usually called in the animation loop.\n     */\n    this.compute = function () {\n      const currentTextureIndex = this.currentTextureIndex;\n      const nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n      for (let i = 0, il = this.variables.length; i < il; i++) {\n        const variable = this.variables[i];\n\n        // Sets texture dependencies uniforms\n        if (variable.dependencies !== null) {\n          const uniforms = variable.material.uniforms;\n          for (let d = 0, dl = variable.dependencies.length; d < dl; d++) {\n            const depVar = variable.dependencies[d];\n            uniforms[depVar.name].value = depVar.renderTargets[currentTextureIndex].texture;\n          }\n        }\n\n        // Performs the computation for this variable\n        this.doRenderTarget(variable.material, variable.renderTargets[nextTextureIndex]);\n      }\n      this.currentTextureIndex = nextTextureIndex;\n    };\n\n    /**\n     * Returns the current render target for the given compute variable.\n     *\n     * @param {Object} variable - The compute variable.\n     * @return {WebGLRenderTarget} The current render target.\n     */\n    this.getCurrentRenderTarget = function (variable) {\n      return variable.renderTargets[this.currentTextureIndex];\n    };\n\n    /**\n     * Returns the alternate render target for the given compute variable.\n     *\n     * @param {Object} variable - The compute variable.\n     * @return {WebGLRenderTarget} The alternate render target.\n     */\n    this.getAlternateRenderTarget = function (variable) {\n      return variable.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];\n    };\n\n    /**\n     * Frees all internal resources. Call this method if you don't need the\n     * renderer anymore.\n     */\n    this.dispose = function () {\n      quad.dispose();\n      const variables = this.variables;\n      for (let i = 0; i < variables.length; i++) {\n        const variable = variables[i];\n        if (variable.initialValueTexture) variable.initialValueTexture.dispose();\n        const renderTargets = variable.renderTargets;\n        for (let j = 0; j < renderTargets.length; j++) {\n          const renderTarget = renderTargets[j];\n          renderTarget.dispose();\n        }\n      }\n    };\n    function addResolutionDefine(materialShader) {\n      materialShader.defines.resolution = 'vec2( ' + sizeX.toFixed(1) + ', ' + sizeY.toFixed(1) + ' )';\n    }\n\n    /**\n     * Adds a resolution defined for the given material shader.\n     *\n     * @param {Object} materialShader - The material shader.\n     */\n    this.addResolutionDefine = addResolutionDefine;\n\n    // The following functions can be used to compute things manually\n\n    function createShaderMaterial(computeFragmentShader, uniforms) {\n      uniforms = uniforms || {};\n      const material = new ShaderMaterial({\n        name: 'GPUComputationShader',\n        uniforms: uniforms,\n        vertexShader: getPassThroughVertexShader(),\n        fragmentShader: computeFragmentShader\n      });\n      addResolutionDefine(material);\n      return material;\n    }\n    this.createShaderMaterial = createShaderMaterial;\n\n    /**\n     * Creates a new render target from the given parameters.\n     *\n     * @param {number} sizeXTexture - The width of the render target.\n     * @param {number} sizeYTexture - The height of the render target.\n     * @param {number} wrapS - The wrapS value.\n     * @param {number} wrapT - The wrapS value.\n     * @param {number} minFilter - The minFilter value.\n     * @param {number} magFilter - The magFilter value.\n     * @return {WebGLRenderTarget} The new render target.\n     */\n    this.createRenderTarget = function (sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) {\n      sizeXTexture = sizeXTexture || sizeX;\n      sizeYTexture = sizeYTexture || sizeY;\n      wrapS = wrapS || ClampToEdgeWrapping;\n      wrapT = wrapT || ClampToEdgeWrapping;\n      minFilter = minFilter || NearestFilter;\n      magFilter = magFilter || NearestFilter;\n      const renderTarget = new WebGLRenderTarget(sizeXTexture, sizeYTexture, {\n        wrapS: wrapS,\n        wrapT: wrapT,\n        minFilter: minFilter,\n        magFilter: magFilter,\n        format: RGBAFormat,\n        type: dataType,\n        depthBuffer: false\n      });\n      return renderTarget;\n    };\n\n    /**\n     * Creates a new data texture.\n     *\n     * @return {DataTexture} The new data texture.\n     */\n    this.createTexture = function () {\n      const data = new Float32Array(sizeX * sizeY * 4);\n      const texture = new DataTexture(data, sizeX, sizeY, RGBAFormat, FloatType);\n      texture.needsUpdate = true;\n      return texture;\n    };\n\n    /**\n     * Renders the given texture into the given render target.\n     *\n     * @param {Texture} input - The input.\n     * @param {WebGLRenderTarget} output - The output.\n     */\n    this.renderTexture = function (input, output) {\n      passThruUniforms.passThruTexture.value = input;\n      this.doRenderTarget(passThruShader, output);\n      passThruUniforms.passThruTexture.value = null;\n    };\n\n    /**\n     * Renders the given material into the given render target\n     * with a full-screen pass.\n     *\n     * @param {Material} material - The material.\n     * @param {WebGLRenderTarget} output - The output.\n     */\n    this.doRenderTarget = function (material, output) {\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      renderer.xr.enabled = false; // Avoid camera modification\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n      quad.material = material;\n      renderer.setRenderTarget(output);\n      quad.render(renderer);\n      quad.material = passThruShader;\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget);\n    };\n\n    // Shaders\n\n    function getPassThroughVertexShader() {\n      return 'void main()\t{\\n' + '\\n' + '\tgl_Position = vec4( position, 1.0 );\\n' + '\\n' + '}\\n';\n    }\n    function getPassThroughFragmentShader() {\n      return 'uniform sampler2D passThruTexture;\\n' + '\\n' + 'void main() {\\n' + '\\n' + '\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n' + '\\n' + '\tgl_FragColor = texture2D( passThruTexture, uv );\\n' + '\\n' + '}\\n';\n    }\n  }\n}\nexport { GPUComputationRenderer };","map":{"version":3,"names":["ClampToEdgeWrapping","DataTexture","FloatType","NearestFilter","RGBAFormat","ShaderMaterial","WebGLRenderTarget","FullScreenQuad","GPUComputationRenderer","constructor","sizeX","sizeY","renderer","variables","currentTextureIndex","dataType","passThruUniforms","passThruTexture","value","passThruShader","createShaderMaterial","getPassThroughFragmentShader","quad","setDataType","type","addVariable","variableName","computeFragmentShader","initialValueTexture","material","variable","name","dependencies","renderTargets","wrapS","wrapT","minFilter","magFilter","push","setVariableDependencies","init","capabilities","maxVertexTextures","i","length","createRenderTarget","renderTexture","uniforms","d","depVar","found","j","fragmentShader","compute","nextTextureIndex","il","dl","texture","doRenderTarget","getCurrentRenderTarget","getAlternateRenderTarget","dispose","renderTarget","addResolutionDefine","materialShader","defines","resolution","toFixed","vertexShader","getPassThroughVertexShader","sizeXTexture","sizeYTexture","format","depthBuffer","createTexture","data","Float32Array","needsUpdate","input","output","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","render"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/misc/GPUComputationRenderer.js"],"sourcesContent":["import {\n\tClampToEdgeWrapping,\n\tDataTexture,\n\tFloatType,\n\tNearestFilter,\n\tRGBAFormat,\n\tShaderMaterial,\n\tWebGLRenderTarget\n} from 'three';\n\nimport { FullScreenQuad } from '../postprocessing/Pass.js';\n\n/**\n * GPUComputationRenderer, based on SimulationRenderer by @zz85.\n *\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\n * for each compute element (texel).\n *\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\n *\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\n * as inputs to render the textures of the next frame.\n *\n * The render targets of the variables can be used as input textures for your visualization shaders.\n *\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\n *\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\n * ```\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\n * ```\n * Basic use:\n * ```js\n * // Initialization...\n *\n * // Create computation renderer\n * const gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );\n *\n * // Create initial state float textures\n * const pos0 = gpuCompute.createTexture();\n * const vel0 = gpuCompute.createTexture();\n * // and fill in here the texture data...\n *\n * // Add texture variables\n * const velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, vel0 );\n * const posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, pos0 );\n *\n * // Add variable dependencies\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\n *\n * // Add custom uniforms\n * velVar.material.uniforms.time = { value: 0.0 };\n *\n * // Check for completeness\n * const error = gpuCompute.init();\n * if ( error !== null ) {\n *\t\tconsole.error( error );\n  * }\n *\n * // In each frame...\n *\n * // Compute!\n * gpuCompute.compute();\n *\n * // Update texture uniforms in your visualization materials with the gpu renderer output\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\n *\n * // Do your rendering\n * renderer.render( myScene, myCamera );\n * ```\n *\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\n * Note that the shaders can have multiple input textures.\n *\n * ```js\n * const myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\n * const myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\n *\n * const inputTexture = gpuCompute.createTexture();\n *\n * // Fill in here inputTexture...\n *\n * myFilter1.uniforms.theTexture.value = inputTexture;\n *\n * const myRenderTarget = gpuCompute.createRenderTarget();\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\n *\n * const outputRenderTarget = gpuCompute.createRenderTarget();\n *\n * // Now use the output texture where you want:\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\n *\n * // And compute each frame, before rendering to screen:\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\n * ```\n *\n * @three_import import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';\n */\nclass GPUComputationRenderer {\n\n\t/**\n\t * Constructs a new GPU computation renderer.\n\t *\n\t * @param {number} sizeX - Computation problem size is always 2d: sizeX * sizeY elements.\n \t * @param {number} sizeY - Computation problem size is always 2d: sizeX * sizeY elements.\n \t * @param {WebGLRenderer} renderer - The renderer.\n\t */\n\tconstructor( sizeX, sizeY, renderer ) {\n\n\t\tthis.variables = [];\n\n\t\tthis.currentTextureIndex = 0;\n\n\t\tlet dataType = FloatType;\n\n\t\tconst passThruUniforms = {\n\t\t\tpassThruTexture: { value: null }\n\t\t};\n\n\t\tconst passThruShader = createShaderMaterial( getPassThroughFragmentShader(), passThruUniforms );\n\n\t\tconst quad = new FullScreenQuad( passThruShader );\n\n\t\t/**\n\t\t * Sets the data type of the internal textures.\n\t\t *\n\t\t * @param {(FloatType|HalfFloatType)} type - The type to set.\n\t\t * @return {GPUComputationRenderer} A reference to this renderer.\n\t\t */\n\t\tthis.setDataType = function ( type ) {\n\n\t\t\tdataType = type;\n\t\t\treturn this;\n\n\t\t};\n\n\t\t/**\n\t\t * Adds a compute variable to the renderer.\n\t\t *\n\t\t * @param {string} variableName - The variable name.\n\t\t * @param {string} computeFragmentShader - The compute (fragment) shader source.\n\t\t * @param {Texture} initialValueTexture - The initial value texture.\n\t\t * @return {Object} The compute variable.\n\t\t */\n\t\tthis.addVariable = function ( variableName, computeFragmentShader, initialValueTexture ) {\n\n\t\t\tconst material = this.createShaderMaterial( computeFragmentShader );\n\n\t\t\tconst variable = {\n\t\t\t\tname: variableName,\n\t\t\t\tinitialValueTexture: initialValueTexture,\n\t\t\t\tmaterial: material,\n\t\t\t\tdependencies: null,\n\t\t\t\trenderTargets: [],\n\t\t\t\twrapS: null,\n\t\t\t\twrapT: null,\n\t\t\t\tminFilter: NearestFilter,\n\t\t\t\tmagFilter: NearestFilter\n\t\t\t};\n\n\t\t\tthis.variables.push( variable );\n\n\t\t\treturn variable;\n\n\t\t};\n\n\t\t/**\n\t\t * Sets variable dependencies.\n\t\t *\n\t\t * @param {Object} variable - The compute variable.\n\t\t * @param {Array<Object>} dependencies - Other compute variables that represents the dependencies.\n\t\t */\n\t\tthis.setVariableDependencies = function ( variable, dependencies ) {\n\n\t\t\tvariable.dependencies = dependencies;\n\n\t\t};\n\n\t\t/**\n\t\t * Initializes the renderer.\n\t\t *\n\t\t * @return {?string} Returns `null` if no errors are detected. Otherwise returns the error message.\n\t\t */\n\t\tthis.init = function () {\n\n\t\t\tif ( renderer.capabilities.maxVertexTextures === 0 ) {\n\n\t\t\t\treturn 'No support for vertex shader textures.';\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < this.variables.length; i ++ ) {\n\n\t\t\t\tconst variable = this.variables[ i ];\n\n\t\t\t\t// Creates rendertargets and initialize them with input texture\n\t\t\t\tvariable.renderTargets[ 0 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\t\tvariable.renderTargets[ 1 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 0 ] );\n\t\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 1 ] );\n\n\t\t\t\t// Adds dependencies uniforms to the ShaderMaterial\n\t\t\t\tconst material = variable.material;\n\t\t\t\tconst uniforms = material.uniforms;\n\n\t\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\t\tfor ( let d = 0; d < variable.dependencies.length; d ++ ) {\n\n\t\t\t\t\t\tconst depVar = variable.dependencies[ d ];\n\n\t\t\t\t\t\tif ( depVar.name !== variable.name ) {\n\n\t\t\t\t\t\t\t// Checks if variable exists\n\t\t\t\t\t\t\tlet found = false;\n\n\t\t\t\t\t\t\tfor ( let j = 0; j < this.variables.length; j ++ ) {\n\n\t\t\t\t\t\t\t\tif ( depVar.name === this.variables[ j ].name ) {\n\n\t\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( ! found ) {\n\n\t\t\t\t\t\t\t\treturn 'Variable dependency not found. Variable=' + variable.name + ', dependency=' + depVar.name;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuniforms[ depVar.name ] = { value: null };\n\n\t\t\t\t\t\tmaterial.fragmentShader = '\\nuniform sampler2D ' + depVar.name + ';\\n' + material.fragmentShader;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.currentTextureIndex = 0;\n\n\t\t\treturn null;\n\n\t\t};\n\n\t\t/**\n\t\t * Executes the compute. This method is usually called in the animation loop.\n\t\t */\n\t\tthis.compute = function () {\n\n\t\t\tconst currentTextureIndex = this.currentTextureIndex;\n\t\t\tconst nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n\n\t\t\tfor ( let i = 0, il = this.variables.length; i < il; i ++ ) {\n\n\t\t\t\tconst variable = this.variables[ i ];\n\n\t\t\t\t// Sets texture dependencies uniforms\n\t\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\t\tconst uniforms = variable.material.uniforms;\n\n\t\t\t\t\tfor ( let d = 0, dl = variable.dependencies.length; d < dl; d ++ ) {\n\n\t\t\t\t\t\tconst depVar = variable.dependencies[ d ];\n\n\t\t\t\t\t\tuniforms[ depVar.name ].value = depVar.renderTargets[ currentTextureIndex ].texture;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Performs the computation for this variable\n\t\t\t\tthis.doRenderTarget( variable.material, variable.renderTargets[ nextTextureIndex ] );\n\n\t\t\t}\n\n\t\t\tthis.currentTextureIndex = nextTextureIndex;\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the current render target for the given compute variable.\n\t\t *\n\t\t * @param {Object} variable - The compute variable.\n\t\t * @return {WebGLRenderTarget} The current render target.\n\t\t */\n\t\tthis.getCurrentRenderTarget = function ( variable ) {\n\n\t\t\treturn variable.renderTargets[ this.currentTextureIndex ];\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the alternate render target for the given compute variable.\n\t\t *\n\t\t * @param {Object} variable - The compute variable.\n\t\t * @return {WebGLRenderTarget} The alternate render target.\n\t\t */\n\t\tthis.getAlternateRenderTarget = function ( variable ) {\n\n\t\t\treturn variable.renderTargets[ this.currentTextureIndex === 0 ? 1 : 0 ];\n\n\t\t};\n\n\t\t/**\n\t\t * Frees all internal resources. Call this method if you don't need the\n\t\t * renderer anymore.\n\t\t */\n\t\tthis.dispose = function () {\n\n\t\t\tquad.dispose();\n\n\t\t\tconst variables = this.variables;\n\n\t\t\tfor ( let i = 0; i < variables.length; i ++ ) {\n\n\t\t\t\tconst variable = variables[ i ];\n\n\t\t\t\tif ( variable.initialValueTexture ) variable.initialValueTexture.dispose();\n\n\t\t\t\tconst renderTargets = variable.renderTargets;\n\n\t\t\t\tfor ( let j = 0; j < renderTargets.length; j ++ ) {\n\n\t\t\t\t\tconst renderTarget = renderTargets[ j ];\n\t\t\t\t\trenderTarget.dispose();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction addResolutionDefine( materialShader ) {\n\n\t\t\tmaterialShader.defines.resolution = 'vec2( ' + sizeX.toFixed( 1 ) + ', ' + sizeY.toFixed( 1 ) + ' )';\n\n\t\t}\n\n\t\t/**\n\t\t * Adds a resolution defined for the given material shader.\n\t\t *\n\t\t * @param {Object} materialShader - The material shader.\n\t\t */\n\t\tthis.addResolutionDefine = addResolutionDefine;\n\n\n\t\t// The following functions can be used to compute things manually\n\n\t\tfunction createShaderMaterial( computeFragmentShader, uniforms ) {\n\n\t\t\tuniforms = uniforms || {};\n\n\t\t\tconst material = new ShaderMaterial( {\n\t\t\t\tname: 'GPUComputationShader',\n\t\t\t\tuniforms: uniforms,\n\t\t\t\tvertexShader: getPassThroughVertexShader(),\n\t\t\t\tfragmentShader: computeFragmentShader\n\t\t\t} );\n\n\t\t\taddResolutionDefine( material );\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tthis.createShaderMaterial = createShaderMaterial;\n\n\t\t/**\n\t\t * Creates a new render target from the given parameters.\n\t\t *\n\t\t * @param {number} sizeXTexture - The width of the render target.\n\t\t * @param {number} sizeYTexture - The height of the render target.\n\t\t * @param {number} wrapS - The wrapS value.\n\t\t * @param {number} wrapT - The wrapS value.\n\t\t * @param {number} minFilter - The minFilter value.\n\t\t * @param {number} magFilter - The magFilter value.\n\t\t * @return {WebGLRenderTarget} The new render target.\n\t\t */\n\t\tthis.createRenderTarget = function ( sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter ) {\n\n\t\t\tsizeXTexture = sizeXTexture || sizeX;\n\t\t\tsizeYTexture = sizeYTexture || sizeY;\n\n\t\t\twrapS = wrapS || ClampToEdgeWrapping;\n\t\t\twrapT = wrapT || ClampToEdgeWrapping;\n\n\t\t\tminFilter = minFilter || NearestFilter;\n\t\t\tmagFilter = magFilter || NearestFilter;\n\n\t\t\tconst renderTarget = new WebGLRenderTarget( sizeXTexture, sizeYTexture, {\n\t\t\t\twrapS: wrapS,\n\t\t\t\twrapT: wrapT,\n\t\t\t\tminFilter: minFilter,\n\t\t\t\tmagFilter: magFilter,\n\t\t\t\tformat: RGBAFormat,\n\t\t\t\ttype: dataType,\n\t\t\t\tdepthBuffer: false\n\t\t\t} );\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t\t/**\n\t\t * Creates a new data texture.\n\t\t *\n\t\t * @return {DataTexture} The new data texture.\n\t\t */\n\t\tthis.createTexture = function () {\n\n\t\t\tconst data = new Float32Array( sizeX * sizeY * 4 );\n\t\t\tconst texture = new DataTexture( data, sizeX, sizeY, RGBAFormat, FloatType );\n\t\t\ttexture.needsUpdate = true;\n\t\t\treturn texture;\n\n\t\t};\n\n\t\t/**\n\t\t * Renders the given texture into the given render target.\n\t\t *\n\t\t * @param {Texture} input - The input.\n\t\t * @param {WebGLRenderTarget} output - The output.\n\t\t */\n\t\tthis.renderTexture = function ( input, output ) {\n\n\t\t\tpassThruUniforms.passThruTexture.value = input;\n\n\t\t\tthis.doRenderTarget( passThruShader, output );\n\n\t\t\tpassThruUniforms.passThruTexture.value = null;\n\n\t\t};\n\n\n\t\t/**\n\t\t * Renders the given material into the given render target\n\t\t * with a full-screen pass.\n\t\t *\n\t\t * @param {Material} material - The material.\n\t\t * @param {WebGLRenderTarget} output - The output.\n\t\t */\n\t\tthis.doRenderTarget = function ( material, output ) {\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\t\t\tquad.material = material;\n\t\t\trenderer.setRenderTarget( output );\n\t\t\tquad.render( renderer );\n\t\t\tquad.material = passThruShader;\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t};\n\n\t\t// Shaders\n\n\t\tfunction getPassThroughVertexShader() {\n\n\t\t\treturn\t'void main()\t{\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'\tgl_Position = vec4( position, 1.0 );\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'}\\n';\n\n\t\t}\n\n\t\tfunction getPassThroughFragmentShader() {\n\n\t\t\treturn\t'uniform sampler2D passThruTexture;\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'void main() {\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'\tgl_FragColor = texture2D( passThruTexture, uv );\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'}\\n';\n\n\t\t}\n\n\t}\n\n}\n\nexport { GPUComputationRenderer };\n"],"mappings":"AAAA,SACCA,mBAAmB,EACnBC,WAAW,EACXC,SAAS,EACTC,aAAa,EACbC,UAAU,EACVC,cAAc,EACdC,iBAAiB,QACX,OAAO;AAEd,SAASC,cAAc,QAAQ,2BAA2B;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,sBAAsB,CAAC;EAE5B;AACD;AACA;AACA;AACA;AACA;AACA;EACCC,WAAWA,CAAEC,KAAK,EAAEC,KAAK,EAAEC,QAAQ,EAAG;IAErC,IAAI,CAACC,SAAS,GAAG,EAAE;IAEnB,IAAI,CAACC,mBAAmB,GAAG,CAAC;IAE5B,IAAIC,QAAQ,GAAGb,SAAS;IAExB,MAAMc,gBAAgB,GAAG;MACxBC,eAAe,EAAE;QAAEC,KAAK,EAAE;MAAK;IAChC,CAAC;IAED,MAAMC,cAAc,GAAGC,oBAAoB,CAAEC,4BAA4B,CAAC,CAAC,EAAEL,gBAAiB,CAAC;IAE/F,MAAMM,IAAI,GAAG,IAAIf,cAAc,CAAEY,cAAe,CAAC;;IAEjD;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACI,WAAW,GAAG,UAAWC,IAAI,EAAG;MAEpCT,QAAQ,GAAGS,IAAI;MACf,OAAO,IAAI;IAEZ,CAAC;;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,WAAW,GAAG,UAAWC,YAAY,EAAEC,qBAAqB,EAAEC,mBAAmB,EAAG;MAExF,MAAMC,QAAQ,GAAG,IAAI,CAACT,oBAAoB,CAAEO,qBAAsB,CAAC;MAEnE,MAAMG,QAAQ,GAAG;QAChBC,IAAI,EAAEL,YAAY;QAClBE,mBAAmB,EAAEA,mBAAmB;QACxCC,QAAQ,EAAEA,QAAQ;QAClBG,YAAY,EAAE,IAAI;QAClBC,aAAa,EAAE,EAAE;QACjBC,KAAK,EAAE,IAAI;QACXC,KAAK,EAAE,IAAI;QACXC,SAAS,EAAEjC,aAAa;QACxBkC,SAAS,EAAElC;MACZ,CAAC;MAED,IAAI,CAACU,SAAS,CAACyB,IAAI,CAAER,QAAS,CAAC;MAE/B,OAAOA,QAAQ;IAEhB,CAAC;;IAED;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACS,uBAAuB,GAAG,UAAWT,QAAQ,EAAEE,YAAY,EAAG;MAElEF,QAAQ,CAACE,YAAY,GAAGA,YAAY;IAErC,CAAC;;IAED;AACF;AACA;AACA;AACA;IACE,IAAI,CAACQ,IAAI,GAAG,YAAY;MAEvB,IAAK5B,QAAQ,CAAC6B,YAAY,CAACC,iBAAiB,KAAK,CAAC,EAAG;QAEpD,OAAO,wCAAwC;MAEhD;MAEA,KAAM,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC9B,SAAS,CAAC+B,MAAM,EAAED,CAAC,EAAG,EAAG;QAElD,MAAMb,QAAQ,GAAG,IAAI,CAACjB,SAAS,CAAE8B,CAAC,CAAE;;QAEpC;QACAb,QAAQ,CAACG,aAAa,CAAE,CAAC,CAAE,GAAG,IAAI,CAACY,kBAAkB,CAAEnC,KAAK,EAAEC,KAAK,EAAEmB,QAAQ,CAACI,KAAK,EAAEJ,QAAQ,CAACK,KAAK,EAAEL,QAAQ,CAACM,SAAS,EAAEN,QAAQ,CAACO,SAAU,CAAC;QAC7IP,QAAQ,CAACG,aAAa,CAAE,CAAC,CAAE,GAAG,IAAI,CAACY,kBAAkB,CAAEnC,KAAK,EAAEC,KAAK,EAAEmB,QAAQ,CAACI,KAAK,EAAEJ,QAAQ,CAACK,KAAK,EAAEL,QAAQ,CAACM,SAAS,EAAEN,QAAQ,CAACO,SAAU,CAAC;QAC7I,IAAI,CAACS,aAAa,CAAEhB,QAAQ,CAACF,mBAAmB,EAAEE,QAAQ,CAACG,aAAa,CAAE,CAAC,CAAG,CAAC;QAC/E,IAAI,CAACa,aAAa,CAAEhB,QAAQ,CAACF,mBAAmB,EAAEE,QAAQ,CAACG,aAAa,CAAE,CAAC,CAAG,CAAC;;QAE/E;QACA,MAAMJ,QAAQ,GAAGC,QAAQ,CAACD,QAAQ;QAClC,MAAMkB,QAAQ,GAAGlB,QAAQ,CAACkB,QAAQ;QAElC,IAAKjB,QAAQ,CAACE,YAAY,KAAK,IAAI,EAAG;UAErC,KAAM,IAAIgB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlB,QAAQ,CAACE,YAAY,CAACY,MAAM,EAAEI,CAAC,EAAG,EAAG;YAEzD,MAAMC,MAAM,GAAGnB,QAAQ,CAACE,YAAY,CAAEgB,CAAC,CAAE;YAEzC,IAAKC,MAAM,CAAClB,IAAI,KAAKD,QAAQ,CAACC,IAAI,EAAG;cAEpC;cACA,IAAImB,KAAK,GAAG,KAAK;cAEjB,KAAM,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACtC,SAAS,CAAC+B,MAAM,EAAEO,CAAC,EAAG,EAAG;gBAElD,IAAKF,MAAM,CAAClB,IAAI,KAAK,IAAI,CAAClB,SAAS,CAAEsC,CAAC,CAAE,CAACpB,IAAI,EAAG;kBAE/CmB,KAAK,GAAG,IAAI;kBACZ;gBAED;cAED;cAEA,IAAK,CAAEA,KAAK,EAAG;gBAEd,OAAO,0CAA0C,GAAGpB,QAAQ,CAACC,IAAI,GAAG,eAAe,GAAGkB,MAAM,CAAClB,IAAI;cAElG;YAED;YAEAgB,QAAQ,CAAEE,MAAM,CAAClB,IAAI,CAAE,GAAG;cAAEb,KAAK,EAAE;YAAK,CAAC;YAEzCW,QAAQ,CAACuB,cAAc,GAAG,sBAAsB,GAAGH,MAAM,CAAClB,IAAI,GAAG,KAAK,GAAGF,QAAQ,CAACuB,cAAc;UAEjG;QAED;MAED;MAEA,IAAI,CAACtC,mBAAmB,GAAG,CAAC;MAE5B,OAAO,IAAI;IAEZ,CAAC;;IAED;AACF;AACA;IACE,IAAI,CAACuC,OAAO,GAAG,YAAY;MAE1B,MAAMvC,mBAAmB,GAAG,IAAI,CAACA,mBAAmB;MACpD,MAAMwC,gBAAgB,GAAG,IAAI,CAACxC,mBAAmB,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC;MAE/D,KAAM,IAAI6B,CAAC,GAAG,CAAC,EAAEY,EAAE,GAAG,IAAI,CAAC1C,SAAS,CAAC+B,MAAM,EAAED,CAAC,GAAGY,EAAE,EAAEZ,CAAC,EAAG,EAAG;QAE3D,MAAMb,QAAQ,GAAG,IAAI,CAACjB,SAAS,CAAE8B,CAAC,CAAE;;QAEpC;QACA,IAAKb,QAAQ,CAACE,YAAY,KAAK,IAAI,EAAG;UAErC,MAAMe,QAAQ,GAAGjB,QAAQ,CAACD,QAAQ,CAACkB,QAAQ;UAE3C,KAAM,IAAIC,CAAC,GAAG,CAAC,EAAEQ,EAAE,GAAG1B,QAAQ,CAACE,YAAY,CAACY,MAAM,EAAEI,CAAC,GAAGQ,EAAE,EAAER,CAAC,EAAG,EAAG;YAElE,MAAMC,MAAM,GAAGnB,QAAQ,CAACE,YAAY,CAAEgB,CAAC,CAAE;YAEzCD,QAAQ,CAAEE,MAAM,CAAClB,IAAI,CAAE,CAACb,KAAK,GAAG+B,MAAM,CAAChB,aAAa,CAAEnB,mBAAmB,CAAE,CAAC2C,OAAO;UAEpF;QAED;;QAEA;QACA,IAAI,CAACC,cAAc,CAAE5B,QAAQ,CAACD,QAAQ,EAAEC,QAAQ,CAACG,aAAa,CAAEqB,gBAAgB,CAAG,CAAC;MAErF;MAEA,IAAI,CAACxC,mBAAmB,GAAGwC,gBAAgB;IAE5C,CAAC;;IAED;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACK,sBAAsB,GAAG,UAAW7B,QAAQ,EAAG;MAEnD,OAAOA,QAAQ,CAACG,aAAa,CAAE,IAAI,CAACnB,mBAAmB,CAAE;IAE1D,CAAC;;IAED;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAAC8C,wBAAwB,GAAG,UAAW9B,QAAQ,EAAG;MAErD,OAAOA,QAAQ,CAACG,aAAa,CAAE,IAAI,CAACnB,mBAAmB,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAE;IAExE,CAAC;;IAED;AACF;AACA;AACA;IACE,IAAI,CAAC+C,OAAO,GAAG,YAAY;MAE1BvC,IAAI,CAACuC,OAAO,CAAC,CAAC;MAEd,MAAMhD,SAAS,GAAG,IAAI,CAACA,SAAS;MAEhC,KAAM,IAAI8B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG9B,SAAS,CAAC+B,MAAM,EAAED,CAAC,EAAG,EAAG;QAE7C,MAAMb,QAAQ,GAAGjB,SAAS,CAAE8B,CAAC,CAAE;QAE/B,IAAKb,QAAQ,CAACF,mBAAmB,EAAGE,QAAQ,CAACF,mBAAmB,CAACiC,OAAO,CAAC,CAAC;QAE1E,MAAM5B,aAAa,GAAGH,QAAQ,CAACG,aAAa;QAE5C,KAAM,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlB,aAAa,CAACW,MAAM,EAAEO,CAAC,EAAG,EAAG;UAEjD,MAAMW,YAAY,GAAG7B,aAAa,CAAEkB,CAAC,CAAE;UACvCW,YAAY,CAACD,OAAO,CAAC,CAAC;QAEvB;MAED;IAED,CAAC;IAED,SAASE,mBAAmBA,CAAEC,cAAc,EAAG;MAE9CA,cAAc,CAACC,OAAO,CAACC,UAAU,GAAG,QAAQ,GAAGxD,KAAK,CAACyD,OAAO,CAAE,CAAE,CAAC,GAAG,IAAI,GAAGxD,KAAK,CAACwD,OAAO,CAAE,CAAE,CAAC,GAAG,IAAI;IAErG;;IAEA;AACF;AACA;AACA;AACA;IACE,IAAI,CAACJ,mBAAmB,GAAGA,mBAAmB;;IAG9C;;IAEA,SAAS3C,oBAAoBA,CAAEO,qBAAqB,EAAEoB,QAAQ,EAAG;MAEhEA,QAAQ,GAAGA,QAAQ,IAAI,CAAC,CAAC;MAEzB,MAAMlB,QAAQ,GAAG,IAAIxB,cAAc,CAAE;QACpC0B,IAAI,EAAE,sBAAsB;QAC5BgB,QAAQ,EAAEA,QAAQ;QAClBqB,YAAY,EAAEC,0BAA0B,CAAC,CAAC;QAC1CjB,cAAc,EAAEzB;MACjB,CAAE,CAAC;MAEHoC,mBAAmB,CAAElC,QAAS,CAAC;MAE/B,OAAOA,QAAQ;IAEhB;IAEA,IAAI,CAACT,oBAAoB,GAAGA,oBAAoB;;IAEhD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACyB,kBAAkB,GAAG,UAAWyB,YAAY,EAAEC,YAAY,EAAErC,KAAK,EAAEC,KAAK,EAAEC,SAAS,EAAEC,SAAS,EAAG;MAErGiC,YAAY,GAAGA,YAAY,IAAI5D,KAAK;MACpC6D,YAAY,GAAGA,YAAY,IAAI5D,KAAK;MAEpCuB,KAAK,GAAGA,KAAK,IAAIlC,mBAAmB;MACpCmC,KAAK,GAAGA,KAAK,IAAInC,mBAAmB;MAEpCoC,SAAS,GAAGA,SAAS,IAAIjC,aAAa;MACtCkC,SAAS,GAAGA,SAAS,IAAIlC,aAAa;MAEtC,MAAM2D,YAAY,GAAG,IAAIxD,iBAAiB,CAAEgE,YAAY,EAAEC,YAAY,EAAE;QACvErC,KAAK,EAAEA,KAAK;QACZC,KAAK,EAAEA,KAAK;QACZC,SAAS,EAAEA,SAAS;QACpBC,SAAS,EAAEA,SAAS;QACpBmC,MAAM,EAAEpE,UAAU;QAClBoB,IAAI,EAAET,QAAQ;QACd0D,WAAW,EAAE;MACd,CAAE,CAAC;MAEH,OAAOX,YAAY;IAEpB,CAAC;;IAED;AACF;AACA;AACA;AACA;IACE,IAAI,CAACY,aAAa,GAAG,YAAY;MAEhC,MAAMC,IAAI,GAAG,IAAIC,YAAY,CAAElE,KAAK,GAAGC,KAAK,GAAG,CAAE,CAAC;MAClD,MAAM8C,OAAO,GAAG,IAAIxD,WAAW,CAAE0E,IAAI,EAAEjE,KAAK,EAAEC,KAAK,EAAEP,UAAU,EAAEF,SAAU,CAAC;MAC5EuD,OAAO,CAACoB,WAAW,GAAG,IAAI;MAC1B,OAAOpB,OAAO;IAEf,CAAC;;IAED;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACX,aAAa,GAAG,UAAWgC,KAAK,EAAEC,MAAM,EAAG;MAE/C/D,gBAAgB,CAACC,eAAe,CAACC,KAAK,GAAG4D,KAAK;MAE9C,IAAI,CAACpB,cAAc,CAAEvC,cAAc,EAAE4D,MAAO,CAAC;MAE7C/D,gBAAgB,CAACC,eAAe,CAACC,KAAK,GAAG,IAAI;IAE9C,CAAC;;IAGD;AACF;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACwC,cAAc,GAAG,UAAW7B,QAAQ,EAAEkD,MAAM,EAAG;MAEnD,MAAMC,mBAAmB,GAAGpE,QAAQ,CAACqE,eAAe,CAAC,CAAC;MAEtD,MAAMC,gBAAgB,GAAGtE,QAAQ,CAACuE,EAAE,CAACC,OAAO;MAC5C,MAAMC,uBAAuB,GAAGzE,QAAQ,CAAC0E,SAAS,CAACC,UAAU;MAE7D3E,QAAQ,CAACuE,EAAE,CAACC,OAAO,GAAG,KAAK,CAAC,CAAC;MAC7BxE,QAAQ,CAAC0E,SAAS,CAACC,UAAU,GAAG,KAAK,CAAC,CAAC;MACvCjE,IAAI,CAACO,QAAQ,GAAGA,QAAQ;MACxBjB,QAAQ,CAAC4E,eAAe,CAAET,MAAO,CAAC;MAClCzD,IAAI,CAACmE,MAAM,CAAE7E,QAAS,CAAC;MACvBU,IAAI,CAACO,QAAQ,GAAGV,cAAc;MAE9BP,QAAQ,CAACuE,EAAE,CAACC,OAAO,GAAGF,gBAAgB;MACtCtE,QAAQ,CAAC0E,SAAS,CAACC,UAAU,GAAGF,uBAAuB;MAEvDzE,QAAQ,CAAC4E,eAAe,CAAER,mBAAoB,CAAC;IAEhD,CAAC;;IAED;;IAEA,SAASX,0BAA0BA,CAAA,EAAG;MAErC,OAAO,iBAAiB,GACtB,IAAI,GACJ,yCAAyC,GACzC,IAAI,GACJ,KAAK;IAER;IAEA,SAAShD,4BAA4BA,CAAA,EAAG;MAEvC,OAAO,sCAAsC,GAC3C,IAAI,GACJ,iBAAiB,GACjB,IAAI,GACJ,+CAA+C,GAC/C,IAAI,GACJ,qDAAqD,GACrD,IAAI,GACJ,KAAK;IAER;EAED;AAED;AAEA,SAASb,sBAAsB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}