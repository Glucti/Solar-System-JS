{"ast":null,"code":"import { WebGLRenderTarget, MeshNormalMaterial, ShaderMaterial, Vector2, Vector4, DepthTexture, NearestFilter, HalfFloatType } from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\n\n/**\n * A special type of render pass that produces a pixelated beauty pass.\n *\n * ```js\n * const renderPixelatedPass = new RenderPixelatedPass( 6, scene, camera );\n * composer.addPass( renderPixelatedPass );\n * ```\n *\n * @augments Pass\n * @three_import import { RenderPixelatedPass } from 'three/addons/postprocessing/RenderPixelatedPass.js';\n */\nclass RenderPixelatedPass extends Pass {\n  /**\n   * Constructs a new render pixelated pass.\n   *\n   * @param {number} pixelSize - The effect's pixel size.\n   * @param {Scene} scene - The scene to render.\n   * @param {Camera} camera - The camera.\n   * @param {{normalEdgeStrength:number,depthEdgeStrength:number}} options - The pass options.\n   */\n  constructor(pixelSize, scene, camera, options = {}) {\n    super();\n\n    /**\n     * The effect's pixel size.\n     *\n     * @type {number}\n     */\n    this.pixelSize = pixelSize;\n\n    /**\n     * The scene to render.\n     *\n     * @type {Scene}\n     */\n    this.scene = scene;\n\n    /**\n     * The camera.\n     *\n     * @type {Camera}\n     */\n    this.camera = camera;\n\n    /**\n     * The normal edge strength.\n     *\n     * @type {number}\n     * @default 0.3\n     */\n    this.normalEdgeStrength = options.normalEdgeStrength || 0.3;\n\n    /**\n     * The normal edge strength.\n     *\n     * @type {number}\n     * @default 0.4\n     */\n    this.depthEdgeStrength = options.depthEdgeStrength || 0.4;\n\n    /**\n     * The pixelated material.\n     *\n     * @type {ShaderMaterial}\n     */\n    this.pixelatedMaterial = this._createPixelatedMaterial();\n\n    // internals\n\n    this._resolution = new Vector2();\n    this._renderResolution = new Vector2();\n    this._normalMaterial = new MeshNormalMaterial();\n    this._beautyRenderTarget = new WebGLRenderTarget();\n    this._beautyRenderTarget.texture.minFilter = NearestFilter;\n    this._beautyRenderTarget.texture.magFilter = NearestFilter;\n    this._beautyRenderTarget.texture.type = HalfFloatType;\n    this._beautyRenderTarget.depthTexture = new DepthTexture();\n    this._normalRenderTarget = new WebGLRenderTarget();\n    this._normalRenderTarget.texture.minFilter = NearestFilter;\n    this._normalRenderTarget.texture.magFilter = NearestFilter;\n    this._normalRenderTarget.texture.type = HalfFloatType;\n    this._fsQuad = new FullScreenQuad(this.pixelatedMaterial);\n  }\n\n  /**\n   * Frees the GPU-related resources allocated by this instance. Call this\n   * method whenever the pass is no longer used in your app.\n   */\n  dispose() {\n    this._beautyRenderTarget.dispose();\n    this._normalRenderTarget.dispose();\n    this.pixelatedMaterial.dispose();\n    this._normalMaterial.dispose();\n    this._fsQuad.dispose();\n  }\n\n  /**\n   * Sets the size of the pass.\n   *\n   * @param {number} width - The width to set.\n   * @param {number} height - The height to set.\n   */\n  setSize(width, height) {\n    this._resolution.set(width, height);\n    this._renderResolution.set(width / this.pixelSize | 0, height / this.pixelSize | 0);\n    const {\n      x,\n      y\n    } = this._renderResolution;\n    this._beautyRenderTarget.setSize(x, y);\n    this._normalRenderTarget.setSize(x, y);\n    this._fsQuad.material.uniforms.resolution.value.set(x, y, 1 / x, 1 / y);\n  }\n\n  /**\n   * Sets the effect's pixel size.\n   *\n   * @param {number} pixelSize - The pixel size to set.\n   */\n  setPixelSize(pixelSize) {\n    this.pixelSize = pixelSize;\n    this.setSize(this._resolution.x, this._resolution.y);\n  }\n\n  /**\n   * Performs the pixelation pass.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n   * destination for the pass.\n   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n   * previous pass from this buffer.\n   * @param {number} deltaTime - The delta time in seconds.\n   * @param {boolean} maskActive - Whether masking is active or not.\n   */\n  render(renderer, writeBuffer /*, readBuffer , deltaTime, maskActive */) {\n    const uniforms = this._fsQuad.material.uniforms;\n    uniforms.normalEdgeStrength.value = this.normalEdgeStrength;\n    uniforms.depthEdgeStrength.value = this.depthEdgeStrength;\n    renderer.setRenderTarget(this._beautyRenderTarget);\n    renderer.render(this.scene, this.camera);\n    const overrideMaterial_old = this.scene.overrideMaterial;\n    renderer.setRenderTarget(this._normalRenderTarget);\n    this.scene.overrideMaterial = this._normalMaterial;\n    renderer.render(this.scene, this.camera);\n    this.scene.overrideMaterial = overrideMaterial_old;\n    uniforms.tDiffuse.value = this._beautyRenderTarget.texture;\n    uniforms.tDepth.value = this._beautyRenderTarget.depthTexture;\n    uniforms.tNormal.value = this._normalRenderTarget.texture;\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear) renderer.clear();\n    }\n    this._fsQuad.render(renderer);\n  }\n\n  // internals\n\n  _createPixelatedMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        tDiffuse: {\n          value: null\n        },\n        tDepth: {\n          value: null\n        },\n        tNormal: {\n          value: null\n        },\n        resolution: {\n          value: new Vector4()\n        },\n        normalEdgeStrength: {\n          value: 0\n        },\n        depthEdgeStrength: {\n          value: 0\n        }\n      },\n      vertexShader: /* glsl */`\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t`,\n      fragmentShader: /* glsl */`\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tuniform sampler2D tDepth;\n\t\t\t\tuniform sampler2D tNormal;\n\t\t\t\tuniform vec4 resolution;\n\t\t\t\tuniform float normalEdgeStrength;\n\t\t\t\tuniform float depthEdgeStrength;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tfloat getDepth(int x, int y) {\n\n\t\t\t\t\treturn texture2D( tDepth, vUv + vec2(x, y) * resolution.zw ).r;\n\n\t\t\t\t}\n\n\t\t\t\tvec3 getNormal(int x, int y) {\n\n\t\t\t\t\treturn texture2D( tNormal, vUv + vec2(x, y) * resolution.zw ).rgb * 2.0 - 1.0;\n\n\t\t\t\t}\n\n\t\t\t\tfloat depthEdgeIndicator(float depth, vec3 normal) {\n\n\t\t\t\t\tfloat diff = 0.0;\n\t\t\t\t\tdiff += clamp(getDepth(1, 0) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(-1, 0) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(0, 1) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(0, -1) - depth, 0.0, 1.0);\n\t\t\t\t\treturn floor(smoothstep(0.01, 0.02, diff) * 2.) / 2.;\n\n\t\t\t\t}\n\n\t\t\t\tfloat neighborNormalEdgeIndicator(int x, int y, float depth, vec3 normal) {\n\n\t\t\t\t\tfloat depthDiff = getDepth(x, y) - depth;\n\t\t\t\t\tvec3 neighborNormal = getNormal(x, y);\n\n\t\t\t\t\t// Edge pixels should yield to faces who's normals are closer to the bias normal.\n\t\t\t\t\tvec3 normalEdgeBias = vec3(1., 1., 1.); // This should probably be a parameter.\n\t\t\t\t\tfloat normalDiff = dot(normal - neighborNormal, normalEdgeBias);\n\t\t\t\t\tfloat normalIndicator = clamp(smoothstep(-.01, .01, normalDiff), 0.0, 1.0);\n\n\t\t\t\t\t// Only the shallower pixel should detect the normal edge.\n\t\t\t\t\tfloat depthIndicator = clamp(sign(depthDiff * .25 + .0025), 0.0, 1.0);\n\n\t\t\t\t\treturn (1.0 - dot(normal, neighborNormal)) * depthIndicator * normalIndicator;\n\n\t\t\t\t}\n\n\t\t\t\tfloat normalEdgeIndicator(float depth, vec3 normal) {\n\n\t\t\t\t\tfloat indicator = 0.0;\n\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(0, -1, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(0, 1, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(-1, 0, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(1, 0, depth, normal);\n\n\t\t\t\t\treturn step(0.1, indicator);\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\t\t\tfloat depth = 0.0;\n\t\t\t\t\tvec3 normal = vec3(0.0);\n\n\t\t\t\t\tif (depthEdgeStrength > 0.0 || normalEdgeStrength > 0.0) {\n\n\t\t\t\t\t\tdepth = getDepth(0, 0);\n\t\t\t\t\t\tnormal = getNormal(0, 0);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat dei = 0.0;\n\t\t\t\t\tif (depthEdgeStrength > 0.0)\n\t\t\t\t\t\tdei = depthEdgeIndicator(depth, normal);\n\n\t\t\t\t\tfloat nei = 0.0;\n\t\t\t\t\tif (normalEdgeStrength > 0.0)\n\t\t\t\t\t\tnei = normalEdgeIndicator(depth, normal);\n\n\t\t\t\t\tfloat Strength = dei > 0.0 ? (1.0 - depthEdgeStrength * dei) : (1.0 + normalEdgeStrength * nei);\n\n\t\t\t\t\tgl_FragColor = texel * Strength;\n\n\t\t\t\t}\n\t\t\t`\n    });\n  }\n}\nexport { RenderPixelatedPass };","map":{"version":3,"names":["WebGLRenderTarget","MeshNormalMaterial","ShaderMaterial","Vector2","Vector4","DepthTexture","NearestFilter","HalfFloatType","Pass","FullScreenQuad","RenderPixelatedPass","constructor","pixelSize","scene","camera","options","normalEdgeStrength","depthEdgeStrength","pixelatedMaterial","_createPixelatedMaterial","_resolution","_renderResolution","_normalMaterial","_beautyRenderTarget","texture","minFilter","magFilter","type","depthTexture","_normalRenderTarget","_fsQuad","dispose","setSize","width","height","set","x","y","material","uniforms","resolution","value","setPixelSize","render","renderer","writeBuffer","setRenderTarget","overrideMaterial_old","overrideMaterial","tDiffuse","tDepth","tNormal","renderToScreen","clear","vertexShader","fragmentShader"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/postprocessing/RenderPixelatedPass.js"],"sourcesContent":["import {\n\tWebGLRenderTarget,\n\tMeshNormalMaterial,\n\tShaderMaterial,\n\tVector2,\n\tVector4,\n\tDepthTexture,\n\tNearestFilter,\n\tHalfFloatType\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\n\n/**\n * A special type of render pass that produces a pixelated beauty pass.\n *\n * ```js\n * const renderPixelatedPass = new RenderPixelatedPass( 6, scene, camera );\n * composer.addPass( renderPixelatedPass );\n * ```\n *\n * @augments Pass\n * @three_import import { RenderPixelatedPass } from 'three/addons/postprocessing/RenderPixelatedPass.js';\n */\nclass RenderPixelatedPass extends Pass {\n\n\t/**\n\t * Constructs a new render pixelated pass.\n\t *\n\t * @param {number} pixelSize - The effect's pixel size.\n\t * @param {Scene} scene - The scene to render.\n\t * @param {Camera} camera - The camera.\n\t * @param {{normalEdgeStrength:number,depthEdgeStrength:number}} options - The pass options.\n\t */\n\tconstructor( pixelSize, scene, camera, options = {} ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The effect's pixel size.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.pixelSize = pixelSize;\n\n\t\t/**\n\t\t * The scene to render.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * The camera.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * The normal edge strength.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0.3\n\t\t */\n\t\tthis.normalEdgeStrength = options.normalEdgeStrength || 0.3;\n\n\t\t/**\n\t\t * The normal edge strength.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0.4\n\t\t */\n\t\tthis.depthEdgeStrength = options.depthEdgeStrength || 0.4;\n\n\t\t/**\n\t\t * The pixelated material.\n\t\t *\n\t\t * @type {ShaderMaterial}\n\t\t */\n\t\tthis.pixelatedMaterial = this._createPixelatedMaterial();\n\n\t\t// internals\n\n\t\tthis._resolution = new Vector2();\n\t\tthis._renderResolution = new Vector2();\n\n\t\tthis._normalMaterial = new MeshNormalMaterial();\n\n\t\tthis._beautyRenderTarget = new WebGLRenderTarget();\n\t\tthis._beautyRenderTarget.texture.minFilter = NearestFilter;\n\t\tthis._beautyRenderTarget.texture.magFilter = NearestFilter;\n\t\tthis._beautyRenderTarget.texture.type = HalfFloatType;\n\t\tthis._beautyRenderTarget.depthTexture = new DepthTexture();\n\n\t\tthis._normalRenderTarget = new WebGLRenderTarget();\n\t\tthis._normalRenderTarget.texture.minFilter = NearestFilter;\n\t\tthis._normalRenderTarget.texture.magFilter = NearestFilter;\n\t\tthis._normalRenderTarget.texture.type = HalfFloatType;\n\n\t\tthis._fsQuad = new FullScreenQuad( this.pixelatedMaterial );\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the pass is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis._beautyRenderTarget.dispose();\n\t\tthis._normalRenderTarget.dispose();\n\n\t\tthis.pixelatedMaterial.dispose();\n\t\tthis._normalMaterial.dispose();\n\n\t\tthis._fsQuad.dispose();\n\n\t}\n\n\t/**\n\t * Sets the size of the pass.\n\t *\n\t * @param {number} width - The width to set.\n\t * @param {number} height - The height to set.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis._resolution.set( width, height );\n\t\tthis._renderResolution.set( ( width / this.pixelSize ) | 0, ( height / this.pixelSize ) | 0 );\n\t\tconst { x, y } = this._renderResolution;\n\t\tthis._beautyRenderTarget.setSize( x, y );\n\t\tthis._normalRenderTarget.setSize( x, y );\n\t\tthis._fsQuad.material.uniforms.resolution.value.set( x, y, 1 / x, 1 / y );\n\n\t}\n\n\t/**\n\t * Sets the effect's pixel size.\n\t *\n\t * @param {number} pixelSize - The pixel size to set.\n\t */\n\tsetPixelSize( pixelSize ) {\n\n\t\tthis.pixelSize = pixelSize;\n\t\tthis.setSize( this._resolution.x, this._resolution.y );\n\n\t}\n\n\t/**\n\t * Performs the pixelation pass.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer, writeBuffer/*, readBuffer , deltaTime, maskActive */ ) {\n\n\t\tconst uniforms = this._fsQuad.material.uniforms;\n\t\tuniforms.normalEdgeStrength.value = this.normalEdgeStrength;\n\t\tuniforms.depthEdgeStrength.value = this.depthEdgeStrength;\n\n\t\trenderer.setRenderTarget( this._beautyRenderTarget );\n\t\trenderer.render( this.scene, this.camera );\n\n\t\tconst overrideMaterial_old = this.scene.overrideMaterial;\n\t\trenderer.setRenderTarget( this._normalRenderTarget );\n\t\tthis.scene.overrideMaterial = this._normalMaterial;\n\t\trenderer.render( this.scene, this.camera );\n\t\tthis.scene.overrideMaterial = overrideMaterial_old;\n\n\t\tuniforms.tDiffuse.value = this._beautyRenderTarget.texture;\n\t\tuniforms.tDepth.value = this._beautyRenderTarget.depthTexture;\n\t\tuniforms.tNormal.value = this._normalRenderTarget.texture;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( writeBuffer );\n\n\t\t\tif ( this.clear ) renderer.clear();\n\n\t\t}\n\n\t\tthis._fsQuad.render( renderer );\n\n\t}\n\n\t// internals\n\n\t_createPixelatedMaterial() {\n\n\t\treturn new ShaderMaterial( {\n\t\t\tuniforms: {\n\t\t\t\ttDiffuse: { value: null },\n\t\t\t\ttDepth: { value: null },\n\t\t\t\ttNormal: { value: null },\n\t\t\t\tresolution: { value: new Vector4() },\n\t\t\t\tnormalEdgeStrength: { value: 0 },\n\t\t\t\tdepthEdgeStrength: { value: 0 }\n\t\t\t},\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t`,\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tuniform sampler2D tDepth;\n\t\t\t\tuniform sampler2D tNormal;\n\t\t\t\tuniform vec4 resolution;\n\t\t\t\tuniform float normalEdgeStrength;\n\t\t\t\tuniform float depthEdgeStrength;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tfloat getDepth(int x, int y) {\n\n\t\t\t\t\treturn texture2D( tDepth, vUv + vec2(x, y) * resolution.zw ).r;\n\n\t\t\t\t}\n\n\t\t\t\tvec3 getNormal(int x, int y) {\n\n\t\t\t\t\treturn texture2D( tNormal, vUv + vec2(x, y) * resolution.zw ).rgb * 2.0 - 1.0;\n\n\t\t\t\t}\n\n\t\t\t\tfloat depthEdgeIndicator(float depth, vec3 normal) {\n\n\t\t\t\t\tfloat diff = 0.0;\n\t\t\t\t\tdiff += clamp(getDepth(1, 0) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(-1, 0) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(0, 1) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(0, -1) - depth, 0.0, 1.0);\n\t\t\t\t\treturn floor(smoothstep(0.01, 0.02, diff) * 2.) / 2.;\n\n\t\t\t\t}\n\n\t\t\t\tfloat neighborNormalEdgeIndicator(int x, int y, float depth, vec3 normal) {\n\n\t\t\t\t\tfloat depthDiff = getDepth(x, y) - depth;\n\t\t\t\t\tvec3 neighborNormal = getNormal(x, y);\n\n\t\t\t\t\t// Edge pixels should yield to faces who's normals are closer to the bias normal.\n\t\t\t\t\tvec3 normalEdgeBias = vec3(1., 1., 1.); // This should probably be a parameter.\n\t\t\t\t\tfloat normalDiff = dot(normal - neighborNormal, normalEdgeBias);\n\t\t\t\t\tfloat normalIndicator = clamp(smoothstep(-.01, .01, normalDiff), 0.0, 1.0);\n\n\t\t\t\t\t// Only the shallower pixel should detect the normal edge.\n\t\t\t\t\tfloat depthIndicator = clamp(sign(depthDiff * .25 + .0025), 0.0, 1.0);\n\n\t\t\t\t\treturn (1.0 - dot(normal, neighborNormal)) * depthIndicator * normalIndicator;\n\n\t\t\t\t}\n\n\t\t\t\tfloat normalEdgeIndicator(float depth, vec3 normal) {\n\n\t\t\t\t\tfloat indicator = 0.0;\n\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(0, -1, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(0, 1, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(-1, 0, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(1, 0, depth, normal);\n\n\t\t\t\t\treturn step(0.1, indicator);\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\t\t\tfloat depth = 0.0;\n\t\t\t\t\tvec3 normal = vec3(0.0);\n\n\t\t\t\t\tif (depthEdgeStrength > 0.0 || normalEdgeStrength > 0.0) {\n\n\t\t\t\t\t\tdepth = getDepth(0, 0);\n\t\t\t\t\t\tnormal = getNormal(0, 0);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat dei = 0.0;\n\t\t\t\t\tif (depthEdgeStrength > 0.0)\n\t\t\t\t\t\tdei = depthEdgeIndicator(depth, normal);\n\n\t\t\t\t\tfloat nei = 0.0;\n\t\t\t\t\tif (normalEdgeStrength > 0.0)\n\t\t\t\t\t\tnei = normalEdgeIndicator(depth, normal);\n\n\t\t\t\t\tfloat Strength = dei > 0.0 ? (1.0 - depthEdgeStrength * dei) : (1.0 + normalEdgeStrength * nei);\n\n\t\t\t\t\tgl_FragColor = texel * Strength;\n\n\t\t\t\t}\n\t\t\t`\n\t\t} );\n\n\t}\n\n}\n\nexport { RenderPixelatedPass };\n"],"mappings":"AAAA,SACCA,iBAAiB,EACjBC,kBAAkB,EAClBC,cAAc,EACdC,OAAO,EACPC,OAAO,EACPC,YAAY,EACZC,aAAa,EACbC,aAAa,QACP,OAAO;AACd,SAASC,IAAI,EAAEC,cAAc,QAAQ,WAAW;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,mBAAmB,SAASF,IAAI,CAAC;EAEtC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;EACCG,WAAWA,CAAEC,SAAS,EAAEC,KAAK,EAAEC,MAAM,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAG;IAErD,KAAK,CAAC,CAAC;;IAEP;AACF;AACA;AACA;AACA;IACE,IAAI,CAACH,SAAS,GAAGA,SAAS;;IAE1B;AACF;AACA;AACA;AACA;IACE,IAAI,CAACC,KAAK,GAAGA,KAAK;;IAElB;AACF;AACA;AACA;AACA;IACE,IAAI,CAACC,MAAM,GAAGA,MAAM;;IAEpB;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACE,kBAAkB,GAAGD,OAAO,CAACC,kBAAkB,IAAI,GAAG;;IAE3D;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,iBAAiB,GAAGF,OAAO,CAACE,iBAAiB,IAAI,GAAG;;IAEzD;AACF;AACA;AACA;AACA;IACE,IAAI,CAACC,iBAAiB,GAAG,IAAI,CAACC,wBAAwB,CAAC,CAAC;;IAExD;;IAEA,IAAI,CAACC,WAAW,GAAG,IAAIjB,OAAO,CAAC,CAAC;IAChC,IAAI,CAACkB,iBAAiB,GAAG,IAAIlB,OAAO,CAAC,CAAC;IAEtC,IAAI,CAACmB,eAAe,GAAG,IAAIrB,kBAAkB,CAAC,CAAC;IAE/C,IAAI,CAACsB,mBAAmB,GAAG,IAAIvB,iBAAiB,CAAC,CAAC;IAClD,IAAI,CAACuB,mBAAmB,CAACC,OAAO,CAACC,SAAS,GAAGnB,aAAa;IAC1D,IAAI,CAACiB,mBAAmB,CAACC,OAAO,CAACE,SAAS,GAAGpB,aAAa;IAC1D,IAAI,CAACiB,mBAAmB,CAACC,OAAO,CAACG,IAAI,GAAGpB,aAAa;IACrD,IAAI,CAACgB,mBAAmB,CAACK,YAAY,GAAG,IAAIvB,YAAY,CAAC,CAAC;IAE1D,IAAI,CAACwB,mBAAmB,GAAG,IAAI7B,iBAAiB,CAAC,CAAC;IAClD,IAAI,CAAC6B,mBAAmB,CAACL,OAAO,CAACC,SAAS,GAAGnB,aAAa;IAC1D,IAAI,CAACuB,mBAAmB,CAACL,OAAO,CAACE,SAAS,GAAGpB,aAAa;IAC1D,IAAI,CAACuB,mBAAmB,CAACL,OAAO,CAACG,IAAI,GAAGpB,aAAa;IAErD,IAAI,CAACuB,OAAO,GAAG,IAAIrB,cAAc,CAAE,IAAI,CAACS,iBAAkB,CAAC;EAE5D;;EAEA;AACD;AACA;AACA;EACCa,OAAOA,CAAA,EAAG;IAET,IAAI,CAACR,mBAAmB,CAACQ,OAAO,CAAC,CAAC;IAClC,IAAI,CAACF,mBAAmB,CAACE,OAAO,CAAC,CAAC;IAElC,IAAI,CAACb,iBAAiB,CAACa,OAAO,CAAC,CAAC;IAChC,IAAI,CAACT,eAAe,CAACS,OAAO,CAAC,CAAC;IAE9B,IAAI,CAACD,OAAO,CAACC,OAAO,CAAC,CAAC;EAEvB;;EAEA;AACD;AACA;AACA;AACA;AACA;EACCC,OAAOA,CAAEC,KAAK,EAAEC,MAAM,EAAG;IAExB,IAAI,CAACd,WAAW,CAACe,GAAG,CAAEF,KAAK,EAAEC,MAAO,CAAC;IACrC,IAAI,CAACb,iBAAiB,CAACc,GAAG,CAAIF,KAAK,GAAG,IAAI,CAACrB,SAAS,GAAK,CAAC,EAAIsB,MAAM,GAAG,IAAI,CAACtB,SAAS,GAAK,CAAE,CAAC;IAC7F,MAAM;MAAEwB,CAAC;MAAEC;IAAE,CAAC,GAAG,IAAI,CAAChB,iBAAiB;IACvC,IAAI,CAACE,mBAAmB,CAACS,OAAO,CAAEI,CAAC,EAAEC,CAAE,CAAC;IACxC,IAAI,CAACR,mBAAmB,CAACG,OAAO,CAAEI,CAAC,EAAEC,CAAE,CAAC;IACxC,IAAI,CAACP,OAAO,CAACQ,QAAQ,CAACC,QAAQ,CAACC,UAAU,CAACC,KAAK,CAACN,GAAG,CAAEC,CAAC,EAAEC,CAAC,EAAE,CAAC,GAAGD,CAAC,EAAE,CAAC,GAAGC,CAAE,CAAC;EAE1E;;EAEA;AACD;AACA;AACA;AACA;EACCK,YAAYA,CAAE9B,SAAS,EAAG;IAEzB,IAAI,CAACA,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACoB,OAAO,CAAE,IAAI,CAACZ,WAAW,CAACgB,CAAC,EAAE,IAAI,CAAChB,WAAW,CAACiB,CAAE,CAAC;EAEvD;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCM,MAAMA,CAAEC,QAAQ,EAAEC,WAAW,4CAA4C;IAExE,MAAMN,QAAQ,GAAG,IAAI,CAACT,OAAO,CAACQ,QAAQ,CAACC,QAAQ;IAC/CA,QAAQ,CAACvB,kBAAkB,CAACyB,KAAK,GAAG,IAAI,CAACzB,kBAAkB;IAC3DuB,QAAQ,CAACtB,iBAAiB,CAACwB,KAAK,GAAG,IAAI,CAACxB,iBAAiB;IAEzD2B,QAAQ,CAACE,eAAe,CAAE,IAAI,CAACvB,mBAAoB,CAAC;IACpDqB,QAAQ,CAACD,MAAM,CAAE,IAAI,CAAC9B,KAAK,EAAE,IAAI,CAACC,MAAO,CAAC;IAE1C,MAAMiC,oBAAoB,GAAG,IAAI,CAAClC,KAAK,CAACmC,gBAAgB;IACxDJ,QAAQ,CAACE,eAAe,CAAE,IAAI,CAACjB,mBAAoB,CAAC;IACpD,IAAI,CAAChB,KAAK,CAACmC,gBAAgB,GAAG,IAAI,CAAC1B,eAAe;IAClDsB,QAAQ,CAACD,MAAM,CAAE,IAAI,CAAC9B,KAAK,EAAE,IAAI,CAACC,MAAO,CAAC;IAC1C,IAAI,CAACD,KAAK,CAACmC,gBAAgB,GAAGD,oBAAoB;IAElDR,QAAQ,CAACU,QAAQ,CAACR,KAAK,GAAG,IAAI,CAAClB,mBAAmB,CAACC,OAAO;IAC1De,QAAQ,CAACW,MAAM,CAACT,KAAK,GAAG,IAAI,CAAClB,mBAAmB,CAACK,YAAY;IAC7DW,QAAQ,CAACY,OAAO,CAACV,KAAK,GAAG,IAAI,CAACZ,mBAAmB,CAACL,OAAO;IAEzD,IAAK,IAAI,CAAC4B,cAAc,EAAG;MAE1BR,QAAQ,CAACE,eAAe,CAAE,IAAK,CAAC;IAEjC,CAAC,MAAM;MAENF,QAAQ,CAACE,eAAe,CAAED,WAAY,CAAC;MAEvC,IAAK,IAAI,CAACQ,KAAK,EAAGT,QAAQ,CAACS,KAAK,CAAC,CAAC;IAEnC;IAEA,IAAI,CAACvB,OAAO,CAACa,MAAM,CAAEC,QAAS,CAAC;EAEhC;;EAEA;;EAEAzB,wBAAwBA,CAAA,EAAG;IAE1B,OAAO,IAAIjB,cAAc,CAAE;MAC1BqC,QAAQ,EAAE;QACTU,QAAQ,EAAE;UAAER,KAAK,EAAE;QAAK,CAAC;QACzBS,MAAM,EAAE;UAAET,KAAK,EAAE;QAAK,CAAC;QACvBU,OAAO,EAAE;UAAEV,KAAK,EAAE;QAAK,CAAC;QACxBD,UAAU,EAAE;UAAEC,KAAK,EAAE,IAAIrC,OAAO,CAAC;QAAE,CAAC;QACpCY,kBAAkB,EAAE;UAAEyB,KAAK,EAAE;QAAE,CAAC;QAChCxB,iBAAiB,EAAE;UAAEwB,KAAK,EAAE;QAAE;MAC/B,CAAC;MACDa,YAAY,EAAE,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;MACDC,cAAc,EAAE,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE,CAAE,CAAC;EAEJ;AAED;AAEA,SAAS7C,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}