{"ast":null,"code":"// Original src: https://github.com/zz85/threejs-path-flow\nconst CHANNELS = 4;\nconst TEXTURE_WIDTH = 1024;\nconst TEXTURE_HEIGHT = 4;\nimport { DataTexture, DataUtils, RGBAFormat, HalfFloatType, RepeatWrapping, Mesh, InstancedMesh, LinearFilter, DynamicDrawUsage, Matrix4 } from 'three';\n\n/**\n * Make a new DataTexture to store the descriptions of the curves.\n *\n * @private\n * @param {number} numberOfCurves - The number of curves needed to be described by this texture.\n * @returns {DataTexture}\n */\nfunction initSplineTexture(numberOfCurves = 1) {\n  const dataArray = new Uint16Array(TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * CHANNELS);\n  const dataTexture = new DataTexture(dataArray, TEXTURE_WIDTH, TEXTURE_HEIGHT * numberOfCurves, RGBAFormat, HalfFloatType);\n  dataTexture.wrapS = RepeatWrapping;\n  dataTexture.wrapY = RepeatWrapping;\n  dataTexture.magFilter = LinearFilter;\n  dataTexture.minFilter = LinearFilter;\n  dataTexture.needsUpdate = true;\n  return dataTexture;\n}\n\n/**\n * Write the curve description to the data texture.\n *\n * @private\n * @param {DataTexture} texture - The data texture to write to.\n * @param {Curve} splineCurve - The curve to describe.\n * @param {number} offset - Which curve slot to write to.\n */\nfunction updateSplineTexture(texture, splineCurve, offset = 0) {\n  const numberOfPoints = Math.floor(TEXTURE_WIDTH * (TEXTURE_HEIGHT / 4));\n  splineCurve.arcLengthDivisions = numberOfPoints / 2;\n  splineCurve.updateArcLengths();\n  const points = splineCurve.getSpacedPoints(numberOfPoints);\n  const frenetFrames = splineCurve.computeFrenetFrames(numberOfPoints, true);\n  for (let i = 0; i < numberOfPoints; i++) {\n    const rowOffset = Math.floor(i / TEXTURE_WIDTH);\n    const rowIndex = i % TEXTURE_WIDTH;\n    let pt = points[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.tangents[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.normals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.binormals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + TEXTURE_HEIGHT * offset);\n  }\n  texture.needsUpdate = true;\n}\nfunction setTextureValue(texture, index, x, y, z, o) {\n  const image = texture.image;\n  const {\n    data\n  } = image;\n  const i = CHANNELS * TEXTURE_WIDTH * o; // Row Offset\n  data[index * CHANNELS + i + 0] = DataUtils.toHalfFloat(x);\n  data[index * CHANNELS + i + 1] = DataUtils.toHalfFloat(y);\n  data[index * CHANNELS + i + 2] = DataUtils.toHalfFloat(z);\n  data[index * CHANNELS + i + 3] = DataUtils.toHalfFloat(1);\n}\n\n/**\n * Create a new set of uniforms for describing the curve modifier.\n *\n * @param {DataTexture} splineTexture - Which holds the curve description.\n * @returns {Object} The uniforms object to be used in the shader.\n */\nfunction getUniforms(splineTexture) {\n  const uniforms = {\n    spineTexture: {\n      value: splineTexture\n    },\n    pathOffset: {\n      type: 'f',\n      value: 0\n    },\n    // time of path curve\n    pathSegment: {\n      type: 'f',\n      value: 1\n    },\n    // fractional length of path\n    spineOffset: {\n      type: 'f',\n      value: 161\n    },\n    spineLength: {\n      type: 'f',\n      value: 400\n    },\n    flow: {\n      type: 'i',\n      value: 1\n    }\n  };\n  return uniforms;\n}\nfunction modifyShader(material, uniforms, numberOfCurves = 1) {\n  if (material.__ok) return;\n  material.__ok = true;\n  material.onBeforeCompile = shader => {\n    if (shader.__modified) return;\n    shader.__modified = true;\n    Object.assign(shader.uniforms, uniforms);\n    const vertexShader = `\n\t\tuniform sampler2D spineTexture;\n\t\tuniform float pathOffset;\n\t\tuniform float pathSegment;\n\t\tuniform float spineOffset;\n\t\tuniform float spineLength;\n\t\tuniform int flow;\n\n\t\tfloat textureLayers = ${TEXTURE_HEIGHT * numberOfCurves}.;\n\t\tfloat textureStacks = ${TEXTURE_HEIGHT / 4}.;\n\n\t\t${shader.vertexShader}\n\t\t`\n    // chunk import moved in front of modified shader below\n    .replace('#include <beginnormal_vertex>', '')\n\n    // vec3 transformedNormal declaration overridden below\n    .replace('#include <defaultnormal_vertex>', '')\n\n    // vec3 transformed declaration overridden below\n    .replace('#include <begin_vertex>', '')\n\n    // shader override\n    .replace(/void\\s*main\\s*\\(\\)\\s*\\{/, `\nvoid main() {\n#include <beginnormal_vertex>\n\nvec4 worldPos = modelMatrix * vec4(position, 1.);\n\nbool bend = flow > 0;\nfloat xWeight = bend ? 0. : 1.;\n\n#ifdef USE_INSTANCING\nfloat pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\nfloat spineLengthFromInstanceMatrix = instanceMatrix[3][0];\nfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\nfloat mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\n#else\nfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\nfloat mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\n#endif\n\nmt = mod(mt, textureStacks);\nfloat rowOffset = floor(mt);\n\n#ifdef USE_INSTANCING\nrowOffset += instanceMatrix[3][1] * ${TEXTURE_HEIGHT}.;\n#endif\n\nvec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\nmat3 basis = mat3(a, b, c);\n\nvec3 transformed = basis\n\t* vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n\t+ spinePos;\n\nvec3 transformedNormal = normalMatrix * (basis * objectNormal);\n\t\t\t`).replace('#include <project_vertex>', `vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;`);\n    shader.vertexShader = vertexShader;\n  };\n}\n\n/**\n * A modifier for making meshes bend around curves.\n *\n * This module can only be used with {@link WebGLRenderer}. When using {@link WebGPURenderer},\n * import the class from `CurveModifierGPU.js`.\n *\n * @three_import import { Flow } from 'three/addons/modifiers/CurveModifier.js';\n */\nexport class Flow {\n  /**\n   * Constructs a new Flow instance.\n   *\n   * @param {Mesh} mesh - The mesh to clone and modify to bend around the curve.\n   * @param {number} numberOfCurves - The amount of space that should preallocated for additional curves.\n   */\n  constructor(mesh, numberOfCurves = 1) {\n    const obj3D = mesh.clone();\n    const splineTexture = initSplineTexture(numberOfCurves);\n    const uniforms = getUniforms(splineTexture);\n    obj3D.traverse(function (child) {\n      if (child instanceof Mesh || child instanceof InstancedMesh) {\n        if (Array.isArray(child.material)) {\n          const materials = [];\n          for (const material of child.material) {\n            const newMaterial = material.clone();\n            modifyShader(newMaterial, uniforms, numberOfCurves);\n            materials.push(newMaterial);\n          }\n          child.material = materials;\n        } else {\n          child.material = child.material.clone();\n          modifyShader(child.material, uniforms, numberOfCurves);\n        }\n      }\n    });\n    this.curveArray = new Array(numberOfCurves);\n    this.curveLengthArray = new Array(numberOfCurves);\n    this.object3D = obj3D;\n    this.splineTexture = splineTexture;\n    this.uniforms = uniforms;\n  }\n\n  /**\n   * Updates the curve for the given curve index.\n   *\n   * @param {number} index - The curve index.\n   * @param {Curve} curve - The curve that should be used to bend the mesh.\n   */\n  updateCurve(index, curve) {\n    if (index >= this.curveArray.length) throw Error('Flow: Index out of range.');\n    const curveLength = curve.getLength();\n    this.uniforms.spineLength.value = curveLength;\n    this.curveLengthArray[index] = curveLength;\n    this.curveArray[index] = curve;\n    updateSplineTexture(this.splineTexture, curve, index);\n  }\n\n  /**\n   * Moves the mesh along the curve.\n   *\n   * @param {number} amount - The offset.\n   */\n  moveAlongCurve(amount) {\n    this.uniforms.pathOffset.value += amount;\n  }\n}\nconst _matrix = new Matrix4();\n\n/**\n * An instanced version of {@link Flow} for making meshes bend around curves, where the instances are placed on the curve.\n *\n * This module can only be used with {@link WebGLRenderer}.\n *\n * @augments Flow\n * @three_import import { InstancedFlow } from 'three/addons/modifiers/CurveModifier.js';\n */\nexport class InstancedFlow extends Flow {\n  /**\n   * Constructs a new InstancedFlow instance.\n   *\n   * @param {number} count - The number of instanced elements.\n   * @param {number} curveCount - The number of curves to preallocate for.\n   * @param {Geometry} geometry - The geometry to use for the instanced mesh.\n   * @param {Material} material - The material to use for the instanced mesh.\n   */\n  constructor(count, curveCount, geometry, material) {\n    const mesh = new InstancedMesh(geometry, material, count);\n    mesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    mesh.frustumCulled = false;\n    super(mesh, curveCount);\n    this.offsets = new Array(count).fill(0);\n    this.whichCurve = new Array(count).fill(0);\n  }\n\n  /**\n   * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\n   * This writes that information to the matrix and marks it as needing update.\n   *\n   * @param {number} index - The index of tge instanced element to update.\n   */\n  writeChanges(index) {\n    _matrix.makeTranslation(this.curveLengthArray[this.whichCurve[index]], this.whichCurve[index], this.offsets[index]);\n    this.object3D.setMatrixAt(index, _matrix);\n    this.object3D.instanceMatrix.needsUpdate = true;\n  }\n\n  /**\n   * Move an individual element along the curve by a specific amount.\n   *\n   * @param {number} index - Which element to update.\n   * @param {number} offset - The offset.\n   */\n  moveIndividualAlongCurve(index, offset) {\n    this.offsets[index] += offset;\n    this.writeChanges(index);\n  }\n\n  /**\n   * Select which curve to use for an element.\n   *\n   * @param {number} index - The index of the instanced element to update.\n   * @param {number} curveNo - The index of the curve it should use.\n   */\n  setCurve(index, curveNo) {\n    if (isNaN(curveNo)) throw Error('InstancedFlow: Curve index being set is Not a Number (NaN).');\n    this.whichCurve[index] = curveNo;\n    this.writeChanges(index);\n  }\n}","map":{"version":3,"names":["CHANNELS","TEXTURE_WIDTH","TEXTURE_HEIGHT","DataTexture","DataUtils","RGBAFormat","HalfFloatType","RepeatWrapping","Mesh","InstancedMesh","LinearFilter","DynamicDrawUsage","Matrix4","initSplineTexture","numberOfCurves","dataArray","Uint16Array","dataTexture","wrapS","wrapY","magFilter","minFilter","needsUpdate","updateSplineTexture","texture","splineCurve","offset","numberOfPoints","Math","floor","arcLengthDivisions","updateArcLengths","points","getSpacedPoints","frenetFrames","computeFrenetFrames","i","rowOffset","rowIndex","pt","setTextureValue","x","y","z","tangents","normals","binormals","index","o","image","data","toHalfFloat","getUniforms","splineTexture","uniforms","spineTexture","value","pathOffset","type","pathSegment","spineOffset","spineLength","flow","modifyShader","material","__ok","onBeforeCompile","shader","__modified","Object","assign","vertexShader","replace","Flow","constructor","mesh","obj3D","clone","traverse","child","Array","isArray","materials","newMaterial","push","curveArray","curveLengthArray","object3D","updateCurve","curve","length","Error","curveLength","getLength","moveAlongCurve","amount","_matrix","InstancedFlow","count","curveCount","geometry","instanceMatrix","setUsage","frustumCulled","offsets","fill","whichCurve","writeChanges","makeTranslation","setMatrixAt","moveIndividualAlongCurve","setCurve","curveNo","isNaN"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/modifiers/CurveModifier.js"],"sourcesContent":["// Original src: https://github.com/zz85/threejs-path-flow\nconst CHANNELS = 4;\nconst TEXTURE_WIDTH = 1024;\nconst TEXTURE_HEIGHT = 4;\n\nimport {\n\tDataTexture,\n\tDataUtils,\n\tRGBAFormat,\n\tHalfFloatType,\n\tRepeatWrapping,\n\tMesh,\n\tInstancedMesh,\n\tLinearFilter,\n\tDynamicDrawUsage,\n\tMatrix4\n} from 'three';\n\n/**\n * Make a new DataTexture to store the descriptions of the curves.\n *\n * @private\n * @param {number} numberOfCurves - The number of curves needed to be described by this texture.\n * @returns {DataTexture}\n */\nfunction initSplineTexture( numberOfCurves = 1 ) {\n\n\tconst dataArray = new Uint16Array( TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * CHANNELS );\n\tconst dataTexture = new DataTexture(\n\t\tdataArray,\n\t\tTEXTURE_WIDTH,\n\t\tTEXTURE_HEIGHT * numberOfCurves,\n\t\tRGBAFormat,\n\t\tHalfFloatType\n\t);\n\n\tdataTexture.wrapS = RepeatWrapping;\n\tdataTexture.wrapY = RepeatWrapping;\n\tdataTexture.magFilter = LinearFilter;\n\tdataTexture.minFilter = LinearFilter;\n\tdataTexture.needsUpdate = true;\n\n\treturn dataTexture;\n\n}\n\n/**\n * Write the curve description to the data texture.\n *\n * @private\n * @param {DataTexture} texture - The data texture to write to.\n * @param {Curve} splineCurve - The curve to describe.\n * @param {number} offset - Which curve slot to write to.\n */\nfunction updateSplineTexture( texture, splineCurve, offset = 0 ) {\n\n\tconst numberOfPoints = Math.floor( TEXTURE_WIDTH * ( TEXTURE_HEIGHT / 4 ) );\n\tsplineCurve.arcLengthDivisions = numberOfPoints / 2;\n\tsplineCurve.updateArcLengths();\n\tconst points = splineCurve.getSpacedPoints( numberOfPoints );\n\tconst frenetFrames = splineCurve.computeFrenetFrames( numberOfPoints, true );\n\n\tfor ( let i = 0; i < numberOfPoints; i ++ ) {\n\n\t\tconst rowOffset = Math.floor( i / TEXTURE_WIDTH );\n\t\tconst rowIndex = i % TEXTURE_WIDTH;\n\n\t\tlet pt = points[ i ];\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\n\t\tpt = frenetFrames.tangents[ i ];\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\n\t\tpt = frenetFrames.normals[ i ];\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\n\t\tpt = frenetFrames.binormals[ i ];\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\n\n\t}\n\n\ttexture.needsUpdate = true;\n\n}\n\nfunction setTextureValue( texture, index, x, y, z, o ) {\n\n\tconst image = texture.image;\n\tconst { data } = image;\n\tconst i = CHANNELS * TEXTURE_WIDTH * o; // Row Offset\n\tdata[ index * CHANNELS + i + 0 ] = DataUtils.toHalfFloat( x );\n\tdata[ index * CHANNELS + i + 1 ] = DataUtils.toHalfFloat( y );\n\tdata[ index * CHANNELS + i + 2 ] = DataUtils.toHalfFloat( z );\n\tdata[ index * CHANNELS + i + 3 ] = DataUtils.toHalfFloat( 1 );\n\n}\n\n/**\n * Create a new set of uniforms for describing the curve modifier.\n *\n * @param {DataTexture} splineTexture - Which holds the curve description.\n * @returns {Object} The uniforms object to be used in the shader.\n */\nfunction getUniforms( splineTexture ) {\n\n\tconst uniforms = {\n\t\tspineTexture: { value: splineTexture },\n\t\tpathOffset: { type: 'f', value: 0 }, // time of path curve\n\t\tpathSegment: { type: 'f', value: 1 }, // fractional length of path\n\t\tspineOffset: { type: 'f', value: 161 },\n\t\tspineLength: { type: 'f', value: 400 },\n\t\tflow: { type: 'i', value: 1 },\n\t};\n\treturn uniforms;\n\n}\n\nfunction modifyShader( material, uniforms, numberOfCurves = 1 ) {\n\n\tif ( material.__ok ) return;\n\tmaterial.__ok = true;\n\n\tmaterial.onBeforeCompile = ( shader ) => {\n\n\t\tif ( shader.__modified ) return;\n\t\tshader.__modified = true;\n\n\t\tObject.assign( shader.uniforms, uniforms );\n\n\t\tconst vertexShader = `\n\t\tuniform sampler2D spineTexture;\n\t\tuniform float pathOffset;\n\t\tuniform float pathSegment;\n\t\tuniform float spineOffset;\n\t\tuniform float spineLength;\n\t\tuniform int flow;\n\n\t\tfloat textureLayers = ${TEXTURE_HEIGHT * numberOfCurves}.;\n\t\tfloat textureStacks = ${TEXTURE_HEIGHT / 4}.;\n\n\t\t${shader.vertexShader}\n\t\t`\n\t\t// chunk import moved in front of modified shader below\n\t\t\t.replace( '#include <beginnormal_vertex>', '' )\n\n\t\t\t// vec3 transformedNormal declaration overridden below\n\t\t\t.replace( '#include <defaultnormal_vertex>', '' )\n\n\t\t\t// vec3 transformed declaration overridden below\n\t\t\t.replace( '#include <begin_vertex>', '' )\n\n\t\t\t// shader override\n\t\t\t.replace(\n\t\t\t\t/void\\s*main\\s*\\(\\)\\s*\\{/,\n\t\t\t\t`\nvoid main() {\n#include <beginnormal_vertex>\n\nvec4 worldPos = modelMatrix * vec4(position, 1.);\n\nbool bend = flow > 0;\nfloat xWeight = bend ? 0. : 1.;\n\n#ifdef USE_INSTANCING\nfloat pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\nfloat spineLengthFromInstanceMatrix = instanceMatrix[3][0];\nfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\nfloat mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\n#else\nfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\nfloat mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\n#endif\n\nmt = mod(mt, textureStacks);\nfloat rowOffset = floor(mt);\n\n#ifdef USE_INSTANCING\nrowOffset += instanceMatrix[3][1] * ${TEXTURE_HEIGHT}.;\n#endif\n\nvec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\nmat3 basis = mat3(a, b, c);\n\nvec3 transformed = basis\n\t* vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n\t+ spinePos;\n\nvec3 transformedNormal = normalMatrix * (basis * objectNormal);\n\t\t\t` ).replace(\n\t\t\t\t'#include <project_vertex>',\n\t\t\t\t`vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;`\n\t\t\t);\n\n\t\tshader.vertexShader = vertexShader;\n\n\t};\n\n}\n\n/**\n * A modifier for making meshes bend around curves.\n *\n * This module can only be used with {@link WebGLRenderer}. When using {@link WebGPURenderer},\n * import the class from `CurveModifierGPU.js`.\n *\n * @three_import import { Flow } from 'three/addons/modifiers/CurveModifier.js';\n */\nexport class Flow {\n\n\t/**\n\t * Constructs a new Flow instance.\n\t *\n\t * @param {Mesh} mesh - The mesh to clone and modify to bend around the curve.\n\t * @param {number} numberOfCurves - The amount of space that should preallocated for additional curves.\n\t */\n\tconstructor( mesh, numberOfCurves = 1 ) {\n\n\t\tconst obj3D = mesh.clone();\n\t\tconst splineTexture = initSplineTexture( numberOfCurves );\n\t\tconst uniforms = getUniforms( splineTexture );\n\t\tobj3D.traverse( function ( child ) {\n\n\t\t\tif (\n\t\t\t\tchild instanceof Mesh ||\n\t\t\t\tchild instanceof InstancedMesh\n\t\t\t) {\n\n\t\t\t\tif ( Array.isArray( child.material ) ) {\n\n\t\t\t\t\tconst materials = [];\n\n\t\t\t\t\tfor ( const material of child.material ) {\n\n\t\t\t\t\t\tconst newMaterial = material.clone();\n\t\t\t\t\t\tmodifyShader( newMaterial, uniforms, numberOfCurves );\n\t\t\t\t\t\tmaterials.push( newMaterial );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tchild.material = materials;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tchild.material = child.material.clone();\n\t\t\t\t\tmodifyShader( child.material, uniforms, numberOfCurves );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.curveArray = new Array( numberOfCurves );\n\t\tthis.curveLengthArray = new Array( numberOfCurves );\n\n\t\tthis.object3D = obj3D;\n\t\tthis.splineTexture = splineTexture;\n\t\tthis.uniforms = uniforms;\n\n\t}\n\n\t/**\n\t * Updates the curve for the given curve index.\n\t *\n\t * @param {number} index - The curve index.\n\t * @param {Curve} curve - The curve that should be used to bend the mesh.\n\t */\n\tupdateCurve( index, curve ) {\n\n\t\tif ( index >= this.curveArray.length ) throw Error( 'Flow: Index out of range.' );\n\t\tconst curveLength = curve.getLength();\n\t\tthis.uniforms.spineLength.value = curveLength;\n\t\tthis.curveLengthArray[ index ] = curveLength;\n\t\tthis.curveArray[ index ] = curve;\n\t\tupdateSplineTexture( this.splineTexture, curve, index );\n\n\t}\n\n\t/**\n\t * Moves the mesh along the curve.\n\t *\n\t * @param {number} amount - The offset.\n\t */\n\tmoveAlongCurve( amount ) {\n\n\t\tthis.uniforms.pathOffset.value += amount;\n\n\t}\n\n}\n\nconst _matrix = new Matrix4();\n\n/**\n * An instanced version of {@link Flow} for making meshes bend around curves, where the instances are placed on the curve.\n *\n * This module can only be used with {@link WebGLRenderer}.\n *\n * @augments Flow\n * @three_import import { InstancedFlow } from 'three/addons/modifiers/CurveModifier.js';\n */\nexport class InstancedFlow extends Flow {\n\n\t/**\n\t * Constructs a new InstancedFlow instance.\n\t *\n\t * @param {number} count - The number of instanced elements.\n\t * @param {number} curveCount - The number of curves to preallocate for.\n\t * @param {Geometry} geometry - The geometry to use for the instanced mesh.\n\t * @param {Material} material - The material to use for the instanced mesh.\n\t */\n\tconstructor( count, curveCount, geometry, material ) {\n\n\t\tconst mesh = new InstancedMesh(\n\t\t\tgeometry,\n\t\t\tmaterial,\n\t\t\tcount\n\t\t);\n\t\tmesh.instanceMatrix.setUsage( DynamicDrawUsage );\n\t\tmesh.frustumCulled = false;\n\t\tsuper( mesh, curveCount );\n\n\t\tthis.offsets = new Array( count ).fill( 0 );\n\t\tthis.whichCurve = new Array( count ).fill( 0 );\n\n\t}\n\n\t/**\n\t * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\n\t * This writes that information to the matrix and marks it as needing update.\n\t *\n\t * @param {number} index - The index of tge instanced element to update.\n\t */\n\twriteChanges( index ) {\n\n\t\t_matrix.makeTranslation(\n\t\t\tthis.curveLengthArray[ this.whichCurve[ index ] ],\n\t\t\tthis.whichCurve[ index ],\n\t\t\tthis.offsets[ index ]\n\t\t);\n\t\tthis.object3D.setMatrixAt( index, _matrix );\n\t\tthis.object3D.instanceMatrix.needsUpdate = true;\n\n\t}\n\n\t/**\n\t * Move an individual element along the curve by a specific amount.\n\t *\n\t * @param {number} index - Which element to update.\n\t * @param {number} offset - The offset.\n\t */\n\tmoveIndividualAlongCurve( index, offset ) {\n\n\t\tthis.offsets[ index ] += offset;\n\t\tthis.writeChanges( index );\n\n\t}\n\n\t/**\n\t * Select which curve to use for an element.\n\t *\n\t * @param {number} index - The index of the instanced element to update.\n\t * @param {number} curveNo - The index of the curve it should use.\n\t */\n\tsetCurve( index, curveNo ) {\n\n\t\tif ( isNaN( curveNo ) ) throw Error( 'InstancedFlow: Curve index being set is Not a Number (NaN).' );\n\t\tthis.whichCurve[ index ] = curveNo;\n\t\tthis.writeChanges( index );\n\n\t}\n\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}