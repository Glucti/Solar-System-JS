{"ast":null,"code":"import { NoColorSpace, DoubleSide, Color } from 'three';\nimport { strToU8, zipSync } from '../libs/fflate.module.js';\n\n/**\n * An exporter for USDZ.\n *\n * ```js\n * const exporter = new USDZExporter();\n * const arraybuffer = await exporter.parseAsync( scene );\n * ```\n *\n * @three_import import { USDZExporter } from 'three/addons/exporters/USDZExporter.js';\n */\nclass USDZExporter {\n  /**\n   * Constructs a new USDZ exporter.\n   */\n  constructor() {\n    /**\n     * A reference to a texture utils module.\n     *\n     * @type {?(WebGLTextureUtils|WebGPUTextureUtils)}\n     * @default null\n     */\n    this.textureUtils = null;\n  }\n\n  /**\n   * Sets the texture utils for this exporter. Only relevant when compressed textures have to be exported.\n   *\n   * Depending on whether you use {@link WebGLRenderer} or {@link WebGPURenderer}, you must inject the\n   * corresponding texture utils {@link WebGLTextureUtils} or {@link WebGPUTextureUtils}.\n   *\n   * @param {WebGLTextureUtils|WebGPUTextureUtils} utils - The texture utils.\n   */\n  setTextureUtils(utils) {\n    this.textureUtils = utils;\n  }\n\n  /**\n   * Parse the given 3D object and generates the USDZ output.\n   *\n   * @param {Object3D} scene - The 3D object to export.\n   * @param {USDZExporter~OnDone} onDone - A callback function that is executed when the export has finished.\n   * @param {USDZExporter~OnError} onError - A callback function that is executed when an error happens.\n   * @param {USDZExporter~Options} options - The export options.\n   */\n  parse(scene, onDone, onError, options) {\n    this.parseAsync(scene, options).then(onDone).catch(onError);\n  }\n\n  /**\n   * Async version of {@link USDZExporter#parse}.\n   *\n   * @async\n   * @param {Object3D} scene - The 3D object to export.\n   * @param {USDZExporter~Options} options - The export options.\n   * @return {Promise<ArrayBuffer>} A Promise that resolved with the exported USDZ data.\n   */\n  async parseAsync(scene, options = {}) {\n    options = Object.assign({\n      ar: {\n        anchoring: {\n          type: 'plane'\n        },\n        planeAnchoring: {\n          alignment: 'horizontal'\n        }\n      },\n      includeAnchoringProperties: true,\n      quickLookCompatible: false,\n      maxTextureSize: 1024\n    }, options);\n    const files = {};\n    const modelFileName = 'model.usda';\n\n    // model file should be first in USDZ archive so we init it here\n    files[modelFileName] = null;\n    let output = buildHeader();\n    output += buildSceneStart(options);\n    const materials = {};\n    const textures = {};\n    scene.traverseVisible(object => {\n      if (object.isMesh) {\n        const geometry = object.geometry;\n        const material = object.material;\n        if (material.isMeshStandardMaterial) {\n          const geometryFileName = 'geometries/Geometry_' + geometry.id + '.usda';\n          if (!(geometryFileName in files)) {\n            const meshObject = buildMeshObject(geometry);\n            files[geometryFileName] = buildUSDFileAsString(meshObject);\n          }\n          if (!(material.uuid in materials)) {\n            materials[material.uuid] = material;\n          }\n          output += buildXform(object, geometry, materials[material.uuid]);\n        } else {\n          console.warn('THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)', object);\n        }\n      } else if (object.isCamera) {\n        output += buildCamera(object);\n      }\n    });\n    output += buildSceneEnd();\n    output += buildMaterials(materials, textures, options.quickLookCompatible);\n    files[modelFileName] = strToU8(output);\n    output = null;\n    for (const id in textures) {\n      let texture = textures[id];\n      if (texture.isCompressedTexture === true) {\n        if (this.textureUtils === null) {\n          throw new Error('THREE.USDZExporter: setTextureUtils() must be called to process compressed textures.');\n        } else {\n          texture = await this.textureUtils.decompress(texture);\n        }\n      }\n      const canvas = imageToCanvas(texture.image, texture.flipY, options.maxTextureSize);\n      const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png', 1));\n      files[`textures/Texture_${id}.png`] = new Uint8Array(await blob.arrayBuffer());\n    }\n\n    // 64 byte alignment\n    // https://github.com/101arrowz/fflate/issues/39#issuecomment-777263109\n\n    let offset = 0;\n    for (const filename in files) {\n      const file = files[filename];\n      const headerSize = 34 + filename.length;\n      offset += headerSize;\n      const offsetMod64 = offset & 63;\n      if (offsetMod64 !== 4) {\n        const padLength = 64 - offsetMod64;\n        const padding = new Uint8Array(padLength);\n        files[filename] = [file, {\n          extra: {\n            12345: padding\n          }\n        }];\n      }\n      offset = file.length;\n    }\n    return zipSync(files, {\n      level: 0\n    });\n  }\n}\nfunction imageToCanvas(image, flipY, maxTextureSize) {\n  if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    const scale = maxTextureSize / Math.max(image.width, image.height);\n    const canvas = document.createElement('canvas');\n    canvas.width = image.width * Math.min(1, scale);\n    canvas.height = image.height * Math.min(1, scale);\n    const context = canvas.getContext('2d');\n\n    // TODO: We should be able to do this in the UsdTransform2d?\n\n    if (flipY === true) {\n      context.translate(0, canvas.height);\n      context.scale(1, -1);\n    }\n    context.drawImage(image, 0, 0, canvas.width, canvas.height);\n    return canvas;\n  } else {\n    throw new Error('THREE.USDZExporter: No valid image data found. Unable to process texture.');\n  }\n}\n\n//\n\nconst PRECISION = 7;\nfunction buildHeader() {\n  return `#usda 1.0\n(\n\tcustomLayerData = {\n\t\tstring creator = \"Three.js USDZExporter\"\n\t}\n\tdefaultPrim = \"Root\"\n\tmetersPerUnit = 1\n\tupAxis = \"Y\"\n)\n\n`;\n}\nfunction buildSceneStart(options) {\n  const alignment = options.includeAnchoringProperties === true ? `\n\t\ttoken preliminary:anchoring:type = \"${options.ar.anchoring.type}\"\n\t\ttoken preliminary:planeAnchoring:alignment = \"${options.ar.planeAnchoring.alignment}\"\n\t` : '';\n  return `def Xform \"Root\"\n{\n\tdef Scope \"Scenes\" (\n\t\tkind = \"sceneLibrary\"\n\t)\n\t{\n\t\tdef Xform \"Scene\" (\n\t\t\tcustomData = {\n\t\t\t\tbool preliminary_collidesWithEnvironment = 0\n\t\t\t\tstring sceneName = \"Scene\"\n\t\t\t}\n\t\t\tsceneName = \"Scene\"\n\t\t)\n\t\t{${alignment}\n`;\n}\nfunction buildSceneEnd() {\n  return `\n\t\t}\n\t}\n}\n\n`;\n}\nfunction buildUSDFileAsString(dataToInsert) {\n  let output = buildHeader();\n  output += dataToInsert;\n  return strToU8(output);\n}\n\n// Xform\n\nfunction buildXform(object, geometry, material) {\n  const name = 'Object_' + object.id;\n  const transform = buildMatrix(object.matrixWorld);\n  if (object.matrixWorld.determinant() < 0) {\n    console.warn('THREE.USDZExporter: USDZ does not support negative scales', object);\n  }\n  return `\t\t\tdef Xform \"${name}\" (\n\t\t\t\tprepend references = @./geometries/Geometry_${geometry.id}.usda@</Geometry>\n\t\t\t\tprepend apiSchemas = [\"MaterialBindingAPI\"]\n\t\t\t)\n\t\t\t{\n\t\t\t\tmatrix4d xformOp:transform = ${transform}\n\t\t\t\tuniform token[] xformOpOrder = [\"xformOp:transform\"]\n\n\t\t\t\trel material:binding = </Materials/Material_${material.id}>\n\t\t\t}\n\n`;\n}\nfunction buildMatrix(matrix) {\n  const array = matrix.elements;\n  return `( ${buildMatrixRow(array, 0)}, ${buildMatrixRow(array, 4)}, ${buildMatrixRow(array, 8)}, ${buildMatrixRow(array, 12)} )`;\n}\nfunction buildMatrixRow(array, offset) {\n  return `(${array[offset + 0]}, ${array[offset + 1]}, ${array[offset + 2]}, ${array[offset + 3]})`;\n}\n\n// Mesh\n\nfunction buildMeshObject(geometry) {\n  const mesh = buildMesh(geometry);\n  return `\ndef \"Geometry\"\n{\n${mesh}\n}\n`;\n}\nfunction buildMesh(geometry) {\n  const name = 'Geometry';\n  const attributes = geometry.attributes;\n  const count = attributes.position.count;\n  return `\n\tdef Mesh \"${name}\"\n\t{\n\t\tint[] faceVertexCounts = [${buildMeshVertexCount(geometry)}]\n\t\tint[] faceVertexIndices = [${buildMeshVertexIndices(geometry)}]\n\t\tnormal3f[] normals = [${buildVector3Array(attributes.normal, count)}] (\n\t\t\tinterpolation = \"vertex\"\n\t\t)\n\t\tpoint3f[] points = [${buildVector3Array(attributes.position, count)}]\n${buildPrimvars(attributes)}\n\t\tuniform token subdivisionScheme = \"none\"\n\t}\n`;\n}\nfunction buildMeshVertexCount(geometry) {\n  const count = geometry.index !== null ? geometry.index.count : geometry.attributes.position.count;\n  return Array(count / 3).fill(3).join(', ');\n}\nfunction buildMeshVertexIndices(geometry) {\n  const index = geometry.index;\n  const array = [];\n  if (index !== null) {\n    for (let i = 0; i < index.count; i++) {\n      array.push(index.getX(i));\n    }\n  } else {\n    const length = geometry.attributes.position.count;\n    for (let i = 0; i < length; i++) {\n      array.push(i);\n    }\n  }\n  return array.join(', ');\n}\nfunction buildVector3Array(attribute, count) {\n  if (attribute === undefined) {\n    console.warn('USDZExporter: Normals missing.');\n    return Array(count).fill('(0, 0, 0)').join(', ');\n  }\n  const array = [];\n  for (let i = 0; i < attribute.count; i++) {\n    const x = attribute.getX(i);\n    const y = attribute.getY(i);\n    const z = attribute.getZ(i);\n    array.push(`(${x.toPrecision(PRECISION)}, ${y.toPrecision(PRECISION)}, ${z.toPrecision(PRECISION)})`);\n  }\n  return array.join(', ');\n}\nfunction buildVector2Array(attribute) {\n  const array = [];\n  for (let i = 0; i < attribute.count; i++) {\n    const x = attribute.getX(i);\n    const y = attribute.getY(i);\n    array.push(`(${x.toPrecision(PRECISION)}, ${1 - y.toPrecision(PRECISION)})`);\n  }\n  return array.join(', ');\n}\nfunction buildPrimvars(attributes) {\n  let string = '';\n  for (let i = 0; i < 4; i++) {\n    const id = i > 0 ? i : '';\n    const attribute = attributes['uv' + id];\n    if (attribute !== undefined) {\n      string += `\n\t\ttexCoord2f[] primvars:st${id} = [${buildVector2Array(attribute)}] (\n\t\t\tinterpolation = \"vertex\"\n\t\t)`;\n    }\n  }\n\n  // vertex colors\n\n  const colorAttribute = attributes.color;\n  if (colorAttribute !== undefined) {\n    const count = colorAttribute.count;\n    string += `\n\tcolor3f[] primvars:displayColor = [${buildVector3Array(colorAttribute, count)}] (\n\t\tinterpolation = \"vertex\"\n\t\t)`;\n  }\n  return string;\n}\n\n// Materials\n\nfunction buildMaterials(materials, textures, quickLookCompatible = false) {\n  const array = [];\n  for (const uuid in materials) {\n    const material = materials[uuid];\n    array.push(buildMaterial(material, textures, quickLookCompatible));\n  }\n  return `def \"Materials\"\n{\n${array.join('')}\n}\n\n`;\n}\nfunction buildMaterial(material, textures, quickLookCompatible = false) {\n  // https://graphics.pixar.com/usd/docs/UsdPreviewSurface-Proposal.html\n\n  const pad = '\t\t\t';\n  const inputs = [];\n  const samplers = [];\n  function buildTexture(texture, mapType, color) {\n    const id = texture.source.id + '_' + texture.flipY;\n    textures[id] = texture;\n    const uv = texture.channel > 0 ? 'st' + texture.channel : 'st';\n    const WRAPPINGS = {\n      1000: 'repeat',\n      // RepeatWrapping\n      1001: 'clamp',\n      // ClampToEdgeWrapping\n      1002: 'mirror' // MirroredRepeatWrapping\n    };\n    const repeat = texture.repeat.clone();\n    const offset = texture.offset.clone();\n    const rotation = texture.rotation;\n\n    // rotation is around the wrong point. after rotation we need to shift offset again so that we're rotating around the right spot\n    const xRotationOffset = Math.sin(rotation);\n    const yRotationOffset = Math.cos(rotation);\n\n    // texture coordinates start in the opposite corner, need to correct\n    offset.y = 1 - offset.y - repeat.y;\n\n    // turns out QuickLook is buggy and interprets texture repeat inverted/applies operations in a different order.\n    // Apple Feedback: \tFB10036297 and FB11442287\n    if (quickLookCompatible) {\n      // This is NOT correct yet in QuickLook, but comes close for a range of models.\n      // It becomes more incorrect the bigger the offset is\n\n      offset.x = offset.x / repeat.x;\n      offset.y = offset.y / repeat.y;\n      offset.x += xRotationOffset / repeat.x;\n      offset.y += yRotationOffset - 1;\n    } else {\n      // results match glTF results exactly. verified correct in usdview.\n      offset.x += xRotationOffset * repeat.x;\n      offset.y += (1 - yRotationOffset) * repeat.y;\n    }\n    return `\n\t\tdef Shader \"PrimvarReader_${mapType}\"\n\t\t{\n\t\t\tuniform token info:id = \"UsdPrimvarReader_float2\"\n\t\t\tfloat2 inputs:fallback = (0.0, 0.0)\n\t\t\ttoken inputs:varname = \"${uv}\"\n\t\t\tfloat2 outputs:result\n\t\t}\n\n\t\tdef Shader \"Transform2d_${mapType}\"\n\t\t{\n\t\t\tuniform token info:id = \"UsdTransform2d\"\n\t\t\ttoken inputs:in.connect = </Materials/Material_${material.id}/PrimvarReader_${mapType}.outputs:result>\n\t\t\tfloat inputs:rotation = ${(rotation * (180 / Math.PI)).toFixed(PRECISION)}\n\t\t\tfloat2 inputs:scale = ${buildVector2(repeat)}\n\t\t\tfloat2 inputs:translation = ${buildVector2(offset)}\n\t\t\tfloat2 outputs:result\n\t\t}\n\n\t\tdef Shader \"Texture_${texture.id}_${mapType}\"\n\t\t{\n\t\t\tuniform token info:id = \"UsdUVTexture\"\n\t\t\tasset inputs:file = @textures/Texture_${id}.png@\n\t\t\tfloat2 inputs:st.connect = </Materials/Material_${material.id}/Transform2d_${mapType}.outputs:result>\n\t\t\t${color !== undefined ? 'float4 inputs:scale = ' + buildColor4(color) : ''}\n\t\t\ttoken inputs:sourceColorSpace = \"${texture.colorSpace === NoColorSpace ? 'raw' : 'sRGB'}\"\n\t\t\ttoken inputs:wrapS = \"${WRAPPINGS[texture.wrapS]}\"\n\t\t\ttoken inputs:wrapT = \"${WRAPPINGS[texture.wrapT]}\"\n\t\t\tfloat outputs:r\n\t\t\tfloat outputs:g\n\t\t\tfloat outputs:b\n\t\t\tfloat3 outputs:rgb\n\t\t\t${material.transparent || material.alphaTest > 0.0 ? 'float outputs:a' : ''}\n\t\t}`;\n  }\n  if (material.side === DoubleSide) {\n    console.warn('THREE.USDZExporter: USDZ does not support double sided materials', material);\n  }\n  if (material.map !== null) {\n    inputs.push(`${pad}color3f inputs:diffuseColor.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:rgb>`);\n    if (material.transparent) {\n      inputs.push(`${pad}float inputs:opacity.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:a>`);\n    } else if (material.alphaTest > 0.0) {\n      inputs.push(`${pad}float inputs:opacity.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:a>`);\n      inputs.push(`${pad}float inputs:opacityThreshold = ${material.alphaTest}`);\n    }\n    samplers.push(buildTexture(material.map, 'diffuse', material.color));\n  } else {\n    inputs.push(`${pad}color3f inputs:diffuseColor = ${buildColor(material.color)}`);\n  }\n  if (material.emissiveMap !== null) {\n    inputs.push(`${pad}color3f inputs:emissiveColor.connect = </Materials/Material_${material.id}/Texture_${material.emissiveMap.id}_emissive.outputs:rgb>`);\n    samplers.push(buildTexture(material.emissiveMap, 'emissive', new Color(material.emissive.r * material.emissiveIntensity, material.emissive.g * material.emissiveIntensity, material.emissive.b * material.emissiveIntensity)));\n  } else if (material.emissive.getHex() > 0) {\n    inputs.push(`${pad}color3f inputs:emissiveColor = ${buildColor(material.emissive)}`);\n  }\n  if (material.normalMap !== null) {\n    inputs.push(`${pad}normal3f inputs:normal.connect = </Materials/Material_${material.id}/Texture_${material.normalMap.id}_normal.outputs:rgb>`);\n    samplers.push(buildTexture(material.normalMap, 'normal'));\n  }\n  if (material.aoMap !== null) {\n    inputs.push(`${pad}float inputs:occlusion.connect = </Materials/Material_${material.id}/Texture_${material.aoMap.id}_occlusion.outputs:r>`);\n    samplers.push(buildTexture(material.aoMap, 'occlusion', new Color(material.aoMapIntensity, material.aoMapIntensity, material.aoMapIntensity)));\n  }\n  if (material.roughnessMap !== null) {\n    inputs.push(`${pad}float inputs:roughness.connect = </Materials/Material_${material.id}/Texture_${material.roughnessMap.id}_roughness.outputs:g>`);\n    samplers.push(buildTexture(material.roughnessMap, 'roughness', new Color(material.roughness, material.roughness, material.roughness)));\n  } else {\n    inputs.push(`${pad}float inputs:roughness = ${material.roughness}`);\n  }\n  if (material.metalnessMap !== null) {\n    inputs.push(`${pad}float inputs:metallic.connect = </Materials/Material_${material.id}/Texture_${material.metalnessMap.id}_metallic.outputs:b>`);\n    samplers.push(buildTexture(material.metalnessMap, 'metallic', new Color(material.metalness, material.metalness, material.metalness)));\n  } else {\n    inputs.push(`${pad}float inputs:metallic = ${material.metalness}`);\n  }\n  if (material.alphaMap !== null) {\n    inputs.push(`${pad}float inputs:opacity.connect = </Materials/Material_${material.id}/Texture_${material.alphaMap.id}_opacity.outputs:r>`);\n    inputs.push(`${pad}float inputs:opacityThreshold = 0.0001`);\n    samplers.push(buildTexture(material.alphaMap, 'opacity'));\n  } else {\n    inputs.push(`${pad}float inputs:opacity = ${material.opacity}`);\n  }\n  if (material.isMeshPhysicalMaterial) {\n    if (material.clearcoatMap !== null) {\n      inputs.push(`${pad}float inputs:clearcoat.connect = </Materials/Material_${material.id}/Texture_${material.clearcoatMap.id}_clearcoat.outputs:r>`);\n      samplers.push(buildTexture(material.clearcoatMap, 'clearcoat', new Color(material.clearcoat, material.clearcoat, material.clearcoat)));\n    } else {\n      inputs.push(`${pad}float inputs:clearcoat = ${material.clearcoat}`);\n    }\n    if (material.clearcoatRoughnessMap !== null) {\n      inputs.push(`${pad}float inputs:clearcoatRoughness.connect = </Materials/Material_${material.id}/Texture_${material.clearcoatRoughnessMap.id}_clearcoatRoughness.outputs:g>`);\n      samplers.push(buildTexture(material.clearcoatRoughnessMap, 'clearcoatRoughness', new Color(material.clearcoatRoughness, material.clearcoatRoughness, material.clearcoatRoughness)));\n    } else {\n      inputs.push(`${pad}float inputs:clearcoatRoughness = ${material.clearcoatRoughness}`);\n    }\n    inputs.push(`${pad}float inputs:ior = ${material.ior}`);\n  }\n  return `\n\tdef Material \"Material_${material.id}\"\n\t{\n\t\tdef Shader \"PreviewSurface\"\n\t\t{\n\t\t\tuniform token info:id = \"UsdPreviewSurface\"\n${inputs.join('\\n')}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${material.id}/PreviewSurface.outputs:surface>\n\n${samplers.join('\\n')}\n\n\t}\n`;\n}\nfunction buildColor(color) {\n  return `(${color.r}, ${color.g}, ${color.b})`;\n}\nfunction buildColor4(color) {\n  return `(${color.r}, ${color.g}, ${color.b}, 1.0)`;\n}\nfunction buildVector2(vector) {\n  return `(${vector.x}, ${vector.y})`;\n}\nfunction buildCamera(camera) {\n  const name = camera.name ? camera.name : 'Camera_' + camera.id;\n  const transform = buildMatrix(camera.matrixWorld);\n  if (camera.matrixWorld.determinant() < 0) {\n    console.warn('THREE.USDZExporter: USDZ does not support negative scales', camera);\n  }\n  if (camera.isOrthographicCamera) {\n    return `def Camera \"${name}\"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${transform}\n\t\t\tuniform token[] xformOpOrder = [\"xformOp:transform\"]\n\n\t\t\tfloat2 clippingRange = (${camera.near.toPrecision(PRECISION)}, ${camera.far.toPrecision(PRECISION)})\n\t\t\tfloat horizontalAperture = ${((Math.abs(camera.left) + Math.abs(camera.right)) * 10).toPrecision(PRECISION)}\n\t\t\tfloat verticalAperture = ${((Math.abs(camera.top) + Math.abs(camera.bottom)) * 10).toPrecision(PRECISION)}\n\t\t\ttoken projection = \"orthographic\"\n\t\t}\n\n\t`;\n  } else {\n    return `def Camera \"${name}\"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${transform}\n\t\t\tuniform token[] xformOpOrder = [\"xformOp:transform\"]\n\n\t\t\tfloat2 clippingRange = (${camera.near.toPrecision(PRECISION)}, ${camera.far.toPrecision(PRECISION)})\n\t\t\tfloat focalLength = ${camera.getFocalLength().toPrecision(PRECISION)}\n\t\t\tfloat focusDistance = ${camera.focus.toPrecision(PRECISION)}\n\t\t\tfloat horizontalAperture = ${camera.getFilmWidth().toPrecision(PRECISION)}\n\t\t\ttoken projection = \"perspective\"\n\t\t\tfloat verticalAperture = ${camera.getFilmHeight().toPrecision(PRECISION)}\n\t\t}\n\n\t`;\n  }\n}\n\n/**\n * Export options of `USDZExporter`.\n *\n * @typedef {Object} USDZExporter~Options\n * @property {number} [maxTextureSize=1024] - The maximum texture size that is going to be exported.\n * @property {boolean} [includeAnchoringProperties=true] - Whether to include anchoring properties or not.\n * @property {Object} [ar] - If `includeAnchoringProperties` is set to `true`, the anchoring type and alignment\n * can be configured via `ar.anchoring.type` and `ar.planeAnchoring.alignment`.\n * @property {boolean} [quickLookCompatible=false] - Whether to make the exported USDZ compatible to QuickLook\n * which means the asset is modified to accommodate the bugs FB10036297 and FB11442287 (Apple Feedback).\n **/\n\n/**\n * onDone callback of `USDZExporter`.\n *\n * @callback USDZExporter~OnDone\n * @param {ArrayBuffer} result - The generated USDZ.\n */\n\n/**\n * onError callback of `USDZExporter`.\n *\n * @callback USDZExporter~OnError\n * @param {Error} error - The error object.\n */\n\nexport { USDZExporter };","map":{"version":3,"names":["NoColorSpace","DoubleSide","Color","strToU8","zipSync","USDZExporter","constructor","textureUtils","setTextureUtils","utils","parse","scene","onDone","onError","options","parseAsync","then","catch","Object","assign","ar","anchoring","type","planeAnchoring","alignment","includeAnchoringProperties","quickLookCompatible","maxTextureSize","files","modelFileName","output","buildHeader","buildSceneStart","materials","textures","traverseVisible","object","isMesh","geometry","material","isMeshStandardMaterial","geometryFileName","id","meshObject","buildMeshObject","buildUSDFileAsString","uuid","buildXform","console","warn","isCamera","buildCamera","buildSceneEnd","buildMaterials","texture","isCompressedTexture","Error","decompress","canvas","imageToCanvas","image","flipY","blob","Promise","resolve","toBlob","Uint8Array","arrayBuffer","offset","filename","file","headerSize","length","offsetMod64","padLength","padding","extra","level","HTMLImageElement","HTMLCanvasElement","OffscreenCanvas","ImageBitmap","scale","Math","max","width","height","document","createElement","min","context","getContext","translate","drawImage","PRECISION","dataToInsert","name","transform","buildMatrix","matrixWorld","determinant","matrix","array","elements","buildMatrixRow","mesh","buildMesh","attributes","count","position","buildMeshVertexCount","buildMeshVertexIndices","buildVector3Array","normal","buildPrimvars","index","Array","fill","join","i","push","getX","attribute","undefined","x","y","getY","z","getZ","toPrecision","buildVector2Array","string","colorAttribute","color","buildMaterial","pad","inputs","samplers","buildTexture","mapType","source","uv","channel","WRAPPINGS","repeat","clone","rotation","xRotationOffset","sin","yRotationOffset","cos","PI","toFixed","buildVector2","buildColor4","colorSpace","wrapS","wrapT","transparent","alphaTest","side","map","buildColor","emissiveMap","emissive","r","emissiveIntensity","g","b","getHex","normalMap","aoMap","aoMapIntensity","roughnessMap","roughness","metalnessMap","metalness","alphaMap","opacity","isMeshPhysicalMaterial","clearcoatMap","clearcoat","clearcoatRoughnessMap","clearcoatRoughness","ior","vector","camera","isOrthographicCamera","near","far","abs","left","right","top","bottom","getFocalLength","focus","getFilmWidth","getFilmHeight"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/exporters/USDZExporter.js"],"sourcesContent":["import {\n\tNoColorSpace,\n\tDoubleSide,\n\tColor,\n} from 'three';\n\nimport {\n\tstrToU8,\n\tzipSync,\n} from '../libs/fflate.module.js';\n\n/**\n * An exporter for USDZ.\n *\n * ```js\n * const exporter = new USDZExporter();\n * const arraybuffer = await exporter.parseAsync( scene );\n * ```\n *\n * @three_import import { USDZExporter } from 'three/addons/exporters/USDZExporter.js';\n */\nclass USDZExporter {\n\n\t/**\n\t * Constructs a new USDZ exporter.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * A reference to a texture utils module.\n\t\t *\n\t\t * @type {?(WebGLTextureUtils|WebGPUTextureUtils)}\n\t\t * @default null\n\t\t */\n\t\tthis.textureUtils = null;\n\n\t}\n\n\t/**\n\t * Sets the texture utils for this exporter. Only relevant when compressed textures have to be exported.\n\t *\n\t * Depending on whether you use {@link WebGLRenderer} or {@link WebGPURenderer}, you must inject the\n\t * corresponding texture utils {@link WebGLTextureUtils} or {@link WebGPUTextureUtils}.\n\t *\n\t * @param {WebGLTextureUtils|WebGPUTextureUtils} utils - The texture utils.\n\t */\n\tsetTextureUtils( utils ) {\n\n\t\tthis.textureUtils = utils;\n\n\t}\n\n\t/**\n\t * Parse the given 3D object and generates the USDZ output.\n\t *\n\t * @param {Object3D} scene - The 3D object to export.\n\t * @param {USDZExporter~OnDone} onDone - A callback function that is executed when the export has finished.\n\t * @param {USDZExporter~OnError} onError - A callback function that is executed when an error happens.\n\t * @param {USDZExporter~Options} options - The export options.\n\t */\n\tparse( scene, onDone, onError, options ) {\n\n\t\tthis.parseAsync( scene, options ).then( onDone ).catch( onError );\n\n\t}\n\n\t/**\n\t * Async version of {@link USDZExporter#parse}.\n\t *\n\t * @async\n\t * @param {Object3D} scene - The 3D object to export.\n\t * @param {USDZExporter~Options} options - The export options.\n\t * @return {Promise<ArrayBuffer>} A Promise that resolved with the exported USDZ data.\n\t */\n\tasync parseAsync( scene, options = {} ) {\n\n\t\toptions = Object.assign( {\n\t\t\tar: {\n\t\t\t\tanchoring: { type: 'plane' },\n\t\t\t\tplaneAnchoring: { alignment: 'horizontal' }\n\t\t\t},\n\t\t\tincludeAnchoringProperties: true,\n\t\t\tquickLookCompatible: false,\n\t\t\tmaxTextureSize: 1024,\n\t\t}, options );\n\n\t\tconst files = {};\n\t\tconst modelFileName = 'model.usda';\n\n\t\t// model file should be first in USDZ archive so we init it here\n\t\tfiles[ modelFileName ] = null;\n\n\t\tlet output = buildHeader();\n\n\t\toutput += buildSceneStart( options );\n\n\t\tconst materials = {};\n\t\tconst textures = {};\n\n\t\tscene.traverseVisible( ( object ) => {\n\n\t\t\tif ( object.isMesh ) {\n\n\t\t\t\tconst geometry = object.geometry;\n\t\t\t\tconst material = object.material;\n\n\t\t\t\tif ( material.isMeshStandardMaterial ) {\n\n\t\t\t\t\tconst geometryFileName = 'geometries/Geometry_' + geometry.id + '.usda';\n\n\t\t\t\t\tif ( ! ( geometryFileName in files ) ) {\n\n\t\t\t\t\t\tconst meshObject = buildMeshObject( geometry );\n\t\t\t\t\t\tfiles[ geometryFileName ] = buildUSDFileAsString( meshObject );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! ( material.uuid in materials ) ) {\n\n\t\t\t\t\t\tmaterials[ material.uuid ] = material;\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutput += buildXform( object, geometry, materials[ material.uuid ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)', object );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isCamera ) {\n\n\t\t\t\toutput += buildCamera( object );\n\n\t\t\t}\n\n\t\t} );\n\n\n\t\toutput += buildSceneEnd();\n\n\t\toutput += buildMaterials( materials, textures, options.quickLookCompatible );\n\n\t\tfiles[ modelFileName ] = strToU8( output );\n\t\toutput = null;\n\n\t\tfor ( const id in textures ) {\n\n\t\t\tlet texture = textures[ id ];\n\n\t\t\tif ( texture.isCompressedTexture === true ) {\n\n\t\t\t\tif ( this.textureUtils === null ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.USDZExporter: setTextureUtils() must be called to process compressed textures.' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture = await this.textureUtils.decompress( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst canvas = imageToCanvas( texture.image, texture.flipY, options.maxTextureSize );\n\t\t\tconst blob = await new Promise( resolve => canvas.toBlob( resolve, 'image/png', 1 ) );\n\n\t\t\tfiles[ `textures/Texture_${ id }.png` ] = new Uint8Array( await blob.arrayBuffer() );\n\n\t\t}\n\n\t\t// 64 byte alignment\n\t\t// https://github.com/101arrowz/fflate/issues/39#issuecomment-777263109\n\n\t\tlet offset = 0;\n\n\t\tfor ( const filename in files ) {\n\n\t\t\tconst file = files[ filename ];\n\t\t\tconst headerSize = 34 + filename.length;\n\n\t\t\toffset += headerSize;\n\n\t\t\tconst offsetMod64 = offset & 63;\n\n\t\t\tif ( offsetMod64 !== 4 ) {\n\n\t\t\t\tconst padLength = 64 - offsetMod64;\n\t\t\t\tconst padding = new Uint8Array( padLength );\n\n\t\t\t\tfiles[ filename ] = [ file, { extra: { 12345: padding } } ];\n\n\t\t\t}\n\n\t\t\toffset = file.length;\n\n\t\t}\n\n\t\treturn zipSync( files, { level: 0 } );\n\n\t}\n\n}\n\nfunction imageToCanvas( image, flipY, maxTextureSize ) {\n\n\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t( typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas ) ||\n\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\tconst scale = maxTextureSize / Math.max( image.width, image.height );\n\n\t\tconst canvas = document.createElement( 'canvas' );\n\t\tcanvas.width = image.width * Math.min( 1, scale );\n\t\tcanvas.height = image.height * Math.min( 1, scale );\n\n\t\tconst context = canvas.getContext( '2d' );\n\n\t\t// TODO: We should be able to do this in the UsdTransform2d?\n\n\t\tif ( flipY === true ) {\n\n\t\t\tcontext.translate( 0, canvas.height );\n\t\t\tcontext.scale( 1, - 1 );\n\n\t\t}\n\n\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\treturn canvas;\n\n\t} else {\n\n\t\tthrow new Error( 'THREE.USDZExporter: No valid image data found. Unable to process texture.' );\n\n\t}\n\n}\n\n//\n\nconst PRECISION = 7;\n\nfunction buildHeader() {\n\n\treturn `#usda 1.0\n(\n\tcustomLayerData = {\n\t\tstring creator = \"Three.js USDZExporter\"\n\t}\n\tdefaultPrim = \"Root\"\n\tmetersPerUnit = 1\n\tupAxis = \"Y\"\n)\n\n`;\n\n}\n\nfunction buildSceneStart( options ) {\n\n\tconst alignment = options.includeAnchoringProperties === true ? `\n\t\ttoken preliminary:anchoring:type = \"${options.ar.anchoring.type}\"\n\t\ttoken preliminary:planeAnchoring:alignment = \"${options.ar.planeAnchoring.alignment}\"\n\t` : '';\n\treturn `def Xform \"Root\"\n{\n\tdef Scope \"Scenes\" (\n\t\tkind = \"sceneLibrary\"\n\t)\n\t{\n\t\tdef Xform \"Scene\" (\n\t\t\tcustomData = {\n\t\t\t\tbool preliminary_collidesWithEnvironment = 0\n\t\t\t\tstring sceneName = \"Scene\"\n\t\t\t}\n\t\t\tsceneName = \"Scene\"\n\t\t)\n\t\t{${alignment}\n`;\n\n}\n\nfunction buildSceneEnd() {\n\n\treturn `\n\t\t}\n\t}\n}\n\n`;\n\n}\n\nfunction buildUSDFileAsString( dataToInsert ) {\n\n\tlet output = buildHeader();\n\toutput += dataToInsert;\n\treturn strToU8( output );\n\n}\n\n// Xform\n\nfunction buildXform( object, geometry, material ) {\n\n\tconst name = 'Object_' + object.id;\n\tconst transform = buildMatrix( object.matrixWorld );\n\n\tif ( object.matrixWorld.determinant() < 0 ) {\n\n\t\tconsole.warn( 'THREE.USDZExporter: USDZ does not support negative scales', object );\n\n\t}\n\n\treturn `\t\t\tdef Xform \"${ name }\" (\n\t\t\t\tprepend references = @./geometries/Geometry_${ geometry.id }.usda@</Geometry>\n\t\t\t\tprepend apiSchemas = [\"MaterialBindingAPI\"]\n\t\t\t)\n\t\t\t{\n\t\t\t\tmatrix4d xformOp:transform = ${ transform }\n\t\t\t\tuniform token[] xformOpOrder = [\"xformOp:transform\"]\n\n\t\t\t\trel material:binding = </Materials/Material_${ material.id }>\n\t\t\t}\n\n`;\n\n}\n\nfunction buildMatrix( matrix ) {\n\n\tconst array = matrix.elements;\n\n\treturn `( ${ buildMatrixRow( array, 0 ) }, ${ buildMatrixRow( array, 4 ) }, ${ buildMatrixRow( array, 8 ) }, ${ buildMatrixRow( array, 12 ) } )`;\n\n}\n\nfunction buildMatrixRow( array, offset ) {\n\n\treturn `(${ array[ offset + 0 ] }, ${ array[ offset + 1 ] }, ${ array[ offset + 2 ] }, ${ array[ offset + 3 ] })`;\n\n}\n\n// Mesh\n\nfunction buildMeshObject( geometry ) {\n\n\tconst mesh = buildMesh( geometry );\n\treturn `\ndef \"Geometry\"\n{\n${mesh}\n}\n`;\n\n}\n\nfunction buildMesh( geometry ) {\n\n\tconst name = 'Geometry';\n\tconst attributes = geometry.attributes;\n\tconst count = attributes.position.count;\n\n\treturn `\n\tdef Mesh \"${ name }\"\n\t{\n\t\tint[] faceVertexCounts = [${ buildMeshVertexCount( geometry ) }]\n\t\tint[] faceVertexIndices = [${ buildMeshVertexIndices( geometry ) }]\n\t\tnormal3f[] normals = [${ buildVector3Array( attributes.normal, count )}] (\n\t\t\tinterpolation = \"vertex\"\n\t\t)\n\t\tpoint3f[] points = [${ buildVector3Array( attributes.position, count )}]\n${ buildPrimvars( attributes ) }\n\t\tuniform token subdivisionScheme = \"none\"\n\t}\n`;\n\n}\n\nfunction buildMeshVertexCount( geometry ) {\n\n\tconst count = geometry.index !== null ? geometry.index.count : geometry.attributes.position.count;\n\n\treturn Array( count / 3 ).fill( 3 ).join( ', ' );\n\n}\n\nfunction buildMeshVertexIndices( geometry ) {\n\n\tconst index = geometry.index;\n\tconst array = [];\n\n\tif ( index !== null ) {\n\n\t\tfor ( let i = 0; i < index.count; i ++ ) {\n\n\t\t\tarray.push( index.getX( i ) );\n\n\t\t}\n\n\t} else {\n\n\t\tconst length = geometry.attributes.position.count;\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tarray.push( i );\n\n\t\t}\n\n\t}\n\n\treturn array.join( ', ' );\n\n}\n\nfunction buildVector3Array( attribute, count ) {\n\n\tif ( attribute === undefined ) {\n\n\t\tconsole.warn( 'USDZExporter: Normals missing.' );\n\t\treturn Array( count ).fill( '(0, 0, 0)' ).join( ', ' );\n\n\t}\n\n\tconst array = [];\n\n\tfor ( let i = 0; i < attribute.count; i ++ ) {\n\n\t\tconst x = attribute.getX( i );\n\t\tconst y = attribute.getY( i );\n\t\tconst z = attribute.getZ( i );\n\n\t\tarray.push( `(${ x.toPrecision( PRECISION ) }, ${ y.toPrecision( PRECISION ) }, ${ z.toPrecision( PRECISION ) })` );\n\n\t}\n\n\treturn array.join( ', ' );\n\n}\n\nfunction buildVector2Array( attribute ) {\n\n\tconst array = [];\n\n\tfor ( let i = 0; i < attribute.count; i ++ ) {\n\n\t\tconst x = attribute.getX( i );\n\t\tconst y = attribute.getY( i );\n\n\t\tarray.push( `(${ x.toPrecision( PRECISION ) }, ${ 1 - y.toPrecision( PRECISION ) })` );\n\n\t}\n\n\treturn array.join( ', ' );\n\n}\n\nfunction buildPrimvars( attributes ) {\n\n\tlet string = '';\n\n\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\tconst id = ( i > 0 ? i : '' );\n\t\tconst attribute = attributes[ 'uv' + id ];\n\n\t\tif ( attribute !== undefined ) {\n\n\t\t\tstring += `\n\t\ttexCoord2f[] primvars:st${ id } = [${ buildVector2Array( attribute )}] (\n\t\t\tinterpolation = \"vertex\"\n\t\t)`;\n\n\t\t}\n\n\t}\n\n\t// vertex colors\n\n\tconst colorAttribute = attributes.color;\n\n\tif ( colorAttribute !== undefined ) {\n\n\t\tconst count = colorAttribute.count;\n\n\t\tstring += `\n\tcolor3f[] primvars:displayColor = [${buildVector3Array( colorAttribute, count )}] (\n\t\tinterpolation = \"vertex\"\n\t\t)`;\n\n\t}\n\n\treturn string;\n\n}\n\n// Materials\n\nfunction buildMaterials( materials, textures, quickLookCompatible = false ) {\n\n\tconst array = [];\n\n\tfor ( const uuid in materials ) {\n\n\t\tconst material = materials[ uuid ];\n\n\t\tarray.push( buildMaterial( material, textures, quickLookCompatible ) );\n\n\t}\n\n\treturn `def \"Materials\"\n{\n${ array.join( '' ) }\n}\n\n`;\n\n}\n\nfunction buildMaterial( material, textures, quickLookCompatible = false ) {\n\n\t// https://graphics.pixar.com/usd/docs/UsdPreviewSurface-Proposal.html\n\n\tconst pad = '\t\t\t';\n\tconst inputs = [];\n\tconst samplers = [];\n\n\tfunction buildTexture( texture, mapType, color ) {\n\n\t\tconst id = texture.source.id + '_' + texture.flipY;\n\n\t\ttextures[ id ] = texture;\n\n\t\tconst uv = texture.channel > 0 ? 'st' + texture.channel : 'st';\n\n\t\tconst WRAPPINGS = {\n\t\t\t1000: 'repeat', // RepeatWrapping\n\t\t\t1001: 'clamp', // ClampToEdgeWrapping\n\t\t\t1002: 'mirror' // MirroredRepeatWrapping\n\t\t};\n\n\t\tconst repeat = texture.repeat.clone();\n\t\tconst offset = texture.offset.clone();\n\t\tconst rotation = texture.rotation;\n\n\t\t// rotation is around the wrong point. after rotation we need to shift offset again so that we're rotating around the right spot\n\t\tconst xRotationOffset = Math.sin( rotation );\n\t\tconst yRotationOffset = Math.cos( rotation );\n\n\t\t// texture coordinates start in the opposite corner, need to correct\n\t\toffset.y = 1 - offset.y - repeat.y;\n\n\t\t// turns out QuickLook is buggy and interprets texture repeat inverted/applies operations in a different order.\n\t\t// Apple Feedback: \tFB10036297 and FB11442287\n\t\tif ( quickLookCompatible ) {\n\n\t\t\t// This is NOT correct yet in QuickLook, but comes close for a range of models.\n\t\t\t// It becomes more incorrect the bigger the offset is\n\n\t\t\toffset.x = offset.x / repeat.x;\n\t\t\toffset.y = offset.y / repeat.y;\n\n\t\t\toffset.x += xRotationOffset / repeat.x;\n\t\t\toffset.y += yRotationOffset - 1;\n\n\t\t} else {\n\n\t\t\t// results match glTF results exactly. verified correct in usdview.\n\t\t\toffset.x += xRotationOffset * repeat.x;\n\t\t\toffset.y += ( 1 - yRotationOffset ) * repeat.y;\n\n\t\t}\n\n\t\treturn `\n\t\tdef Shader \"PrimvarReader_${ mapType }\"\n\t\t{\n\t\t\tuniform token info:id = \"UsdPrimvarReader_float2\"\n\t\t\tfloat2 inputs:fallback = (0.0, 0.0)\n\t\t\ttoken inputs:varname = \"${ uv }\"\n\t\t\tfloat2 outputs:result\n\t\t}\n\n\t\tdef Shader \"Transform2d_${ mapType }\"\n\t\t{\n\t\t\tuniform token info:id = \"UsdTransform2d\"\n\t\t\ttoken inputs:in.connect = </Materials/Material_${ material.id }/PrimvarReader_${ mapType }.outputs:result>\n\t\t\tfloat inputs:rotation = ${ ( rotation * ( 180 / Math.PI ) ).toFixed( PRECISION ) }\n\t\t\tfloat2 inputs:scale = ${ buildVector2( repeat ) }\n\t\t\tfloat2 inputs:translation = ${ buildVector2( offset ) }\n\t\t\tfloat2 outputs:result\n\t\t}\n\n\t\tdef Shader \"Texture_${ texture.id }_${ mapType }\"\n\t\t{\n\t\t\tuniform token info:id = \"UsdUVTexture\"\n\t\t\tasset inputs:file = @textures/Texture_${ id }.png@\n\t\t\tfloat2 inputs:st.connect = </Materials/Material_${ material.id }/Transform2d_${ mapType }.outputs:result>\n\t\t\t${ color !== undefined ? 'float4 inputs:scale = ' + buildColor4( color ) : '' }\n\t\t\ttoken inputs:sourceColorSpace = \"${ texture.colorSpace === NoColorSpace ? 'raw' : 'sRGB' }\"\n\t\t\ttoken inputs:wrapS = \"${ WRAPPINGS[ texture.wrapS ] }\"\n\t\t\ttoken inputs:wrapT = \"${ WRAPPINGS[ texture.wrapT ] }\"\n\t\t\tfloat outputs:r\n\t\t\tfloat outputs:g\n\t\t\tfloat outputs:b\n\t\t\tfloat3 outputs:rgb\n\t\t\t${ material.transparent || material.alphaTest > 0.0 ? 'float outputs:a' : '' }\n\t\t}`;\n\n\t}\n\n\n\tif ( material.side === DoubleSide ) {\n\n\t\tconsole.warn( 'THREE.USDZExporter: USDZ does not support double sided materials', material );\n\n\t}\n\n\tif ( material.map !== null ) {\n\n\t\tinputs.push( `${ pad }color3f inputs:diffuseColor.connect = </Materials/Material_${ material.id }/Texture_${ material.map.id }_diffuse.outputs:rgb>` );\n\n\t\tif ( material.transparent ) {\n\n\t\t\tinputs.push( `${ pad }float inputs:opacity.connect = </Materials/Material_${ material.id }/Texture_${ material.map.id }_diffuse.outputs:a>` );\n\n\t\t} else if ( material.alphaTest > 0.0 ) {\n\n\t\t\tinputs.push( `${ pad }float inputs:opacity.connect = </Materials/Material_${ material.id }/Texture_${ material.map.id }_diffuse.outputs:a>` );\n\t\t\tinputs.push( `${ pad }float inputs:opacityThreshold = ${material.alphaTest}` );\n\n\t\t}\n\n\t\tsamplers.push( buildTexture( material.map, 'diffuse', material.color ) );\n\n\t} else {\n\n\t\tinputs.push( `${ pad }color3f inputs:diffuseColor = ${ buildColor( material.color ) }` );\n\n\t}\n\n\tif ( material.emissiveMap !== null ) {\n\n\t\tinputs.push( `${ pad }color3f inputs:emissiveColor.connect = </Materials/Material_${ material.id }/Texture_${ material.emissiveMap.id }_emissive.outputs:rgb>` );\n\n\t\tsamplers.push( buildTexture( material.emissiveMap, 'emissive', new Color( material.emissive.r * material.emissiveIntensity, material.emissive.g * material.emissiveIntensity, material.emissive.b * material.emissiveIntensity ) ) );\n\n\t} else if ( material.emissive.getHex() > 0 ) {\n\n\t\tinputs.push( `${ pad }color3f inputs:emissiveColor = ${ buildColor( material.emissive ) }` );\n\n\t}\n\n\tif ( material.normalMap !== null ) {\n\n\t\tinputs.push( `${ pad }normal3f inputs:normal.connect = </Materials/Material_${ material.id }/Texture_${ material.normalMap.id }_normal.outputs:rgb>` );\n\n\t\tsamplers.push( buildTexture( material.normalMap, 'normal' ) );\n\n\t}\n\n\tif ( material.aoMap !== null ) {\n\n\t\tinputs.push( `${ pad }float inputs:occlusion.connect = </Materials/Material_${ material.id }/Texture_${ material.aoMap.id }_occlusion.outputs:r>` );\n\n\t\tsamplers.push( buildTexture( material.aoMap, 'occlusion', new Color( material.aoMapIntensity, material.aoMapIntensity, material.aoMapIntensity ) ) );\n\n\t}\n\n\tif ( material.roughnessMap !== null ) {\n\n\t\tinputs.push( `${ pad }float inputs:roughness.connect = </Materials/Material_${ material.id }/Texture_${ material.roughnessMap.id }_roughness.outputs:g>` );\n\n\t\tsamplers.push( buildTexture( material.roughnessMap, 'roughness', new Color( material.roughness, material.roughness, material.roughness ) ) );\n\n\t} else {\n\n\t\tinputs.push( `${ pad }float inputs:roughness = ${ material.roughness }` );\n\n\t}\n\n\tif ( material.metalnessMap !== null ) {\n\n\t\tinputs.push( `${ pad }float inputs:metallic.connect = </Materials/Material_${ material.id }/Texture_${ material.metalnessMap.id }_metallic.outputs:b>` );\n\n\t\tsamplers.push( buildTexture( material.metalnessMap, 'metallic', new Color( material.metalness, material.metalness, material.metalness ) ) );\n\n\t} else {\n\n\t\tinputs.push( `${ pad }float inputs:metallic = ${ material.metalness }` );\n\n\t}\n\n\tif ( material.alphaMap !== null ) {\n\n\t\tinputs.push( `${pad}float inputs:opacity.connect = </Materials/Material_${material.id}/Texture_${material.alphaMap.id}_opacity.outputs:r>` );\n\t\tinputs.push( `${pad}float inputs:opacityThreshold = 0.0001` );\n\n\t\tsamplers.push( buildTexture( material.alphaMap, 'opacity' ) );\n\n\t} else {\n\n\t\tinputs.push( `${pad}float inputs:opacity = ${material.opacity}` );\n\n\t}\n\n\tif ( material.isMeshPhysicalMaterial ) {\n\n\t\tif ( material.clearcoatMap !== null ) {\n\n\t\t\tinputs.push( `${pad}float inputs:clearcoat.connect = </Materials/Material_${material.id}/Texture_${material.clearcoatMap.id}_clearcoat.outputs:r>` );\n\t\t\tsamplers.push( buildTexture( material.clearcoatMap, 'clearcoat', new Color( material.clearcoat, material.clearcoat, material.clearcoat ) ) );\n\n\t\t} else {\n\n\t\t\tinputs.push( `${pad}float inputs:clearcoat = ${material.clearcoat}` );\n\n\t\t}\n\n\t\tif ( material.clearcoatRoughnessMap !== null ) {\n\n\t\t\tinputs.push( `${pad}float inputs:clearcoatRoughness.connect = </Materials/Material_${material.id}/Texture_${material.clearcoatRoughnessMap.id}_clearcoatRoughness.outputs:g>` );\n\t\t\tsamplers.push( buildTexture( material.clearcoatRoughnessMap, 'clearcoatRoughness', new Color( material.clearcoatRoughness, material.clearcoatRoughness, material.clearcoatRoughness ) ) );\n\n\t\t} else {\n\n\t\t\tinputs.push( `${pad}float inputs:clearcoatRoughness = ${material.clearcoatRoughness}` );\n\n\t\t}\n\n\t\tinputs.push( `${ pad }float inputs:ior = ${ material.ior }` );\n\n\t}\n\n\treturn `\n\tdef Material \"Material_${ material.id }\"\n\t{\n\t\tdef Shader \"PreviewSurface\"\n\t\t{\n\t\t\tuniform token info:id = \"UsdPreviewSurface\"\n${ inputs.join( '\\n' ) }\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${ material.id }/PreviewSurface.outputs:surface>\n\n${ samplers.join( '\\n' ) }\n\n\t}\n`;\n\n}\n\nfunction buildColor( color ) {\n\n\treturn `(${ color.r }, ${ color.g }, ${ color.b })`;\n\n}\n\nfunction buildColor4( color ) {\n\n\treturn `(${ color.r }, ${ color.g }, ${ color.b }, 1.0)`;\n\n}\n\nfunction buildVector2( vector ) {\n\n\treturn `(${ vector.x }, ${ vector.y })`;\n\n}\n\n\nfunction buildCamera( camera ) {\n\n\tconst name = camera.name ? camera.name : 'Camera_' + camera.id;\n\n\tconst transform = buildMatrix( camera.matrixWorld );\n\n\tif ( camera.matrixWorld.determinant() < 0 ) {\n\n\t\tconsole.warn( 'THREE.USDZExporter: USDZ does not support negative scales', camera );\n\n\t}\n\n\tif ( camera.isOrthographicCamera ) {\n\n\t\treturn `def Camera \"${name}\"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${ transform }\n\t\t\tuniform token[] xformOpOrder = [\"xformOp:transform\"]\n\n\t\t\tfloat2 clippingRange = (${ camera.near.toPrecision( PRECISION ) }, ${ camera.far.toPrecision( PRECISION ) })\n\t\t\tfloat horizontalAperture = ${ ( ( Math.abs( camera.left ) + Math.abs( camera.right ) ) * 10 ).toPrecision( PRECISION ) }\n\t\t\tfloat verticalAperture = ${ ( ( Math.abs( camera.top ) + Math.abs( camera.bottom ) ) * 10 ).toPrecision( PRECISION ) }\n\t\t\ttoken projection = \"orthographic\"\n\t\t}\n\n\t`;\n\n\t} else {\n\n\t\treturn `def Camera \"${name}\"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${ transform }\n\t\t\tuniform token[] xformOpOrder = [\"xformOp:transform\"]\n\n\t\t\tfloat2 clippingRange = (${ camera.near.toPrecision( PRECISION ) }, ${ camera.far.toPrecision( PRECISION ) })\n\t\t\tfloat focalLength = ${ camera.getFocalLength().toPrecision( PRECISION ) }\n\t\t\tfloat focusDistance = ${ camera.focus.toPrecision( PRECISION ) }\n\t\t\tfloat horizontalAperture = ${ camera.getFilmWidth().toPrecision( PRECISION ) }\n\t\t\ttoken projection = \"perspective\"\n\t\t\tfloat verticalAperture = ${ camera.getFilmHeight().toPrecision( PRECISION ) }\n\t\t}\n\n\t`;\n\n\t}\n\n}\n\n/**\n * Export options of `USDZExporter`.\n *\n * @typedef {Object} USDZExporter~Options\n * @property {number} [maxTextureSize=1024] - The maximum texture size that is going to be exported.\n * @property {boolean} [includeAnchoringProperties=true] - Whether to include anchoring properties or not.\n * @property {Object} [ar] - If `includeAnchoringProperties` is set to `true`, the anchoring type and alignment\n * can be configured via `ar.anchoring.type` and `ar.planeAnchoring.alignment`.\n * @property {boolean} [quickLookCompatible=false] - Whether to make the exported USDZ compatible to QuickLook\n * which means the asset is modified to accommodate the bugs FB10036297 and FB11442287 (Apple Feedback).\n **/\n\n/**\n * onDone callback of `USDZExporter`.\n *\n * @callback USDZExporter~OnDone\n * @param {ArrayBuffer} result - The generated USDZ.\n */\n\n/**\n * onError callback of `USDZExporter`.\n *\n * @callback USDZExporter~OnError\n * @param {Error} error - The error object.\n */\n\nexport { USDZExporter };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}