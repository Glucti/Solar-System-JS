{"ast":null,"code":"import { BoxGeometry, Vector3 } from 'three';\nconst _tempNormal = new Vector3();\nfunction getUv(faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength) {\n  const totArcLength = 2 * Math.PI * radius / 4;\n\n  // length of the planes between the arcs on each axis\n  const centerLength = Math.max(sideLength - 2 * radius, 0);\n  const halfArc = Math.PI / 4;\n\n  // Get the vector projected onto the Y plane\n  _tempNormal.copy(normal);\n  _tempNormal[projectionAxis] = 0;\n  _tempNormal.normalize();\n\n  // total amount of UV space alloted to a single arc\n  const arcUvRatio = 0.5 * totArcLength / (totArcLength + centerLength);\n\n  // the distance along one arc the point is at\n  const arcAngleRatio = 1.0 - _tempNormal.angleTo(faceDirVector) / halfArc;\n  if (Math.sign(_tempNormal[uvAxis]) === 1) {\n    return arcAngleRatio * arcUvRatio;\n  } else {\n    // total amount of UV space alloted to the plane between the arcs\n    const lenUv = centerLength / (totArcLength + centerLength);\n    return lenUv + arcUvRatio + arcUvRatio * (1.0 - arcAngleRatio);\n  }\n}\n\n/**\n * A special type of box geometry with rounded corners and edges.\n *\n * ```js\n * const geometry = new THREE.RoundedBoxGeometry();\n * const material = new THREE.MeshStandardMaterial( { color: 0x00ff00 } );\n * const cube = new THREE.Mesh( geometry, material );\n * scene.add( cube );\n * ```\n *\n * @augments BoxGeometry\n * @three_import import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';\n */\nclass RoundedBoxGeometry extends BoxGeometry {\n  /**\n   * Constructs a new rounded box geometry.\n   *\n   * @param {number} [width=1] - The width. That is, the length of the edges parallel to the X axis.\n   * @param {number} [height=1] - The height. That is, the length of the edges parallel to the Y axis.\n   * @param {number} [depth=1] - The depth. That is, the length of the edges parallel to the Z axis.\n   * @param {number} [segments=2] - Number of segmented that form the rounded corners.\n   * @param {number} [radius=0.1] - The radius of the rounded corners.\n   */\n  constructor(width = 1, height = 1, depth = 1, segments = 2, radius = 0.1) {\n    // ensure segments is odd so we have a plane connecting the rounded corners\n    segments = segments * 2 + 1;\n\n    // ensure radius isn't bigger than shortest side\n    radius = Math.min(width / 2, height / 2, depth / 2, radius);\n    super(1, 1, 1, segments, segments, segments);\n\n    // if we just have one segment we're the same as a regular box\n    if (segments === 1) return;\n    const geometry2 = this.toNonIndexed();\n    this.index = null;\n    this.attributes.position = geometry2.attributes.position;\n    this.attributes.normal = geometry2.attributes.normal;\n    this.attributes.uv = geometry2.attributes.uv;\n\n    //\n\n    const position = new Vector3();\n    const normal = new Vector3();\n    const box = new Vector3(width, height, depth).divideScalar(2).subScalar(radius);\n    const positions = this.attributes.position.array;\n    const normals = this.attributes.normal.array;\n    const uvs = this.attributes.uv.array;\n    const faceTris = positions.length / 6;\n    const faceDirVector = new Vector3();\n    const halfSegmentSize = 0.5 / segments;\n    for (let i = 0, j = 0; i < positions.length; i += 3, j += 2) {\n      position.fromArray(positions, i);\n      normal.copy(position);\n      normal.x -= Math.sign(normal.x) * halfSegmentSize;\n      normal.y -= Math.sign(normal.y) * halfSegmentSize;\n      normal.z -= Math.sign(normal.z) * halfSegmentSize;\n      normal.normalize();\n      positions[i + 0] = box.x * Math.sign(position.x) + normal.x * radius;\n      positions[i + 1] = box.y * Math.sign(position.y) + normal.y * radius;\n      positions[i + 2] = box.z * Math.sign(position.z) + normal.z * radius;\n      normals[i + 0] = normal.x;\n      normals[i + 1] = normal.y;\n      normals[i + 2] = normal.z;\n      const side = Math.floor(i / faceTris);\n      switch (side) {\n        case 0:\n          // right\n\n          // generate UVs along Z then Y\n          faceDirVector.set(1, 0, 0);\n          uvs[j + 0] = getUv(faceDirVector, normal, 'z', 'y', radius, depth);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height);\n          break;\n        case 1:\n          // left\n\n          // generate UVs along Z then Y\n          faceDirVector.set(-1, 0, 0);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'z', 'y', radius, depth);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height);\n          break;\n        case 2:\n          // top\n\n          // generate UVs along X then Z\n          faceDirVector.set(0, 1, 0);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width);\n          uvs[j + 1] = getUv(faceDirVector, normal, 'z', 'x', radius, depth);\n          break;\n        case 3:\n          // bottom\n\n          // generate UVs along X then Z\n          faceDirVector.set(0, -1, 0);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'z', 'x', radius, depth);\n          break;\n        case 4:\n          // front\n\n          // generate UVs along X then Y\n          faceDirVector.set(0, 0, 1);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'y', radius, width);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height);\n          break;\n        case 5:\n          // back\n\n          // generate UVs along X then Y\n          faceDirVector.set(0, 0, -1);\n          uvs[j + 0] = getUv(faceDirVector, normal, 'x', 'y', radius, width);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height);\n          break;\n      }\n    }\n  }\n}\nexport { RoundedBoxGeometry };","map":{"version":3,"names":["BoxGeometry","Vector3","_tempNormal","getUv","faceDirVector","normal","uvAxis","projectionAxis","radius","sideLength","totArcLength","Math","PI","centerLength","max","halfArc","copy","normalize","arcUvRatio","arcAngleRatio","angleTo","sign","lenUv","RoundedBoxGeometry","constructor","width","height","depth","segments","min","geometry2","toNonIndexed","index","attributes","position","uv","box","divideScalar","subScalar","positions","array","normals","uvs","faceTris","length","halfSegmentSize","i","j","fromArray","x","y","z","side","floor","set"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/geometries/RoundedBoxGeometry.js"],"sourcesContent":["import {\n\tBoxGeometry,\n\tVector3\n} from 'three';\n\nconst _tempNormal = new Vector3();\n\nfunction getUv( faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength ) {\n\n\tconst totArcLength = 2 * Math.PI * radius / 4;\n\n\t// length of the planes between the arcs on each axis\n\tconst centerLength = Math.max( sideLength - 2 * radius, 0 );\n\tconst halfArc = Math.PI / 4;\n\n\t// Get the vector projected onto the Y plane\n\t_tempNormal.copy( normal );\n\t_tempNormal[ projectionAxis ] = 0;\n\t_tempNormal.normalize();\n\n\t// total amount of UV space alloted to a single arc\n\tconst arcUvRatio = 0.5 * totArcLength / ( totArcLength + centerLength );\n\n\t// the distance along one arc the point is at\n\tconst arcAngleRatio = 1.0 - ( _tempNormal.angleTo( faceDirVector ) / halfArc );\n\n\tif ( Math.sign( _tempNormal[ uvAxis ] ) === 1 ) {\n\n\t\treturn arcAngleRatio * arcUvRatio;\n\n\t} else {\n\n\t\t// total amount of UV space alloted to the plane between the arcs\n\t\tconst lenUv = centerLength / ( totArcLength + centerLength );\n\t\treturn lenUv + arcUvRatio + arcUvRatio * ( 1.0 - arcAngleRatio );\n\n\t}\n\n}\n\n/**\n * A special type of box geometry with rounded corners and edges.\n *\n * ```js\n * const geometry = new THREE.RoundedBoxGeometry();\n * const material = new THREE.MeshStandardMaterial( { color: 0x00ff00 } );\n * const cube = new THREE.Mesh( geometry, material );\n * scene.add( cube );\n * ```\n *\n * @augments BoxGeometry\n * @three_import import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';\n */\nclass RoundedBoxGeometry extends BoxGeometry {\n\n\t/**\n\t * Constructs a new rounded box geometry.\n\t *\n\t * @param {number} [width=1] - The width. That is, the length of the edges parallel to the X axis.\n\t * @param {number} [height=1] - The height. That is, the length of the edges parallel to the Y axis.\n\t * @param {number} [depth=1] - The depth. That is, the length of the edges parallel to the Z axis.\n\t * @param {number} [segments=2] - Number of segmented that form the rounded corners.\n\t * @param {number} [radius=0.1] - The radius of the rounded corners.\n\t */\n\tconstructor( width = 1, height = 1, depth = 1, segments = 2, radius = 0.1 ) {\n\n\t\t// ensure segments is odd so we have a plane connecting the rounded corners\n\t\tsegments = segments * 2 + 1;\n\n\t\t// ensure radius isn't bigger than shortest side\n\t\tradius = Math.min( width / 2, height / 2, depth / 2, radius );\n\n\t\tsuper( 1, 1, 1, segments, segments, segments );\n\n\t\t// if we just have one segment we're the same as a regular box\n\t\tif ( segments === 1 ) return;\n\n\t\tconst geometry2 = this.toNonIndexed();\n\n\t\tthis.index = null;\n\t\tthis.attributes.position = geometry2.attributes.position;\n\t\tthis.attributes.normal = geometry2.attributes.normal;\n\t\tthis.attributes.uv = geometry2.attributes.uv;\n\n\t\t//\n\n\t\tconst position = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\tconst box = new Vector3( width, height, depth ).divideScalar( 2 ).subScalar( radius );\n\n\t\tconst positions = this.attributes.position.array;\n\t\tconst normals = this.attributes.normal.array;\n\t\tconst uvs = this.attributes.uv.array;\n\n\t\tconst faceTris = positions.length / 6;\n\t\tconst faceDirVector = new Vector3();\n\t\tconst halfSegmentSize = 0.5 / segments;\n\n\t\tfor ( let i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\n\t\t\tposition.fromArray( positions, i );\n\t\t\tnormal.copy( position );\n\t\t\tnormal.x -= Math.sign( normal.x ) * halfSegmentSize;\n\t\t\tnormal.y -= Math.sign( normal.y ) * halfSegmentSize;\n\t\t\tnormal.z -= Math.sign( normal.z ) * halfSegmentSize;\n\t\t\tnormal.normalize();\n\n\t\t\tpositions[ i + 0 ] = box.x * Math.sign( position.x ) + normal.x * radius;\n\t\t\tpositions[ i + 1 ] = box.y * Math.sign( position.y ) + normal.y * radius;\n\t\t\tpositions[ i + 2 ] = box.z * Math.sign( position.z ) + normal.z * radius;\n\n\t\t\tnormals[ i + 0 ] = normal.x;\n\t\t\tnormals[ i + 1 ] = normal.y;\n\t\t\tnormals[ i + 2 ] = normal.z;\n\n\t\t\tconst side = Math.floor( i / faceTris );\n\n\t\t\tswitch ( side ) {\n\n\t\t\t\tcase 0: // right\n\n\t\t\t\t\t// generate UVs along Z then Y\n\t\t\t\t\tfaceDirVector.set( 1, 0, 0 );\n\t\t\t\t\tuvs[ j + 0 ] = getUv( faceDirVector, normal, 'z', 'y', radius, depth );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'z', radius, height );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1: // left\n\n\t\t\t\t\t// generate UVs along Z then Y\n\t\t\t\t\tfaceDirVector.set( - 1, 0, 0 );\n\t\t\t\t\tuvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'z', 'y', radius, depth );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'z', radius, height );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: // top\n\n\t\t\t\t\t// generate UVs along X then Z\n\t\t\t\t\tfaceDirVector.set( 0, 1, 0 );\n\t\t\t\t\tuvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'x', 'z', radius, width );\n\t\t\t\t\tuvs[ j + 1 ] = getUv( faceDirVector, normal, 'z', 'x', radius, depth );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3: // bottom\n\n\t\t\t\t\t// generate UVs along X then Z\n\t\t\t\t\tfaceDirVector.set( 0, - 1, 0 );\n\t\t\t\t\tuvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'x', 'z', radius, width );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'z', 'x', radius, depth );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 4: // front\n\n\t\t\t\t\t// generate UVs along X then Y\n\t\t\t\t\tfaceDirVector.set( 0, 0, 1 );\n\t\t\t\t\tuvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'x', 'y', radius, width );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'x', radius, height );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 5: // back\n\n\t\t\t\t\t// generate UVs along X then Y\n\t\t\t\t\tfaceDirVector.set( 0, 0, - 1 );\n\t\t\t\t\tuvs[ j + 0 ] = getUv( faceDirVector, normal, 'x', 'y', radius, width );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'x', radius, height );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexport { RoundedBoxGeometry };\n"],"mappings":"AAAA,SACCA,WAAW,EACXC,OAAO,QACD,OAAO;AAEd,MAAMC,WAAW,GAAG,IAAID,OAAO,CAAC,CAAC;AAEjC,SAASE,KAAKA,CAAEC,aAAa,EAAEC,MAAM,EAAEC,MAAM,EAAEC,cAAc,EAAEC,MAAM,EAAEC,UAAU,EAAG;EAEnF,MAAMC,YAAY,GAAG,CAAC,GAAGC,IAAI,CAACC,EAAE,GAAGJ,MAAM,GAAG,CAAC;;EAE7C;EACA,MAAMK,YAAY,GAAGF,IAAI,CAACG,GAAG,CAAEL,UAAU,GAAG,CAAC,GAAGD,MAAM,EAAE,CAAE,CAAC;EAC3D,MAAMO,OAAO,GAAGJ,IAAI,CAACC,EAAE,GAAG,CAAC;;EAE3B;EACAV,WAAW,CAACc,IAAI,CAAEX,MAAO,CAAC;EAC1BH,WAAW,CAAEK,cAAc,CAAE,GAAG,CAAC;EACjCL,WAAW,CAACe,SAAS,CAAC,CAAC;;EAEvB;EACA,MAAMC,UAAU,GAAG,GAAG,GAAGR,YAAY,IAAKA,YAAY,GAAGG,YAAY,CAAE;;EAEvE;EACA,MAAMM,aAAa,GAAG,GAAG,GAAKjB,WAAW,CAACkB,OAAO,CAAEhB,aAAc,CAAC,GAAGW,OAAS;EAE9E,IAAKJ,IAAI,CAACU,IAAI,CAAEnB,WAAW,CAAEI,MAAM,CAAG,CAAC,KAAK,CAAC,EAAG;IAE/C,OAAOa,aAAa,GAAGD,UAAU;EAElC,CAAC,MAAM;IAEN;IACA,MAAMI,KAAK,GAAGT,YAAY,IAAKH,YAAY,GAAGG,YAAY,CAAE;IAC5D,OAAOS,KAAK,GAAGJ,UAAU,GAAGA,UAAU,IAAK,GAAG,GAAGC,aAAa,CAAE;EAEjE;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMI,kBAAkB,SAASvB,WAAW,CAAC;EAE5C;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCwB,WAAWA,CAAEC,KAAK,GAAG,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEC,KAAK,GAAG,CAAC,EAAEC,QAAQ,GAAG,CAAC,EAAEpB,MAAM,GAAG,GAAG,EAAG;IAE3E;IACAoB,QAAQ,GAAGA,QAAQ,GAAG,CAAC,GAAG,CAAC;;IAE3B;IACApB,MAAM,GAAGG,IAAI,CAACkB,GAAG,CAAEJ,KAAK,GAAG,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEC,KAAK,GAAG,CAAC,EAAEnB,MAAO,CAAC;IAE7D,KAAK,CAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAEoB,QAAQ,EAAEA,QAAQ,EAAEA,QAAS,CAAC;;IAE9C;IACA,IAAKA,QAAQ,KAAK,CAAC,EAAG;IAEtB,MAAME,SAAS,GAAG,IAAI,CAACC,YAAY,CAAC,CAAC;IAErC,IAAI,CAACC,KAAK,GAAG,IAAI;IACjB,IAAI,CAACC,UAAU,CAACC,QAAQ,GAAGJ,SAAS,CAACG,UAAU,CAACC,QAAQ;IACxD,IAAI,CAACD,UAAU,CAAC5B,MAAM,GAAGyB,SAAS,CAACG,UAAU,CAAC5B,MAAM;IACpD,IAAI,CAAC4B,UAAU,CAACE,EAAE,GAAGL,SAAS,CAACG,UAAU,CAACE,EAAE;;IAE5C;;IAEA,MAAMD,QAAQ,GAAG,IAAIjC,OAAO,CAAC,CAAC;IAC9B,MAAMI,MAAM,GAAG,IAAIJ,OAAO,CAAC,CAAC;IAE5B,MAAMmC,GAAG,GAAG,IAAInC,OAAO,CAAEwB,KAAK,EAAEC,MAAM,EAAEC,KAAM,CAAC,CAACU,YAAY,CAAE,CAAE,CAAC,CAACC,SAAS,CAAE9B,MAAO,CAAC;IAErF,MAAM+B,SAAS,GAAG,IAAI,CAACN,UAAU,CAACC,QAAQ,CAACM,KAAK;IAChD,MAAMC,OAAO,GAAG,IAAI,CAACR,UAAU,CAAC5B,MAAM,CAACmC,KAAK;IAC5C,MAAME,GAAG,GAAG,IAAI,CAACT,UAAU,CAACE,EAAE,CAACK,KAAK;IAEpC,MAAMG,QAAQ,GAAGJ,SAAS,CAACK,MAAM,GAAG,CAAC;IACrC,MAAMxC,aAAa,GAAG,IAAIH,OAAO,CAAC,CAAC;IACnC,MAAM4C,eAAe,GAAG,GAAG,GAAGjB,QAAQ;IAEtC,KAAM,IAAIkB,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAED,CAAC,GAAGP,SAAS,CAACK,MAAM,EAAEE,CAAC,IAAI,CAAC,EAAEC,CAAC,IAAI,CAAC,EAAG;MAE9Db,QAAQ,CAACc,SAAS,CAAET,SAAS,EAAEO,CAAE,CAAC;MAClCzC,MAAM,CAACW,IAAI,CAAEkB,QAAS,CAAC;MACvB7B,MAAM,CAAC4C,CAAC,IAAItC,IAAI,CAACU,IAAI,CAAEhB,MAAM,CAAC4C,CAAE,CAAC,GAAGJ,eAAe;MACnDxC,MAAM,CAAC6C,CAAC,IAAIvC,IAAI,CAACU,IAAI,CAAEhB,MAAM,CAAC6C,CAAE,CAAC,GAAGL,eAAe;MACnDxC,MAAM,CAAC8C,CAAC,IAAIxC,IAAI,CAACU,IAAI,CAAEhB,MAAM,CAAC8C,CAAE,CAAC,GAAGN,eAAe;MACnDxC,MAAM,CAACY,SAAS,CAAC,CAAC;MAElBsB,SAAS,CAAEO,CAAC,GAAG,CAAC,CAAE,GAAGV,GAAG,CAACa,CAAC,GAAGtC,IAAI,CAACU,IAAI,CAAEa,QAAQ,CAACe,CAAE,CAAC,GAAG5C,MAAM,CAAC4C,CAAC,GAAGzC,MAAM;MACxE+B,SAAS,CAAEO,CAAC,GAAG,CAAC,CAAE,GAAGV,GAAG,CAACc,CAAC,GAAGvC,IAAI,CAACU,IAAI,CAAEa,QAAQ,CAACgB,CAAE,CAAC,GAAG7C,MAAM,CAAC6C,CAAC,GAAG1C,MAAM;MACxE+B,SAAS,CAAEO,CAAC,GAAG,CAAC,CAAE,GAAGV,GAAG,CAACe,CAAC,GAAGxC,IAAI,CAACU,IAAI,CAAEa,QAAQ,CAACiB,CAAE,CAAC,GAAG9C,MAAM,CAAC8C,CAAC,GAAG3C,MAAM;MAExEiC,OAAO,CAAEK,CAAC,GAAG,CAAC,CAAE,GAAGzC,MAAM,CAAC4C,CAAC;MAC3BR,OAAO,CAAEK,CAAC,GAAG,CAAC,CAAE,GAAGzC,MAAM,CAAC6C,CAAC;MAC3BT,OAAO,CAAEK,CAAC,GAAG,CAAC,CAAE,GAAGzC,MAAM,CAAC8C,CAAC;MAE3B,MAAMC,IAAI,GAAGzC,IAAI,CAAC0C,KAAK,CAAEP,CAAC,GAAGH,QAAS,CAAC;MAEvC,QAASS,IAAI;QAEZ,KAAK,CAAC;UAAE;;UAEP;UACAhD,aAAa,CAACkD,GAAG,CAAE,CAAC,EAAE,CAAC,EAAE,CAAE,CAAC;UAC5BZ,GAAG,CAAEK,CAAC,GAAG,CAAC,CAAE,GAAG5C,KAAK,CAAEC,aAAa,EAAEC,MAAM,EAAE,GAAG,EAAE,GAAG,EAAEG,MAAM,EAAEmB,KAAM,CAAC;UACtEe,GAAG,CAAEK,CAAC,GAAG,CAAC,CAAE,GAAG,GAAG,GAAG5C,KAAK,CAAEC,aAAa,EAAEC,MAAM,EAAE,GAAG,EAAE,GAAG,EAAEG,MAAM,EAAEkB,MAAO,CAAC;UAC7E;QAED,KAAK,CAAC;UAAE;;UAEP;UACAtB,aAAa,CAACkD,GAAG,CAAE,CAAE,CAAC,EAAE,CAAC,EAAE,CAAE,CAAC;UAC9BZ,GAAG,CAAEK,CAAC,GAAG,CAAC,CAAE,GAAG,GAAG,GAAG5C,KAAK,CAAEC,aAAa,EAAEC,MAAM,EAAE,GAAG,EAAE,GAAG,EAAEG,MAAM,EAAEmB,KAAM,CAAC;UAC5Ee,GAAG,CAAEK,CAAC,GAAG,CAAC,CAAE,GAAG,GAAG,GAAG5C,KAAK,CAAEC,aAAa,EAAEC,MAAM,EAAE,GAAG,EAAE,GAAG,EAAEG,MAAM,EAAEkB,MAAO,CAAC;UAC7E;QAED,KAAK,CAAC;UAAE;;UAEP;UACAtB,aAAa,CAACkD,GAAG,CAAE,CAAC,EAAE,CAAC,EAAE,CAAE,CAAC;UAC5BZ,GAAG,CAAEK,CAAC,GAAG,CAAC,CAAE,GAAG,GAAG,GAAG5C,KAAK,CAAEC,aAAa,EAAEC,MAAM,EAAE,GAAG,EAAE,GAAG,EAAEG,MAAM,EAAEiB,KAAM,CAAC;UAC5EiB,GAAG,CAAEK,CAAC,GAAG,CAAC,CAAE,GAAG5C,KAAK,CAAEC,aAAa,EAAEC,MAAM,EAAE,GAAG,EAAE,GAAG,EAAEG,MAAM,EAAEmB,KAAM,CAAC;UACtE;QAED,KAAK,CAAC;UAAE;;UAEP;UACAvB,aAAa,CAACkD,GAAG,CAAE,CAAC,EAAE,CAAE,CAAC,EAAE,CAAE,CAAC;UAC9BZ,GAAG,CAAEK,CAAC,GAAG,CAAC,CAAE,GAAG,GAAG,GAAG5C,KAAK,CAAEC,aAAa,EAAEC,MAAM,EAAE,GAAG,EAAE,GAAG,EAAEG,MAAM,EAAEiB,KAAM,CAAC;UAC5EiB,GAAG,CAAEK,CAAC,GAAG,CAAC,CAAE,GAAG,GAAG,GAAG5C,KAAK,CAAEC,aAAa,EAAEC,MAAM,EAAE,GAAG,EAAE,GAAG,EAAEG,MAAM,EAAEmB,KAAM,CAAC;UAC5E;QAED,KAAK,CAAC;UAAE;;UAEP;UACAvB,aAAa,CAACkD,GAAG,CAAE,CAAC,EAAE,CAAC,EAAE,CAAE,CAAC;UAC5BZ,GAAG,CAAEK,CAAC,GAAG,CAAC,CAAE,GAAG,GAAG,GAAG5C,KAAK,CAAEC,aAAa,EAAEC,MAAM,EAAE,GAAG,EAAE,GAAG,EAAEG,MAAM,EAAEiB,KAAM,CAAC;UAC5EiB,GAAG,CAAEK,CAAC,GAAG,CAAC,CAAE,GAAG,GAAG,GAAG5C,KAAK,CAAEC,aAAa,EAAEC,MAAM,EAAE,GAAG,EAAE,GAAG,EAAEG,MAAM,EAAEkB,MAAO,CAAC;UAC7E;QAED,KAAK,CAAC;UAAE;;UAEP;UACAtB,aAAa,CAACkD,GAAG,CAAE,CAAC,EAAE,CAAC,EAAE,CAAE,CAAE,CAAC;UAC9BZ,GAAG,CAAEK,CAAC,GAAG,CAAC,CAAE,GAAG5C,KAAK,CAAEC,aAAa,EAAEC,MAAM,EAAE,GAAG,EAAE,GAAG,EAAEG,MAAM,EAAEiB,KAAM,CAAC;UACtEiB,GAAG,CAAEK,CAAC,GAAG,CAAC,CAAE,GAAG,GAAG,GAAG5C,KAAK,CAAEC,aAAa,EAAEC,MAAM,EAAE,GAAG,EAAE,GAAG,EAAEG,MAAM,EAAEkB,MAAO,CAAC;UAC7E;MAEF;IAED;EAED;AAED;AAEA,SAASH,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}