{"ast":null,"code":"import { Matrix3, Matrix4, Vector3 } from 'three';\nimport { VolumeSlice } from '../misc/VolumeSlice.js';\n\n/**\n * This class had been written to handle the output of the {@link NRRDLoader}.\n * It contains a volume of data and information about it. For now it only handles 3 dimensional data.\n *\n * @three_import import { Volume } from 'three/addons/misc/Volume.js';\n */\nclass Volume {\n  /**\n   * Constructs a new volume.\n   *\n   * @param {number} [xLength] - Width of the volume.\n   * @param {number} [yLength] - Length of the volume.\n   * @param {number} [zLength] - Depth of the volume.\n   * @param {string} [type] - The type of data (uint8, uint16, ...).\n   * @param {ArrayBuffer} [arrayBuffer] - The buffer with volume data.\n   */\n  constructor(xLength, yLength, zLength, type, arrayBuffer) {\n    if (xLength !== undefined) {\n      /**\n       * Width of the volume in the IJK coordinate system.\n       *\n       * @type {number}\n       * @default 1\n       */\n      this.xLength = Number(xLength) || 1;\n\n      /**\n       * Height of the volume in the IJK coordinate system.\n       *\n       * @type {number}\n       * @default 1\n       */\n      this.yLength = Number(yLength) || 1;\n\n      /**\n       * Depth of the volume in the IJK coordinate system.\n       *\n       * @type {number}\n       * @default 1\n       */\n      this.zLength = Number(zLength) || 1;\n\n      /**\n       * The order of the Axis dictated by the NRRD header\n       *\n       * @type {Array<string>}\n       */\n      this.axisOrder = ['x', 'y', 'z'];\n\n      /**\n       * The data of the volume.\n       *\n       * @type {TypedArray}\n       */\n      this.data;\n      switch (type) {\n        case 'Uint8':\n        case 'uint8':\n        case 'uchar':\n        case 'unsigned char':\n        case 'uint8_t':\n          this.data = new Uint8Array(arrayBuffer);\n          break;\n        case 'Int8':\n        case 'int8':\n        case 'signed char':\n        case 'int8_t':\n          this.data = new Int8Array(arrayBuffer);\n          break;\n        case 'Int16':\n        case 'int16':\n        case 'short':\n        case 'short int':\n        case 'signed short':\n        case 'signed short int':\n        case 'int16_t':\n          this.data = new Int16Array(arrayBuffer);\n          break;\n        case 'Uint16':\n        case 'uint16':\n        case 'ushort':\n        case 'unsigned short':\n        case 'unsigned short int':\n        case 'uint16_t':\n          this.data = new Uint16Array(arrayBuffer);\n          break;\n        case 'Int32':\n        case 'int32':\n        case 'int':\n        case 'signed int':\n        case 'int32_t':\n          this.data = new Int32Array(arrayBuffer);\n          break;\n        case 'Uint32':\n        case 'uint32':\n        case 'uint':\n        case 'unsigned int':\n        case 'uint32_t':\n          this.data = new Uint32Array(arrayBuffer);\n          break;\n        case 'longlong':\n        case 'long long':\n        case 'long long int':\n        case 'signed long long':\n        case 'signed long long int':\n        case 'int64':\n        case 'int64_t':\n        case 'ulonglong':\n        case 'unsigned long long':\n        case 'unsigned long long int':\n        case 'uint64':\n        case 'uint64_t':\n          throw new Error('Error in Volume constructor : this type is not supported in JavaScript');\n          break;\n        case 'Float32':\n        case 'float32':\n        case 'float':\n          this.data = new Float32Array(arrayBuffer);\n          break;\n        case 'Float64':\n        case 'float64':\n        case 'double':\n          this.data = new Float64Array(arrayBuffer);\n          break;\n        default:\n          this.data = new Uint8Array(arrayBuffer);\n      }\n      if (this.data.length !== this.xLength * this.yLength * this.zLength) {\n        throw new Error('Error in Volume constructor, lengths are not matching arrayBuffer size');\n      }\n    }\n\n    /**\n     * Spacing to apply to the volume from IJK to RAS coordinate system\n     *\n     * @type {Array<number>}\n     */\n    this.spacing = [1, 1, 1];\n\n    /**\n     * Offset of the volume in the RAS coordinate system\n     *\n     * @type {Array<number>}\n     */\n    this.offset = [0, 0, 0];\n\n    /**\n     * The IJK to RAS matrix.\n     *\n     * @type {Martrix3}\n     */\n    this.matrix = new Matrix3();\n    this.matrix.identity();\n\n    /**\n     * The RAS to IJK matrix.\n     *\n     * @type {Martrix3}\n     */\n    this.inverseMatrix = new Matrix3();\n    let lowerThreshold = -Infinity;\n    Object.defineProperty(this, 'lowerThreshold', {\n      get: function () {\n        return lowerThreshold;\n      },\n      /**\n       * The voxels with values under this threshold won't appear in the slices.\n       * If changed, geometryNeedsUpdate is automatically set to true on all the slices associated to this volume.\n       *\n       * @name Volume#lowerThreshold\n       * @type {number}\n       * @param {number} value\n       */\n      set: function (value) {\n        lowerThreshold = value;\n        this.sliceList.forEach(function (slice) {\n          slice.geometryNeedsUpdate = true;\n        });\n      }\n    });\n    let upperThreshold = Infinity;\n    Object.defineProperty(this, 'upperThreshold', {\n      get: function () {\n        return upperThreshold;\n      },\n      /**\n       * The voxels with values over this threshold won't appear in the slices.\n       * If changed, geometryNeedsUpdate is automatically set to true on all the slices associated to this volume\n       *\n       * @name Volume#upperThreshold\n       * @type {number}\n       * @param {number} value\n       */\n      set: function (value) {\n        upperThreshold = value;\n        this.sliceList.forEach(function (slice) {\n          slice.geometryNeedsUpdate = true;\n        });\n      }\n    });\n\n    /**\n     * The list of all the slices associated to this volume\n     *\n     * @type {Array}\n     */\n    this.sliceList = [];\n\n    /**\n     * Whether to use segmentation mode or not.\n     * It can load 16-bits nrrds correctly.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    this.segmentation = false;\n\n    /**\n     * This array holds the dimensions of the volume in the RAS space\n     *\n     * @type {Array<number>}\n     */\n    this.RASDimensions = [];\n  }\n\n  /**\n   * Shortcut for data[access(i,j,k)].\n   *\n   * @param {number} i - First coordinate.\n   * @param {number} j - Second coordinate.\n   * @param {number} k - Third coordinate.\n   * @returns {number} The value in the data array.\n   */\n  getData(i, j, k) {\n    return this.data[k * this.xLength * this.yLength + j * this.xLength + i];\n  }\n\n  /**\n   * Compute the index in the data array corresponding to the given coordinates in IJK system.\n   *\n   * @param {number} i - First coordinate.\n   * @param {number} j - Second coordinate.\n   * @param {number} k - Third coordinate.\n   * @returns {number} The index.\n   */\n  access(i, j, k) {\n    return k * this.xLength * this.yLength + j * this.xLength + i;\n  }\n\n  /**\n   * Retrieve the IJK coordinates of the voxel corresponding of the given index in the data.\n   *\n   * @param {number} index - Index of the voxel.\n   * @returns {Array<number>} The IJK coordinates as `[x,y,z]`.\n   */\n  reverseAccess(index) {\n    const z = Math.floor(index / (this.yLength * this.xLength));\n    const y = Math.floor((index - z * this.yLength * this.xLength) / this.xLength);\n    const x = index - z * this.yLength * this.xLength - y * this.xLength;\n    return [x, y, z];\n  }\n\n  /**\n   * Apply a function to all the voxels, be careful, the value will be replaced.\n   *\n   * @param {Function} functionToMap A function to apply to every voxel, will be called with the following parameters:\n   * value of the voxel, index of the voxel, the data (TypedArray).\n   * @param {Object} context - You can specify a context in which call the function, default if this Volume.\n   * @returns {Volume} A reference to this instance.\n   */\n  map(functionToMap, context) {\n    const length = this.data.length;\n    context = context || this;\n    for (let i = 0; i < length; i++) {\n      this.data[i] = functionToMap.call(context, this.data[i], i, this.data);\n    }\n    return this;\n  }\n\n  /**\n   * Compute the orientation of the slice and returns all the information relative to the geometry such as sliceAccess,\n   * the plane matrix (orientation and position in RAS coordinate) and the dimensions of the plane in both coordinate system.\n   *\n   * @param {('x'|'y'|'z')} axis - The normal axis to the slice.\n   * @param {number} RASIndex - The index of the slice.\n   * @returns {Object} An object containing all the useful information on the geometry of the slice.\n   */\n  extractPerpendicularPlane(axis, RASIndex) {\n    let firstSpacing, secondSpacing, positionOffset, IJKIndex;\n    const axisInIJK = new Vector3(),\n      firstDirection = new Vector3(),\n      secondDirection = new Vector3(),\n      planeMatrix = new Matrix4().identity(),\n      volume = this;\n    const dimensions = new Vector3(this.xLength, this.yLength, this.zLength);\n    switch (axis) {\n      case 'x':\n        axisInIJK.set(1, 0, 0);\n        firstDirection.set(0, 0, -1);\n        secondDirection.set(0, -1, 0);\n        firstSpacing = this.spacing[this.axisOrder.indexOf('z')];\n        secondSpacing = this.spacing[this.axisOrder.indexOf('y')];\n        IJKIndex = new Vector3(RASIndex, 0, 0);\n        planeMatrix.multiply(new Matrix4().makeRotationY(Math.PI / 2));\n        positionOffset = (volume.RASDimensions[0] - 1) / 2;\n        planeMatrix.setPosition(new Vector3(RASIndex - positionOffset, 0, 0));\n        break;\n      case 'y':\n        axisInIJK.set(0, 1, 0);\n        firstDirection.set(1, 0, 0);\n        secondDirection.set(0, 0, 1);\n        firstSpacing = this.spacing[this.axisOrder.indexOf('x')];\n        secondSpacing = this.spacing[this.axisOrder.indexOf('z')];\n        IJKIndex = new Vector3(0, RASIndex, 0);\n        planeMatrix.multiply(new Matrix4().makeRotationX(-Math.PI / 2));\n        positionOffset = (volume.RASDimensions[1] - 1) / 2;\n        planeMatrix.setPosition(new Vector3(0, RASIndex - positionOffset, 0));\n        break;\n      case 'z':\n      default:\n        axisInIJK.set(0, 0, 1);\n        firstDirection.set(1, 0, 0);\n        secondDirection.set(0, -1, 0);\n        firstSpacing = this.spacing[this.axisOrder.indexOf('x')];\n        secondSpacing = this.spacing[this.axisOrder.indexOf('y')];\n        IJKIndex = new Vector3(0, 0, RASIndex);\n        positionOffset = (volume.RASDimensions[2] - 1) / 2;\n        planeMatrix.setPosition(new Vector3(0, 0, RASIndex - positionOffset));\n        break;\n    }\n    if (!this.segmentation) {\n      firstDirection.applyMatrix4(volume.inverseMatrix).normalize();\n      secondDirection.applyMatrix4(volume.inverseMatrix).normalize();\n      axisInIJK.applyMatrix4(volume.inverseMatrix).normalize();\n    }\n    firstDirection.arglet = 'i';\n    secondDirection.arglet = 'j';\n    const iLength = Math.floor(Math.abs(firstDirection.dot(dimensions)));\n    const jLength = Math.floor(Math.abs(secondDirection.dot(dimensions)));\n    const planeWidth = Math.abs(iLength * firstSpacing);\n    const planeHeight = Math.abs(jLength * secondSpacing);\n    IJKIndex = Math.abs(Math.round(IJKIndex.applyMatrix4(volume.inverseMatrix).dot(axisInIJK)));\n    const base = [new Vector3(1, 0, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1)];\n    const iDirection = [firstDirection, secondDirection, axisInIJK].find(function (x) {\n      return Math.abs(x.dot(base[0])) > 0.9;\n    });\n    const jDirection = [firstDirection, secondDirection, axisInIJK].find(function (x) {\n      return Math.abs(x.dot(base[1])) > 0.9;\n    });\n    const kDirection = [firstDirection, secondDirection, axisInIJK].find(function (x) {\n      return Math.abs(x.dot(base[2])) > 0.9;\n    });\n    function sliceAccess(i, j) {\n      const si = iDirection === axisInIJK ? IJKIndex : iDirection.arglet === 'i' ? i : j;\n      const sj = jDirection === axisInIJK ? IJKIndex : jDirection.arglet === 'i' ? i : j;\n      const sk = kDirection === axisInIJK ? IJKIndex : kDirection.arglet === 'i' ? i : j;\n\n      // invert indices if necessary\n\n      const accessI = iDirection.dot(base[0]) > 0 ? si : volume.xLength - 1 - si;\n      const accessJ = jDirection.dot(base[1]) > 0 ? sj : volume.yLength - 1 - sj;\n      const accessK = kDirection.dot(base[2]) > 0 ? sk : volume.zLength - 1 - sk;\n      return volume.access(accessI, accessJ, accessK);\n    }\n    return {\n      iLength: iLength,\n      jLength: jLength,\n      sliceAccess: sliceAccess,\n      matrix: planeMatrix,\n      planeWidth: planeWidth,\n      planeHeight: planeHeight\n    };\n  }\n\n  /**\n   * Returns a slice corresponding to the given axis and index.\n   * The coordinate are given in the Right Anterior Superior coordinate format.\n   *\n   * @param {('x'|'y'|'z')} axis - The normal axis to the slice.\n   * @param {number} index - The index of the slice.\n   * @returns {VolumeSlice} The extracted slice.\n   */\n  extractSlice(axis, index) {\n    const slice = new VolumeSlice(this, index, axis);\n    this.sliceList.push(slice);\n    return slice;\n  }\n\n  /**\n   * Call repaint on all the slices extracted from this volume.\n   *\n   * @see {@link VolumeSlice#repaint}\n   * @returns {Volume} A reference to this volume.\n   */\n  repaintAllSlices() {\n    this.sliceList.forEach(function (slice) {\n      slice.repaint();\n    });\n    return this;\n  }\n\n  /**\n   * Compute the minimum and the maximum of the data in the volume.\n   *\n   * @returns {Array<number>} The min/max data as `[min,max]`.\n   */\n  computeMinMax() {\n    let min = Infinity;\n    let max = -Infinity;\n\n    // buffer the length\n    const datasize = this.data.length;\n    let i = 0;\n    for (i = 0; i < datasize; i++) {\n      if (!isNaN(this.data[i])) {\n        const value = this.data[i];\n        min = Math.min(min, value);\n        max = Math.max(max, value);\n      }\n    }\n    this.min = min;\n    this.max = max;\n    return [min, max];\n  }\n}\nexport { Volume };","map":{"version":3,"names":["Matrix3","Matrix4","Vector3","VolumeSlice","Volume","constructor","xLength","yLength","zLength","type","arrayBuffer","undefined","Number","axisOrder","data","Uint8Array","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Error","Float32Array","Float64Array","length","spacing","offset","matrix","identity","inverseMatrix","lowerThreshold","Infinity","Object","defineProperty","get","set","value","sliceList","forEach","slice","geometryNeedsUpdate","upperThreshold","segmentation","RASDimensions","getData","i","j","k","access","reverseAccess","index","z","Math","floor","y","x","map","functionToMap","context","call","extractPerpendicularPlane","axis","RASIndex","firstSpacing","secondSpacing","positionOffset","IJKIndex","axisInIJK","firstDirection","secondDirection","planeMatrix","volume","dimensions","indexOf","multiply","makeRotationY","PI","setPosition","makeRotationX","applyMatrix4","normalize","arglet","iLength","abs","dot","jLength","planeWidth","planeHeight","round","base","iDirection","find","jDirection","kDirection","sliceAccess","si","sj","sk","accessI","accessJ","accessK","extractSlice","push","repaintAllSlices","repaint","computeMinMax","min","max","datasize","isNaN"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/misc/Volume.js"],"sourcesContent":["import {\n\tMatrix3,\n\tMatrix4,\n\tVector3\n} from 'three';\nimport { VolumeSlice } from '../misc/VolumeSlice.js';\n\n/**\n * This class had been written to handle the output of the {@link NRRDLoader}.\n * It contains a volume of data and information about it. For now it only handles 3 dimensional data.\n *\n * @three_import import { Volume } from 'three/addons/misc/Volume.js';\n */\nclass Volume {\n\n\t/**\n\t * Constructs a new volume.\n\t *\n\t * @param {number} [xLength] - Width of the volume.\n\t * @param {number} [yLength] - Length of the volume.\n\t * @param {number} [zLength] - Depth of the volume.\n\t * @param {string} [type] - The type of data (uint8, uint16, ...).\n\t * @param {ArrayBuffer} [arrayBuffer] - The buffer with volume data.\n\t */\n\tconstructor( xLength, yLength, zLength, type, arrayBuffer ) {\n\n\t\tif ( xLength !== undefined ) {\n\n\t\t\t/**\n\t\t\t * Width of the volume in the IJK coordinate system.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default 1\n\t\t\t */\n\t\t\tthis.xLength = Number( xLength ) || 1;\n\n\t\t\t/**\n\t\t\t * Height of the volume in the IJK coordinate system.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default 1\n\t\t\t */\n\t\t\tthis.yLength = Number( yLength ) || 1;\n\n\t\t\t/**\n\t\t\t * Depth of the volume in the IJK coordinate system.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default 1\n\t\t\t */\n\t\t\tthis.zLength = Number( zLength ) || 1;\n\n\t\t\t/**\n\t\t\t * The order of the Axis dictated by the NRRD header\n\t\t\t *\n\t\t\t * @type {Array<string>}\n\t\t\t */\n\t\t\tthis.axisOrder = [ 'x', 'y', 'z' ];\n\n\t\t\t/**\n\t\t\t * The data of the volume.\n\t\t\t *\n\t\t\t * @type {TypedArray}\n\t\t\t */\n\t\t\tthis.data;\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'Uint8' :\n\t\t\t\tcase 'uint8' :\n\t\t\t\tcase 'uchar' :\n\t\t\t\tcase 'unsigned char' :\n\t\t\t\tcase 'uint8_t' :\n\t\t\t\t\tthis.data = new Uint8Array( arrayBuffer );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Int8' :\n\t\t\t\tcase 'int8' :\n\t\t\t\tcase 'signed char' :\n\t\t\t\tcase 'int8_t' :\n\t\t\t\t\tthis.data = new Int8Array( arrayBuffer );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Int16' :\n\t\t\t\tcase 'int16' :\n\t\t\t\tcase 'short' :\n\t\t\t\tcase 'short int' :\n\t\t\t\tcase 'signed short' :\n\t\t\t\tcase 'signed short int' :\n\t\t\t\tcase 'int16_t' :\n\t\t\t\t\tthis.data = new Int16Array( arrayBuffer );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Uint16' :\n\t\t\t\tcase 'uint16' :\n\t\t\t\tcase 'ushort' :\n\t\t\t\tcase 'unsigned short' :\n\t\t\t\tcase 'unsigned short int' :\n\t\t\t\tcase 'uint16_t' :\n\t\t\t\t\tthis.data = new Uint16Array( arrayBuffer );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Int32' :\n\t\t\t\tcase 'int32' :\n\t\t\t\tcase 'int' :\n\t\t\t\tcase 'signed int' :\n\t\t\t\tcase 'int32_t' :\n\t\t\t\t\tthis.data = new Int32Array( arrayBuffer );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Uint32' :\n\t\t\t\tcase 'uint32' :\n\t\t\t\tcase 'uint' :\n\t\t\t\tcase 'unsigned int' :\n\t\t\t\tcase 'uint32_t' :\n\t\t\t\t\tthis.data = new Uint32Array( arrayBuffer );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'longlong' :\n\t\t\t\tcase 'long long' :\n\t\t\t\tcase 'long long int' :\n\t\t\t\tcase 'signed long long' :\n\t\t\t\tcase 'signed long long int' :\n\t\t\t\tcase 'int64' :\n\t\t\t\tcase 'int64_t' :\n\t\t\t\tcase 'ulonglong' :\n\t\t\t\tcase 'unsigned long long' :\n\t\t\t\tcase 'unsigned long long int' :\n\t\t\t\tcase 'uint64' :\n\t\t\t\tcase 'uint64_t' :\n\t\t\t\t\tthrow new Error( 'Error in Volume constructor : this type is not supported in JavaScript' );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Float32' :\n\t\t\t\tcase 'float32' :\n\t\t\t\tcase 'float' :\n\t\t\t\t\tthis.data = new Float32Array( arrayBuffer );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Float64' :\n\t\t\t\tcase 'float64' :\n\t\t\t\tcase 'double' :\n\t\t\t\t\tthis.data = new Float64Array( arrayBuffer );\n\t\t\t\t\tbreak;\n\t\t\t\tdefault :\n\t\t\t\t\tthis.data = new Uint8Array( arrayBuffer );\n\n\t\t\t}\n\n\t\t\tif ( this.data.length !== this.xLength * this.yLength * this.zLength ) {\n\n\t\t\t\tthrow new Error( 'Error in Volume constructor, lengths are not matching arrayBuffer size' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * Spacing to apply to the volume from IJK to RAS coordinate system\n\t\t *\n\t\t * @type {Array<number>}\n\t\t */\n\t\tthis.spacing = [ 1, 1, 1 ];\n\n\t\t/**\n\t\t * Offset of the volume in the RAS coordinate system\n\t\t *\n\t\t * @type {Array<number>}\n\t\t */\n\t\tthis.offset = [ 0, 0, 0 ];\n\n\t\t/**\n\t\t * The IJK to RAS matrix.\n\t\t *\n\t\t * @type {Martrix3}\n\t\t */\n\t\tthis.matrix = new Matrix3();\n\t\tthis.matrix.identity();\n\n\t\t/**\n\t\t * The RAS to IJK matrix.\n\t\t *\n\t\t * @type {Martrix3}\n\t\t */\n\t\tthis.inverseMatrix = new Matrix3();\n\n\t\tlet lowerThreshold = - Infinity;\n\t\tObject.defineProperty( this, 'lowerThreshold', {\n\t\t\tget: function () {\n\n\t\t\t\treturn lowerThreshold;\n\n\t\t\t},\n\t\t\t/**\n\t\t\t * The voxels with values under this threshold won't appear in the slices.\n\t\t\t * If changed, geometryNeedsUpdate is automatically set to true on all the slices associated to this volume.\n\t\t\t *\n\t\t\t * @name Volume#lowerThreshold\n\t\t\t * @type {number}\n\t\t\t * @param {number} value\n\t\t\t */\n\t\t\tset: function ( value ) {\n\n\t\t\t\tlowerThreshold = value;\n\t\t\t\tthis.sliceList.forEach( function ( slice ) {\n\n\t\t\t\t\tslice.geometryNeedsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t}\n\t\t} );\n\n\t\tlet upperThreshold = Infinity;\n\t\tObject.defineProperty( this, 'upperThreshold', {\n\t\t\tget: function () {\n\n\t\t\t\treturn upperThreshold;\n\n\t\t\t},\n\t\t\t/**\n\t\t\t * The voxels with values over this threshold won't appear in the slices.\n\t\t\t * If changed, geometryNeedsUpdate is automatically set to true on all the slices associated to this volume\n\t\t\t *\n\t\t\t * @name Volume#upperThreshold\n\t\t\t * @type {number}\n\t\t\t * @param {number} value\n\t\t\t */\n\t\t\tset: function ( value ) {\n\n\t\t\t\tupperThreshold = value;\n\t\t\t\tthis.sliceList.forEach( function ( slice ) {\n\n\t\t\t\t\tslice.geometryNeedsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t}\n\t\t} );\n\n\n\t\t/**\n\t\t * The list of all the slices associated to this volume\n\t\t *\n\t\t * @type {Array}\n\t\t */\n\t\tthis.sliceList = [];\n\n\t\t/**\n\t\t * Whether to use segmentation mode or not.\n\t\t * It can load 16-bits nrrds correctly.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.segmentation = false;\n\n\n\t\t/**\n\t\t * This array holds the dimensions of the volume in the RAS space\n\t\t *\n\t\t * @type {Array<number>}\n\t\t */\n\t\tthis.RASDimensions = [];\n\n\t}\n\n\t/**\n\t * Shortcut for data[access(i,j,k)].\n\t *\n\t * @param {number} i - First coordinate.\n\t * @param {number} j - Second coordinate.\n\t * @param {number} k - Third coordinate.\n\t * @returns {number} The value in the data array.\n\t */\n\tgetData( i, j, k ) {\n\n\t\treturn this.data[ k * this.xLength * this.yLength + j * this.xLength + i ];\n\n\t}\n\n\t/**\n\t * Compute the index in the data array corresponding to the given coordinates in IJK system.\n\t *\n\t * @param {number} i - First coordinate.\n\t * @param {number} j - Second coordinate.\n\t * @param {number} k - Third coordinate.\n\t * @returns {number} The index.\n\t */\n\taccess( i, j, k ) {\n\n\t\treturn k * this.xLength * this.yLength + j * this.xLength + i;\n\n\t}\n\n\t/**\n\t * Retrieve the IJK coordinates of the voxel corresponding of the given index in the data.\n\t *\n\t * @param {number} index - Index of the voxel.\n\t * @returns {Array<number>} The IJK coordinates as `[x,y,z]`.\n\t */\n\treverseAccess( index ) {\n\n\t\tconst z = Math.floor( index / ( this.yLength * this.xLength ) );\n\t\tconst y = Math.floor( ( index - z * this.yLength * this.xLength ) / this.xLength );\n\t\tconst x = index - z * this.yLength * this.xLength - y * this.xLength;\n\t\treturn [ x, y, z ];\n\n\t}\n\n\t/**\n\t * Apply a function to all the voxels, be careful, the value will be replaced.\n\t *\n\t * @param {Function} functionToMap A function to apply to every voxel, will be called with the following parameters:\n\t * value of the voxel, index of the voxel, the data (TypedArray).\n\t * @param {Object} context - You can specify a context in which call the function, default if this Volume.\n\t * @returns {Volume} A reference to this instance.\n\t */\n\tmap( functionToMap, context ) {\n\n\t\tconst length = this.data.length;\n\t\tcontext = context || this;\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tthis.data[ i ] = functionToMap.call( context, this.data[ i ], i, this.data );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Compute the orientation of the slice and returns all the information relative to the geometry such as sliceAccess,\n\t * the plane matrix (orientation and position in RAS coordinate) and the dimensions of the plane in both coordinate system.\n\t *\n\t * @param {('x'|'y'|'z')} axis - The normal axis to the slice.\n\t * @param {number} RASIndex - The index of the slice.\n\t * @returns {Object} An object containing all the useful information on the geometry of the slice.\n\t */\n\textractPerpendicularPlane( axis, RASIndex ) {\n\n\t\tlet firstSpacing,\n\t\t\tsecondSpacing,\n\t\t\tpositionOffset,\n\t\t\tIJKIndex;\n\n\t\tconst axisInIJK = new Vector3(),\n\t\t\tfirstDirection = new Vector3(),\n\t\t\tsecondDirection = new Vector3(),\n\t\t\tplaneMatrix = ( new Matrix4() ).identity(),\n\t\t\tvolume = this;\n\n\t\tconst dimensions = new Vector3( this.xLength, this.yLength, this.zLength );\n\n\n\t\tswitch ( axis ) {\n\n\t\t\tcase 'x' :\n\t\t\t\taxisInIJK.set( 1, 0, 0 );\n\t\t\t\tfirstDirection.set( 0, 0, - 1 );\n\t\t\t\tsecondDirection.set( 0, - 1, 0 );\n\t\t\t\tfirstSpacing = this.spacing[ this.axisOrder.indexOf( 'z' ) ];\n\t\t\t\tsecondSpacing = this.spacing[ this.axisOrder.indexOf( 'y' ) ];\n\t\t\t\tIJKIndex = new Vector3( RASIndex, 0, 0 );\n\n\t\t\t\tplaneMatrix.multiply( ( new Matrix4() ).makeRotationY( Math.PI / 2 ) );\n\t\t\t\tpositionOffset = ( volume.RASDimensions[ 0 ] - 1 ) / 2;\n\t\t\t\tplaneMatrix.setPosition( new Vector3( RASIndex - positionOffset, 0, 0 ) );\n\t\t\t\tbreak;\n\t\t\tcase 'y' :\n\t\t\t\taxisInIJK.set( 0, 1, 0 );\n\t\t\t\tfirstDirection.set( 1, 0, 0 );\n\t\t\t\tsecondDirection.set( 0, 0, 1 );\n\t\t\t\tfirstSpacing = this.spacing[ this.axisOrder.indexOf( 'x' ) ];\n\t\t\t\tsecondSpacing = this.spacing[ this.axisOrder.indexOf( 'z' ) ];\n\t\t\t\tIJKIndex = new Vector3( 0, RASIndex, 0 );\n\n\t\t\t\tplaneMatrix.multiply( ( new Matrix4() ).makeRotationX( - Math.PI / 2 ) );\n\t\t\t\tpositionOffset = ( volume.RASDimensions[ 1 ] - 1 ) / 2;\n\t\t\t\tplaneMatrix.setPosition( new Vector3( 0, RASIndex - positionOffset, 0 ) );\n\t\t\t\tbreak;\n\t\t\tcase 'z' :\n\t\t\tdefault :\n\t\t\t\taxisInIJK.set( 0, 0, 1 );\n\t\t\t\tfirstDirection.set( 1, 0, 0 );\n\t\t\t\tsecondDirection.set( 0, - 1, 0 );\n\t\t\t\tfirstSpacing = this.spacing[ this.axisOrder.indexOf( 'x' ) ];\n\t\t\t\tsecondSpacing = this.spacing[ this.axisOrder.indexOf( 'y' ) ];\n\t\t\t\tIJKIndex = new Vector3( 0, 0, RASIndex );\n\n\t\t\t\tpositionOffset = ( volume.RASDimensions[ 2 ] - 1 ) / 2;\n\t\t\t\tplaneMatrix.setPosition( new Vector3( 0, 0, RASIndex - positionOffset ) );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( ! this.segmentation ) {\n\n\t\t\tfirstDirection.applyMatrix4( volume.inverseMatrix ).normalize();\n\t\t\tsecondDirection.applyMatrix4( volume.inverseMatrix ).normalize();\n\t\t\taxisInIJK.applyMatrix4( volume.inverseMatrix ).normalize();\n\n\t\t}\n\n\t\tfirstDirection.arglet = 'i';\n\t\tsecondDirection.arglet = 'j';\n\t\tconst iLength = Math.floor( Math.abs( firstDirection.dot( dimensions ) ) );\n\t\tconst jLength = Math.floor( Math.abs( secondDirection.dot( dimensions ) ) );\n\t\tconst planeWidth = Math.abs( iLength * firstSpacing );\n\t\tconst planeHeight = Math.abs( jLength * secondSpacing );\n\n\t\tIJKIndex = Math.abs( Math.round( IJKIndex.applyMatrix4( volume.inverseMatrix ).dot( axisInIJK ) ) );\n\t\tconst base = [ new Vector3( 1, 0, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ) ];\n\t\tconst iDirection = [ firstDirection, secondDirection, axisInIJK ].find( function ( x ) {\n\n\t\t\treturn Math.abs( x.dot( base[ 0 ] ) ) > 0.9;\n\n\t\t} );\n\t\tconst jDirection = [ firstDirection, secondDirection, axisInIJK ].find( function ( x ) {\n\n\t\t\treturn Math.abs( x.dot( base[ 1 ] ) ) > 0.9;\n\n\t\t} );\n\t\tconst kDirection = [ firstDirection, secondDirection, axisInIJK ].find( function ( x ) {\n\n\t\t\treturn Math.abs( x.dot( base[ 2 ] ) ) > 0.9;\n\n\t\t} );\n\n\t\tfunction sliceAccess( i, j ) {\n\n\t\t\tconst si = ( iDirection === axisInIJK ) ? IJKIndex : ( iDirection.arglet === 'i' ? i : j );\n\t\t\tconst sj = ( jDirection === axisInIJK ) ? IJKIndex : ( jDirection.arglet === 'i' ? i : j );\n\t\t\tconst sk = ( kDirection === axisInIJK ) ? IJKIndex : ( kDirection.arglet === 'i' ? i : j );\n\n\t\t\t// invert indices if necessary\n\n\t\t\tconst accessI = ( iDirection.dot( base[ 0 ] ) > 0 ) ? si : ( volume.xLength - 1 ) - si;\n\t\t\tconst accessJ = ( jDirection.dot( base[ 1 ] ) > 0 ) ? sj : ( volume.yLength - 1 ) - sj;\n\t\t\tconst accessK = ( kDirection.dot( base[ 2 ] ) > 0 ) ? sk : ( volume.zLength - 1 ) - sk;\n\n\t\t\treturn volume.access( accessI, accessJ, accessK );\n\n\t\t}\n\n\t\treturn {\n\t\t\tiLength: iLength,\n\t\t\tjLength: jLength,\n\t\t\tsliceAccess: sliceAccess,\n\t\t\tmatrix: planeMatrix,\n\t\t\tplaneWidth: planeWidth,\n\t\t\tplaneHeight: planeHeight\n\t\t};\n\n\t}\n\n\t/**\n\t * Returns a slice corresponding to the given axis and index.\n\t * The coordinate are given in the Right Anterior Superior coordinate format.\n\t *\n\t * @param {('x'|'y'|'z')} axis - The normal axis to the slice.\n\t * @param {number} index - The index of the slice.\n\t * @returns {VolumeSlice} The extracted slice.\n\t */\n\textractSlice( axis, index ) {\n\n\t\tconst slice = new VolumeSlice( this, index, axis );\n\t\tthis.sliceList.push( slice );\n\t\treturn slice;\n\n\t}\n\n\t/**\n\t * Call repaint on all the slices extracted from this volume.\n\t *\n\t * @see {@link VolumeSlice#repaint}\n\t * @returns {Volume} A reference to this volume.\n\t */\n\trepaintAllSlices() {\n\n\t\tthis.sliceList.forEach( function ( slice ) {\n\n\t\t\tslice.repaint();\n\n\t\t} );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Compute the minimum and the maximum of the data in the volume.\n\t *\n\t * @returns {Array<number>} The min/max data as `[min,max]`.\n\t */\n\tcomputeMinMax() {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\n\t\t// buffer the length\n\t\tconst datasize = this.data.length;\n\n\t\tlet i = 0;\n\n\t\tfor ( i = 0; i < datasize; i ++ ) {\n\n\t\t\tif ( ! isNaN( this.data[ i ] ) ) {\n\n\t\t\t\tconst value = this.data[ i ];\n\t\t\t\tmin = Math.min( min, value );\n\t\t\t\tmax = Math.max( max, value );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t\treturn [ min, max ];\n\n\t}\n\n}\n\nexport { Volume };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}