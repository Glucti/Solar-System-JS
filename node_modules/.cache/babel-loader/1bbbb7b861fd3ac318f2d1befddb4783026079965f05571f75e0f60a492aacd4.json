{"ast":null,"code":"import { Color, Matrix4, Mesh, PerspectiveCamera, ShaderMaterial, UniformsUtils, Vector2, Vector3, WebGLRenderTarget, DepthTexture, UnsignedShortType, NearestFilter, Plane, HalfFloatType } from 'three';\n\n/**\n * A special version of {@link Reflector} for usage with {@link SSRPass}.\n *\n * @augments Mesh\n * @three_import import { ReflectorForSSRPass } from 'three/addons/objects/ReflectorForSSRPass.js';\n */\nclass ReflectorForSSRPass extends Mesh {\n  /**\n   * Constructs a new reflector.\n   *\n   * @param {BufferGeometry} geometry - The reflector's geometry.\n   * @param {ReflectorForSSRPass~Options} [options] - The configuration options.\n   */\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.isReflectorForSSRPass = true;\n    this.type = 'ReflectorForSSRPass';\n    const scope = this;\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7F7F7F);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || ReflectorForSSRPass.ReflectorShader;\n    const useDepthTexture = options.useDepthTexture === true;\n    const yAxis = new Vector3(0, 1, 0);\n    const vecTemp0 = new Vector3();\n    const vecTemp1 = new Vector3();\n\n    //\n\n    scope.needsUpdate = false;\n    scope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n    scope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n    scope.color = color;\n    scope.resolution = options.resolution || new Vector2(window.innerWidth, window.innerHeight);\n    scope._distanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;\n    Object.defineProperty(scope, 'distanceAttenuation', {\n      get() {\n        return scope._distanceAttenuation;\n      },\n      set(val) {\n        if (scope._distanceAttenuation === val) return;\n        scope._distanceAttenuation = val;\n        scope.material.defines.DISTANCE_ATTENUATION = val;\n        scope.material.needsUpdate = true;\n      }\n    });\n    scope._fresnel = ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;\n    Object.defineProperty(scope, 'fresnel', {\n      get() {\n        return scope._fresnel;\n      },\n      set(val) {\n        if (scope._fresnel === val) return;\n        scope._fresnel = val;\n        scope.material.defines.FRESNEL = val;\n        scope.material.needsUpdate = true;\n      }\n    });\n    const normal = new Vector3();\n    const reflectorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const view = new Vector3();\n    const target = new Vector3();\n    const textureMatrix = new Matrix4();\n    const virtualCamera = new PerspectiveCamera();\n    let depthTexture;\n    if (useDepthTexture) {\n      depthTexture = new DepthTexture();\n      depthTexture.type = UnsignedShortType;\n      depthTexture.minFilter = NearestFilter;\n      depthTexture.magFilter = NearestFilter;\n    }\n    const parameters = {\n      depthTexture: useDepthTexture ? depthTexture : null,\n      type: HalfFloatType\n    };\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n    const material = new ShaderMaterial({\n      name: shader.name !== undefined ? shader.name : 'unspecified',\n      transparent: useDepthTexture,\n      defines: Object.assign({}, ReflectorForSSRPass.ReflectorShader.defines, {\n        useDepthTexture\n      }),\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms['tDiffuse'].value = renderTarget.texture;\n    material.uniforms['color'].value = scope.color;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n    if (useDepthTexture) {\n      material.uniforms['tDepth'].value = renderTarget.depthTexture;\n    }\n    this.material = material;\n    const globalPlane = new Plane(new Vector3(0, 1, 0), clipBias);\n    const globalPlanes = [globalPlane];\n    this.doRender = function (renderer, scene, camera) {\n      material.uniforms['maxDistance'].value = scope.maxDistance;\n      material.uniforms['color'].value = scope.color;\n      material.uniforms['opacity'].value = scope.opacity;\n      vecTemp0.copy(camera.position).normalize();\n      vecTemp1.copy(vecTemp0).reflect(yAxis);\n      material.uniforms['fresnelCoe'].value = (vecTemp0.dot(vecTemp1) + 1.) / 2.; // TODO: Also need to use glsl viewPosition and viewNormal per pixel.\n\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition);\n\n      // Avoid rendering when reflector is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far; // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n      material.uniforms['virtualCameraNear'].value = camera.near;\n      material.uniforms['virtualCameraFar'].value = camera.far;\n      material.uniforms['virtualCameraMatrixWorld'].value = virtualCamera.matrixWorld;\n      material.uniforms['virtualCameraProjectionMatrix'].value = camera.projectionMatrix;\n      material.uniforms['virtualCameraProjectionMatrixInverse'].value = camera.projectionMatrixInverse;\n      material.uniforms['resolution'].value = scope.resolution;\n\n      // Update the texture matrix\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n\n      // scope.visible = false;\n\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentClippingPlanes = renderer.clippingPlanes;\n      renderer.xr.enabled = false; // Avoid camera modification\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n      renderer.clippingPlanes = globalPlanes;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.clippingPlanes = currentClippingPlanes;\n      renderer.setRenderTarget(currentRenderTarget);\n\n      // Restore viewport\n\n      const viewport = camera.viewport;\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n\n      // scope.visible = true;\n    };\n\n    /**\n     * Returns the reflector's internal render target.\n     *\n     * @return {WebGLRenderTarget} The internal render target\n     */\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n\n    /**\n     * Frees the GPU-related resources allocated by this instance. Call this\n     * method whenever this instance is no longer used in your app.\n     */\n    this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n  }\n}\nReflectorForSSRPass.ReflectorShader = {\n  name: 'ReflectorShader',\n  defines: {\n    DISTANCE_ATTENUATION: true,\n    FRESNEL: true\n  },\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    textureMatrix: {\n      value: new Matrix4()\n    },\n    maxDistance: {\n      value: 180\n    },\n    opacity: {\n      value: 0.5\n    },\n    fresnelCoe: {\n      value: null\n    },\n    virtualCameraNear: {\n      value: null\n    },\n    virtualCameraFar: {\n      value: null\n    },\n    virtualCameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    virtualCameraMatrixWorld: {\n      value: new Matrix4()\n    },\n    virtualCameraProjectionMatrixInverse: {\n      value: new Matrix4()\n    },\n    resolution: {\n      value: new Vector2()\n    }\n  },\n  vertexShader: /* glsl */`\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n  fragmentShader: /* glsl */`\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnelCoe;\n\t\tuniform float virtualCameraNear;\n\t\tuniform float virtualCameraFar;\n\t\tuniform mat4 virtualCameraProjectionMatrix;\n\t\tuniform mat4 virtualCameraProjectionMatrixInverse;\n\t\tuniform mat4 virtualCameraMatrixWorld;\n\t\tuniform vec2 resolution;\n\t\tvarying vec4 vUv;\n\t\t#include <packing>\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\n\t\t\t\tuv.x=1.-uv.x;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\t\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\n\t\t\t\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\n\t\t\t\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\n\t\t\t\tif(worldPosition.y>maxDistance) discard;\n\t\t\t\tfloat op=opacity;\n\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\tfloat ratio=1.-(worldPosition.y/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t`\n};\n\n/**\n * Constructor options of `ReflectorForSSRPass`.\n *\n * @typedef {Object} ReflectorForSSRPass~Options\n * @property {number|Color|string} [color=0x7F7F7F] - The reflector's color.\n * @property {number} [textureWidth=512] - The texture width. A higher value results in more clear reflections but is also more expensive.\n * @property {number} [textureHeight=512] - The texture height. A higher value results in more clear reflections but is also more expensive.\n * @property {number} [clipBias=0] - The clip bias.\n * @property {Object} [shader] - Can be used to pass in a custom shader that defines how the reflective view is projected onto the reflector's geometry.\n * @property {boolean} [useDepthTexture=true] - Whether to store depth values in a texture or not.\n **/\n\nexport { ReflectorForSSRPass };","map":{"version":3,"names":["Color","Matrix4","Mesh","PerspectiveCamera","ShaderMaterial","UniformsUtils","Vector2","Vector3","WebGLRenderTarget","DepthTexture","UnsignedShortType","NearestFilter","Plane","HalfFloatType","ReflectorForSSRPass","constructor","geometry","options","isReflectorForSSRPass","type","scope","color","undefined","textureWidth","textureHeight","clipBias","shader","ReflectorShader","useDepthTexture","yAxis","vecTemp0","vecTemp1","needsUpdate","maxDistance","uniforms","value","opacity","resolution","window","innerWidth","innerHeight","_distanceAttenuation","defines","DISTANCE_ATTENUATION","Object","defineProperty","get","set","val","material","_fresnel","FRESNEL","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","view","target","textureMatrix","virtualCamera","depthTexture","minFilter","magFilter","parameters","renderTarget","name","transparent","assign","clone","fragmentShader","vertexShader","texture","globalPlane","globalPlanes","doRender","renderer","scene","camera","copy","position","normalize","reflect","dot","setFromMatrixPosition","matrixWorld","extractRotation","applyMatrix4","subVectors","negate","add","up","lookAt","far","updateMatrixWorld","projectionMatrix","near","projectionMatrixInverse","multiply","matrixWorldInverse","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","currentClippingPlanes","clippingPlanes","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","dispose","tDiffuse","tDepth","fresnelCoe","virtualCameraNear","virtualCameraFar","virtualCameraProjectionMatrix","virtualCameraMatrixWorld","virtualCameraProjectionMatrixInverse"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/objects/ReflectorForSSRPass.js"],"sourcesContent":["import {\n\tColor,\n\tMatrix4,\n\tMesh,\n\tPerspectiveCamera,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector2,\n\tVector3,\n\tWebGLRenderTarget,\n\tDepthTexture,\n\tUnsignedShortType,\n\tNearestFilter,\n\tPlane,\n\tHalfFloatType\n} from 'three';\n\n/**\n * A special version of {@link Reflector} for usage with {@link SSRPass}.\n *\n * @augments Mesh\n * @three_import import { ReflectorForSSRPass } from 'three/addons/objects/ReflectorForSSRPass.js';\n */\nclass ReflectorForSSRPass extends Mesh {\n\n\t/**\n\t * Constructs a new reflector.\n\t *\n\t * @param {BufferGeometry} geometry - The reflector's geometry.\n\t * @param {ReflectorForSSRPass~Options} [options] - The configuration options.\n\t */\n\tconstructor( geometry, options = {} ) {\n\n\t\tsuper( geometry );\n\n\t\tthis.isReflectorForSSRPass = true;\n\n\t\tthis.type = 'ReflectorForSSRPass';\n\n\t\tconst scope = this;\n\n\t\tconst color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );\n\t\tconst textureWidth = options.textureWidth || 512;\n\t\tconst textureHeight = options.textureHeight || 512;\n\t\tconst clipBias = options.clipBias || 0;\n\t\tconst shader = options.shader || ReflectorForSSRPass.ReflectorShader;\n\t\tconst useDepthTexture = options.useDepthTexture === true;\n\t\tconst yAxis = new Vector3( 0, 1, 0 );\n\t\tconst vecTemp0 = new Vector3();\n\t\tconst vecTemp1 = new Vector3();\n\n\t\t//\n\n\t\tscope.needsUpdate = false;\n\t\tscope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n\t\tscope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n\t\tscope.color = color;\n\t\tscope.resolution = options.resolution || new Vector2( window.innerWidth, window.innerHeight );\n\n\n\t\tscope._distanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;\n\t\tObject.defineProperty( scope, 'distanceAttenuation', {\n\t\t\tget() {\n\n\t\t\t\treturn scope._distanceAttenuation;\n\n\t\t\t},\n\t\t\tset( val ) {\n\n\t\t\t\tif ( scope._distanceAttenuation === val ) return;\n\t\t\t\tscope._distanceAttenuation = val;\n\t\t\t\tscope.material.defines.DISTANCE_ATTENUATION = val;\n\t\t\t\tscope.material.needsUpdate = true;\n\n\t\t\t}\n\t\t} );\n\n\t\tscope._fresnel = ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;\n\t\tObject.defineProperty( scope, 'fresnel', {\n\t\t\tget() {\n\n\t\t\t\treturn scope._fresnel;\n\n\t\t\t},\n\t\t\tset( val ) {\n\n\t\t\t\tif ( scope._fresnel === val ) return;\n\t\t\t\tscope._fresnel = val;\n\t\t\t\tscope.material.defines.FRESNEL = val;\n\t\t\t\tscope.material.needsUpdate = true;\n\n\t\t\t}\n\t\t} );\n\n\t\tconst normal = new Vector3();\n\t\tconst reflectorWorldPosition = new Vector3();\n\t\tconst cameraWorldPosition = new Vector3();\n\t\tconst rotationMatrix = new Matrix4();\n\t\tconst lookAtPosition = new Vector3( 0, 0, - 1 );\n\n\t\tconst view = new Vector3();\n\t\tconst target = new Vector3();\n\n\t\tconst textureMatrix = new Matrix4();\n\t\tconst virtualCamera = new PerspectiveCamera();\n\n\t\tlet depthTexture;\n\n\t\tif ( useDepthTexture ) {\n\n\t\t\tdepthTexture = new DepthTexture();\n\t\t\tdepthTexture.type = UnsignedShortType;\n\t\t\tdepthTexture.minFilter = NearestFilter;\n\t\t\tdepthTexture.magFilter = NearestFilter;\n\n\t\t}\n\n\t\tconst parameters = {\n\t\t\tdepthTexture: useDepthTexture ? depthTexture : null,\n\t\t\ttype: HalfFloatType\n\t\t};\n\n\t\tconst renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, parameters );\n\n\t\tconst material = new ShaderMaterial( {\n\t\t\tname: ( shader.name !== undefined ) ? shader.name : 'unspecified',\n\t\t\ttransparent: useDepthTexture,\n\t\t\tdefines: Object.assign( {}, ReflectorForSSRPass.ReflectorShader.defines, {\n\t\t\t\tuseDepthTexture\n\t\t\t} ),\n\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tvertexShader: shader.vertexShader\n\t\t} );\n\n\t\tmaterial.uniforms[ 'tDiffuse' ].value = renderTarget.texture;\n\t\tmaterial.uniforms[ 'color' ].value = scope.color;\n\t\tmaterial.uniforms[ 'textureMatrix' ].value = textureMatrix;\n\t\tif ( useDepthTexture ) {\n\n\t\t\tmaterial.uniforms[ 'tDepth' ].value = renderTarget.depthTexture;\n\n\t\t}\n\n\t\tthis.material = material;\n\n\t\tconst globalPlane = new Plane( new Vector3( 0, 1, 0 ), clipBias );\n\t\tconst globalPlanes = [ globalPlane ];\n\n\t\tthis.doRender = function ( renderer, scene, camera ) {\n\n\t\t\tmaterial.uniforms[ 'maxDistance' ].value = scope.maxDistance;\n\t\t\tmaterial.uniforms[ 'color' ].value = scope.color;\n\t\t\tmaterial.uniforms[ 'opacity' ].value = scope.opacity;\n\n\t\t\tvecTemp0.copy( camera.position ).normalize();\n\t\t\tvecTemp1.copy( vecTemp0 ).reflect( yAxis );\n\t\t\tmaterial.uniforms[ 'fresnelCoe' ].value = ( vecTemp0.dot( vecTemp1 ) + 1. ) / 2.; // TODO: Also need to use glsl viewPosition and viewNormal per pixel.\n\n\t\t\treflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\tnormal.set( 0, 0, 1 );\n\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\tview.subVectors( reflectorWorldPosition, cameraWorldPosition );\n\n\t\t\t// Avoid rendering when reflector is facing away\n\n\t\t\tif ( view.dot( normal ) > 0 ) return;\n\n\t\t\tview.reflect( normal ).negate();\n\t\t\tview.add( reflectorWorldPosition );\n\n\t\t\trotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t\tlookAtPosition.set( 0, 0, - 1 );\n\t\t\tlookAtPosition.applyMatrix4( rotationMatrix );\n\t\t\tlookAtPosition.add( cameraWorldPosition );\n\n\t\t\ttarget.subVectors( reflectorWorldPosition, lookAtPosition );\n\t\t\ttarget.reflect( normal ).negate();\n\t\t\ttarget.add( reflectorWorldPosition );\n\n\t\t\tvirtualCamera.position.copy( view );\n\t\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\t\tvirtualCamera.up.applyMatrix4( rotationMatrix );\n\t\t\tvirtualCamera.up.reflect( normal );\n\t\t\tvirtualCamera.lookAt( target );\n\n\t\t\tvirtualCamera.far = camera.far; // Used in WebGLBackground\n\n\t\t\tvirtualCamera.updateMatrixWorld();\n\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\tmaterial.uniforms[ 'virtualCameraNear' ].value = camera.near;\n\t\t\tmaterial.uniforms[ 'virtualCameraFar' ].value = camera.far;\n\t\t\tmaterial.uniforms[ 'virtualCameraMatrixWorld' ].value = virtualCamera.matrixWorld;\n\t\t\tmaterial.uniforms[ 'virtualCameraProjectionMatrix' ].value = camera.projectionMatrix;\n\t\t\tmaterial.uniforms[ 'virtualCameraProjectionMatrixInverse' ].value = camera.projectionMatrixInverse;\n\t\t\tmaterial.uniforms[ 'resolution' ].value = scope.resolution;\n\n\t\t\t// Update the texture matrix\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\t\t\ttextureMatrix.multiply( virtualCamera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( virtualCamera.matrixWorldInverse );\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t\t// scope.visible = false;\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\t\t\tconst currentClippingPlanes = renderer.clippingPlanes;\n\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\t\t\trenderer.clippingPlanes = globalPlanes;\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\n\t\t\trenderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\trenderer.render( scene, virtualCamera );\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\t\t\trenderer.clippingPlanes = currentClippingPlanes;\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t// Restore viewport\n\n\t\t\tconst viewport = camera.viewport;\n\n\t\t\tif ( viewport !== undefined ) {\n\n\t\t\t\trenderer.state.viewport( viewport );\n\n\t\t\t}\n\n\t\t\t// scope.visible = true;\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the reflector's internal render target.\n\t\t *\n\t\t * @return {WebGLRenderTarget} The internal render target\n\t\t */\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t\t/**\n\t\t * Frees the GPU-related resources allocated by this instance. Call this\n\t\t * method whenever this instance is no longer used in your app.\n\t\t */\n\t\tthis.dispose = function () {\n\n\t\t\trenderTarget.dispose();\n\t\t\tscope.material.dispose();\n\n\t\t};\n\n\t}\n\n}\n\nReflectorForSSRPass.ReflectorShader = {\n\n\tname: 'ReflectorShader',\n\n\tdefines: {\n\t\tDISTANCE_ATTENUATION: true,\n\t\tFRESNEL: true,\n\t},\n\n\tuniforms: {\n\n\t\tcolor: { value: null },\n\t\ttDiffuse: { value: null },\n\t\ttDepth: { value: null },\n\t\ttextureMatrix: { value: new Matrix4() },\n\t\tmaxDistance: { value: 180 },\n\t\topacity: { value: 0.5 },\n\t\tfresnelCoe: { value: null },\n\t\tvirtualCameraNear: { value: null },\n\t\tvirtualCameraFar: { value: null },\n\t\tvirtualCameraProjectionMatrix: { value: new Matrix4() },\n\t\tvirtualCameraMatrixWorld: { value: new Matrix4() },\n\t\tvirtualCameraProjectionMatrixInverse: { value: new Matrix4() },\n\t\tresolution: { value: new Vector2() },\n\n\t},\n\n\tvertexShader: /* glsl */`\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnelCoe;\n\t\tuniform float virtualCameraNear;\n\t\tuniform float virtualCameraFar;\n\t\tuniform mat4 virtualCameraProjectionMatrix;\n\t\tuniform mat4 virtualCameraProjectionMatrixInverse;\n\t\tuniform mat4 virtualCameraMatrixWorld;\n\t\tuniform vec2 resolution;\n\t\tvarying vec4 vUv;\n\t\t#include <packing>\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\n\t\t\t\tuv.x=1.-uv.x;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\t\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\n\t\t\t\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\n\t\t\t\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\n\t\t\t\tif(worldPosition.y>maxDistance) discard;\n\t\t\t\tfloat op=opacity;\n\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\tfloat ratio=1.-(worldPosition.y/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t`,\n};\n\n/**\n * Constructor options of `ReflectorForSSRPass`.\n *\n * @typedef {Object} ReflectorForSSRPass~Options\n * @property {number|Color|string} [color=0x7F7F7F] - The reflector's color.\n * @property {number} [textureWidth=512] - The texture width. A higher value results in more clear reflections but is also more expensive.\n * @property {number} [textureHeight=512] - The texture height. A higher value results in more clear reflections but is also more expensive.\n * @property {number} [clipBias=0] - The clip bias.\n * @property {Object} [shader] - Can be used to pass in a custom shader that defines how the reflective view is projected onto the reflector's geometry.\n * @property {boolean} [useDepthTexture=true] - Whether to store depth values in a texture or not.\n **/\n\nexport { ReflectorForSSRPass };\n"],"mappings":"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,KAAK,EAAE,IAAIlC,OAAO,CAAC;IAAE,CAAC;IAClD8H,oCAAoC,EAAE;MAAE5F,KAAK,EAAE,IAAIlC,OAAO,CAAC;IAAE,CAAC;IAC9DoC,UAAU,EAAE;MAAEF,KAAK,EAAE,IAAI7B,OAAO,CAAC;IAAE;EAEpC,CAAC;EAEDiE,YAAY,EAAE,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;EAEHD,cAAc,EAAE,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASxD,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}