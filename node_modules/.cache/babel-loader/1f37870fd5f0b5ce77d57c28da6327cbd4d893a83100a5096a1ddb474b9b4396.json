{"ast":null,"code":"import { Box3, MathUtils, Matrix4, Matrix3, Ray, Vector3 } from 'three';\n\n// module scope helper variables\n\nconst a = {\n  c: null,\n  // center\n  u: [new Vector3(), new Vector3(), new Vector3()],\n  // basis vectors\n  e: [] // half width\n};\nconst b = {\n  c: null,\n  // center\n  u: [new Vector3(), new Vector3(), new Vector3()],\n  // basis vectors\n  e: [] // half width\n};\nconst R = [[], [], []];\nconst AbsR = [[], [], []];\nconst t = [];\nconst xAxis = new Vector3();\nconst yAxis = new Vector3();\nconst zAxis = new Vector3();\nconst v1 = new Vector3();\nconst size = new Vector3();\nconst closestPoint = new Vector3();\nconst rotationMatrix = new Matrix3();\nconst aabb = new Box3();\nconst matrix = new Matrix4();\nconst inverse = new Matrix4();\nconst localRay = new Ray();\n\n/**\n * Represents an oriented bounding box (OBB) in 3D space.\n *\n * @three_import import { OBB } from 'three/addons/math/OBB.js';\n */\nclass OBB {\n  /**\n   * Constructs a new OBB.\n   *\n   * @param {Vector3} [center] - The center of the OBB.\n   * @param {Vector3} [halfSize] - Positive halfwidth extents of the OBB along each axis.\n   * @param {Matrix3} [rotation] - The rotation of the OBB.\n   */\n  constructor(center = new Vector3(), halfSize = new Vector3(), rotation = new Matrix3()) {\n    /**\n     * The center of the OBB.\n     *\n     * @type {Vector3}\n     */\n    this.center = center;\n\n    /**\n     * Positive halfwidth extents of the OBB along each axis.\n     *\n     * @type {Vector3}\n     */\n    this.halfSize = halfSize;\n\n    /**\n     * The rotation of the OBB.\n     *\n     * @type {Matrix3}\n     */\n    this.rotation = rotation;\n  }\n\n  /**\n   * Sets the OBBs components to the given values.\n   *\n   * @param {Vector3} [center] - The center of the OBB.\n   * @param {Vector3} [halfSize] - Positive halfwidth extents of the OBB along each axis.\n   * @param {Matrix3} [rotation] - The rotation of the OBB.\n   * @return {OBB} A reference to this OBB.\n   */\n  set(center, halfSize, rotation) {\n    this.center = center;\n    this.halfSize = halfSize;\n    this.rotation = rotation;\n    return this;\n  }\n\n  /**\n   * Copies the values of the given OBB to this instance.\n   *\n   * @param {OBB} obb - The OBB to copy.\n   * @return {OBB} A reference to this OBB.\n   */\n  copy(obb) {\n    this.center.copy(obb.center);\n    this.halfSize.copy(obb.halfSize);\n    this.rotation.copy(obb.rotation);\n    return this;\n  }\n\n  /**\n   * Returns a new OBB with copied values from this instance.\n   *\n   * @return {OBB} A clone of this instance.\n   */\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  /**\n   * Returns the size of this OBB.\n   *\n   * @param {Vector3} target - The target vector that is used to store the method's result.\n   * @return {Vector3} The size.\n   */\n  getSize(target) {\n    return target.copy(this.halfSize).multiplyScalar(2);\n  }\n\n  /**\n   * Clamps the given point within the bounds of this OBB.\n   *\n   * @param {Vector3} point - The point that should be clamped within the bounds of this OBB.\n   * @param {Vector3} target - The target vector that is used to store the method's result.\n   * @returns {Vector3} - The clamped point.\n   */\n  clampPoint(point, target) {\n    // Reference: Closest Point on OBB to Point in Real-Time Collision Detection\n    // by Christer Ericson (chapter 5.1.4)\n\n    const halfSize = this.halfSize;\n    v1.subVectors(point, this.center);\n    this.rotation.extractBasis(xAxis, yAxis, zAxis);\n\n    // start at the center position of the OBB\n\n    target.copy(this.center);\n\n    // project the target onto the OBB axes and walk towards that point\n\n    const x = MathUtils.clamp(v1.dot(xAxis), -halfSize.x, halfSize.x);\n    target.add(xAxis.multiplyScalar(x));\n    const y = MathUtils.clamp(v1.dot(yAxis), -halfSize.y, halfSize.y);\n    target.add(yAxis.multiplyScalar(y));\n    const z = MathUtils.clamp(v1.dot(zAxis), -halfSize.z, halfSize.z);\n    target.add(zAxis.multiplyScalar(z));\n    return target;\n  }\n\n  /**\n   * Returns `true` if the given point lies within this OBB.\n   *\n   * @param {Vector3} point - The point to test.\n   * @returns {boolean} - Whether the given point lies within this OBB or not.\n   */\n  containsPoint(point) {\n    v1.subVectors(point, this.center);\n    this.rotation.extractBasis(xAxis, yAxis, zAxis);\n\n    // project v1 onto each axis and check if these points lie inside the OBB\n\n    return Math.abs(v1.dot(xAxis)) <= this.halfSize.x && Math.abs(v1.dot(yAxis)) <= this.halfSize.y && Math.abs(v1.dot(zAxis)) <= this.halfSize.z;\n  }\n\n  /**\n   * Returns `true` if the given AABB intersects this OBB.\n   *\n   * @param {Box3} box3 - The AABB to test.\n   * @returns {boolean} - Whether the given AABB intersects this OBB or not.\n   */\n  intersectsBox3(box3) {\n    return this.intersectsOBB(obb.fromBox3(box3));\n  }\n\n  /**\n   * Returns `true` if the given bounding sphere intersects this OBB.\n   *\n   * @param {Sphere} sphere - The bounding sphere to test.\n   * @returns {boolean} - Whether the given bounding sphere intersects this OBB or not.\n   */\n  intersectsSphere(sphere) {\n    // find the point on the OBB closest to the sphere center\n\n    this.clampPoint(sphere.center, closestPoint);\n\n    // if that point is inside the sphere, the OBB and sphere intersect\n\n    return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n  }\n\n  /**\n   * Returns `true` if the given OBB intersects this OBB.\n   *\n   * @param {OBB} obb - The OBB to test.\n   * @param {number} [epsilon=Number.EPSILON] - A small value to prevent arithmetic errors.\n   * @returns {boolean} - Whether the given OBB intersects this OBB or not.\n   */\n  intersectsOBB(obb, epsilon = Number.EPSILON) {\n    // Reference: OBB-OBB Intersection in Real-Time Collision Detection\n    // by Christer Ericson (chapter 4.4.1)\n\n    // prepare data structures (the code uses the same nomenclature like the reference)\n\n    a.c = this.center;\n    a.e[0] = this.halfSize.x;\n    a.e[1] = this.halfSize.y;\n    a.e[2] = this.halfSize.z;\n    this.rotation.extractBasis(a.u[0], a.u[1], a.u[2]);\n    b.c = obb.center;\n    b.e[0] = obb.halfSize.x;\n    b.e[1] = obb.halfSize.y;\n    b.e[2] = obb.halfSize.z;\n    obb.rotation.extractBasis(b.u[0], b.u[1], b.u[2]);\n\n    // compute rotation matrix expressing b in a's coordinate frame\n\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        R[i][j] = a.u[i].dot(b.u[j]);\n      }\n    }\n\n    // compute translation vector\n\n    v1.subVectors(b.c, a.c);\n\n    // bring translation into a's coordinate frame\n\n    t[0] = v1.dot(a.u[0]);\n    t[1] = v1.dot(a.u[1]);\n    t[2] = v1.dot(a.u[2]);\n\n    // compute common subexpressions. Add in an epsilon term to\n    // counteract arithmetic errors when two edges are parallel and\n    // their cross product is (near) null\n\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        AbsR[i][j] = Math.abs(R[i][j]) + epsilon;\n      }\n    }\n    let ra, rb;\n\n    // test axes L = A0, L = A1, L = A2\n\n    for (let i = 0; i < 3; i++) {\n      ra = a.e[i];\n      rb = b.e[0] * AbsR[i][0] + b.e[1] * AbsR[i][1] + b.e[2] * AbsR[i][2];\n      if (Math.abs(t[i]) > ra + rb) return false;\n    }\n\n    // test axes L = B0, L = B1, L = B2\n\n    for (let i = 0; i < 3; i++) {\n      ra = a.e[0] * AbsR[0][i] + a.e[1] * AbsR[1][i] + a.e[2] * AbsR[2][i];\n      rb = b.e[i];\n      if (Math.abs(t[0] * R[0][i] + t[1] * R[1][i] + t[2] * R[2][i]) > ra + rb) return false;\n    }\n\n    // test axis L = A0 x B0\n\n    ra = a.e[1] * AbsR[2][0] + a.e[2] * AbsR[1][0];\n    rb = b.e[1] * AbsR[0][2] + b.e[2] * AbsR[0][1];\n    if (Math.abs(t[2] * R[1][0] - t[1] * R[2][0]) > ra + rb) return false;\n\n    // test axis L = A0 x B1\n\n    ra = a.e[1] * AbsR[2][1] + a.e[2] * AbsR[1][1];\n    rb = b.e[0] * AbsR[0][2] + b.e[2] * AbsR[0][0];\n    if (Math.abs(t[2] * R[1][1] - t[1] * R[2][1]) > ra + rb) return false;\n\n    // test axis L = A0 x B2\n\n    ra = a.e[1] * AbsR[2][2] + a.e[2] * AbsR[1][2];\n    rb = b.e[0] * AbsR[0][1] + b.e[1] * AbsR[0][0];\n    if (Math.abs(t[2] * R[1][2] - t[1] * R[2][2]) > ra + rb) return false;\n\n    // test axis L = A1 x B0\n\n    ra = a.e[0] * AbsR[2][0] + a.e[2] * AbsR[0][0];\n    rb = b.e[1] * AbsR[1][2] + b.e[2] * AbsR[1][1];\n    if (Math.abs(t[0] * R[2][0] - t[2] * R[0][0]) > ra + rb) return false;\n\n    // test axis L = A1 x B1\n\n    ra = a.e[0] * AbsR[2][1] + a.e[2] * AbsR[0][1];\n    rb = b.e[0] * AbsR[1][2] + b.e[2] * AbsR[1][0];\n    if (Math.abs(t[0] * R[2][1] - t[2] * R[0][1]) > ra + rb) return false;\n\n    // test axis L = A1 x B2\n\n    ra = a.e[0] * AbsR[2][2] + a.e[2] * AbsR[0][2];\n    rb = b.e[0] * AbsR[1][1] + b.e[1] * AbsR[1][0];\n    if (Math.abs(t[0] * R[2][2] - t[2] * R[0][2]) > ra + rb) return false;\n\n    // test axis L = A2 x B0\n\n    ra = a.e[0] * AbsR[1][0] + a.e[1] * AbsR[0][0];\n    rb = b.e[1] * AbsR[2][2] + b.e[2] * AbsR[2][1];\n    if (Math.abs(t[1] * R[0][0] - t[0] * R[1][0]) > ra + rb) return false;\n\n    // test axis L = A2 x B1\n\n    ra = a.e[0] * AbsR[1][1] + a.e[1] * AbsR[0][1];\n    rb = b.e[0] * AbsR[2][2] + b.e[2] * AbsR[2][0];\n    if (Math.abs(t[1] * R[0][1] - t[0] * R[1][1]) > ra + rb) return false;\n\n    // test axis L = A2 x B2\n\n    ra = a.e[0] * AbsR[1][2] + a.e[1] * AbsR[0][2];\n    rb = b.e[0] * AbsR[2][1] + b.e[1] * AbsR[2][0];\n    if (Math.abs(t[1] * R[0][2] - t[0] * R[1][2]) > ra + rb) return false;\n\n    // since no separating axis is found, the OBBs must be intersecting\n\n    return true;\n  }\n\n  /**\n   * Returns `true` if the given plane intersects this OBB.\n   *\n   * @param {Plane} plane - The plane to test.\n   * @returns {boolean} Whether the given plane intersects this OBB or not.\n   */\n  intersectsPlane(plane) {\n    // Reference: Testing Box Against Plane in Real-Time Collision Detection\n    // by Christer Ericson (chapter 5.2.3)\n\n    this.rotation.extractBasis(xAxis, yAxis, zAxis);\n\n    // compute the projection interval radius of this OBB onto L(t) = this->center + t * p.normal;\n\n    const r = this.halfSize.x * Math.abs(plane.normal.dot(xAxis)) + this.halfSize.y * Math.abs(plane.normal.dot(yAxis)) + this.halfSize.z * Math.abs(plane.normal.dot(zAxis));\n\n    // compute distance of the OBB's center from the plane\n\n    const d = plane.normal.dot(this.center) - plane.constant;\n\n    // Intersection occurs when distance d falls within [-r,+r] interval\n\n    return Math.abs(d) <= r;\n  }\n\n  /**\n   * Performs a ray/OBB intersection test and stores the intersection point\n   * in the given 3D vector.\n   *\n   * @param {Ray} ray - The ray to test.\n   * @param {Vector3} target - The target vector that is used to store the method's result.\n   * @return {?Vector3} The intersection point. If no intersection is detected, `null` is returned.\n   */\n  intersectRay(ray, target) {\n    // the idea is to perform the intersection test in the local space\n    // of the OBB.\n\n    this.getSize(size);\n    aabb.setFromCenterAndSize(v1.set(0, 0, 0), size);\n\n    // create a 4x4 transformation matrix\n\n    matrix.setFromMatrix3(this.rotation);\n    matrix.setPosition(this.center);\n\n    // transform ray to the local space of the OBB\n\n    inverse.copy(matrix).invert();\n    localRay.copy(ray).applyMatrix4(inverse);\n\n    // perform ray <-> AABB intersection test\n\n    if (localRay.intersectBox(aabb, target)) {\n      // transform the intersection point back to world space\n\n      return target.applyMatrix4(matrix);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Returns `true` if the given ray intersects this OBB.\n   *\n   * @param {Ray} ray - The ray to test.\n   * @returns {boolean} Whether the given ray intersects this OBB or not.\n   */\n  intersectsRay(ray) {\n    return this.intersectRay(ray, v1) !== null;\n  }\n\n  /**\n   * Defines an OBB based on the given AABB.\n   *\n   * @param {Box3} box3 - The AABB to setup the OBB from.\n   * @return {OBB} A reference of this OBB.\n   */\n  fromBox3(box3) {\n    box3.getCenter(this.center);\n    box3.getSize(this.halfSize).multiplyScalar(0.5);\n    this.rotation.identity();\n    return this;\n  }\n\n  /**\n   * Returns `true` if the given OBB is equal to this OBB.\n   *\n   * @param {OBB} obb - The OBB to test.\n   * @returns {boolean} Whether the given OBB is equal to this OBB or not.\n   */\n  equals(obb) {\n    return obb.center.equals(this.center) && obb.halfSize.equals(this.halfSize) && obb.rotation.equals(this.rotation);\n  }\n\n  /**\n   * Applies the given transformation matrix to this OBB. This method can be\n   * used to transform the bounding volume with the world matrix of a 3D object\n   * in order to keep both entities in sync.\n   *\n   * @param {Matrix4} matrix - The matrix to apply.\n   * @return {OBB} A reference of this OBB.\n   */\n  applyMatrix4(matrix) {\n    const e = matrix.elements;\n    let sx = v1.set(e[0], e[1], e[2]).length();\n    const sy = v1.set(e[4], e[5], e[6]).length();\n    const sz = v1.set(e[8], e[9], e[10]).length();\n    const det = matrix.determinant();\n    if (det < 0) sx = -sx;\n    rotationMatrix.setFromMatrix4(matrix);\n    const invSX = 1 / sx;\n    const invSY = 1 / sy;\n    const invSZ = 1 / sz;\n    rotationMatrix.elements[0] *= invSX;\n    rotationMatrix.elements[1] *= invSX;\n    rotationMatrix.elements[2] *= invSX;\n    rotationMatrix.elements[3] *= invSY;\n    rotationMatrix.elements[4] *= invSY;\n    rotationMatrix.elements[5] *= invSY;\n    rotationMatrix.elements[6] *= invSZ;\n    rotationMatrix.elements[7] *= invSZ;\n    rotationMatrix.elements[8] *= invSZ;\n    this.rotation.multiply(rotationMatrix);\n    this.halfSize.x *= sx;\n    this.halfSize.y *= sy;\n    this.halfSize.z *= sz;\n    v1.setFromMatrixPosition(matrix);\n    this.center.add(v1);\n    return this;\n  }\n}\nconst obb = new OBB();\nexport { OBB };","map":{"version":3,"names":["Box3","MathUtils","Matrix4","Matrix3","Ray","Vector3","a","c","u","e","b","R","AbsR","t","xAxis","yAxis","zAxis","v1","size","closestPoint","rotationMatrix","aabb","matrix","inverse","localRay","OBB","constructor","center","halfSize","rotation","set","copy","obb","clone","getSize","target","multiplyScalar","clampPoint","point","subVectors","extractBasis","x","clamp","dot","add","y","z","containsPoint","Math","abs","intersectsBox3","box3","intersectsOBB","fromBox3","intersectsSphere","sphere","distanceToSquared","radius","epsilon","Number","EPSILON","i","j","ra","rb","intersectsPlane","plane","r","normal","d","constant","intersectRay","ray","setFromCenterAndSize","setFromMatrix3","setPosition","invert","applyMatrix4","intersectBox","intersectsRay","getCenter","identity","equals","elements","sx","length","sy","sz","det","determinant","setFromMatrix4","invSX","invSY","invSZ","multiply","setFromMatrixPosition"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/math/OBB.js"],"sourcesContent":["import {\n\tBox3,\n\tMathUtils,\n\tMatrix4,\n\tMatrix3,\n\tRay,\n\tVector3\n} from 'three';\n\n// module scope helper variables\n\nconst a = {\n\tc: null, // center\n\tu: [ new Vector3(), new Vector3(), new Vector3() ], // basis vectors\n\te: [] // half width\n};\n\nconst b = {\n\tc: null, // center\n\tu: [ new Vector3(), new Vector3(), new Vector3() ], // basis vectors\n\te: [] // half width\n};\n\nconst R = [[], [], []];\nconst AbsR = [[], [], []];\nconst t = [];\n\nconst xAxis = new Vector3();\nconst yAxis = new Vector3();\nconst zAxis = new Vector3();\nconst v1 = new Vector3();\nconst size = new Vector3();\nconst closestPoint = new Vector3();\nconst rotationMatrix = new Matrix3();\nconst aabb = new Box3();\nconst matrix = new Matrix4();\nconst inverse = new Matrix4();\nconst localRay = new Ray();\n\n/**\n * Represents an oriented bounding box (OBB) in 3D space.\n *\n * @three_import import { OBB } from 'three/addons/math/OBB.js';\n */\nclass OBB {\n\n\t/**\n\t * Constructs a new OBB.\n\t *\n\t * @param {Vector3} [center] - The center of the OBB.\n\t * @param {Vector3} [halfSize] - Positive halfwidth extents of the OBB along each axis.\n\t * @param {Matrix3} [rotation] - The rotation of the OBB.\n\t */\n\tconstructor( center = new Vector3(), halfSize = new Vector3(), rotation = new Matrix3() ) {\n\n\t\t/**\n\t\t * The center of the OBB.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.center = center;\n\n\t\t/**\n\t\t * Positive halfwidth extents of the OBB along each axis.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.halfSize = halfSize;\n\n\t\t/**\n\t\t * The rotation of the OBB.\n\t\t *\n\t\t * @type {Matrix3}\n\t\t */\n\t\tthis.rotation = rotation;\n\n\t}\n\n\t/**\n\t * Sets the OBBs components to the given values.\n\t *\n\t * @param {Vector3} [center] - The center of the OBB.\n\t * @param {Vector3} [halfSize] - Positive halfwidth extents of the OBB along each axis.\n\t * @param {Matrix3} [rotation] - The rotation of the OBB.\n\t * @return {OBB} A reference to this OBB.\n\t */\n\tset( center, halfSize, rotation ) {\n\n\t\tthis.center = center;\n\t\tthis.halfSize = halfSize;\n\t\tthis.rotation = rotation;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Copies the values of the given OBB to this instance.\n\t *\n\t * @param {OBB} obb - The OBB to copy.\n\t * @return {OBB} A reference to this OBB.\n\t */\n\tcopy( obb ) {\n\n\t\tthis.center.copy( obb.center );\n\t\tthis.halfSize.copy( obb.halfSize );\n\t\tthis.rotation.copy( obb.rotation );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a new OBB with copied values from this instance.\n\t *\n\t * @return {OBB} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\t/**\n\t * Returns the size of this OBB.\n\t *\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3} The size.\n\t */\n\tgetSize( target ) {\n\n\t\treturn target.copy( this.halfSize ).multiplyScalar( 2 );\n\n\t}\n\n\t/**\n\t * Clamps the given point within the bounds of this OBB.\n\t *\n\t * @param {Vector3} point - The point that should be clamped within the bounds of this OBB.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @returns {Vector3} - The clamped point.\n\t */\n\tclampPoint( point, target ) {\n\n\t\t// Reference: Closest Point on OBB to Point in Real-Time Collision Detection\n\t\t// by Christer Ericson (chapter 5.1.4)\n\n\t\tconst halfSize = this.halfSize;\n\n\t\tv1.subVectors( point, this.center );\n\t\tthis.rotation.extractBasis( xAxis, yAxis, zAxis );\n\n\t\t// start at the center position of the OBB\n\n\t\ttarget.copy( this.center );\n\n\t\t// project the target onto the OBB axes and walk towards that point\n\n\t\tconst x = MathUtils.clamp( v1.dot( xAxis ), - halfSize.x, halfSize.x );\n\t\ttarget.add( xAxis.multiplyScalar( x ) );\n\n\t\tconst y = MathUtils.clamp( v1.dot( yAxis ), - halfSize.y, halfSize.y );\n\t\ttarget.add( yAxis.multiplyScalar( y ) );\n\n\t\tconst z = MathUtils.clamp( v1.dot( zAxis ), - halfSize.z, halfSize.z );\n\t\ttarget.add( zAxis.multiplyScalar( z ) );\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given point lies within this OBB.\n\t *\n\t * @param {Vector3} point - The point to test.\n\t * @returns {boolean} - Whether the given point lies within this OBB or not.\n\t */\n\tcontainsPoint( point ) {\n\n\t\tv1.subVectors( point, this.center );\n\t\tthis.rotation.extractBasis( xAxis, yAxis, zAxis );\n\n\t\t// project v1 onto each axis and check if these points lie inside the OBB\n\n\t\treturn Math.abs( v1.dot( xAxis ) ) <= this.halfSize.x &&\n\t\t\t\tMath.abs( v1.dot( yAxis ) ) <= this.halfSize.y &&\n\t\t\t\tMath.abs( v1.dot( zAxis ) ) <= this.halfSize.z;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given AABB intersects this OBB.\n\t *\n\t * @param {Box3} box3 - The AABB to test.\n\t * @returns {boolean} - Whether the given AABB intersects this OBB or not.\n\t */\n\tintersectsBox3( box3 ) {\n\n\t\treturn this.intersectsOBB( obb.fromBox3( box3 ) );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given bounding sphere intersects this OBB.\n\t *\n\t * @param {Sphere} sphere - The bounding sphere to test.\n\t * @returns {boolean} - Whether the given bounding sphere intersects this OBB or not.\n\t */\n\tintersectsSphere( sphere ) {\n\n\t\t// find the point on the OBB closest to the sphere center\n\n\t\tthis.clampPoint( sphere.center, closestPoint );\n\n\t\t// if that point is inside the sphere, the OBB and sphere intersect\n\n\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given OBB intersects this OBB.\n\t *\n\t * @param {OBB} obb - The OBB to test.\n\t * @param {number} [epsilon=Number.EPSILON] - A small value to prevent arithmetic errors.\n\t * @returns {boolean} - Whether the given OBB intersects this OBB or not.\n\t */\n\tintersectsOBB( obb, epsilon = Number.EPSILON ) {\n\n\t\t// Reference: OBB-OBB Intersection in Real-Time Collision Detection\n\t\t// by Christer Ericson (chapter 4.4.1)\n\n\t\t// prepare data structures (the code uses the same nomenclature like the reference)\n\n\t\ta.c = this.center;\n\t\ta.e[ 0 ] = this.halfSize.x;\n\t\ta.e[ 1 ] = this.halfSize.y;\n\t\ta.e[ 2 ] = this.halfSize.z;\n\t\tthis.rotation.extractBasis( a.u[ 0 ], a.u[ 1 ], a.u[ 2 ] );\n\n\t\tb.c = obb.center;\n\t\tb.e[ 0 ] = obb.halfSize.x;\n\t\tb.e[ 1 ] = obb.halfSize.y;\n\t\tb.e[ 2 ] = obb.halfSize.z;\n\t\tobb.rotation.extractBasis( b.u[ 0 ], b.u[ 1 ], b.u[ 2 ] );\n\n\t\t// compute rotation matrix expressing b in a's coordinate frame\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\tR[ i ][ j ] = a.u[ i ].dot( b.u[ j ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute translation vector\n\n\t\tv1.subVectors( b.c, a.c );\n\n\t\t// bring translation into a's coordinate frame\n\n\t\tt[ 0 ] = v1.dot( a.u[ 0 ] );\n\t\tt[ 1 ] = v1.dot( a.u[ 1 ] );\n\t\tt[ 2 ] = v1.dot( a.u[ 2 ] );\n\n\t\t// compute common subexpressions. Add in an epsilon term to\n\t\t// counteract arithmetic errors when two edges are parallel and\n\t\t// their cross product is (near) null\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\tAbsR[ i ][ j ] = Math.abs( R[ i ][ j ] ) + epsilon;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet ra, rb;\n\n\t\t// test axes L = A0, L = A1, L = A2\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tra = a.e[ i ];\n\t\t\trb = b.e[ 0 ] * AbsR[ i ][ 0 ] + b.e[ 1 ] * AbsR[ i ][ 1 ] + b.e[ 2 ] * AbsR[ i ][ 2 ];\n\t\t\tif ( Math.abs( t[ i ] ) > ra + rb ) return false;\n\n\n\t\t}\n\n\t\t// test axes L = B0, L = B1, L = B2\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tra = a.e[ 0 ] * AbsR[ 0 ][ i ] + a.e[ 1 ] * AbsR[ 1 ][ i ] + a.e[ 2 ] * AbsR[ 2 ][ i ];\n\t\t\trb = b.e[ i ];\n\t\t\tif ( Math.abs( t[ 0 ] * R[ 0 ][ i ] + t[ 1 ] * R[ 1 ][ i ] + t[ 2 ] * R[ 2 ][ i ] ) > ra + rb ) return false;\n\n\t\t}\n\n\t\t// test axis L = A0 x B0\n\n\t\tra = a.e[ 1 ] * AbsR[ 2 ][ 0 ] + a.e[ 2 ] * AbsR[ 1 ][ 0 ];\n\t\trb = b.e[ 1 ] * AbsR[ 0 ][ 2 ] + b.e[ 2 ] * AbsR[ 0 ][ 1 ];\n\t\tif ( Math.abs( t[ 2 ] * R[ 1 ][ 0 ] - t[ 1 ] * R[ 2 ][ 0 ] ) > ra + rb ) return false;\n\n\t\t// test axis L = A0 x B1\n\n\t\tra = a.e[ 1 ] * AbsR[ 2 ][ 1 ] + a.e[ 2 ] * AbsR[ 1 ][ 1 ];\n\t\trb = b.e[ 0 ] * AbsR[ 0 ][ 2 ] + b.e[ 2 ] * AbsR[ 0 ][ 0 ];\n\t\tif ( Math.abs( t[ 2 ] * R[ 1 ][ 1 ] - t[ 1 ] * R[ 2 ][ 1 ] ) > ra + rb ) return false;\n\n\t\t// test axis L = A0 x B2\n\n\t\tra = a.e[ 1 ] * AbsR[ 2 ][ 2 ] + a.e[ 2 ] * AbsR[ 1 ][ 2 ];\n\t\trb = b.e[ 0 ] * AbsR[ 0 ][ 1 ] + b.e[ 1 ] * AbsR[ 0 ][ 0 ];\n\t\tif ( Math.abs( t[ 2 ] * R[ 1 ][ 2 ] - t[ 1 ] * R[ 2 ][ 2 ] ) > ra + rb ) return false;\n\n\t\t// test axis L = A1 x B0\n\n\t\tra = a.e[ 0 ] * AbsR[ 2 ][ 0 ] + a.e[ 2 ] * AbsR[ 0 ][ 0 ];\n\t\trb = b.e[ 1 ] * AbsR[ 1 ][ 2 ] + b.e[ 2 ] * AbsR[ 1 ][ 1 ];\n\t\tif ( Math.abs( t[ 0 ] * R[ 2 ][ 0 ] - t[ 2 ] * R[ 0 ][ 0 ] ) > ra + rb ) return false;\n\n\t\t// test axis L = A1 x B1\n\n\t\tra = a.e[ 0 ] * AbsR[ 2 ][ 1 ] + a.e[ 2 ] * AbsR[ 0 ][ 1 ];\n\t\trb = b.e[ 0 ] * AbsR[ 1 ][ 2 ] + b.e[ 2 ] * AbsR[ 1 ][ 0 ];\n\t\tif ( Math.abs( t[ 0 ] * R[ 2 ][ 1 ] - t[ 2 ] * R[ 0 ][ 1 ] ) > ra + rb ) return false;\n\n\t\t// test axis L = A1 x B2\n\n\t\tra = a.e[ 0 ] * AbsR[ 2 ][ 2 ] + a.e[ 2 ] * AbsR[ 0 ][ 2 ];\n\t\trb = b.e[ 0 ] * AbsR[ 1 ][ 1 ] + b.e[ 1 ] * AbsR[ 1 ][ 0 ];\n\t\tif ( Math.abs( t[ 0 ] * R[ 2 ][ 2 ] - t[ 2 ] * R[ 0 ][ 2 ] ) > ra + rb ) return false;\n\n\t\t// test axis L = A2 x B0\n\n\t\tra = a.e[ 0 ] * AbsR[ 1 ][ 0 ] + a.e[ 1 ] * AbsR[ 0 ][ 0 ];\n\t\trb = b.e[ 1 ] * AbsR[ 2 ][ 2 ] + b.e[ 2 ] * AbsR[ 2 ][ 1 ];\n\t\tif ( Math.abs( t[ 1 ] * R[ 0 ][ 0 ] - t[ 0 ] * R[ 1 ][ 0 ] ) > ra + rb ) return false;\n\n\t\t// test axis L = A2 x B1\n\n\t\tra = a.e[ 0 ] * AbsR[ 1 ][ 1 ] + a.e[ 1 ] * AbsR[ 0 ][ 1 ];\n\t\trb = b.e[ 0 ] * AbsR[ 2 ][ 2 ] + b.e[ 2 ] * AbsR[ 2 ][ 0 ];\n\t\tif ( Math.abs( t[ 1 ] * R[ 0 ][ 1 ] - t[ 0 ] * R[ 1 ][ 1 ] ) > ra + rb ) return false;\n\n\t\t// test axis L = A2 x B2\n\n\t\tra = a.e[ 0 ] * AbsR[ 1 ][ 2 ] + a.e[ 1 ] * AbsR[ 0 ][ 2 ];\n\t\trb = b.e[ 0 ] * AbsR[ 2 ][ 1 ] + b.e[ 1 ] * AbsR[ 2 ][ 0 ];\n\t\tif ( Math.abs( t[ 1 ] * R[ 0 ][ 2 ] - t[ 0 ] * R[ 1 ][ 2 ] ) > ra + rb ) return false;\n\n\t\t// since no separating axis is found, the OBBs must be intersecting\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given plane intersects this OBB.\n\t *\n\t * @param {Plane} plane - The plane to test.\n\t * @returns {boolean} Whether the given plane intersects this OBB or not.\n\t */\n\tintersectsPlane( plane ) {\n\n\t\t// Reference: Testing Box Against Plane in Real-Time Collision Detection\n\t\t// by Christer Ericson (chapter 5.2.3)\n\n\t\tthis.rotation.extractBasis( xAxis, yAxis, zAxis );\n\n\t\t// compute the projection interval radius of this OBB onto L(t) = this->center + t * p.normal;\n\n\t\tconst r = this.halfSize.x * Math.abs( plane.normal.dot( xAxis ) ) +\n\t\t\t\tthis.halfSize.y * Math.abs( plane.normal.dot( yAxis ) ) +\n\t\t\t\tthis.halfSize.z * Math.abs( plane.normal.dot( zAxis ) );\n\n\t\t// compute distance of the OBB's center from the plane\n\n\t\tconst d = plane.normal.dot( this.center ) - plane.constant;\n\n\t\t// Intersection occurs when distance d falls within [-r,+r] interval\n\n\t\treturn Math.abs( d ) <= r;\n\n\t}\n\n\t/**\n\t * Performs a ray/OBB intersection test and stores the intersection point\n\t * in the given 3D vector.\n\t *\n\t * @param {Ray} ray - The ray to test.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {?Vector3} The intersection point. If no intersection is detected, `null` is returned.\n\t */\n\tintersectRay( ray, target ) {\n\n\t\t// the idea is to perform the intersection test in the local space\n\t\t// of the OBB.\n\n\t\tthis.getSize( size );\n\t\taabb.setFromCenterAndSize( v1.set( 0, 0, 0 ), size );\n\n\t\t// create a 4x4 transformation matrix\n\n\t\tmatrix.setFromMatrix3( this.rotation );\n\t\tmatrix.setPosition( this.center );\n\n\t\t// transform ray to the local space of the OBB\n\n\t\tinverse.copy( matrix ).invert();\n\t\tlocalRay.copy( ray ).applyMatrix4( inverse );\n\n\t\t// perform ray <-> AABB intersection test\n\n\t\tif ( localRay.intersectBox( aabb, target ) ) {\n\n\t\t\t// transform the intersection point back to world space\n\n\t\t\treturn target.applyMatrix4( matrix );\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` if the given ray intersects this OBB.\n\t *\n\t * @param {Ray} ray - The ray to test.\n\t * @returns {boolean} Whether the given ray intersects this OBB or not.\n\t */\n\tintersectsRay( ray ) {\n\n\t\treturn this.intersectRay( ray, v1 ) !== null;\n\n\t}\n\n\t/**\n\t * Defines an OBB based on the given AABB.\n\t *\n\t * @param {Box3} box3 - The AABB to setup the OBB from.\n\t * @return {OBB} A reference of this OBB.\n\t */\n\tfromBox3( box3 ) {\n\n\t\tbox3.getCenter( this.center );\n\n\t\tbox3.getSize( this.halfSize ).multiplyScalar( 0.5 );\n\n\t\tthis.rotation.identity();\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given OBB is equal to this OBB.\n\t *\n\t * @param {OBB} obb - The OBB to test.\n\t * @returns {boolean} Whether the given OBB is equal to this OBB or not.\n\t */\n\tequals( obb ) {\n\n\t\treturn obb.center.equals( this.center ) &&\n\t\t\tobb.halfSize.equals( this.halfSize ) &&\n\t\t\tobb.rotation.equals( this.rotation );\n\n\t}\n\n\t/**\n\t * Applies the given transformation matrix to this OBB. This method can be\n\t * used to transform the bounding volume with the world matrix of a 3D object\n\t * in order to keep both entities in sync.\n\t *\n\t * @param {Matrix4} matrix - The matrix to apply.\n\t * @return {OBB} A reference of this OBB.\n\t */\n\tapplyMatrix4( matrix ) {\n\n\t\tconst e = matrix.elements;\n\n\t\tlet sx = v1.set( e[ 0 ], e[ 1 ], e[ 2 ] ).length();\n\t\tconst sy = v1.set( e[ 4 ], e[ 5 ], e[ 6 ] ).length();\n\t\tconst sz = v1.set( e[ 8 ], e[ 9 ], e[ 10 ] ).length();\n\n\t\tconst det = matrix.determinant();\n\t\tif ( det < 0 ) sx = - sx;\n\n\t\trotationMatrix.setFromMatrix4( matrix );\n\n\t\tconst invSX = 1 / sx;\n\t\tconst invSY = 1 / sy;\n\t\tconst invSZ = 1 / sz;\n\n\t\trotationMatrix.elements[ 0 ] *= invSX;\n\t\trotationMatrix.elements[ 1 ] *= invSX;\n\t\trotationMatrix.elements[ 2 ] *= invSX;\n\n\t\trotationMatrix.elements[ 3 ] *= invSY;\n\t\trotationMatrix.elements[ 4 ] *= invSY;\n\t\trotationMatrix.elements[ 5 ] *= invSY;\n\n\t\trotationMatrix.elements[ 6 ] *= invSZ;\n\t\trotationMatrix.elements[ 7 ] *= invSZ;\n\t\trotationMatrix.elements[ 8 ] *= invSZ;\n\n\t\tthis.rotation.multiply( rotationMatrix );\n\n\t\tthis.halfSize.x *= sx;\n\t\tthis.halfSize.y *= sy;\n\t\tthis.halfSize.z *= sz;\n\n\t\tv1.setFromMatrixPosition( matrix );\n\t\tthis.center.add( v1 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst obb = new OBB();\n\nexport { OBB };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}