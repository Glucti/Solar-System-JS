{"ast":null,"code":"import { GLTFLoader } from '../loaders/GLTFLoader.js';\nconst DEFAULT_HAND_PROFILE_PATH = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/';\n\n/**\n * Represents one of the hand model types {@link XRHandModelFactory} might produce\n * depending on the selected profile. `XRHandMeshModel` represents a hand with a\n * custom asset.\n *\n * @three_import import { XRHandMeshModel } from 'three/addons/webxr/XRHandMeshModel.js';\n */\nclass XRHandMeshModel {\n  /**\n   * Constructs a new XR hand mesh model.\n   *\n   * @param {XRHandModel} handModel - The hand model.\n   * @param {Group} controller - The WebXR controller.\n   * @param {?string} path - The model path.\n   * @param {XRHandedness} handedness - The handedness of the XR input source.\n   * @param {?Loader} [loader=null] - The loader. If not provided, an instance of `GLTFLoader` will be used to load models.\n   * @param {?Function} [onLoad=null] - A callback that is executed when a controller model has been loaded.\n   */\n  constructor(handModel, controller, path, handedness, loader = null, onLoad = null) {\n    /**\n     * The WebXR controller.\n     *\n     * @type {Group}\n     */\n    this.controller = controller;\n\n    /**\n     * The hand model.\n     *\n     * @type {XRHandModel}\n     */\n    this.handModel = handModel;\n\n    /**\n     * An array of bones representing the bones\n     * of the hand skeleton.\n     *\n     * @type {Array<Bone>}\n     */\n    this.bones = [];\n    if (loader === null) {\n      loader = new GLTFLoader();\n      loader.setPath(path || DEFAULT_HAND_PROFILE_PATH);\n    }\n    loader.load(`${handedness}.glb`, gltf => {\n      const object = gltf.scene.children[0];\n      this.handModel.add(object);\n      const mesh = object.getObjectByProperty('type', 'SkinnedMesh');\n      mesh.frustumCulled = false;\n      mesh.castShadow = true;\n      mesh.receiveShadow = true;\n      const joints = ['wrist', 'thumb-metacarpal', 'thumb-phalanx-proximal', 'thumb-phalanx-distal', 'thumb-tip', 'index-finger-metacarpal', 'index-finger-phalanx-proximal', 'index-finger-phalanx-intermediate', 'index-finger-phalanx-distal', 'index-finger-tip', 'middle-finger-metacarpal', 'middle-finger-phalanx-proximal', 'middle-finger-phalanx-intermediate', 'middle-finger-phalanx-distal', 'middle-finger-tip', 'ring-finger-metacarpal', 'ring-finger-phalanx-proximal', 'ring-finger-phalanx-intermediate', 'ring-finger-phalanx-distal', 'ring-finger-tip', 'pinky-finger-metacarpal', 'pinky-finger-phalanx-proximal', 'pinky-finger-phalanx-intermediate', 'pinky-finger-phalanx-distal', 'pinky-finger-tip'];\n      joints.forEach(jointName => {\n        const bone = object.getObjectByName(jointName);\n        if (bone !== undefined) {\n          bone.jointName = jointName;\n        } else {\n          console.warn(`Couldn't find ${jointName} in ${handedness} hand mesh`);\n        }\n        this.bones.push(bone);\n      });\n      if (onLoad) onLoad(object);\n    });\n  }\n\n  /**\n   * Updates the mesh based on the tracked XR joints data.\n   */\n  updateMesh() {\n    // XR Joints\n    const XRJoints = this.controller.joints;\n    for (let i = 0; i < this.bones.length; i++) {\n      const bone = this.bones[i];\n      if (bone) {\n        const XRJoint = XRJoints[bone.jointName];\n        if (XRJoint.visible) {\n          const position = XRJoint.position;\n          bone.position.copy(position);\n          bone.quaternion.copy(XRJoint.quaternion);\n          // bone.scale.setScalar( XRJoint.jointRadius || defaultRadius );\n        }\n      }\n    }\n  }\n}\nexport { XRHandMeshModel };","map":{"version":3,"names":["GLTFLoader","DEFAULT_HAND_PROFILE_PATH","XRHandMeshModel","constructor","handModel","controller","path","handedness","loader","onLoad","bones","setPath","load","gltf","object","scene","children","add","mesh","getObjectByProperty","frustumCulled","castShadow","receiveShadow","joints","forEach","jointName","bone","getObjectByName","undefined","console","warn","push","updateMesh","XRJoints","i","length","XRJoint","visible","position","copy","quaternion"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/webxr/XRHandMeshModel.js"],"sourcesContent":["import { GLTFLoader } from '../loaders/GLTFLoader.js';\n\nconst DEFAULT_HAND_PROFILE_PATH = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/';\n\n/**\n * Represents one of the hand model types {@link XRHandModelFactory} might produce\n * depending on the selected profile. `XRHandMeshModel` represents a hand with a\n * custom asset.\n *\n * @three_import import { XRHandMeshModel } from 'three/addons/webxr/XRHandMeshModel.js';\n */\nclass XRHandMeshModel {\n\n\t/**\n\t * Constructs a new XR hand mesh model.\n\t *\n\t * @param {XRHandModel} handModel - The hand model.\n\t * @param {Group} controller - The WebXR controller.\n\t * @param {?string} path - The model path.\n\t * @param {XRHandedness} handedness - The handedness of the XR input source.\n\t * @param {?Loader} [loader=null] - The loader. If not provided, an instance of `GLTFLoader` will be used to load models.\n\t * @param {?Function} [onLoad=null] - A callback that is executed when a controller model has been loaded.\n\t */\n\tconstructor( handModel, controller, path, handedness, loader = null, onLoad = null ) {\n\n\t\t/**\n\t\t * The WebXR controller.\n\t\t *\n\t\t * @type {Group}\n\t\t */\n\t\tthis.controller = controller;\n\n\t\t/**\n\t\t * The hand model.\n\t\t *\n\t\t * @type {XRHandModel}\n\t\t */\n\t\tthis.handModel = handModel;\n\n\t\t/**\n\t\t * An array of bones representing the bones\n\t\t * of the hand skeleton.\n\t\t *\n\t\t * @type {Array<Bone>}\n\t\t */\n\t\tthis.bones = [];\n\n\t\tif ( loader === null ) {\n\n\t\t\tloader = new GLTFLoader();\n\t\t\tloader.setPath( path || DEFAULT_HAND_PROFILE_PATH );\n\n\t\t}\n\n\t\tloader.load( `${handedness}.glb`, gltf => {\n\n\t\t\tconst object = gltf.scene.children[ 0 ];\n\t\t\tthis.handModel.add( object );\n\n\t\t\tconst mesh = object.getObjectByProperty( 'type', 'SkinnedMesh' );\n\t\t\tmesh.frustumCulled = false;\n\t\t\tmesh.castShadow = true;\n\t\t\tmesh.receiveShadow = true;\n\n\t\t\tconst joints = [\n\t\t\t\t'wrist',\n\t\t\t\t'thumb-metacarpal',\n\t\t\t\t'thumb-phalanx-proximal',\n\t\t\t\t'thumb-phalanx-distal',\n\t\t\t\t'thumb-tip',\n\t\t\t\t'index-finger-metacarpal',\n\t\t\t\t'index-finger-phalanx-proximal',\n\t\t\t\t'index-finger-phalanx-intermediate',\n\t\t\t\t'index-finger-phalanx-distal',\n\t\t\t\t'index-finger-tip',\n\t\t\t\t'middle-finger-metacarpal',\n\t\t\t\t'middle-finger-phalanx-proximal',\n\t\t\t\t'middle-finger-phalanx-intermediate',\n\t\t\t\t'middle-finger-phalanx-distal',\n\t\t\t\t'middle-finger-tip',\n\t\t\t\t'ring-finger-metacarpal',\n\t\t\t\t'ring-finger-phalanx-proximal',\n\t\t\t\t'ring-finger-phalanx-intermediate',\n\t\t\t\t'ring-finger-phalanx-distal',\n\t\t\t\t'ring-finger-tip',\n\t\t\t\t'pinky-finger-metacarpal',\n\t\t\t\t'pinky-finger-phalanx-proximal',\n\t\t\t\t'pinky-finger-phalanx-intermediate',\n\t\t\t\t'pinky-finger-phalanx-distal',\n\t\t\t\t'pinky-finger-tip',\n\t\t\t];\n\n\t\t\tjoints.forEach( jointName => {\n\n\t\t\t\tconst bone = object.getObjectByName( jointName );\n\n\t\t\t\tif ( bone !== undefined ) {\n\n\t\t\t\t\tbone.jointName = jointName;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( `Couldn't find ${jointName} in ${handedness} hand mesh` );\n\n\t\t\t\t}\n\n\t\t\t\tthis.bones.push( bone );\n\n\t\t\t} );\n\n\t\t\tif ( onLoad ) onLoad( object );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Updates the mesh based on the tracked XR joints data.\n\t */\n\tupdateMesh() {\n\n\t\t// XR Joints\n\t\tconst XRJoints = this.controller.joints;\n\n\t\tfor ( let i = 0; i < this.bones.length; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tconst XRJoint = XRJoints[ bone.jointName ];\n\n\t\t\t\tif ( XRJoint.visible ) {\n\n\t\t\t\t\tconst position = XRJoint.position;\n\n\t\t\t\t\tbone.position.copy( position );\n\t\t\t\t\tbone.quaternion.copy( XRJoint.quaternion );\n\t\t\t\t\t// bone.scale.setScalar( XRJoint.jointRadius || defaultRadius );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexport { XRHandMeshModel };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}