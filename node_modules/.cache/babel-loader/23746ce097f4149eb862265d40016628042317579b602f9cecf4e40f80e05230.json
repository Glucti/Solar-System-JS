{"ast":null,"code":"import { AnimationClip, BufferAttribute, FileLoader, Loader, NumberKeyframeTrack } from 'three';\n\n/**\n * A loader for the MDD format.\n *\n * MDD stores a position for every vertex in a model for every frame in an animation.\n * Similar to BVH, it can be used to transfer animation data between different 3D applications or engines.\n *\n * MDD stores its data in binary format (big endian) in the following way:\n *\n * - number of frames (a single uint32)\n * - number of vertices (a single uint32)\n * - time values for each frame (sequence of float32)\n * - vertex data for each frame (sequence of float32)\n *\n * ```js\n * const loader = new MDDLoader();\n * const result = await loader.loadAsync( 'models/mdd/cube.mdd' );\n *\n * const morphTargets = result.morphTargets;\n * const clip = result.clip;\n * // clip.optimize(); // optional\n *\n * const geometry = new THREE.BoxGeometry();\n * geometry.morphAttributes.position = morphTargets; // apply morph targets (vertex data must match)\n *\n * const material = new THREE.MeshBasicMaterial();\n *\n * const mesh = new THREE.Mesh( geometry, material );\n * scene.add( mesh );\n *\n * const mixer = new THREE.AnimationMixer( mesh );\n * mixer.clipAction( clip ).play();\n * ```\n *\n * @augments Loader\n * @three_import import { MDDLoader } from 'three/addons/loaders/MDDLoader.js';\n */\nclass MDDLoader extends Loader {\n  /**\n   * Constructs a new MDD loader.\n   *\n   * @param {LoadingManager} [manager] - The loading manager.\n   */\n  constructor(manager) {\n    super(manager);\n  }\n\n  /**\n   * Starts loading from the given URL and passes the loaded MDD asset\n   * to the `onLoad()` callback.\n   *\n   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n   * @param {function({clip:AnimationClip, morphTargets:Array<BufferAttribute>})} onLoad - Executed when the loading process has been finished.\n   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n   * @param {onErrorCallback} onError - Executed when errors occur.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.load(url, function (data) {\n      onLoad(scope.parse(data));\n    }, onProgress, onError);\n  }\n\n  /**\n   * Parses the given MDD data and returns an object holding the animation clip and the respective\n   * morph targets.\n   *\n   * @param {ArrayBuffer} data - The raw XYZ data as an array buffer.\n   * @return {{clip:AnimationClip, morphTargets:Array<BufferAttribute>}} The result object.\n   */\n  parse(data) {\n    const view = new DataView(data);\n    const totalFrames = view.getUint32(0);\n    const totalPoints = view.getUint32(4);\n    let offset = 8;\n\n    // animation clip\n\n    const times = new Float32Array(totalFrames);\n    const values = new Float32Array(totalFrames * totalFrames).fill(0);\n    for (let i = 0; i < totalFrames; i++) {\n      times[i] = view.getFloat32(offset);\n      offset += 4;\n      values[totalFrames * i + i] = 1;\n    }\n    const track = new NumberKeyframeTrack('.morphTargetInfluences', times, values);\n    const clip = new AnimationClip('default', times[times.length - 1], [track]);\n\n    // morph targets\n\n    const morphTargets = [];\n    for (let i = 0; i < totalFrames; i++) {\n      const morphTarget = new Float32Array(totalPoints * 3);\n      for (let j = 0; j < totalPoints; j++) {\n        const stride = j * 3;\n        morphTarget[stride + 0] = view.getFloat32(offset);\n        offset += 4; // x\n        morphTarget[stride + 1] = view.getFloat32(offset);\n        offset += 4; // y\n        morphTarget[stride + 2] = view.getFloat32(offset);\n        offset += 4; // z\n      }\n      const attribute = new BufferAttribute(morphTarget, 3);\n      attribute.name = 'morph_' + i;\n      morphTargets.push(attribute);\n    }\n    return {\n      morphTargets: morphTargets,\n      clip: clip\n    };\n  }\n}\nexport { MDDLoader };","map":{"version":3,"names":["AnimationClip","BufferAttribute","FileLoader","Loader","NumberKeyframeTrack","MDDLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","data","parse","view","DataView","totalFrames","getUint32","totalPoints","offset","times","Float32Array","values","fill","i","getFloat32","track","clip","length","morphTargets","morphTarget","j","stride","attribute","name","push"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/loaders/MDDLoader.js"],"sourcesContent":["import {\n\tAnimationClip,\n\tBufferAttribute,\n\tFileLoader,\n\tLoader,\n\tNumberKeyframeTrack\n} from 'three';\n\n/**\n * A loader for the MDD format.\n *\n * MDD stores a position for every vertex in a model for every frame in an animation.\n * Similar to BVH, it can be used to transfer animation data between different 3D applications or engines.\n *\n * MDD stores its data in binary format (big endian) in the following way:\n *\n * - number of frames (a single uint32)\n * - number of vertices (a single uint32)\n * - time values for each frame (sequence of float32)\n * - vertex data for each frame (sequence of float32)\n *\n * ```js\n * const loader = new MDDLoader();\n * const result = await loader.loadAsync( 'models/mdd/cube.mdd' );\n *\n * const morphTargets = result.morphTargets;\n * const clip = result.clip;\n * // clip.optimize(); // optional\n *\n * const geometry = new THREE.BoxGeometry();\n * geometry.morphAttributes.position = morphTargets; // apply morph targets (vertex data must match)\n *\n * const material = new THREE.MeshBasicMaterial();\n *\n * const mesh = new THREE.Mesh( geometry, material );\n * scene.add( mesh );\n *\n * const mixer = new THREE.AnimationMixer( mesh );\n * mixer.clipAction( clip ).play();\n * ```\n *\n * @augments Loader\n * @three_import import { MDDLoader } from 'three/addons/loaders/MDDLoader.js';\n */\nclass MDDLoader extends Loader {\n\n\t/**\n\t * Constructs a new MDD loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded MDD asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function({clip:AnimationClip, morphTargets:Array<BufferAttribute>})} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.load( url, function ( data ) {\n\n\t\t\tonLoad( scope.parse( data ) );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given MDD data and returns an object holding the animation clip and the respective\n\t * morph targets.\n\t *\n\t * @param {ArrayBuffer} data - The raw XYZ data as an array buffer.\n\t * @return {{clip:AnimationClip, morphTargets:Array<BufferAttribute>}} The result object.\n\t */\n\tparse( data ) {\n\n\t\tconst view = new DataView( data );\n\n\t\tconst totalFrames = view.getUint32( 0 );\n\t\tconst totalPoints = view.getUint32( 4 );\n\n\t\tlet offset = 8;\n\n\t\t// animation clip\n\n\t\tconst times = new Float32Array( totalFrames );\n\t\tconst values = new Float32Array( totalFrames * totalFrames ).fill( 0 );\n\n\t\tfor ( let i = 0; i < totalFrames; i ++ ) {\n\n\t\t\ttimes[ i ] = view.getFloat32( offset ); offset += 4;\n\t\t\tvalues[ ( totalFrames * i ) + i ] = 1;\n\n\t\t}\n\n\t\tconst track = new NumberKeyframeTrack( '.morphTargetInfluences', times, values );\n\t\tconst clip = new AnimationClip( 'default', times[ times.length - 1 ], [ track ] );\n\n\t\t// morph targets\n\n\t\tconst morphTargets = [];\n\n\t\tfor ( let i = 0; i < totalFrames; i ++ ) {\n\n\t\t\tconst morphTarget = new Float32Array( totalPoints * 3 );\n\n\t\t\tfor ( let j = 0; j < totalPoints; j ++ ) {\n\n\t\t\t\tconst stride = ( j * 3 );\n\n\t\t\t\tmorphTarget[ stride + 0 ] = view.getFloat32( offset ); offset += 4; // x\n\t\t\t\tmorphTarget[ stride + 1 ] = view.getFloat32( offset ); offset += 4; // y\n\t\t\t\tmorphTarget[ stride + 2 ] = view.getFloat32( offset ); offset += 4; // z\n\n\t\t\t}\n\n\t\t\tconst attribute = new BufferAttribute( morphTarget, 3 );\n\t\t\tattribute.name = 'morph_' + i;\n\n\t\t\tmorphTargets.push( attribute );\n\n\t\t}\n\n\t\treturn {\n\t\t\tmorphTargets: morphTargets,\n\t\t\tclip: clip\n\t\t};\n\n\t}\n\n}\n\nexport { MDDLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}