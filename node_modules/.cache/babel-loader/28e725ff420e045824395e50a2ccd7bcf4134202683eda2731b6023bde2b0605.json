{"ast":null,"code":"import { AnimationClip, Bone, FileLoader, Loader, Quaternion, QuaternionKeyframeTrack, Skeleton, Vector3, VectorKeyframeTrack } from 'three';\n\n/**\n * A loader for the BVH format.\n *\n * Imports BVH files and outputs a single {@link Skeleton} and {@link AnimationClip}.\n * The loader only supports BVH files containing a single root right now.\n *\n * ```js\n * const loader = new BVHLoader();\n * const result = await loader.loadAsync( 'models/bvh/pirouette.bvh' );\n *\n * // visualize skeleton\n * const skeletonHelper = new THREE.SkeletonHelper( result.skeleton.bones[ 0 ] );\n * scene.add( result.skeleton.bones[ 0 ] );\n * scene.add( skeletonHelper );\n *\n * // play animation clip\n * mixer = new THREE.AnimationMixer( result.skeleton.bones[ 0 ] );\n * mixer.clipAction( result.clip ).play();\n * ```\n *\n * @augments Loader\n * @three_import import { BVHLoader } from 'three/addons/loaders/BVHLoader.js';\n */\nclass BVHLoader extends Loader {\n  /**\n   * Constructs a new BVH loader.\n   *\n   * @param {LoadingManager} [manager] - The loading manager.\n   */\n  constructor(manager) {\n    super(manager);\n\n    /**\n     * Whether to animate bone positions or not.\n     *\n     * @type {boolean}\n     * @default true\n     */\n    this.animateBonePositions = true;\n\n    /**\n     * Whether to animate bone rotations or not.\n     *\n     * @type {boolean}\n     * @default true\n     */\n    this.animateBoneRotations = true;\n  }\n\n  /**\n   * Starts loading from the given URL and passes the loaded BVH asset\n   * to the `onLoad()` callback.\n   *\n   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n   * @param {function({skeleton:Skeleton,clip:AnimationClip})} onLoad - Executed when the loading process has been finished.\n   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n   * @param {onErrorCallback} onError - Executed when errors occur.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  /**\n   * Parses the given BVH data and returns the resulting data.\n   *\n   * @param {string} text - The raw BVH data as a string.\n   * @return {{skeleton:Skeleton,clip:AnimationClip}} An object representing the parsed asset.\n   */\n  parse(text) {\n    // reads a string array (lines) from a BVH file\n    // and outputs a skeleton structure including motion data\n\n    // returns thee root node:\n    // { name: '', channels: [], children: [] }\n    function readBvh(lines) {\n      // read model structure\n\n      if (nextLine(lines) !== 'HIERARCHY') {\n        console.error('THREE.BVHLoader: HIERARCHY expected.');\n      }\n      const list = []; // collects flat array of all bones\n      const root = readNode(lines, nextLine(lines), list);\n\n      // read motion data\n\n      if (nextLine(lines) !== 'MOTION') {\n        console.error('THREE.BVHLoader: MOTION expected.');\n      }\n\n      // number of frames\n\n      let tokens = nextLine(lines).split(/[\\s]+/);\n      const numFrames = parseInt(tokens[1]);\n      if (isNaN(numFrames)) {\n        console.error('THREE.BVHLoader: Failed to read number of frames.');\n      }\n\n      // frame time\n\n      tokens = nextLine(lines).split(/[\\s]+/);\n      const frameTime = parseFloat(tokens[2]);\n      if (isNaN(frameTime)) {\n        console.error('THREE.BVHLoader: Failed to read frame time.');\n      }\n\n      // read frame data line by line\n\n      for (let i = 0; i < numFrames; i++) {\n        tokens = nextLine(lines).split(/[\\s]+/);\n        readFrameData(tokens, i * frameTime, root);\n      }\n      return list;\n    }\n\n    /*\n    \tRecursively reads data from a single frame into the bone hierarchy.\n    \tThe passed bone hierarchy has to be structured in the same order as the BVH file.\n    \tkeyframe data is stored in bone.frames.\n    \t\t- data: splitted string array (frame values), values are shift()ed so\n    \tthis should be empty after parsing the whole hierarchy.\n    \t- frameTime: playback time for this keyframe.\n    \t- bone: the bone to read frame data from.\n    */\n    function readFrameData(data, frameTime, bone) {\n      // end sites have no motion data\n\n      if (bone.type === 'ENDSITE') return;\n\n      // add keyframe\n\n      const keyframe = {\n        time: frameTime,\n        position: new Vector3(),\n        rotation: new Quaternion()\n      };\n      bone.frames.push(keyframe);\n      const quat = new Quaternion();\n      const vx = new Vector3(1, 0, 0);\n      const vy = new Vector3(0, 1, 0);\n      const vz = new Vector3(0, 0, 1);\n\n      // parse values for each channel in node\n\n      for (let i = 0; i < bone.channels.length; i++) {\n        switch (bone.channels[i]) {\n          case 'Xposition':\n            keyframe.position.x = parseFloat(data.shift().trim());\n            break;\n          case 'Yposition':\n            keyframe.position.y = parseFloat(data.shift().trim());\n            break;\n          case 'Zposition':\n            keyframe.position.z = parseFloat(data.shift().trim());\n            break;\n          case 'Xrotation':\n            quat.setFromAxisAngle(vx, parseFloat(data.shift().trim()) * Math.PI / 180);\n            keyframe.rotation.multiply(quat);\n            break;\n          case 'Yrotation':\n            quat.setFromAxisAngle(vy, parseFloat(data.shift().trim()) * Math.PI / 180);\n            keyframe.rotation.multiply(quat);\n            break;\n          case 'Zrotation':\n            quat.setFromAxisAngle(vz, parseFloat(data.shift().trim()) * Math.PI / 180);\n            keyframe.rotation.multiply(quat);\n            break;\n          default:\n            console.warn('THREE.BVHLoader: Invalid channel type.');\n        }\n      }\n\n      // parse child nodes\n\n      for (let i = 0; i < bone.children.length; i++) {\n        readFrameData(data, frameTime, bone.children[i]);\n      }\n    }\n\n    /*\n     Recursively parses the HIERARCHY section of the BVH file\n    \t - lines: all lines of the file. lines are consumed as we go along.\n     - firstline: line containing the node type and name e.g. 'JOINT hip'\n     - list: collects a flat list of nodes\n    \t returns: a BVH node including children\n    */\n    function readNode(lines, firstline, list) {\n      const node = {\n        name: '',\n        type: '',\n        frames: []\n      };\n      list.push(node);\n\n      // parse node type and name\n\n      let tokens = firstline.split(/[\\s]+/);\n      if (tokens[0].toUpperCase() === 'END' && tokens[1].toUpperCase() === 'SITE') {\n        node.type = 'ENDSITE';\n        node.name = 'ENDSITE'; // bvh end sites have no name\n      } else {\n        node.name = tokens[1];\n        node.type = tokens[0].toUpperCase();\n      }\n      if (nextLine(lines) !== '{') {\n        console.error('THREE.BVHLoader: Expected opening { after type & name');\n      }\n\n      // parse OFFSET\n\n      tokens = nextLine(lines).split(/[\\s]+/);\n      if (tokens[0] !== 'OFFSET') {\n        console.error('THREE.BVHLoader: Expected OFFSET but got: ' + tokens[0]);\n      }\n      if (tokens.length !== 4) {\n        console.error('THREE.BVHLoader: Invalid number of values for OFFSET.');\n      }\n      const offset = new Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));\n      if (isNaN(offset.x) || isNaN(offset.y) || isNaN(offset.z)) {\n        console.error('THREE.BVHLoader: Invalid values of OFFSET.');\n      }\n      node.offset = offset;\n\n      // parse CHANNELS definitions\n\n      if (node.type !== 'ENDSITE') {\n        tokens = nextLine(lines).split(/[\\s]+/);\n        if (tokens[0] !== 'CHANNELS') {\n          console.error('THREE.BVHLoader: Expected CHANNELS definition.');\n        }\n        const numChannels = parseInt(tokens[1]);\n        node.channels = tokens.splice(2, numChannels);\n        node.children = [];\n      }\n\n      // read children\n\n      while (true) {\n        const line = nextLine(lines);\n        if (line === '}') {\n          return node;\n        } else {\n          node.children.push(readNode(lines, line, list));\n        }\n      }\n    }\n\n    /*\n    \trecursively converts the internal bvh node structure to a Bone hierarchy\n    \t\tsource: the bvh root node\n    \tlist: pass an empty array, collects a flat list of all converted THREE.Bones\n    \t\treturns the root Bone\n    */\n    function toTHREEBone(source, list) {\n      const bone = new Bone();\n      list.push(bone);\n      bone.position.add(source.offset);\n      bone.name = source.name;\n      if (source.type !== 'ENDSITE') {\n        for (let i = 0; i < source.children.length; i++) {\n          bone.add(toTHREEBone(source.children[i], list));\n        }\n      }\n      return bone;\n    }\n\n    /*\n    \tbuilds an AnimationClip from the keyframe data saved in each bone.\n    \t\tbone: bvh root node\n    \t\treturns: an AnimationClip containing position and quaternion tracks\n    */\n    function toTHREEAnimation(bones) {\n      const tracks = [];\n\n      // create a position and quaternion animation track for each node\n\n      for (let i = 0; i < bones.length; i++) {\n        const bone = bones[i];\n        if (bone.type === 'ENDSITE') continue;\n\n        // track data\n\n        const times = [];\n        const positions = [];\n        const rotations = [];\n        for (let j = 0; j < bone.frames.length; j++) {\n          const frame = bone.frames[j];\n          times.push(frame.time);\n\n          // the animation system animates the position property,\n          // so we have to add the joint offset to all values\n\n          positions.push(frame.position.x + bone.offset.x);\n          positions.push(frame.position.y + bone.offset.y);\n          positions.push(frame.position.z + bone.offset.z);\n          rotations.push(frame.rotation.x);\n          rotations.push(frame.rotation.y);\n          rotations.push(frame.rotation.z);\n          rotations.push(frame.rotation.w);\n        }\n        if (scope.animateBonePositions) {\n          tracks.push(new VectorKeyframeTrack(bone.name + '.position', times, positions));\n        }\n        if (scope.animateBoneRotations) {\n          tracks.push(new QuaternionKeyframeTrack(bone.name + '.quaternion', times, rotations));\n        }\n      }\n      return new AnimationClip('animation', -1, tracks);\n    }\n\n    /*\n    \treturns the next non-empty line in lines\n    */\n    function nextLine(lines) {\n      let line;\n      // skip empty lines\n      while ((line = lines.shift().trim()).length === 0) {}\n      return line;\n    }\n    const scope = this;\n    const lines = text.split(/[\\r\\n]+/g);\n    const bones = readBvh(lines);\n    const threeBones = [];\n    toTHREEBone(bones[0], threeBones);\n    const threeClip = toTHREEAnimation(bones);\n    return {\n      skeleton: new Skeleton(threeBones),\n      clip: threeClip\n    };\n  }\n}\nexport { BVHLoader };","map":{"version":3,"names":["AnimationClip","Bone","FileLoader","Loader","Quaternion","QuaternionKeyframeTrack","Skeleton","Vector3","VectorKeyframeTrack","BVHLoader","constructor","manager","animateBonePositions","animateBoneRotations","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","readBvh","lines","nextLine","list","root","readNode","tokens","split","numFrames","parseInt","isNaN","frameTime","parseFloat","i","readFrameData","data","bone","type","keyframe","time","position","rotation","frames","push","quat","vx","vy","vz","channels","length","x","shift","trim","y","z","setFromAxisAngle","Math","PI","multiply","warn","children","firstline","node","name","toUpperCase","offset","numChannels","splice","line","toTHREEBone","source","add","toTHREEAnimation","bones","tracks","times","positions","rotations","j","frame","w","threeBones","threeClip","skeleton","clip"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/loaders/BVHLoader.js"],"sourcesContent":["import {\n\tAnimationClip,\n\tBone,\n\tFileLoader,\n\tLoader,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tSkeleton,\n\tVector3,\n\tVectorKeyframeTrack\n} from 'three';\n\n/**\n * A loader for the BVH format.\n *\n * Imports BVH files and outputs a single {@link Skeleton} and {@link AnimationClip}.\n * The loader only supports BVH files containing a single root right now.\n *\n * ```js\n * const loader = new BVHLoader();\n * const result = await loader.loadAsync( 'models/bvh/pirouette.bvh' );\n *\n * // visualize skeleton\n * const skeletonHelper = new THREE.SkeletonHelper( result.skeleton.bones[ 0 ] );\n * scene.add( result.skeleton.bones[ 0 ] );\n * scene.add( skeletonHelper );\n *\n * // play animation clip\n * mixer = new THREE.AnimationMixer( result.skeleton.bones[ 0 ] );\n * mixer.clipAction( result.clip ).play();\n * ```\n *\n * @augments Loader\n * @three_import import { BVHLoader } from 'three/addons/loaders/BVHLoader.js';\n */\nclass BVHLoader extends Loader {\n\n\t/**\n\t * Constructs a new BVH loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * Whether to animate bone positions or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.animateBonePositions = true;\n\n\t\t/**\n\t\t * Whether to animate bone rotations or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.animateBoneRotations = true;\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded BVH asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function({skeleton:Skeleton,clip:AnimationClip})} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given BVH data and returns the resulting data.\n\t *\n\t * @param {string} text - The raw BVH data as a string.\n\t * @return {{skeleton:Skeleton,clip:AnimationClip}} An object representing the parsed asset.\n\t */\n\tparse( text ) {\n\n\t\t// reads a string array (lines) from a BVH file\n\t\t// and outputs a skeleton structure including motion data\n\n\t\t// returns thee root node:\n\t\t// { name: '', channels: [], children: [] }\n\t\tfunction readBvh( lines ) {\n\n\t\t\t// read model structure\n\n\t\t\tif ( nextLine( lines ) !== 'HIERARCHY' ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: HIERARCHY expected.' );\n\n\t\t\t}\n\n\t\t\tconst list = []; // collects flat array of all bones\n\t\t\tconst root = readNode( lines, nextLine( lines ), list );\n\n\t\t\t// read motion data\n\n\t\t\tif ( nextLine( lines ) !== 'MOTION' ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: MOTION expected.' );\n\n\t\t\t}\n\n\t\t\t// number of frames\n\n\t\t\tlet tokens = nextLine( lines ).split( /[\\s]+/ );\n\t\t\tconst numFrames = parseInt( tokens[ 1 ] );\n\n\t\t\tif ( isNaN( numFrames ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: Failed to read number of frames.' );\n\n\t\t\t}\n\n\t\t\t// frame time\n\n\t\t\ttokens = nextLine( lines ).split( /[\\s]+/ );\n\t\t\tconst frameTime = parseFloat( tokens[ 2 ] );\n\n\t\t\tif ( isNaN( frameTime ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: Failed to read frame time.' );\n\n\t\t\t}\n\n\t\t\t// read frame data line by line\n\n\t\t\tfor ( let i = 0; i < numFrames; i ++ ) {\n\n\t\t\t\ttokens = nextLine( lines ).split( /[\\s]+/ );\n\t\t\t\treadFrameData( tokens, i * frameTime, root );\n\n\t\t\t}\n\n\t\t\treturn list;\n\n\t\t}\n\n\t\t/*\n\t\t\tRecursively reads data from a single frame into the bone hierarchy.\n\t\t\tThe passed bone hierarchy has to be structured in the same order as the BVH file.\n\t\t\tkeyframe data is stored in bone.frames.\n\n\t\t\t- data: splitted string array (frame values), values are shift()ed so\n\t\t\tthis should be empty after parsing the whole hierarchy.\n\t\t\t- frameTime: playback time for this keyframe.\n\t\t\t- bone: the bone to read frame data from.\n\t\t*/\n\t\tfunction readFrameData( data, frameTime, bone ) {\n\n\t\t\t// end sites have no motion data\n\n\t\t\tif ( bone.type === 'ENDSITE' ) return;\n\n\t\t\t// add keyframe\n\n\t\t\tconst keyframe = {\n\t\t\t\ttime: frameTime,\n\t\t\t\tposition: new Vector3(),\n\t\t\t\trotation: new Quaternion()\n\t\t\t};\n\n\t\t\tbone.frames.push( keyframe );\n\n\t\t\tconst quat = new Quaternion();\n\n\t\t\tconst vx = new Vector3( 1, 0, 0 );\n\t\t\tconst vy = new Vector3( 0, 1, 0 );\n\t\t\tconst vz = new Vector3( 0, 0, 1 );\n\n\t\t\t// parse values for each channel in node\n\n\t\t\tfor ( let i = 0; i < bone.channels.length; i ++ ) {\n\n\t\t\t\tswitch ( bone.channels[ i ] ) {\n\n\t\t\t\t\tcase 'Xposition':\n\t\t\t\t\t\tkeyframe.position.x = parseFloat( data.shift().trim() );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Yposition':\n\t\t\t\t\t\tkeyframe.position.y = parseFloat( data.shift().trim() );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Zposition':\n\t\t\t\t\t\tkeyframe.position.z = parseFloat( data.shift().trim() );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Xrotation':\n\t\t\t\t\t\tquat.setFromAxisAngle( vx, parseFloat( data.shift().trim() ) * Math.PI / 180 );\n\t\t\t\t\t\tkeyframe.rotation.multiply( quat );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Yrotation':\n\t\t\t\t\t\tquat.setFromAxisAngle( vy, parseFloat( data.shift().trim() ) * Math.PI / 180 );\n\t\t\t\t\t\tkeyframe.rotation.multiply( quat );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Zrotation':\n\t\t\t\t\t\tquat.setFromAxisAngle( vz, parseFloat( data.shift().trim() ) * Math.PI / 180 );\n\t\t\t\t\t\tkeyframe.rotation.multiply( quat );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.BVHLoader: Invalid channel type.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// parse child nodes\n\n\t\t\tfor ( let i = 0; i < bone.children.length; i ++ ) {\n\n\t\t\t\treadFrameData( data, frameTime, bone.children[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/*\n\t\t Recursively parses the HIERARCHY section of the BVH file\n\n\t\t - lines: all lines of the file. lines are consumed as we go along.\n\t\t - firstline: line containing the node type and name e.g. 'JOINT hip'\n\t\t - list: collects a flat list of nodes\n\n\t\t returns: a BVH node including children\n\t\t*/\n\t\tfunction readNode( lines, firstline, list ) {\n\n\t\t\tconst node = { name: '', type: '', frames: [] };\n\t\t\tlist.push( node );\n\n\t\t\t// parse node type and name\n\n\t\t\tlet tokens = firstline.split( /[\\s]+/ );\n\n\t\t\tif ( tokens[ 0 ].toUpperCase() === 'END' && tokens[ 1 ].toUpperCase() === 'SITE' ) {\n\n\t\t\t\tnode.type = 'ENDSITE';\n\t\t\t\tnode.name = 'ENDSITE'; // bvh end sites have no name\n\n\t\t\t} else {\n\n\t\t\t\tnode.name = tokens[ 1 ];\n\t\t\t\tnode.type = tokens[ 0 ].toUpperCase();\n\n\t\t\t}\n\n\t\t\tif ( nextLine( lines ) !== '{' ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: Expected opening { after type & name' );\n\n\t\t\t}\n\n\t\t\t// parse OFFSET\n\n\t\t\ttokens = nextLine( lines ).split( /[\\s]+/ );\n\n\t\t\tif ( tokens[ 0 ] !== 'OFFSET' ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: Expected OFFSET but got: ' + tokens[ 0 ] );\n\n\t\t\t}\n\n\t\t\tif ( tokens.length !== 4 ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: Invalid number of values for OFFSET.' );\n\n\t\t\t}\n\n\t\t\tconst offset = new Vector3(\n\t\t\t\tparseFloat( tokens[ 1 ] ),\n\t\t\t\tparseFloat( tokens[ 2 ] ),\n\t\t\t\tparseFloat( tokens[ 3 ] )\n\t\t\t);\n\n\t\t\tif ( isNaN( offset.x ) || isNaN( offset.y ) || isNaN( offset.z ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: Invalid values of OFFSET.' );\n\n\t\t\t}\n\n\t\t\tnode.offset = offset;\n\n\t\t\t// parse CHANNELS definitions\n\n\t\t\tif ( node.type !== 'ENDSITE' ) {\n\n\t\t\t\ttokens = nextLine( lines ).split( /[\\s]+/ );\n\n\t\t\t\tif ( tokens[ 0 ] !== 'CHANNELS' ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BVHLoader: Expected CHANNELS definition.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst numChannels = parseInt( tokens[ 1 ] );\n\t\t\t\tnode.channels = tokens.splice( 2, numChannels );\n\t\t\t\tnode.children = [];\n\n\t\t\t}\n\n\t\t\t// read children\n\n\t\t\twhile ( true ) {\n\n\t\t\t\tconst line = nextLine( lines );\n\n\t\t\t\tif ( line === '}' ) {\n\n\t\t\t\t\treturn node;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode.children.push( readNode( lines, line, list ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/*\n\t\t\trecursively converts the internal bvh node structure to a Bone hierarchy\n\n\t\t\tsource: the bvh root node\n\t\t\tlist: pass an empty array, collects a flat list of all converted THREE.Bones\n\n\t\t\treturns the root Bone\n\t\t*/\n\t\tfunction toTHREEBone( source, list ) {\n\n\t\t\tconst bone = new Bone();\n\t\t\tlist.push( bone );\n\n\t\t\tbone.position.add( source.offset );\n\t\t\tbone.name = source.name;\n\n\t\t\tif ( source.type !== 'ENDSITE' ) {\n\n\t\t\t\tfor ( let i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\t\tbone.add( toTHREEBone( source.children[ i ], list ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t\t/*\n\t\t\tbuilds an AnimationClip from the keyframe data saved in each bone.\n\n\t\t\tbone: bvh root node\n\n\t\t\treturns: an AnimationClip containing position and quaternion tracks\n\t\t*/\n\t\tfunction toTHREEAnimation( bones ) {\n\n\t\t\tconst tracks = [];\n\n\t\t\t// create a position and quaternion animation track for each node\n\n\t\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\t\tconst bone = bones[ i ];\n\n\t\t\t\tif ( bone.type === 'ENDSITE' )\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// track data\n\n\t\t\t\tconst times = [];\n\t\t\t\tconst positions = [];\n\t\t\t\tconst rotations = [];\n\n\t\t\t\tfor ( let j = 0; j < bone.frames.length; j ++ ) {\n\n\t\t\t\t\tconst frame = bone.frames[ j ];\n\n\t\t\t\t\ttimes.push( frame.time );\n\n\t\t\t\t\t// the animation system animates the position property,\n\t\t\t\t\t// so we have to add the joint offset to all values\n\n\t\t\t\t\tpositions.push( frame.position.x + bone.offset.x );\n\t\t\t\t\tpositions.push( frame.position.y + bone.offset.y );\n\t\t\t\t\tpositions.push( frame.position.z + bone.offset.z );\n\n\t\t\t\t\trotations.push( frame.rotation.x );\n\t\t\t\t\trotations.push( frame.rotation.y );\n\t\t\t\t\trotations.push( frame.rotation.z );\n\t\t\t\t\trotations.push( frame.rotation.w );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scope.animateBonePositions ) {\n\n\t\t\t\t\ttracks.push( new VectorKeyframeTrack( bone.name + '.position', times, positions ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scope.animateBoneRotations ) {\n\n\t\t\t\t\ttracks.push( new QuaternionKeyframeTrack( bone.name + '.quaternion', times, rotations ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new AnimationClip( 'animation', - 1, tracks );\n\n\t\t}\n\n\t\t/*\n\t\t\treturns the next non-empty line in lines\n\t\t*/\n\t\tfunction nextLine( lines ) {\n\n\t\t\tlet line;\n\t\t\t// skip empty lines\n\t\t\twhile ( ( line = lines.shift().trim() ).length === 0 ) { }\n\n\t\t\treturn line;\n\n\t\t}\n\n\t\tconst scope = this;\n\n\t\tconst lines = text.split( /[\\r\\n]+/g );\n\n\t\tconst bones = readBvh( lines );\n\n\t\tconst threeBones = [];\n\t\ttoTHREEBone( bones[ 0 ], threeBones );\n\n\t\tconst threeClip = toTHREEAnimation( bones );\n\n\t\treturn {\n\t\t\tskeleton: new Skeleton( threeBones ),\n\t\t\tclip: threeClip\n\t\t};\n\n\t}\n\n}\n\nexport { BVHLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}