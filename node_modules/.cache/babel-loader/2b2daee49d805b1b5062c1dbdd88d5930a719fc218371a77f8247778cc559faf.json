{"ast":null,"code":"import { AdditiveBlending, Color, HalfFloatType, ShaderMaterial, UniformsUtils, WebGLRenderTarget } from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\n/**\n * Supersample Anti-Aliasing Render Pass.\n *\n * This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.\n *\n * ```js\n * const ssaaRenderPass = new SSAARenderPass( scene, camera );\n * ssaaRenderPass.sampleLevel = 3;\n * composer.addPass( ssaaRenderPass );\n * ```\n *\n * @augments Pass\n * @three_import import { SSAARenderPass } from 'three/addons/postprocessing/SSAARenderPass.js';\n */\nclass SSAARenderPass extends Pass {\n  /**\n   * Constructs a new SSAA render pass.\n   *\n   * @param {Scene} scene - The scene to render.\n   * @param {Camera} camera - The camera.\n   * @param {?(number|Color|string)} [clearColor=0x000000] - The clear color of the render pass.\n   * @param {?number} [clearAlpha=0] - The clear alpha of the render pass.\n   */\n  constructor(scene, camera, clearColor = 0x000000, clearAlpha = 0) {\n    super();\n\n    /**\n     * The scene to render.\n     *\n     * @type {Scene}\n     */\n    this.scene = scene;\n\n    /**\n     * The camera.\n     *\n     * @type {Camera}\n     */\n    this.camera = camera;\n\n    /**\n     * The sample level. Specified as n, where the number of\n     * samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.\n     *\n     * @type {number}\n     * @default 4\n     */\n    this.sampleLevel = 4;\n\n    /**\n     * Whether the pass should be unbiased or not. This property has the most\n     * visible effect when rendering to a RGBA8 buffer because it mitigates\n     * rounding errors. By default RGBA16F is used.\n     *\n     * @type {boolean}\n     * @default true\n     */\n    this.unbiased = true;\n\n    /**\n     * Whether to use a stencil buffer or not. This property can't\n     * be changed after the first render.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    this.stencilBuffer = false;\n\n    /**\n     * The clear color of the render pass.\n     *\n     * @type {?(number|Color|string)}\n     * @default 0x000000\n     */\n    this.clearColor = clearColor;\n\n    /**\n     * The clear alpha of the render pass.\n     *\n     * @type {?number}\n     * @default 0\n     */\n    this.clearAlpha = clearAlpha;\n\n    // internals\n\n    this._sampleRenderTarget = null;\n    this._oldClearColor = new Color();\n    this._copyUniforms = UniformsUtils.clone(CopyShader.uniforms);\n    this._copyMaterial = new ShaderMaterial({\n      uniforms: this._copyUniforms,\n      vertexShader: CopyShader.vertexShader,\n      fragmentShader: CopyShader.fragmentShader,\n      transparent: true,\n      depthTest: false,\n      depthWrite: false,\n      premultipliedAlpha: true,\n      blending: AdditiveBlending\n    });\n    this._fsQuad = new FullScreenQuad(this._copyMaterial);\n  }\n\n  /**\n   * Frees the GPU-related resources allocated by this instance. Call this\n   * method whenever the pass is no longer used in your app.\n   */\n  dispose() {\n    if (this._sampleRenderTarget) {\n      this._sampleRenderTarget.dispose();\n      this._sampleRenderTarget = null;\n    }\n    this._copyMaterial.dispose();\n    this._fsQuad.dispose();\n  }\n\n  /**\n   * Sets the size of the pass.\n   *\n   * @param {number} width - The width to set.\n   * @param {number} height - The height to set.\n   */\n  setSize(width, height) {\n    if (this._sampleRenderTarget) this._sampleRenderTarget.setSize(width, height);\n  }\n\n  /**\n   * Performs the SSAA render pass.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n   * destination for the pass.\n   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n   * previous pass from this buffer.\n   * @param {number} deltaTime - The delta time in seconds.\n   * @param {boolean} maskActive - Whether masking is active or not.\n   */\n  render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {\n    if (!this._sampleRenderTarget) {\n      this._sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, {\n        type: HalfFloatType,\n        stencilBuffer: this.stencilBuffer\n      });\n      this._sampleRenderTarget.texture.name = 'SSAARenderPass.sample';\n    }\n    const jitterOffsets = _JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))];\n    const autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    renderer.getClearColor(this._oldClearColor);\n    const oldClearAlpha = renderer.getClearAlpha();\n    const baseSampleWeight = 1.0 / jitterOffsets.length;\n    const roundingRange = 1 / 32;\n    this._copyUniforms['tDiffuse'].value = this._sampleRenderTarget.texture;\n    const viewOffset = {\n      fullWidth: readBuffer.width,\n      fullHeight: readBuffer.height,\n      offsetX: 0,\n      offsetY: 0,\n      width: readBuffer.width,\n      height: readBuffer.height\n    };\n    const originalViewOffset = Object.assign({}, this.camera.view);\n    if (originalViewOffset.enabled) Object.assign(viewOffset, originalViewOffset);\n\n    // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n    for (let i = 0; i < jitterOffsets.length; i++) {\n      const jitterOffset = jitterOffsets[i];\n      if (this.camera.setViewOffset) {\n        this.camera.setViewOffset(viewOffset.fullWidth, viewOffset.fullHeight, viewOffset.offsetX + jitterOffset[0] * 0.0625, viewOffset.offsetY + jitterOffset[1] * 0.0625,\n        // 0.0625 = 1 / 16\n\n        viewOffset.width, viewOffset.height);\n      }\n      let sampleWeight = baseSampleWeight;\n      if (this.unbiased) {\n        // the theory is that equal weights for each sample lead to an accumulation of rounding errors.\n        // The following equation varies the sampleWeight per sample so that it is uniformly distributed\n        // across a range of values whose rounding errors cancel each other out.\n\n        const uniformCenteredDistribution = -0.5 + (i + 0.5) / jitterOffsets.length;\n        sampleWeight += roundingRange * uniformCenteredDistribution;\n      }\n      this._copyUniforms['opacity'].value = sampleWeight;\n      renderer.setClearColor(this.clearColor, this.clearAlpha);\n      renderer.setRenderTarget(this._sampleRenderTarget);\n      renderer.clear();\n      renderer.render(this.scene, this.camera);\n      renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n      if (i === 0) {\n        renderer.setClearColor(0x000000, 0.0);\n        renderer.clear();\n      }\n      this._fsQuad.render(renderer);\n    }\n    if (this.camera.setViewOffset && originalViewOffset.enabled) {\n      this.camera.setViewOffset(originalViewOffset.fullWidth, originalViewOffset.fullHeight, originalViewOffset.offsetX, originalViewOffset.offsetY, originalViewOffset.width, originalViewOffset.height);\n    } else if (this.camera.clearViewOffset) {\n      this.camera.clearViewOffset();\n    }\n    renderer.autoClear = autoClear;\n    renderer.setClearColor(this._oldClearColor, oldClearAlpha);\n  }\n}\n\n// These jitter vectors are specified in integers because it is easier.\n// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)\n// before being used, thus these integers need to be scaled by 1/16.\n//\n// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\nconst _JitterVectors = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]];\nexport { SSAARenderPass };","map":{"version":3,"names":["AdditiveBlending","Color","HalfFloatType","ShaderMaterial","UniformsUtils","WebGLRenderTarget","Pass","FullScreenQuad","CopyShader","SSAARenderPass","constructor","scene","camera","clearColor","clearAlpha","sampleLevel","unbiased","stencilBuffer","_sampleRenderTarget","_oldClearColor","_copyUniforms","clone","uniforms","_copyMaterial","vertexShader","fragmentShader","transparent","depthTest","depthWrite","premultipliedAlpha","blending","_fsQuad","dispose","setSize","width","height","render","renderer","writeBuffer","readBuffer","type","texture","name","jitterOffsets","_JitterVectors","Math","max","min","autoClear","getClearColor","oldClearAlpha","getClearAlpha","baseSampleWeight","length","roundingRange","value","viewOffset","fullWidth","fullHeight","offsetX","offsetY","originalViewOffset","Object","assign","view","enabled","i","jitterOffset","setViewOffset","sampleWeight","uniformCenteredDistribution","setClearColor","setRenderTarget","clear","renderToScreen","clearViewOffset"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/postprocessing/SSAARenderPass.js"],"sourcesContent":["import {\n\tAdditiveBlending,\n\tColor,\n\tHalfFloatType,\n\tShaderMaterial,\n\tUniformsUtils,\n\tWebGLRenderTarget\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\n/**\n * Supersample Anti-Aliasing Render Pass.\n *\n * This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.\n *\n * ```js\n * const ssaaRenderPass = new SSAARenderPass( scene, camera );\n * ssaaRenderPass.sampleLevel = 3;\n * composer.addPass( ssaaRenderPass );\n * ```\n *\n * @augments Pass\n * @three_import import { SSAARenderPass } from 'three/addons/postprocessing/SSAARenderPass.js';\n */\nclass SSAARenderPass extends Pass {\n\n\t/**\n\t * Constructs a new SSAA render pass.\n\t *\n\t * @param {Scene} scene - The scene to render.\n\t * @param {Camera} camera - The camera.\n\t * @param {?(number|Color|string)} [clearColor=0x000000] - The clear color of the render pass.\n\t * @param {?number} [clearAlpha=0] - The clear alpha of the render pass.\n\t */\n\tconstructor( scene, camera, clearColor = 0x000000, clearAlpha = 0 ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The scene to render.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * The camera.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * The sample level. Specified as n, where the number of\n\t\t * samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 4\n\t\t */\n\t\tthis.sampleLevel = 4;\n\n\t\t/**\n\t\t * Whether the pass should be unbiased or not. This property has the most\n\t\t * visible effect when rendering to a RGBA8 buffer because it mitigates\n\t\t * rounding errors. By default RGBA16F is used.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.unbiased = true;\n\n\t\t/**\n\t\t * Whether to use a stencil buffer or not. This property can't\n\t\t * be changed after the first render.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.stencilBuffer = false;\n\n\t\t/**\n\t\t * The clear color of the render pass.\n\t\t *\n\t\t * @type {?(number|Color|string)}\n\t\t * @default 0x000000\n\t\t */\n\t\tthis.clearColor = clearColor;\n\n\t\t/**\n\t\t * The clear alpha of the render pass.\n\t\t *\n\t\t * @type {?number}\n\t\t * @default 0\n\t\t */\n\t\tthis.clearAlpha = clearAlpha;\n\n\t\t// internals\n\n\t\tthis._sampleRenderTarget = null;\n\n\t\tthis._oldClearColor = new Color();\n\n\t\tthis._copyUniforms = UniformsUtils.clone( CopyShader.uniforms );\n\n\t\tthis._copyMaterial = new ShaderMaterial(\t{\n\t\t\tuniforms: this._copyUniforms,\n\t\t\tvertexShader: CopyShader.vertexShader,\n\t\t\tfragmentShader: CopyShader.fragmentShader,\n\t\t\ttransparent: true,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\tpremultipliedAlpha: true,\n\t\t\tblending: AdditiveBlending\n\t\t} );\n\n\t\tthis._fsQuad = new FullScreenQuad( this._copyMaterial );\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the pass is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tif ( this._sampleRenderTarget ) {\n\n\t\t\tthis._sampleRenderTarget.dispose();\n\t\t\tthis._sampleRenderTarget = null;\n\n\t\t}\n\n\t\tthis._copyMaterial.dispose();\n\n\t\tthis._fsQuad.dispose();\n\n\t}\n\n\t/**\n\t * Sets the size of the pass.\n\t *\n\t * @param {number} width - The width to set.\n\t * @param {number} height - The height to set.\n\t */\n\tsetSize( width, height ) {\n\n\t\tif ( this._sampleRenderTarget )\tthis._sampleRenderTarget.setSize( width, height );\n\n\t}\n\n\t/**\n\t * Performs the SSAA render pass.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer, writeBuffer, readBuffer/*, deltaTime, maskActive */ ) {\n\n\t\tif ( ! this._sampleRenderTarget ) {\n\n\t\t\tthis._sampleRenderTarget = new WebGLRenderTarget( readBuffer.width, readBuffer.height, { type: HalfFloatType, stencilBuffer: this.stencilBuffer } );\n\t\t\tthis._sampleRenderTarget.texture.name = 'SSAARenderPass.sample';\n\n\t\t}\n\n\t\tconst jitterOffsets = _JitterVectors[ Math.max( 0, Math.min( this.sampleLevel, 5 ) ) ];\n\n\t\tconst autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.getClearColor( this._oldClearColor );\n\t\tconst oldClearAlpha = renderer.getClearAlpha();\n\n\t\tconst baseSampleWeight = 1.0 / jitterOffsets.length;\n\t\tconst roundingRange = 1 / 32;\n\t\tthis._copyUniforms[ 'tDiffuse' ].value = this._sampleRenderTarget.texture;\n\n\t\tconst viewOffset = {\n\n\t\t\tfullWidth: readBuffer.width,\n\t\t\tfullHeight: readBuffer.height,\n\t\t\toffsetX: 0,\n\t\t\toffsetY: 0,\n\t\t\twidth: readBuffer.width,\n\t\t\theight: readBuffer.height\n\n\t\t};\n\n\t\tconst originalViewOffset = Object.assign( {}, this.camera.view );\n\n\t\tif ( originalViewOffset.enabled ) Object.assign( viewOffset, originalViewOffset );\n\n\t\t// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\t\tfor ( let i = 0; i < jitterOffsets.length; i ++ ) {\n\n\t\t\tconst jitterOffset = jitterOffsets[ i ];\n\n\t\t\tif ( this.camera.setViewOffset ) {\n\n\t\t\t\tthis.camera.setViewOffset(\n\n\t\t\t\t\tviewOffset.fullWidth, viewOffset.fullHeight,\n\n\t\t\t\t\tviewOffset.offsetX + jitterOffset[ 0 ] * 0.0625, viewOffset.offsetY + jitterOffset[ 1 ] * 0.0625, // 0.0625 = 1 / 16\n\n\t\t\t\t\tviewOffset.width, viewOffset.height\n\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tlet sampleWeight = baseSampleWeight;\n\n\t\t\tif ( this.unbiased ) {\n\n\t\t\t\t// the theory is that equal weights for each sample lead to an accumulation of rounding errors.\n\t\t\t\t// The following equation varies the sampleWeight per sample so that it is uniformly distributed\n\t\t\t\t// across a range of values whose rounding errors cancel each other out.\n\n\t\t\t\tconst uniformCenteredDistribution = ( - 0.5 + ( i + 0.5 ) / jitterOffsets.length );\n\t\t\t\tsampleWeight += roundingRange * uniformCenteredDistribution;\n\n\t\t\t}\n\n\t\t\tthis._copyUniforms[ 'opacity' ].value = sampleWeight;\n\t\t\trenderer.setClearColor( this.clearColor, this.clearAlpha );\n\t\t\trenderer.setRenderTarget( this._sampleRenderTarget );\n\t\t\trenderer.clear();\n\t\t\trenderer.render( this.scene, this.camera );\n\n\t\t\trenderer.setRenderTarget( this.renderToScreen ? null : writeBuffer );\n\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\trenderer.setClearColor( 0x000000, 0.0 );\n\t\t\t\trenderer.clear();\n\n\t\t\t}\n\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t}\n\n\t\tif ( this.camera.setViewOffset && originalViewOffset.enabled ) {\n\n\t\t\tthis.camera.setViewOffset(\n\n\t\t\t\toriginalViewOffset.fullWidth, originalViewOffset.fullHeight,\n\n\t\t\t\toriginalViewOffset.offsetX, originalViewOffset.offsetY,\n\n\t\t\t\toriginalViewOffset.width, originalViewOffset.height\n\n\t\t\t);\n\n\t\t} else if ( this.camera.clearViewOffset ) {\n\n\t\t\tthis.camera.clearViewOffset();\n\n\t\t}\n\n\t\trenderer.autoClear = autoClear;\n\t\trenderer.setClearColor( this._oldClearColor, oldClearAlpha );\n\n\t}\n\n}\n\n\n// These jitter vectors are specified in integers because it is easier.\n// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)\n// before being used, thus these integers need to be scaled by 1/16.\n//\n// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\nconst _JitterVectors = [\n\t[\n\t\t[ 0, 0 ]\n\t],\n\t[\n\t\t[ 4, 4 ], [ - 4, - 4 ]\n\t],\n\t[\n\t\t[ - 2, - 6 ], [ 6, - 2 ], [ - 6, 2 ], [ 2, 6 ]\n\t],\n\t[\n\t\t[ 1, - 3 ], [ - 1, 3 ], [ 5, 1 ], [ - 3, - 5 ],\n\t\t[ - 5, 5 ], [ - 7, - 1 ], [ 3, 7 ], [ 7, - 7 ]\n\t],\n\t[\n\t\t[ 1, 1 ], [ - 1, - 3 ], [ - 3, 2 ], [ 4, - 1 ],\n\t\t[ - 5, - 2 ], [ 2, 5 ], [ 5, 3 ], [ 3, - 5 ],\n\t\t[ - 2, 6 ], [ 0, - 7 ], [ - 4, - 6 ], [ - 6, 4 ],\n\t\t[ - 8, 0 ], [ 7, - 4 ], [ 6, 7 ], [ - 7, - 8 ]\n\t],\n\t[\n\t\t[ - 4, - 7 ], [ - 7, - 5 ], [ - 3, - 5 ], [ - 5, - 4 ],\n\t\t[ - 1, - 4 ], [ - 2, - 2 ], [ - 6, - 1 ], [ - 4, 0 ],\n\t\t[ - 7, 1 ], [ - 1, 2 ], [ - 6, 3 ], [ - 3, 3 ],\n\t\t[ - 7, 6 ], [ - 3, 6 ], [ - 5, 7 ], [ - 1, 7 ],\n\t\t[ 5, - 7 ], [ 1, - 6 ], [ 6, - 5 ], [ 4, - 4 ],\n\t\t[ 2, - 3 ], [ 7, - 2 ], [ 1, - 1 ], [ 4, - 1 ],\n\t\t[ 2, 1 ], [ 6, 2 ], [ 0, 4 ], [ 4, 4 ],\n\t\t[ 2, 5 ], [ 7, 5 ], [ 5, 6 ], [ 3, 7 ]\n\t]\n];\n\nexport { SSAARenderPass };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}