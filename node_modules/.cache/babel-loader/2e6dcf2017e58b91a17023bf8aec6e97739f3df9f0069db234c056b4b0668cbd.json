{"ast":null,"code":"import { MeshPhysicalMaterial } from 'three';\n\n/**\n * The aim of this mesh material is to use information from a post processing pass in the diffuse color pass.\n * This material is based on the MeshPhysicalMaterial.\n *\n * In the current state, only the information of a screen space AO pass can be used in the material.\n * Actually, the output of any screen space AO (SSAO, GTAO) can be used,\n * as it is only necessary to provide the AO in one color channel of a texture,\n * however the AO pass must be rendered prior to the color pass,\n * which makes the post-processing pass somewhat of a pre-processing pass.\n * Fot this purpose a new map (`aoPassMap`) is added to the material.\n * The value of the map is used the same way as the `aoMap` value.\n *\n * Motivation to use the outputs AO pass directly in the material:\n * The incident light of a fragment is composed of ambient light, direct light and indirect light\n * Ambient Occlusion only occludes ambient light and environment light, but not direct light.\n * Direct light is only occluded by geometry that casts shadows.\n * And of course the emitted light should not be darkened by ambient occlusion either.\n * This cannot be achieved if the AO post processing pass is simply blended with the diffuse render pass.\n *\n * Further extension work might be to use the output of an SSR pass or an HBIL pass from a previous frame.\n * This would then create the possibility of SSR and IR depending on material properties such as `roughness`, `metalness` and `reflectivity`.\n *\n * @augments MeshPhysicalMaterial\n * @three_import import { MeshPostProcessingMaterial } from 'three/addons/materials/MeshPostProcessingMaterial.js';\n */\nclass MeshPostProcessingMaterial extends MeshPhysicalMaterial {\n  /**\n   * Constructs a new conditional line material.\n   *\n   * @param {Object} [parameters] - An object with one or more properties\n   * defining the material's appearance. Any property of the material\n   * (including any property from inherited materials) can be passed\n   * in here. Color values can be passed any type of value accepted\n   * by {@link Color#set}.\n   */\n  constructor(parameters) {\n    const aoPassMap = parameters.aoPassMap;\n    const aoPassMapScale = parameters.aoPassMapScale || 1.0;\n    delete parameters.aoPassMap;\n    delete parameters.aoPassMapScale;\n    super(parameters);\n    this.onBeforeCompile = this._onBeforeCompile;\n    this.customProgramCacheKey = this._customProgramCacheKey;\n    this._aoPassMap = aoPassMap;\n\n    /**\n     * The scale of the AO pass.\n     *\n     * @type {number}\n     * @default 1\n     */\n    this.aoPassMapScale = aoPassMapScale;\n    this._shader = null;\n  }\n\n  /**\n   * A texture representing the AO pass.\n   *\n   * @type {Texture}\n   */\n  get aoPassMap() {\n    return this._aoPassMap;\n  }\n  set aoPassMap(aoPassMap) {\n    this._aoPassMap = aoPassMap;\n    this.needsUpdate = true;\n    this._setUniforms();\n  }\n  _customProgramCacheKey() {\n    return this._aoPassMap !== undefined && this._aoPassMap !== null ? 'aoPassMap' : '';\n  }\n  _onBeforeCompile(shader) {\n    this._shader = shader;\n    if (this._aoPassMap !== undefined && this._aoPassMap !== null) {\n      shader.fragmentShader = shader.fragmentShader.replace('#include <aomap_pars_fragment>', aomap_pars_fragment_replacement);\n      shader.fragmentShader = shader.fragmentShader.replace('#include <aomap_fragment>', aomap_fragment_replacement);\n    }\n    this._setUniforms();\n  }\n  _setUniforms() {\n    if (this._shader) {\n      this._shader.uniforms.tAoPassMap = {\n        value: this._aoPassMap\n      };\n      this._shader.uniforms.aoPassMapScale = {\n        value: this.aoPassMapScale\n      };\n    }\n  }\n}\nconst aomap_pars_fragment_replacement = /* glsl */`\n#ifdef USE_AOMAP\n\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n\n#endif\n\n\tuniform sampler2D tAoPassMap;\n\tuniform float aoPassMapScale;\n`;\nconst aomap_fragment_replacement = /* glsl */`\n#ifndef AOPASSMAP_SWIZZLE\n\t#define AOPASSMAP_SWIZZLE r\n#endif\n\tfloat ambientOcclusion = texelFetch( tAoPassMap, ivec2( gl_FragCoord.xy * aoPassMapScale ), 0 ).AOPASSMAP_SWIZZLE;\n\n#ifdef USE_AOMAP\n\n\t// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tambientOcclusion = min( ambientOcclusion, texture2D( aoMap, vAoMapUv ).r );\n\tambientOcclusion *= ( ambientOcclusion - 1.0 ) * aoMapIntensity + 1.0;\n\n#endif\n\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\n\t#endif\n`;\nexport { MeshPostProcessingMaterial };","map":{"version":3,"names":["MeshPhysicalMaterial","MeshPostProcessingMaterial","constructor","parameters","aoPassMap","aoPassMapScale","onBeforeCompile","_onBeforeCompile","customProgramCacheKey","_customProgramCacheKey","_aoPassMap","_shader","needsUpdate","_setUniforms","undefined","shader","fragmentShader","replace","aomap_pars_fragment_replacement","aomap_fragment_replacement","uniforms","tAoPassMap","value"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/materials/MeshPostProcessingMaterial.js"],"sourcesContent":["import { MeshPhysicalMaterial } from 'three';\n\n/**\n * The aim of this mesh material is to use information from a post processing pass in the diffuse color pass.\n * This material is based on the MeshPhysicalMaterial.\n *\n * In the current state, only the information of a screen space AO pass can be used in the material.\n * Actually, the output of any screen space AO (SSAO, GTAO) can be used,\n * as it is only necessary to provide the AO in one color channel of a texture,\n * however the AO pass must be rendered prior to the color pass,\n * which makes the post-processing pass somewhat of a pre-processing pass.\n * Fot this purpose a new map (`aoPassMap`) is added to the material.\n * The value of the map is used the same way as the `aoMap` value.\n *\n * Motivation to use the outputs AO pass directly in the material:\n * The incident light of a fragment is composed of ambient light, direct light and indirect light\n * Ambient Occlusion only occludes ambient light and environment light, but not direct light.\n * Direct light is only occluded by geometry that casts shadows.\n * And of course the emitted light should not be darkened by ambient occlusion either.\n * This cannot be achieved if the AO post processing pass is simply blended with the diffuse render pass.\n *\n * Further extension work might be to use the output of an SSR pass or an HBIL pass from a previous frame.\n * This would then create the possibility of SSR and IR depending on material properties such as `roughness`, `metalness` and `reflectivity`.\n *\n * @augments MeshPhysicalMaterial\n * @three_import import { MeshPostProcessingMaterial } from 'three/addons/materials/MeshPostProcessingMaterial.js';\n */\nclass MeshPostProcessingMaterial extends MeshPhysicalMaterial {\n\n\t/**\n\t * Constructs a new conditional line material.\n\t *\n\t * @param {Object} [parameters] - An object with one or more properties\n\t * defining the material's appearance. Any property of the material\n\t * (including any property from inherited materials) can be passed\n\t * in here. Color values can be passed any type of value accepted\n\t * by {@link Color#set}.\n\t */\n\tconstructor( parameters ) {\n\n\t\tconst aoPassMap = parameters.aoPassMap;\n\t\tconst aoPassMapScale = parameters.aoPassMapScale || 1.0;\n\t\tdelete parameters.aoPassMap;\n\t\tdelete parameters.aoPassMapScale;\n\n\t\tsuper( parameters );\n\n\t\tthis.onBeforeCompile = this._onBeforeCompile;\n\t\tthis.customProgramCacheKey = this._customProgramCacheKey;\n\t\tthis._aoPassMap = aoPassMap;\n\n\t\t/**\n\t\t * The scale of the AO pass.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.aoPassMapScale = aoPassMapScale;\n\t\tthis._shader = null;\n\n\t}\n\n\t/**\n\t * A texture representing the AO pass.\n\t *\n\t * @type {Texture}\n\t */\n\tget aoPassMap() {\n\n\t\treturn this._aoPassMap;\n\n\t}\n\n\tset aoPassMap( aoPassMap ) {\n\n\t\tthis._aoPassMap = aoPassMap;\n\t\tthis.needsUpdate = true;\n\t\tthis._setUniforms();\n\n\t}\n\n\t_customProgramCacheKey() {\n\n\t\treturn this._aoPassMap !== undefined && this._aoPassMap !== null ? 'aoPassMap' : '';\n\n\t}\n\n\t_onBeforeCompile( shader ) {\n\n\t\tthis._shader = shader;\n\n\t\tif ( this._aoPassMap !== undefined && this._aoPassMap !== null ) {\n\n\t\t\tshader.fragmentShader = shader.fragmentShader.replace(\n\t\t\t\t'#include <aomap_pars_fragment>',\n\t\t\t\taomap_pars_fragment_replacement\n\t\t\t);\n\t\t\tshader.fragmentShader = shader.fragmentShader.replace(\n\t\t\t\t'#include <aomap_fragment>',\n\t\t\t\taomap_fragment_replacement\n\t\t\t);\n\n\t\t}\n\n\t\tthis._setUniforms();\n\n\t}\n\n\t_setUniforms() {\n\n\t\tif ( this._shader ) {\n\n\t\t\tthis._shader.uniforms.tAoPassMap = { value: this._aoPassMap };\n\t\t\tthis._shader.uniforms.aoPassMapScale = { value: this.aoPassMapScale };\n\n\t\t}\n\n\t}\n\n}\n\nconst aomap_pars_fragment_replacement = /* glsl */`\n#ifdef USE_AOMAP\n\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n\n#endif\n\n\tuniform sampler2D tAoPassMap;\n\tuniform float aoPassMapScale;\n`;\n\nconst aomap_fragment_replacement = /* glsl */`\n#ifndef AOPASSMAP_SWIZZLE\n\t#define AOPASSMAP_SWIZZLE r\n#endif\n\tfloat ambientOcclusion = texelFetch( tAoPassMap, ivec2( gl_FragCoord.xy * aoPassMapScale ), 0 ).AOPASSMAP_SWIZZLE;\n\n#ifdef USE_AOMAP\n\n\t// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tambientOcclusion = min( ambientOcclusion, texture2D( aoMap, vAoMapUv ).r );\n\tambientOcclusion *= ( ambientOcclusion - 1.0 ) * aoMapIntensity + 1.0;\n\n#endif\n\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\n\t#endif\n`;\n\nexport { MeshPostProcessingMaterial };\n"],"mappings":"AAAA,SAASA,oBAAoB,QAAQ,OAAO;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,0BAA0B,SAASD,oBAAoB,CAAC;EAE7D;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCE,WAAWA,CAAEC,UAAU,EAAG;IAEzB,MAAMC,SAAS,GAAGD,UAAU,CAACC,SAAS;IACtC,MAAMC,cAAc,GAAGF,UAAU,CAACE,cAAc,IAAI,GAAG;IACvD,OAAOF,UAAU,CAACC,SAAS;IAC3B,OAAOD,UAAU,CAACE,cAAc;IAEhC,KAAK,CAAEF,UAAW,CAAC;IAEnB,IAAI,CAACG,eAAe,GAAG,IAAI,CAACC,gBAAgB;IAC5C,IAAI,CAACC,qBAAqB,GAAG,IAAI,CAACC,sBAAsB;IACxD,IAAI,CAACC,UAAU,GAAGN,SAAS;;IAE3B;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACM,OAAO,GAAG,IAAI;EAEpB;;EAEA;AACD;AACA;AACA;AACA;EACC,IAAIP,SAASA,CAAA,EAAG;IAEf,OAAO,IAAI,CAACM,UAAU;EAEvB;EAEA,IAAIN,SAASA,CAAEA,SAAS,EAAG;IAE1B,IAAI,CAACM,UAAU,GAAGN,SAAS;IAC3B,IAAI,CAACQ,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,YAAY,CAAC,CAAC;EAEpB;EAEAJ,sBAAsBA,CAAA,EAAG;IAExB,OAAO,IAAI,CAACC,UAAU,KAAKI,SAAS,IAAI,IAAI,CAACJ,UAAU,KAAK,IAAI,GAAG,WAAW,GAAG,EAAE;EAEpF;EAEAH,gBAAgBA,CAAEQ,MAAM,EAAG;IAE1B,IAAI,CAACJ,OAAO,GAAGI,MAAM;IAErB,IAAK,IAAI,CAACL,UAAU,KAAKI,SAAS,IAAI,IAAI,CAACJ,UAAU,KAAK,IAAI,EAAG;MAEhEK,MAAM,CAACC,cAAc,GAAGD,MAAM,CAACC,cAAc,CAACC,OAAO,CACpD,gCAAgC,EAChCC,+BACD,CAAC;MACDH,MAAM,CAACC,cAAc,GAAGD,MAAM,CAACC,cAAc,CAACC,OAAO,CACpD,2BAA2B,EAC3BE,0BACD,CAAC;IAEF;IAEA,IAAI,CAACN,YAAY,CAAC,CAAC;EAEpB;EAEAA,YAAYA,CAAA,EAAG;IAEd,IAAK,IAAI,CAACF,OAAO,EAAG;MAEnB,IAAI,CAACA,OAAO,CAACS,QAAQ,CAACC,UAAU,GAAG;QAAEC,KAAK,EAAE,IAAI,CAACZ;MAAW,CAAC;MAC7D,IAAI,CAACC,OAAO,CAACS,QAAQ,CAACf,cAAc,GAAG;QAAEiB,KAAK,EAAE,IAAI,CAACjB;MAAe,CAAC;IAEtE;EAED;AAED;AAEA,MAAMa,+BAA+B,GAAG,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,MAAMC,0BAA0B,GAAG,UAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,SAASlB,0BAA0B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}