{"ast":null,"code":"import { DoubleSide, FloatType, HalfFloatType, Mesh, MeshBasicMaterial, MeshPhongMaterial, PlaneGeometry, Scene, WebGLRenderTarget } from 'three';\nimport { potpack } from '../libs/potpack.module.js';\n\n/**\n * Progressive Light Map Accumulator, by [zalo]{@link https://github.com/zalo/}.\n *\n * To use, simply construct a `ProgressiveLightMap` object,\n * `plmap.addObjectsToLightMap(object)` an array of semi-static\n * objects and lights to the class once, and then call\n * `plmap.update(camera)` every frame to begin accumulating\n * lighting samples.\n *\n * This should begin accumulating lightmaps which apply to\n * your objects, so you can start jittering lighting to achieve\n * the texture-space effect you're looking for.\n *\n * This class can only be used with {@link WebGLRenderer}.\n * When using {@link WebGPURenderer}, import from `ProgressiveLightMapGPU.js`.\n *\n * @three_import import { ProgressiveLightMap } from 'three/addons/misc/ProgressiveLightMap.js';\n */\nclass ProgressiveLightMap {\n  /**\n   * Constructs a new progressive light map.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n  \t * @param {number} [res=1024] - The side-long dimension of the total lightmap.\n   */\n  constructor(renderer, res = 1024) {\n    /**\n     * The renderer.\n     *\n     * @type {WebGLRenderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * The side-long dimension of the total lightmap.\n     *\n     * @type {number}\n     * @default 1024\n     */\n    this.res = res;\n\n    // internals\n\n    this.lightMapContainers = [];\n    this.scene = new Scene();\n    this.buffer1Active = false;\n    this.firstUpdate = true;\n    this.labelMesh = null;\n    this.blurringPlane = null;\n\n    // Create the Progressive LightMap Texture\n    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? HalfFloatType : FloatType;\n    this.progressiveLightMap1 = new WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.progressiveLightMap2 = new WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.progressiveLightMap2.texture.channel = 1;\n\n    // Inject some spicy new logic into a standard phong material\n    this.uvMat = new MeshPhongMaterial();\n    this.uvMat.uniforms = {};\n    this.uvMat.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = 'attribute vec2 uv1;\\n' + '#define USE_LIGHTMAP\\n' + '#define LIGHTMAP_UV uv1\\n' + shader.vertexShader.slice(0, -1) + '\tgl_Position = vec4((LIGHTMAP_UV - 0.5) * 2.0, 1.0, 1.0); }';\n\n      // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = '#define USE_LIGHTMAP\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\\nvec3 texelOld = texture2D(previousShadowMap, vLightMapUv).rgb;\n\t\t\t\tgl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n\t\t\t}`;\n\n      // Set the Previous Frame's Texture Buffer and Averaging Window\n      shader.uniforms.previousShadowMap = {\n        value: this.progressiveLightMap1.texture\n      };\n      shader.uniforms.averagingWindow = {\n        value: 100\n      };\n      this.uvMat.uniforms = shader.uniforms;\n\n      // Set the new Shader to this\n      this.uvMat.userData.shader = shader;\n    };\n  }\n\n  /**\n   * Sets these objects' materials' lightmaps and modifies their uv1's.\n   *\n   * @param {Array<Object3D>} objects - An array of objects and lights to set up your lightmap.\n   */\n  addObjectsToLightMap(objects) {\n    // Prepare list of UV bounding boxes for packing later...\n    this.uv_boxes = [];\n    const padding = 3 / this.res;\n    for (let ob = 0; ob < objects.length; ob++) {\n      const object = objects[ob];\n\n      // If this object is a light, simply add it to the internal scene\n      if (object.isLight) {\n        this.scene.attach(object);\n        continue;\n      }\n      if (object.geometry.hasAttribute('uv') === false) {\n        console.warn('THREE.ProgressiveLightMap: All lightmap objects need uvs.');\n        continue;\n      }\n      if (this.blurringPlane === null) {\n        this._initializeBlurPlane(this.res, this.progressiveLightMap1);\n      }\n\n      // Apply the lightmap to the object\n      object.material.lightMap = this.progressiveLightMap2.texture;\n      object.material.dithering = true;\n      object.castShadow = true;\n      object.receiveShadow = true;\n      object.renderOrder = 1000 + ob;\n\n      // Prepare UV boxes for potpack\n      // TODO: Size these by object surface area\n      this.uv_boxes.push({\n        w: 1 + padding * 2,\n        h: 1 + padding * 2,\n        index: ob\n      });\n      this.lightMapContainers.push({\n        basicMat: object.material,\n        object: object\n      });\n    }\n\n    // Pack the objects' lightmap UVs into the same global space\n    const dimensions = potpack(this.uv_boxes);\n    this.uv_boxes.forEach(box => {\n      const uv1 = objects[box.index].geometry.getAttribute('uv').clone();\n      for (let i = 0; i < uv1.array.length; i += uv1.itemSize) {\n        uv1.array[i] = (uv1.array[i] + box.x + padding) / dimensions.w;\n        uv1.array[i + 1] = (uv1.array[i + 1] + box.y + padding) / dimensions.h;\n      }\n      objects[box.index].geometry.setAttribute('uv1', uv1);\n      objects[box.index].geometry.getAttribute('uv1').needsUpdate = true;\n    });\n  }\n\n  /**\n   * This function renders each mesh one at a time into their respective surface maps.\n   *\n   * @param {Camera} camera - The camera the scene is rendered with.\n   * @param {number} [blendWindow=100] - When >1, samples will accumulate over time.\n   * @param {boolean} [blurEdges=true] - Whether to fix UV Edges via blurring.\n   */\n  update(camera, blendWindow = 100, blurEdges = true) {\n    if (this.blurringPlane === null) {\n      return;\n    }\n\n    // Store the original Render Target\n    const oldTarget = this.renderer.getRenderTarget();\n\n    // The blurring plane applies blur to the seams of the lightmap\n    this.blurringPlane.visible = blurEdges;\n\n    // Steal the Object3D from the real world to our special dimension\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.oldScene = this.lightMapContainers[l].object.parent;\n      this.scene.attach(this.lightMapContainers[l].object);\n    }\n\n    // Initialize everything\n    if (this.firstUpdate === true) {\n      this.renderer.compile(this.scene, camera);\n      this.firstUpdate = false;\n    }\n\n    // Set each object's material to the UV Unwrapped Surface Mapping Version\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.uvMat.uniforms.averagingWindow = {\n        value: blendWindow\n      };\n      this.lightMapContainers[l].object.material = this.uvMat;\n      this.lightMapContainers[l].object.oldFrustumCulled = this.lightMapContainers[l].object.frustumCulled;\n      this.lightMapContainers[l].object.frustumCulled = false;\n    }\n\n    // Ping-pong two surface buffers for reading/writing\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;\n\n    // Render the object's surface maps\n    this.renderer.setRenderTarget(activeMap);\n    this.uvMat.uniforms.previousShadowMap = {\n      value: inactiveMap.texture\n    };\n    this.blurringPlane.material.uniforms.previousShadowMap = {\n      value: inactiveMap.texture\n    };\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera);\n\n    // Restore the object's Real-time Material and add it back to the original world\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.frustumCulled = this.lightMapContainers[l].object.oldFrustumCulled;\n      this.lightMapContainers[l].object.material = this.lightMapContainers[l].basicMat;\n      this.lightMapContainers[l].object.oldScene.attach(this.lightMapContainers[l].object);\n    }\n\n    // Restore the original Render Target\n    this.renderer.setRenderTarget(oldTarget);\n  }\n\n  /**\n   * Draws the lightmap in the main scene. Call this after adding the objects to it.\n   *\n   * @param {boolean} visible - Whether the debug plane should be visible\n   * @param {Vector3} [position] - Where the debug plane should be drawn\n  */\n  showDebugLightmap(visible, position = undefined) {\n    if (this.lightMapContainers.length === 0) {\n      console.warn('THREE.ProgressiveLightMap: Call .showDebugLightmap() after adding the objects.');\n      return;\n    }\n    if (this.labelMesh === null) {\n      const labelMaterial = new MeshBasicMaterial({\n        map: this.progressiveLightMap1.texture,\n        side: DoubleSide\n      });\n      const labelGeometry = new PlaneGeometry(100, 100);\n      this.labelMesh = new Mesh(labelGeometry, labelMaterial);\n      this.labelMesh.position.y = 250;\n      this.lightMapContainers[0].object.parent.add(this.labelMesh);\n    }\n    if (position !== undefined) {\n      this.labelMesh.position.copy(position);\n    }\n    this.labelMesh.visible = visible;\n  }\n\n  /**\n   * Creates the Blurring Plane.\n   *\n   * @private\n   * @param {number} res - The square resolution of this object's lightMap.\n   * @param {WebGLRenderTarget} [lightMap] - The lightmap to initialize the plane with.\n   */\n  _initializeBlurPlane(res, lightMap = null) {\n    const blurMaterial = new MeshBasicMaterial();\n    blurMaterial.uniforms = {\n      previousShadowMap: {\n        value: null\n      },\n      pixelOffset: {\n        value: 1.0 / res\n      },\n      polygonOffset: true,\n      polygonOffsetFactor: -1,\n      polygonOffsetUnits: 3.0\n    };\n    blurMaterial.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = '#define USE_UV\\n' + shader.vertexShader.slice(0, -1) + '\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }';\n\n      // Fragment Shader: Set Pixels to 9-tap box blur the current frame's Shadows\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = '#define USE_UV\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float pixelOffset;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\tgl_FragColor.rgb = (\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\n\t\t\t\t}`;\n\n      // Set the LightMap Accumulation Buffer\n      shader.uniforms.previousShadowMap = {\n        value: lightMap.texture\n      };\n      shader.uniforms.pixelOffset = {\n        value: 0.5 / res\n      };\n      blurMaterial.uniforms = shader.uniforms;\n\n      // Set the new Shader to this\n      blurMaterial.userData.shader = shader;\n    };\n    this.blurringPlane = new Mesh(new PlaneGeometry(1, 1), blurMaterial);\n    this.blurringPlane.name = 'Blurring Plane';\n    this.blurringPlane.frustumCulled = false;\n    this.blurringPlane.renderOrder = 0;\n    this.blurringPlane.material.depthWrite = false;\n    this.scene.add(this.blurringPlane);\n  }\n\n  /**\n   * Frees all internal resources.\n   */\n  dispose() {\n    this.progressiveLightMap1.dispose();\n    this.progressiveLightMap2.dispose();\n    this.uvMat.dispose();\n    if (this.blurringPlane !== null) {\n      this.blurringPlane.geometry.dispose();\n      this.blurringPlane.material.dispose();\n    }\n    if (this.labelMesh !== null) {\n      this.labelMesh.geometry.dispose();\n      this.labelMesh.material.dispose();\n    }\n  }\n}\nexport { ProgressiveLightMap };","map":{"version":3,"names":["DoubleSide","FloatType","HalfFloatType","Mesh","MeshBasicMaterial","MeshPhongMaterial","PlaneGeometry","Scene","WebGLRenderTarget","potpack","ProgressiveLightMap","constructor","renderer","res","lightMapContainers","scene","buffer1Active","firstUpdate","labelMesh","blurringPlane","format","test","navigator","userAgent","progressiveLightMap1","type","progressiveLightMap2","texture","channel","uvMat","uniforms","onBeforeCompile","shader","vertexShader","slice","bodyStart","fragmentShader","indexOf","previousShadowMap","value","averagingWindow","userData","addObjectsToLightMap","objects","uv_boxes","padding","ob","length","object","isLight","attach","geometry","hasAttribute","console","warn","_initializeBlurPlane","material","lightMap","dithering","castShadow","receiveShadow","renderOrder","push","w","h","index","basicMat","dimensions","forEach","box","uv1","getAttribute","clone","i","array","itemSize","x","y","setAttribute","needsUpdate","update","camera","blendWindow","blurEdges","oldTarget","getRenderTarget","visible","l","oldScene","parent","compile","oldFrustumCulled","frustumCulled","activeMap","inactiveMap","setRenderTarget","render","showDebugLightmap","position","undefined","labelMaterial","map","side","labelGeometry","add","copy","blurMaterial","pixelOffset","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","name","depthWrite","dispose"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/misc/ProgressiveLightMap.js"],"sourcesContent":["import { DoubleSide, FloatType, HalfFloatType, Mesh, MeshBasicMaterial, MeshPhongMaterial, PlaneGeometry, Scene, WebGLRenderTarget } from 'three';\nimport { potpack } from '../libs/potpack.module.js';\n\n/**\n * Progressive Light Map Accumulator, by [zalo]{@link https://github.com/zalo/}.\n *\n * To use, simply construct a `ProgressiveLightMap` object,\n * `plmap.addObjectsToLightMap(object)` an array of semi-static\n * objects and lights to the class once, and then call\n * `plmap.update(camera)` every frame to begin accumulating\n * lighting samples.\n *\n * This should begin accumulating lightmaps which apply to\n * your objects, so you can start jittering lighting to achieve\n * the texture-space effect you're looking for.\n *\n * This class can only be used with {@link WebGLRenderer}.\n * When using {@link WebGPURenderer}, import from `ProgressiveLightMapGPU.js`.\n *\n * @three_import import { ProgressiveLightMap } from 'three/addons/misc/ProgressiveLightMap.js';\n */\nclass ProgressiveLightMap {\n\n\t/**\n\t * Constructs a new progressive light map.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n \t * @param {number} [res=1024] - The side-long dimension of the total lightmap.\n\t */\n\tconstructor( renderer, res = 1024 ) {\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @type {WebGLRenderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * The side-long dimension of the total lightmap.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1024\n\t\t */\n\t\tthis.res = res;\n\n\t\t// internals\n\n\t\tthis.lightMapContainers = [];\n\t\tthis.scene = new Scene();\n\t\tthis.buffer1Active = false;\n\t\tthis.firstUpdate = true;\n\t\tthis.labelMesh = null;\n\t\tthis.blurringPlane = null;\n\n\t\t// Create the Progressive LightMap Texture\n\t\tconst format = /(Android|iPad|iPhone|iPod)/g.test( navigator.userAgent ) ? HalfFloatType : FloatType;\n\t\tthis.progressiveLightMap1 = new WebGLRenderTarget( this.res, this.res, { type: format } );\n\t\tthis.progressiveLightMap2 = new WebGLRenderTarget( this.res, this.res, { type: format } );\n\t\tthis.progressiveLightMap2.texture.channel = 1;\n\n\t\t// Inject some spicy new logic into a standard phong material\n\t\tthis.uvMat = new MeshPhongMaterial();\n\t\tthis.uvMat.uniforms = {};\n\t\tthis.uvMat.onBeforeCompile = ( shader ) => {\n\n\t\t\t// Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n\t\t\tshader.vertexShader =\n\t\t\t\t'attribute vec2 uv1;\\n' +\n\t\t\t\t'#define USE_LIGHTMAP\\n' +\n\t\t\t\t'#define LIGHTMAP_UV uv1\\n' +\n\t\t\t\tshader.vertexShader.slice( 0, - 1 ) +\n\t\t\t\t'\tgl_Position = vec4((LIGHTMAP_UV - 0.5) * 2.0, 1.0, 1.0); }';\n\n\t\t\t// Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n\t\t\tconst bodyStart = shader.fragmentShader.indexOf( 'void main() {' );\n\t\t\tshader.fragmentShader =\n\t\t\t\t'#define USE_LIGHTMAP\\n' +\n\t\t\t\tshader.fragmentShader.slice( 0, bodyStart ) +\n\t\t\t\t'\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' +\n\t\t\t\tshader.fragmentShader.slice( bodyStart - 1, - 1 ) +\n\t\t\t\t`\\nvec3 texelOld = texture2D(previousShadowMap, vLightMapUv).rgb;\n\t\t\t\tgl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n\t\t\t}`;\n\n\t\t\t// Set the Previous Frame's Texture Buffer and Averaging Window\n\t\t\tshader.uniforms.previousShadowMap = { value: this.progressiveLightMap1.texture };\n\t\t\tshader.uniforms.averagingWindow = { value: 100 };\n\n\t\t\tthis.uvMat.uniforms = shader.uniforms;\n\n\t\t\t// Set the new Shader to this\n\t\t\tthis.uvMat.userData.shader = shader;\n\n\t\t};\n\n\t}\n\n\t/**\n\t * Sets these objects' materials' lightmaps and modifies their uv1's.\n\t *\n\t * @param {Array<Object3D>} objects - An array of objects and lights to set up your lightmap.\n\t */\n\taddObjectsToLightMap( objects ) {\n\n\t\t// Prepare list of UV bounding boxes for packing later...\n\t\tthis.uv_boxes = []; const padding = 3 / this.res;\n\n\t\tfor ( let ob = 0; ob < objects.length; ob ++ ) {\n\n\t\t\tconst object = objects[ ob ];\n\n\t\t\t// If this object is a light, simply add it to the internal scene\n\t\t\tif ( object.isLight ) {\n\n\t\t\t\tthis.scene.attach( object ); continue;\n\n\t\t\t}\n\n\t\t\tif ( object.geometry.hasAttribute( 'uv' ) === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.ProgressiveLightMap: All lightmap objects need uvs.' ); continue;\n\n\t\t\t}\n\n\t\t\tif ( this.blurringPlane === null ) {\n\n\t\t\t\tthis._initializeBlurPlane( this.res, this.progressiveLightMap1 );\n\n\t\t\t}\n\n\t\t\t// Apply the lightmap to the object\n\t\t\tobject.material.lightMap = this.progressiveLightMap2.texture;\n\t\t\tobject.material.dithering = true;\n\t\t\tobject.castShadow = true;\n\t\t\tobject.receiveShadow = true;\n\t\t\tobject.renderOrder = 1000 + ob;\n\n\t\t\t// Prepare UV boxes for potpack\n\t\t\t// TODO: Size these by object surface area\n\t\t\tthis.uv_boxes.push( { w: 1 + ( padding * 2 ),\n\t\t\t\t\t\t\t\t  h: 1 + ( padding * 2 ), index: ob } );\n\n\t\t\tthis.lightMapContainers.push( { basicMat: object.material, object: object } );\n\n\t\t}\n\n\t\t// Pack the objects' lightmap UVs into the same global space\n\t\tconst dimensions = potpack( this.uv_boxes );\n\t\tthis.uv_boxes.forEach( ( box ) => {\n\n\t\t\tconst uv1 = objects[ box.index ].geometry.getAttribute( 'uv' ).clone();\n\t\t\tfor ( let i = 0; i < uv1.array.length; i += uv1.itemSize ) {\n\n\t\t\t\tuv1.array[ i ] = ( uv1.array[ i ] + box.x + padding ) / dimensions.w;\n\t\t\t\tuv1.array[ i + 1 ] = ( uv1.array[ i + 1 ] + box.y + padding ) / dimensions.h;\n\n\t\t\t}\n\n\t\t\tobjects[ box.index ].geometry.setAttribute( 'uv1', uv1 );\n\t\t\tobjects[ box.index ].geometry.getAttribute( 'uv1' ).needsUpdate = true;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * This function renders each mesh one at a time into their respective surface maps.\n\t *\n\t * @param {Camera} camera - The camera the scene is rendered with.\n\t * @param {number} [blendWindow=100] - When >1, samples will accumulate over time.\n\t * @param {boolean} [blurEdges=true] - Whether to fix UV Edges via blurring.\n\t */\n\tupdate( camera, blendWindow = 100, blurEdges = true ) {\n\n\t\tif ( this.blurringPlane === null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Store the original Render Target\n\t\tconst oldTarget = this.renderer.getRenderTarget();\n\n\t\t// The blurring plane applies blur to the seams of the lightmap\n\t\tthis.blurringPlane.visible = blurEdges;\n\n\t\t// Steal the Object3D from the real world to our special dimension\n\t\tfor ( let l = 0; l < this.lightMapContainers.length; l ++ ) {\n\n\t\t\tthis.lightMapContainers[ l ].object.oldScene =\n\t\t\t\tthis.lightMapContainers[ l ].object.parent;\n\t\t\tthis.scene.attach( this.lightMapContainers[ l ].object );\n\n\t\t}\n\n\t\t// Initialize everything\n\t\tif ( this.firstUpdate === true ) {\n\n\t\t\tthis.renderer.compile( this.scene, camera );\n\t\t\tthis.firstUpdate = false;\n\n\t\t}\n\n\t\t// Set each object's material to the UV Unwrapped Surface Mapping Version\n\t\tfor ( let l = 0; l < this.lightMapContainers.length; l ++ ) {\n\n\t\t\tthis.uvMat.uniforms.averagingWindow = { value: blendWindow };\n\t\t\tthis.lightMapContainers[ l ].object.material = this.uvMat;\n\t\t\tthis.lightMapContainers[ l ].object.oldFrustumCulled =\n\t\t\t\tthis.lightMapContainers[ l ].object.frustumCulled;\n\t\t\tthis.lightMapContainers[ l ].object.frustumCulled = false;\n\n\t\t}\n\n\t\t// Ping-pong two surface buffers for reading/writing\n\t\tconst activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n\t\tconst inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;\n\n\t\t// Render the object's surface maps\n\t\tthis.renderer.setRenderTarget( activeMap );\n\t\tthis.uvMat.uniforms.previousShadowMap = { value: inactiveMap.texture };\n\t\tthis.blurringPlane.material.uniforms.previousShadowMap = { value: inactiveMap.texture };\n\t\tthis.buffer1Active = ! this.buffer1Active;\n\t\tthis.renderer.render( this.scene, camera );\n\n\t\t// Restore the object's Real-time Material and add it back to the original world\n\t\tfor ( let l = 0; l < this.lightMapContainers.length; l ++ ) {\n\n\t\t\tthis.lightMapContainers[ l ].object.frustumCulled =\n\t\t\t\tthis.lightMapContainers[ l ].object.oldFrustumCulled;\n\t\t\tthis.lightMapContainers[ l ].object.material = this.lightMapContainers[ l ].basicMat;\n\t\t\tthis.lightMapContainers[ l ].object.oldScene.attach( this.lightMapContainers[ l ].object );\n\n\t\t}\n\n\t\t// Restore the original Render Target\n\t\tthis.renderer.setRenderTarget( oldTarget );\n\n\t}\n\n\t/**\n\t * Draws the lightmap in the main scene. Call this after adding the objects to it.\n\t *\n\t * @param {boolean} visible - Whether the debug plane should be visible\n\t * @param {Vector3} [position] - Where the debug plane should be drawn\n\t*/\n\tshowDebugLightmap( visible, position = undefined ) {\n\n\t\tif ( this.lightMapContainers.length === 0 ) {\n\n\t\t\tconsole.warn( 'THREE.ProgressiveLightMap: Call .showDebugLightmap() after adding the objects.' );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.labelMesh === null ) {\n\n\t\t\tconst labelMaterial = new MeshBasicMaterial( { map: this.progressiveLightMap1.texture, side: DoubleSide } );\n\t\t\tconst labelGeometry = new PlaneGeometry( 100, 100 );\n\t\t\tthis.labelMesh = new Mesh( labelGeometry, labelMaterial );\n\t\t\tthis.labelMesh.position.y = 250;\n\t\t\tthis.lightMapContainers[ 0 ].object.parent.add( this.labelMesh );\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.labelMesh.position.copy( position );\n\n\t\t}\n\n\t\tthis.labelMesh.visible = visible;\n\n\t}\n\n\t/**\n\t * Creates the Blurring Plane.\n\t *\n\t * @private\n\t * @param {number} res - The square resolution of this object's lightMap.\n\t * @param {WebGLRenderTarget} [lightMap] - The lightmap to initialize the plane with.\n\t */\n\t_initializeBlurPlane( res, lightMap = null ) {\n\n\t\tconst blurMaterial = new MeshBasicMaterial();\n\t\tblurMaterial.uniforms = { previousShadowMap: { value: null },\n\t\t\t\t\t\t\t\t  pixelOffset: { value: 1.0 / res },\n\t\t\t\t\t\t\t\t  polygonOffset: true, polygonOffsetFactor: - 1, polygonOffsetUnits: 3.0 };\n\t\tblurMaterial.onBeforeCompile = ( shader ) => {\n\n\t\t\t// Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n\t\t\tshader.vertexShader =\n\t\t\t\t'#define USE_UV\\n' +\n\t\t\t\tshader.vertexShader.slice( 0, - 1 ) +\n\t\t\t\t'\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }';\n\n\t\t\t// Fragment Shader: Set Pixels to 9-tap box blur the current frame's Shadows\n\t\t\tconst bodyStart\t= shader.fragmentShader.indexOf( 'void main() {' );\n\t\t\tshader.fragmentShader =\n\t\t\t\t'#define USE_UV\\n' +\n\t\t\t\tshader.fragmentShader.slice( 0, bodyStart ) +\n\t\t\t\t'\tuniform sampler2D previousShadowMap;\\n\tuniform float pixelOffset;\\n' +\n\t\t\t\tshader.fragmentShader.slice( bodyStart - 1, - 1 ) +\n\t\t\t\t\t`\tgl_FragColor.rgb = (\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\n\t\t\t\t}`;\n\n\t\t\t// Set the LightMap Accumulation Buffer\n\t\t\tshader.uniforms.previousShadowMap = { value: lightMap.texture };\n\t\t\tshader.uniforms.pixelOffset = { value: 0.5 / res };\n\t\t\tblurMaterial.uniforms = shader.uniforms;\n\n\t\t\t// Set the new Shader to this\n\t\t\tblurMaterial.userData.shader = shader;\n\n\t\t};\n\n\t\tthis.blurringPlane = new Mesh( new PlaneGeometry( 1, 1 ), blurMaterial );\n\t\tthis.blurringPlane.name = 'Blurring Plane';\n\t\tthis.blurringPlane.frustumCulled = false;\n\t\tthis.blurringPlane.renderOrder = 0;\n\t\tthis.blurringPlane.material.depthWrite = false;\n\t\tthis.scene.add( this.blurringPlane );\n\n\t}\n\n\t/**\n\t * Frees all internal resources.\n\t */\n\tdispose() {\n\n\t\tthis.progressiveLightMap1.dispose();\n\t\tthis.progressiveLightMap2.dispose();\n\n\t\tthis.uvMat.dispose();\n\n\t\tif ( this.blurringPlane !== null ) {\n\n\t\t\tthis.blurringPlane.geometry.dispose();\n\t\t\tthis.blurringPlane.material.dispose();\n\n\t\t}\n\n\t\tif ( this.labelMesh !== null ) {\n\n\t\t\tthis.labelMesh.geometry.dispose();\n\t\t\tthis.labelMesh.material.dispose();\n\n\t\t}\n\n\t}\n\n}\n\nexport { ProgressiveLightMap };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}