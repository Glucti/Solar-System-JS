{"ast":null,"code":"import { Controls, GridHelper, EllipseCurve, BufferGeometry, Line, LineBasicMaterial, Raycaster, Group, Box3, Sphere, Quaternion, Vector2, Vector3, Matrix4, MathUtils } from 'three';\n\n//trackball state\nconst STATE = {\n  IDLE: Symbol(),\n  ROTATE: Symbol(),\n  PAN: Symbol(),\n  SCALE: Symbol(),\n  FOV: Symbol(),\n  FOCUS: Symbol(),\n  ZROTATE: Symbol(),\n  TOUCH_MULTI: Symbol(),\n  ANIMATION_FOCUS: Symbol(),\n  ANIMATION_ROTATE: Symbol()\n};\nconst INPUT = {\n  NONE: Symbol(),\n  ONE_FINGER: Symbol(),\n  ONE_FINGER_SWITCHED: Symbol(),\n  TWO_FINGER: Symbol(),\n  MULT_FINGER: Symbol(),\n  CURSOR: Symbol()\n};\n\n//cursor center coordinates\nconst _center = {\n  x: 0,\n  y: 0\n};\n\n//transformation matrices for gizmos and camera\nconst _transformation = {\n  camera: new Matrix4(),\n  gizmos: new Matrix4()\n};\n\n/**\n * Fires when the camera has been transformed by the controls.\n *\n * @event ArcballControls#change\n * @type {Object}\n */\nconst _changeEvent = {\n  type: 'change'\n};\n\n/**\n * Fires when an interaction was initiated.\n *\n * @event ArcballControls#start\n * @type {Object}\n */\nconst _startEvent = {\n  type: 'start'\n};\n\n/**\n * Fires when an interaction has finished.\n *\n * @event ArcballControls#end\n * @type {Object}\n */\nconst _endEvent = {\n  type: 'end'\n};\nconst _raycaster = new Raycaster();\nconst _offset = new Vector3();\nconst _gizmoMatrixStateTemp = new Matrix4();\nconst _cameraMatrixStateTemp = new Matrix4();\nconst _scalePointTemp = new Vector3();\nconst _EPS = 0.000001;\n\n/**\n * Arcball controls allow the camera to be controlled by a virtual trackball with full touch support and advanced navigation functionality.\n * Cursor/finger positions and movements are mapped over a virtual trackball surface represented by a gizmo and mapped in intuitive and\n * consistent camera movements. Dragging cursor/fingers will cause camera to orbit around the center of the trackball in a conservative\n * way (returning to the starting point will make the camera return to its starting orientation).\n *\n * In addition to supporting pan, zoom and pinch gestures, Arcball controls provide focus< functionality with a double click/tap for intuitively\n * moving the object's point of interest in the center of the virtual trackball. Focus allows a much better inspection and navigation in complex\n * environment. Moreover Arcball controls allow FOV manipulation (in a vertigo-style method) and z-rotation. Saving and restoring of Camera State\n * is supported also through clipboard (use ctrl+c and ctrl+v shortcuts for copy and paste the state).\n *\n * Unlike {@link OrbitControls} and {@link TrackballControls}, `ArcballControls` doesn't require `update()` to be called externally in an\n * animation loop when animations are on.\n *\n * @augments Controls\n * @three_import import { ArcballControls } from 'three/addons/controls/ArcballControls.js';\n */\nclass ArcballControls extends Controls {\n  /**\n   * Constructs a new controls instance.\n   *\n   * @param {Camera} camera - The camera to be controlled. The camera must not be a child of another object, unless that object is the scene itself.\n   * @param {?HTMLDOMElement} [domElement=null] - The HTML element used for event listeners.\n   * @param {?Scene} [scene=null] The scene rendered by the camera. If not given, gizmos cannot be shown.\n   */\n  constructor(camera, domElement = null, scene = null) {\n    super(camera, domElement);\n\n    /**\n     * The scene rendered by the camera. If not given, gizmos cannot be shown.\n     *\n     * @type {?Scene}\n     * @default null\n     */\n    this.scene = scene;\n\n    /**\n     * The control's focus point.\n     *\n     * @type {Vector3}\n     */\n    this.target = new Vector3();\n    this._currentTarget = new Vector3();\n\n    /**\n     * The size of the gizmo relative to the screen width and height.\n     *\n     * @type {number}\n     * @default 0.67\n     */\n    this.radiusFactor = 0.67;\n\n    /**\n     * Holds the mouse actions of this controls. This property is maintained by the methods\n     * `setMouseAction()` and `unsetMouseAction()`.\n     *\n     * @type {Array<Object>}\n     */\n    this.mouseActions = [];\n    this._mouseOp = null;\n\n    //global vectors and matrices that are used in some operations to avoid creating new objects every time (e.g. every time cursor moves)\n    this._v2_1 = new Vector2();\n    this._v3_1 = new Vector3();\n    this._v3_2 = new Vector3();\n    this._m4_1 = new Matrix4();\n    this._m4_2 = new Matrix4();\n    this._quat = new Quaternion();\n\n    //transformation matrices\n    this._translationMatrix = new Matrix4(); //matrix for translation operation\n    this._rotationMatrix = new Matrix4(); //matrix for rotation operation\n    this._scaleMatrix = new Matrix4(); //matrix for scaling operation\n\n    this._rotationAxis = new Vector3(); //axis for rotate operation\n\n    //camera state\n    this._cameraMatrixState = new Matrix4();\n    this._cameraProjectionState = new Matrix4();\n    this._fovState = 1;\n    this._upState = new Vector3();\n    this._zoomState = 1;\n    this._nearPos = 0;\n    this._farPos = 0;\n    this._gizmoMatrixState = new Matrix4();\n\n    //initial values\n    this._up0 = new Vector3();\n    this._zoom0 = 1;\n    this._fov0 = 0;\n    this._initialNear = 0;\n    this._nearPos0 = 0;\n    this._initialFar = 0;\n    this._farPos0 = 0;\n    this._cameraMatrixState0 = new Matrix4();\n    this._gizmoMatrixState0 = new Matrix4();\n    this._target0 = new Vector3();\n\n    //pointers array\n    this._button = -1;\n    this._touchStart = [];\n    this._touchCurrent = [];\n    this._input = INPUT.NONE;\n\n    //two fingers touch interaction\n    this._switchSensibility = 32; //minimum movement to be performed to fire single pan start after the second finger has been released\n    this._startFingerDistance = 0; //distance between two fingers\n    this._currentFingerDistance = 0;\n    this._startFingerRotation = 0; //amount of rotation performed with two fingers\n    this._currentFingerRotation = 0;\n\n    //double tap\n    this._devPxRatio = 0;\n    this._downValid = true;\n    this._nclicks = 0;\n    this._downEvents = [];\n    this._downStart = 0; //pointerDown time\n    this._clickStart = 0; //first click time\n    this._maxDownTime = 250;\n    this._maxInterval = 300;\n    this._posThreshold = 24;\n    this._movementThreshold = 24;\n\n    //cursor positions\n    this._currentCursorPosition = new Vector3();\n    this._startCursorPosition = new Vector3();\n\n    //grid\n    this._grid = null; //grid to be visualized during pan operation\n    this._gridPosition = new Vector3();\n\n    //gizmos\n    this._gizmos = new Group();\n    this._curvePts = 128;\n\n    //animations\n    this._timeStart = -1; //initial time\n    this._animationId = -1;\n\n    /**\n     * Duration of focus animations in ms.\n     *\n     * @type {number}\n     * @default 500\n     */\n    this.focusAnimationTime = 500;\n\n    //rotate animation\n    this._timePrev = 0; //time at which previous rotate operation has been detected\n    this._timeCurrent = 0; //time at which current rotate operation has been detected\n    this._anglePrev = 0; //angle of previous rotation\n    this._angleCurrent = 0; //angle of current rotation\n    this._cursorPosPrev = new Vector3(); //cursor position when previous rotate operation has been detected\n    this._cursorPosCurr = new Vector3(); //cursor position when current rotate operation has been detected\n    this._wPrev = 0; //angular velocity of the previous rotate operation\n    this._wCurr = 0; //angular velocity of the current rotate operation\n\n    //parameters\n\n    /**\n     * If set to `true`, the camera's near and far values will be adjusted every time zoom is\n     * performed trying to maintain the same visible portion given by initial near and far\n     * values. Only works with perspective cameras.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    this.adjustNearFar = false;\n\n    /**\n     * The scaling factor used when performing zoom operation.\n     *\n     * @type {number}\n     * @default 1.1\n     */\n    this.scaleFactor = 1.1;\n\n    /**\n     * The damping inertia used if 'enableAnimations` is set to `true`.\n     *\n     * @type {number}\n     * @default 25\n     */\n    this.dampingFactor = 25;\n\n    /**\n     * Maximum angular velocity allowed on rotation animation start.\n     *\n     * @type {number}\n     * @default 20\n     */\n    this.wMax = 20;\n\n    /**\n     * Set to `true` to enable animations for rotation (damping) and focus operation.\n     *\n     * @type {boolean}\n     * @default true\n     */\n    this.enableAnimations = true;\n\n    /**\n     * If set to `true`, a grid will appear when panning operation is being performed\n     * (desktop interaction only).\n     *\n     * @type {boolean}\n     * @default false\n     */\n    this.enableGrid = false;\n\n    /**\n     * Set to `true` to make zoom become cursor centered.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    this.cursorZoom = false;\n\n    /**\n     * The minimum FOV in degrees.\n     *\n     * @type {number}\n     * @default 5\n     */\n    this.minFov = 5;\n\n    /**\n     * The maximum FOV in degrees.\n     *\n     * @type {number}\n     * @default 90\n     */\n    this.maxFov = 90;\n\n    /**\n     * Speed of rotation.\n     *\n     * @type {number}\n     * @default 1\n     */\n    this.rotateSpeed = 1;\n\n    /**\n     * Enable or disable camera panning.\n     *\n     * @type {boolean}\n     * @default true\n     */\n    this.enablePan = true;\n\n    /**\n     * Enable or disable camera rotation.\n     *\n     * @type {boolean}\n     * @default true\n     */\n    this.enableRotate = true;\n\n    /**\n     * Enable or disable camera zoom.\n     *\n     * @type {boolean}\n     * @default true\n     */\n    this.enableZoom = true;\n\n    /**\n     * Enable or disable gizmos.\n     *\n     * @type {boolean}\n     * @default true\n     */\n    this.enableGizmos = true;\n\n    /**\n     * Enable or disable camera focusing on double-tap (or click) operations.\n     *\n     * @type {boolean}\n     * @default true\n     */\n    this.enableFocus = true;\n\n    /**\n     * How far you can dolly in. For perspective cameras only.\n     *\n     * @type {number}\n     * @default 0\n     */\n    this.minDistance = 0;\n\n    /**\n     * How far you can dolly out. For perspective cameras only.\n     *\n     * @type {number}\n     * @default Infinity\n     */\n    this.maxDistance = Infinity;\n\n    /**\n     * How far you can zoom in. For orthographic cameras only.\n     *\n     * @type {number}\n     * @default 0\n     */\n    this.minZoom = 0;\n\n    /**\n     * How far you can zoom out. For orthographic cameras only.\n     *\n     * @type {number}\n     * @default Infinity\n     */\n    this.maxZoom = Infinity;\n\n    //trackball parameters\n    this._tbRadius = 1;\n\n    //FSA\n    this._state = STATE.IDLE;\n    this.setCamera(camera);\n    if (this.scene != null) {\n      this.scene.add(this._gizmos);\n    }\n    this.initializeMouseActions();\n\n    // event listeners\n\n    this._onContextMenu = onContextMenu.bind(this);\n    this._onWheel = onWheel.bind(this);\n    this._onPointerUp = onPointerUp.bind(this);\n    this._onPointerMove = onPointerMove.bind(this);\n    this._onPointerDown = onPointerDown.bind(this);\n    this._onPointerCancel = onPointerCancel.bind(this);\n    this._onWindowResize = onWindowResize.bind(this);\n    if (domElement !== null) {\n      this.connect(domElement);\n    }\n  }\n  connect(element) {\n    super.connect(element);\n    this.domElement.style.touchAction = 'none';\n    this._devPxRatio = window.devicePixelRatio;\n    this.domElement.addEventListener('contextmenu', this._onContextMenu);\n    this.domElement.addEventListener('wheel', this._onWheel);\n    this.domElement.addEventListener('pointerdown', this._onPointerDown);\n    this.domElement.addEventListener('pointercancel', this._onPointerCancel);\n    window.addEventListener('resize', this._onWindowResize);\n  }\n  disconnect() {\n    this.domElement.removeEventListener('pointerdown', this._onPointerDown);\n    this.domElement.removeEventListener('pointercancel', this._onPointerCancel);\n    this.domElement.removeEventListener('wheel', this._onWheel);\n    this.domElement.removeEventListener('contextmenu', this._onContextMenu);\n    window.removeEventListener('pointermove', this._onPointerMove);\n    window.removeEventListener('pointerup', this._onPointerUp);\n    window.removeEventListener('resize', this._onWindowResize);\n  }\n  onSinglePanStart(event, operation) {\n    if (this.enabled) {\n      this.dispatchEvent(_startEvent);\n      this.setCenter(event.clientX, event.clientY);\n      switch (operation) {\n        case 'PAN':\n          if (!this.enablePan) {\n            return;\n          }\n          if (this._animationId != -1) {\n            cancelAnimationFrame(this._animationId);\n            this._animationId = -1;\n            this._timeStart = -1;\n            this.activateGizmos(false);\n            this.dispatchEvent(_changeEvent);\n          }\n          this.updateTbState(STATE.PAN, true);\n          this._startCursorPosition.copy(this.unprojectOnTbPlane(this.object, _center.x, _center.y, this.domElement));\n          if (this.enableGrid) {\n            this.drawGrid();\n            this.dispatchEvent(_changeEvent);\n          }\n          break;\n        case 'ROTATE':\n          if (!this.enableRotate) {\n            return;\n          }\n          if (this._animationId != -1) {\n            cancelAnimationFrame(this._animationId);\n            this._animationId = -1;\n            this._timeStart = -1;\n          }\n          this.updateTbState(STATE.ROTATE, true);\n          this._startCursorPosition.copy(this.unprojectOnTbSurface(this.object, _center.x, _center.y, this.domElement, this._tbRadius));\n          this.activateGizmos(true);\n          if (this.enableAnimations) {\n            this._timePrev = this._timeCurrent = performance.now();\n            this._angleCurrent = this._anglePrev = 0;\n            this._cursorPosPrev.copy(this._startCursorPosition);\n            this._cursorPosCurr.copy(this._cursorPosPrev);\n            this._wCurr = 0;\n            this._wPrev = this._wCurr;\n          }\n          this.dispatchEvent(_changeEvent);\n          break;\n        case 'FOV':\n          if (!this.object.isPerspectiveCamera || !this.enableZoom) {\n            return;\n          }\n          if (this._animationId != -1) {\n            cancelAnimationFrame(this._animationId);\n            this._animationId = -1;\n            this._timeStart = -1;\n            this.activateGizmos(false);\n            this.dispatchEvent(_changeEvent);\n          }\n          this.updateTbState(STATE.FOV, true);\n          this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n          this._currentCursorPosition.copy(this._startCursorPosition);\n          break;\n        case 'ZOOM':\n          if (!this.enableZoom) {\n            return;\n          }\n          if (this._animationId != -1) {\n            cancelAnimationFrame(this._animationId);\n            this._animationId = -1;\n            this._timeStart = -1;\n            this.activateGizmos(false);\n            this.dispatchEvent(_changeEvent);\n          }\n          this.updateTbState(STATE.SCALE, true);\n          this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n          this._currentCursorPosition.copy(this._startCursorPosition);\n          break;\n      }\n    }\n  }\n  onSinglePanMove(event, opState) {\n    if (this.enabled) {\n      const restart = opState != this._state;\n      this.setCenter(event.clientX, event.clientY);\n      switch (opState) {\n        case STATE.PAN:\n          if (this.enablePan) {\n            if (restart) {\n              //switch to pan operation\n\n              this.dispatchEvent(_endEvent);\n              this.dispatchEvent(_startEvent);\n              this.updateTbState(opState, true);\n              this._startCursorPosition.copy(this.unprojectOnTbPlane(this.object, _center.x, _center.y, this.domElement));\n              if (this.enableGrid) {\n                this.drawGrid();\n              }\n              this.activateGizmos(false);\n            } else {\n              //continue with pan operation\n              this._currentCursorPosition.copy(this.unprojectOnTbPlane(this.object, _center.x, _center.y, this.domElement));\n              this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition));\n            }\n          }\n          break;\n        case STATE.ROTATE:\n          if (this.enableRotate) {\n            if (restart) {\n              //switch to rotate operation\n\n              this.dispatchEvent(_endEvent);\n              this.dispatchEvent(_startEvent);\n              this.updateTbState(opState, true);\n              this._startCursorPosition.copy(this.unprojectOnTbSurface(this.object, _center.x, _center.y, this.domElement, this._tbRadius));\n              if (this.enableGrid) {\n                this.disposeGrid();\n              }\n              this.activateGizmos(true);\n            } else {\n              //continue with rotate operation\n              this._currentCursorPosition.copy(this.unprojectOnTbSurface(this.object, _center.x, _center.y, this.domElement, this._tbRadius));\n              const distance = this._startCursorPosition.distanceTo(this._currentCursorPosition);\n              const angle = this._startCursorPosition.angleTo(this._currentCursorPosition);\n              const amount = Math.max(distance / this._tbRadius, angle) * this.rotateSpeed; //effective rotation angle\n\n              this.applyTransformMatrix(this.rotate(this.calculateRotationAxis(this._startCursorPosition, this._currentCursorPosition), amount));\n              if (this.enableAnimations) {\n                this._timePrev = this._timeCurrent;\n                this._timeCurrent = performance.now();\n                this._anglePrev = this._angleCurrent;\n                this._angleCurrent = amount;\n                this._cursorPosPrev.copy(this._cursorPosCurr);\n                this._cursorPosCurr.copy(this._currentCursorPosition);\n                this._wPrev = this._wCurr;\n                this._wCurr = this.calculateAngularSpeed(this._anglePrev, this._angleCurrent, this._timePrev, this._timeCurrent);\n              }\n            }\n          }\n          break;\n        case STATE.SCALE:\n          if (this.enableZoom) {\n            if (restart) {\n              //switch to zoom operation\n\n              this.dispatchEvent(_endEvent);\n              this.dispatchEvent(_startEvent);\n              this.updateTbState(opState, true);\n              this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n              this._currentCursorPosition.copy(this._startCursorPosition);\n              if (this.enableGrid) {\n                this.disposeGrid();\n              }\n              this.activateGizmos(false);\n            } else {\n              //continue with zoom operation\n              const screenNotches = 8; //how many wheel notches corresponds to a full screen pan\n              this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n              const movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n              let size = 1;\n              if (movement < 0) {\n                size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);\n              } else if (movement > 0) {\n                size = Math.pow(this.scaleFactor, movement * screenNotches);\n              }\n              this._v3_1.setFromMatrixPosition(this._gizmoMatrixState);\n              this.applyTransformMatrix(this.scale(size, this._v3_1));\n            }\n          }\n          break;\n        case STATE.FOV:\n          if (this.enableZoom && this.object.isPerspectiveCamera) {\n            if (restart) {\n              //switch to fov operation\n\n              this.dispatchEvent(_endEvent);\n              this.dispatchEvent(_startEvent);\n              this.updateTbState(opState, true);\n              this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n              this._currentCursorPosition.copy(this._startCursorPosition);\n              if (this.enableGrid) {\n                this.disposeGrid();\n              }\n              this.activateGizmos(false);\n            } else {\n              //continue with fov operation\n              const screenNotches = 8; //how many wheel notches corresponds to a full screen pan\n              this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n              const movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n              let size = 1;\n              if (movement < 0) {\n                size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);\n              } else if (movement > 0) {\n                size = Math.pow(this.scaleFactor, movement * screenNotches);\n              }\n              this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n              const x = this._v3_1.distanceTo(this._gizmos.position);\n              let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n              //check min and max distance\n              xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);\n              const y = x * Math.tan(MathUtils.DEG2RAD * this._fovState * 0.5);\n\n              //calculate new fov\n              let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2);\n\n              //check min and max fov\n              newFov = MathUtils.clamp(newFov, this.minFov, this.maxFov);\n              const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n              size = x / newDistance;\n              this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\n              this.setFov(newFov);\n              this.applyTransformMatrix(this.scale(size, this._v3_2, false));\n\n              //adjusting distance\n              _offset.copy(this._gizmos.position).sub(this.object.position).normalize().multiplyScalar(newDistance / x);\n              this._m4_1.makeTranslation(_offset.x, _offset.y, _offset.z);\n            }\n          }\n          break;\n      }\n      this.dispatchEvent(_changeEvent);\n    }\n  }\n  onSinglePanEnd() {\n    if (this._state == STATE.ROTATE) {\n      if (!this.enableRotate) {\n        return;\n      }\n      if (this.enableAnimations) {\n        //perform rotation animation\n        const deltaTime = performance.now() - this._timeCurrent;\n        if (deltaTime < 120) {\n          const w = Math.abs((this._wPrev + this._wCurr) / 2);\n          const self = this;\n          this._animationId = window.requestAnimationFrame(function (t) {\n            self.updateTbState(STATE.ANIMATION_ROTATE, true);\n            const rotationAxis = self.calculateRotationAxis(self._cursorPosPrev, self._cursorPosCurr);\n            self.onRotationAnim(t, rotationAxis, Math.min(w, self.wMax));\n          });\n        } else {\n          //cursor has been standing still for over 120 ms since last movement\n          this.updateTbState(STATE.IDLE, false);\n          this.activateGizmos(false);\n          this.dispatchEvent(_changeEvent);\n        }\n      } else {\n        this.updateTbState(STATE.IDLE, false);\n        this.activateGizmos(false);\n        this.dispatchEvent(_changeEvent);\n      }\n    } else if (this._state == STATE.PAN || this._state == STATE.IDLE) {\n      this.updateTbState(STATE.IDLE, false);\n      if (this.enableGrid) {\n        this.disposeGrid();\n      }\n      this.activateGizmos(false);\n      this.dispatchEvent(_changeEvent);\n    }\n    this.dispatchEvent(_endEvent);\n  }\n  onDoubleTap(event) {\n    if (this.enabled && this.enablePan && this.enableFocus && this.scene != null) {\n      this.dispatchEvent(_startEvent);\n      this.setCenter(event.clientX, event.clientY);\n      const hitP = this.unprojectOnObj(this.getCursorNDC(_center.x, _center.y, this.domElement), this.object);\n      if (hitP != null && this.enableAnimations) {\n        const self = this;\n        if (this._animationId != -1) {\n          window.cancelAnimationFrame(this._animationId);\n        }\n        this._timeStart = -1;\n        this._animationId = window.requestAnimationFrame(function (t) {\n          self.updateTbState(STATE.ANIMATION_FOCUS, true);\n          self.onFocusAnim(t, hitP, self._cameraMatrixState, self._gizmoMatrixState);\n        });\n      } else if (hitP != null && !this.enableAnimations) {\n        this.updateTbState(STATE.FOCUS, true);\n        this.focus(hitP, this.scaleFactor);\n        this.updateTbState(STATE.IDLE, false);\n        this.dispatchEvent(_changeEvent);\n      }\n    }\n    this.dispatchEvent(_endEvent);\n  }\n  onDoublePanStart() {\n    if (this.enabled && this.enablePan) {\n      this.dispatchEvent(_startEvent);\n      this.updateTbState(STATE.PAN, true);\n      this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n      this._startCursorPosition.copy(this.unprojectOnTbPlane(this.object, _center.x, _center.y, this.domElement, true));\n      this._currentCursorPosition.copy(this._startCursorPosition);\n      this.activateGizmos(false);\n    }\n  }\n  onDoublePanMove() {\n    if (this.enabled && this.enablePan) {\n      this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n      if (this._state != STATE.PAN) {\n        this.updateTbState(STATE.PAN, true);\n        this._startCursorPosition.copy(this._currentCursorPosition);\n      }\n      this._currentCursorPosition.copy(this.unprojectOnTbPlane(this.object, _center.x, _center.y, this.domElement, true));\n      this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition, true));\n      this.dispatchEvent(_changeEvent);\n    }\n  }\n  onDoublePanEnd() {\n    this.updateTbState(STATE.IDLE, false);\n    this.dispatchEvent(_endEvent);\n  }\n  onRotateStart() {\n    if (this.enabled && this.enableRotate) {\n      this.dispatchEvent(_startEvent);\n      this.updateTbState(STATE.ZROTATE, true);\n\n      //this._startFingerRotation = event.rotation;\n\n      this._startFingerRotation = this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) + this.getAngle(this._touchStart[1], this._touchStart[0]);\n      this._currentFingerRotation = this._startFingerRotation;\n      this.object.getWorldDirection(this._rotationAxis); //rotation axis\n\n      if (!this.enablePan && !this.enableZoom) {\n        this.activateGizmos(true);\n      }\n    }\n  }\n  onRotateMove() {\n    if (this.enabled && this.enableRotate) {\n      this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n      let rotationPoint;\n      if (this._state != STATE.ZROTATE) {\n        this.updateTbState(STATE.ZROTATE, true);\n        this._startFingerRotation = this._currentFingerRotation;\n      }\n\n      //this._currentFingerRotation = event.rotation;\n      this._currentFingerRotation = this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) + this.getAngle(this._touchStart[1], this._touchStart[0]);\n      if (!this.enablePan) {\n        rotationPoint = new Vector3().setFromMatrixPosition(this._gizmoMatrixState);\n      } else {\n        this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\n        rotationPoint = this.unprojectOnTbPlane(this.object, _center.x, _center.y, this.domElement).applyQuaternion(this.object.quaternion).multiplyScalar(1 / this.object.zoom).add(this._v3_2);\n      }\n      const amount = MathUtils.DEG2RAD * (this._startFingerRotation - this._currentFingerRotation);\n      this.applyTransformMatrix(this.zRotate(rotationPoint, amount));\n      this.dispatchEvent(_changeEvent);\n    }\n  }\n  onRotateEnd() {\n    this.updateTbState(STATE.IDLE, false);\n    this.activateGizmos(false);\n    this.dispatchEvent(_endEvent);\n  }\n  onPinchStart() {\n    if (this.enabled && this.enableZoom) {\n      this.dispatchEvent(_startEvent);\n      this.updateTbState(STATE.SCALE, true);\n      this._startFingerDistance = this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1]);\n      this._currentFingerDistance = this._startFingerDistance;\n      this.activateGizmos(false);\n    }\n  }\n  onPinchMove() {\n    if (this.enabled && this.enableZoom) {\n      this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n      const minDistance = 12; //minimum distance between fingers (in css pixels)\n\n      if (this._state != STATE.SCALE) {\n        this._startFingerDistance = this._currentFingerDistance;\n        this.updateTbState(STATE.SCALE, true);\n      }\n      this._currentFingerDistance = Math.max(this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1]), minDistance * this._devPxRatio);\n      const amount = this._currentFingerDistance / this._startFingerDistance;\n      let scalePoint;\n      if (!this.enablePan) {\n        scalePoint = this._gizmos.position;\n      } else {\n        if (this.object.isOrthographicCamera) {\n          scalePoint = this.unprojectOnTbPlane(this.object, _center.x, _center.y, this.domElement).applyQuaternion(this.object.quaternion).multiplyScalar(1 / this.object.zoom).add(this._gizmos.position);\n        } else if (this.object.isPerspectiveCamera) {\n          scalePoint = this.unprojectOnTbPlane(this.object, _center.x, _center.y, this.domElement).applyQuaternion(this.object.quaternion).add(this._gizmos.position);\n        }\n      }\n      this.applyTransformMatrix(this.scale(amount, scalePoint));\n      this.dispatchEvent(_changeEvent);\n    }\n  }\n  onPinchEnd() {\n    this.updateTbState(STATE.IDLE, false);\n    this.dispatchEvent(_endEvent);\n  }\n  onTriplePanStart() {\n    if (this.enabled && this.enableZoom) {\n      this.dispatchEvent(_startEvent);\n      this.updateTbState(STATE.SCALE, true);\n\n      //const center = event.center;\n      let clientX = 0;\n      let clientY = 0;\n      const nFingers = this._touchCurrent.length;\n      for (let i = 0; i < nFingers; i++) {\n        clientX += this._touchCurrent[i].clientX;\n        clientY += this._touchCurrent[i].clientY;\n      }\n      this.setCenter(clientX / nFingers, clientY / nFingers);\n      this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n      this._currentCursorPosition.copy(this._startCursorPosition);\n    }\n  }\n  onTriplePanMove() {\n    if (this.enabled && this.enableZoom) {\n      //\t  fov / 2\n      //\t\t|\\\n      //\t\t| \\\n      //\t\t|  \\\n      //\tx\t|\t\\\n      //\t\t| \t \\\n      //\t\t| \t  \\\n      //\t\t| _ _ _\\\n      //\t\t\ty\n\n      //const center = event.center;\n      let clientX = 0;\n      let clientY = 0;\n      const nFingers = this._touchCurrent.length;\n      for (let i = 0; i < nFingers; i++) {\n        clientX += this._touchCurrent[i].clientX;\n        clientY += this._touchCurrent[i].clientY;\n      }\n      this.setCenter(clientX / nFingers, clientY / nFingers);\n      const screenNotches = 8; //how many wheel notches corresponds to a full screen pan\n      this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n      const movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n      let size = 1;\n      if (movement < 0) {\n        size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);\n      } else if (movement > 0) {\n        size = Math.pow(this.scaleFactor, movement * screenNotches);\n      }\n      this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n      const x = this._v3_1.distanceTo(this._gizmos.position);\n      let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n      //check min and max distance\n      xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);\n      const y = x * Math.tan(MathUtils.DEG2RAD * this._fovState * 0.5);\n\n      //calculate new fov\n      let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2);\n\n      //check min and max fov\n      newFov = MathUtils.clamp(newFov, this.minFov, this.maxFov);\n      const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n      size = x / newDistance;\n      this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\n      this.setFov(newFov);\n      this.applyTransformMatrix(this.scale(size, this._v3_2, false));\n\n      //adjusting distance\n      _offset.copy(this._gizmos.position).sub(this.object.position).normalize().multiplyScalar(newDistance / x);\n      this._m4_1.makeTranslation(_offset.x, _offset.y, _offset.z);\n      this.dispatchEvent(_changeEvent);\n    }\n  }\n  onTriplePanEnd() {\n    this.updateTbState(STATE.IDLE, false);\n    this.dispatchEvent(_endEvent);\n    //this.dispatchEvent( _changeEvent );\n  }\n\n  /**\n   * Set _center's x/y coordinates.\n   *\n   * @private\n   * @param {number} clientX - The x coordinate.\n   * @param {number} clientY - The y coordinate.\n   */\n  setCenter(clientX, clientY) {\n    _center.x = clientX;\n    _center.y = clientY;\n  }\n\n  /**\n   * Set default mouse actions.\n   *\n   * @private\n   */\n  initializeMouseActions() {\n    this.setMouseAction('PAN', 0, 'CTRL');\n    this.setMouseAction('PAN', 2);\n    this.setMouseAction('ROTATE', 0);\n    this.setMouseAction('ZOOM', 'WHEEL');\n    this.setMouseAction('ZOOM', 1);\n    this.setMouseAction('FOV', 'WHEEL', 'SHIFT');\n    this.setMouseAction('FOV', 1, 'SHIFT');\n  }\n\n  /**\n   * Compare two mouse actions.\n   *\n   * @private\n   * @param {Object} action1 - The first mouse action.\n   * @param {Object} action2 - The second mouse action.\n   * @returns {boolean} `true` if action1 and action 2 are the same mouse action, `false` otherwise.\n   */\n  compareMouseAction(action1, action2) {\n    if (action1.operation == action2.operation) {\n      if (action1.mouse == action2.mouse && action1.key == action2.key) {\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Set a new mouse action by specifying the operation to be performed and a mouse/key combination. In case of conflict, replaces the existing one.\n   *\n   * @param {'PAN'|'ROTATE'|'ZOOM'|'FOV'} operation - The operation to be performed ('PAN', 'ROTATE', 'ZOOM', 'FOV').\n   * @param {0|1|2|'WHEEL'} mouse - A mouse button (0, 1, 2) or 'WHEEL' for wheel notches.\n   * @param {'CTRL'|'SHIFT'|null} [key=null] - The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed.\n   * @returns {boolean} `true` if the mouse action has been successfully added, `false` otherwise.\n   */\n  setMouseAction(operation, mouse, key = null) {\n    const operationInput = ['PAN', 'ROTATE', 'ZOOM', 'FOV'];\n    const mouseInput = [0, 1, 2, 'WHEEL'];\n    const keyInput = ['CTRL', 'SHIFT', null];\n    let state;\n    if (!operationInput.includes(operation) || !mouseInput.includes(mouse) || !keyInput.includes(key)) {\n      //invalid parameters\n      return false;\n    }\n    if (mouse == 'WHEEL') {\n      if (operation != 'ZOOM' && operation != 'FOV') {\n        //cannot associate 2D operation to 1D input\n        return false;\n      }\n    }\n    switch (operation) {\n      case 'PAN':\n        state = STATE.PAN;\n        break;\n      case 'ROTATE':\n        state = STATE.ROTATE;\n        break;\n      case 'ZOOM':\n        state = STATE.SCALE;\n        break;\n      case 'FOV':\n        state = STATE.FOV;\n        break;\n    }\n    const action = {\n      operation: operation,\n      mouse: mouse,\n      key: key,\n      state: state\n    };\n    for (let i = 0; i < this.mouseActions.length; i++) {\n      if (this.mouseActions[i].mouse == action.mouse && this.mouseActions[i].key == action.key) {\n        this.mouseActions.splice(i, 1, action);\n        return true;\n      }\n    }\n    this.mouseActions.push(action);\n    return true;\n  }\n\n  /**\n   * Remove a mouse action by specifying its mouse/key combination.\n   *\n   * @param {0|1|2|'WHEEL'} mouse - A mouse button (0, 1, 2) or 'WHEEL' for wheel notches.\n   * @param {'CTRL'|'SHIFT'|null} key - The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed.\n   * @returns {boolean} `true` if the operation has been successfully removed, `false` otherwise.\n   */\n  unsetMouseAction(mouse, key = null) {\n    for (let i = 0; i < this.mouseActions.length; i++) {\n      if (this.mouseActions[i].mouse == mouse && this.mouseActions[i].key == key) {\n        this.mouseActions.splice(i, 1);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Return the operation associated to a mouse/keyboard combination.\n   *\n   * @private\n   * @param {0|1|2|'WHEEL'} mouse - Mouse button index (0, 1, 2) or 'WHEEL' for wheel notches.\n   * @param {'CTRL'|'SHIFT'|null} key - Keyboard modifier.\n   * @returns {'PAN'|'ROTATE'|'ZOOM'|'FOV'|null} The operation if it has been found, `null` otherwise.\n   */\n  getOpFromAction(mouse, key) {\n    let action;\n    for (let i = 0; i < this.mouseActions.length; i++) {\n      action = this.mouseActions[i];\n      if (action.mouse == mouse && action.key == key) {\n        return action.operation;\n      }\n    }\n    if (key != null) {\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        action = this.mouseActions[i];\n        if (action.mouse == mouse && action.key == null) {\n          return action.operation;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Get the operation associated to mouse and key combination and returns the corresponding FSA state.\n   *\n   * @private\n   * @param {0|1|2} mouse - Mouse button index (0, 1, 2)\n   * @param {'CTRL'|'SHIFT'|null} key - Keyboard modifier\n   * @returns {?STATE} The FSA state obtained from the operation associated to mouse/keyboard combination.\n   */\n  getOpStateFromAction(mouse, key) {\n    let action;\n    for (let i = 0; i < this.mouseActions.length; i++) {\n      action = this.mouseActions[i];\n      if (action.mouse == mouse && action.key == key) {\n        return action.state;\n      }\n    }\n    if (key != null) {\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        action = this.mouseActions[i];\n        if (action.mouse == mouse && action.key == null) {\n          return action.state;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Calculate the angle between two pointers.\n   *\n   * @private\n   * @param {PointerEvent} p1 - The first pointer event.\n   * @param {PointerEvent} p2 - The second pointer event.\n   * @returns {number} The angle between two pointers in degrees.\n   */\n  getAngle(p1, p2) {\n    return Math.atan2(p2.clientY - p1.clientY, p2.clientX - p1.clientX) * 180 / Math.PI;\n  }\n\n  /**\n   * Updates a PointerEvent inside current pointerevents array.\n   *\n   * @private\n   * @param {PointerEvent} event - The pointer event.\n   */\n  updateTouchEvent(event) {\n    for (let i = 0; i < this._touchCurrent.length; i++) {\n      if (this._touchCurrent[i].pointerId == event.pointerId) {\n        this._touchCurrent.splice(i, 1, event);\n        break;\n      }\n    }\n  }\n\n  /**\n   * Applies a transformation matrix, to the camera and gizmos.\n   *\n   * @private\n   * @param {Object} transformation - Object containing matrices to apply to camera and gizmos.\n   */\n  applyTransformMatrix(transformation) {\n    if (transformation.camera != null) {\n      this._m4_1.copy(this._cameraMatrixState).premultiply(transformation.camera);\n      this._m4_1.decompose(this.object.position, this.object.quaternion, this.object.scale);\n      this.object.updateMatrix();\n\n      //update camera up vector\n      if (this._state == STATE.ROTATE || this._state == STATE.ZROTATE || this._state == STATE.ANIMATION_ROTATE) {\n        this.object.up.copy(this._upState).applyQuaternion(this.object.quaternion);\n      }\n    }\n    if (transformation.gizmos != null) {\n      this._m4_1.copy(this._gizmoMatrixState).premultiply(transformation.gizmos);\n      this._m4_1.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n      this._gizmos.updateMatrix();\n    }\n    if (this._state == STATE.SCALE || this._state == STATE.FOCUS || this._state == STATE.ANIMATION_FOCUS) {\n      this._tbRadius = this.calculateTbRadius(this.object);\n      if (this.adjustNearFar) {\n        const cameraDistance = this.object.position.distanceTo(this._gizmos.position);\n        const bb = new Box3();\n        bb.setFromObject(this._gizmos);\n        const sphere = new Sphere();\n        bb.getBoundingSphere(sphere);\n        const adjustedNearPosition = Math.max(this._nearPos0, sphere.radius + sphere.center.length());\n        const regularNearPosition = cameraDistance - this._initialNear;\n        const minNearPos = Math.min(adjustedNearPosition, regularNearPosition);\n        this.object.near = cameraDistance - minNearPos;\n        const adjustedFarPosition = Math.min(this._farPos0, -sphere.radius + sphere.center.length());\n        const regularFarPosition = cameraDistance - this._initialFar;\n        const minFarPos = Math.min(adjustedFarPosition, regularFarPosition);\n        this.object.far = cameraDistance - minFarPos;\n        this.object.updateProjectionMatrix();\n      } else {\n        let update = false;\n        if (this.object.near != this._initialNear) {\n          this.object.near = this._initialNear;\n          update = true;\n        }\n        if (this.object.far != this._initialFar) {\n          this.object.far = this._initialFar;\n          update = true;\n        }\n        if (update) {\n          this.object.updateProjectionMatrix();\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculates the angular speed.\n   *\n   * @private\n   * @param {number} p0 - Position at t0.\n   * @param {number} p1 - Position at t1.\n   * @param {number} t0 - Initial time in milliseconds.\n   * @param {number} t1 - Ending time in milliseconds.\n   * @returns {number} The angular speed.\n   */\n  calculateAngularSpeed(p0, p1, t0, t1) {\n    const s = p1 - p0;\n    const t = (t1 - t0) / 1000;\n    if (t == 0) {\n      return 0;\n    }\n    return s / t;\n  }\n\n  /**\n   * Calculates the distance between two pointers.\n   *\n   * @private\n   * @param {PointerEvent} p0 - The first pointer.\n   * @param {PointerEvent} p1 - The second pointer.\n   * @returns {number} The distance between the two pointers.\n   */\n  calculatePointersDistance(p0, p1) {\n    return Math.sqrt(Math.pow(p1.clientX - p0.clientX, 2) + Math.pow(p1.clientY - p0.clientY, 2));\n  }\n\n  /**\n   * Calculates the rotation axis as the vector perpendicular between two vectors.\n   *\n   * @private\n   * @param {Vector3} vec1 - The first vector.\n   * @param {Vector3} vec2 - The second vector.\n   * @returns {Vector3} The normalized rotation axis.\n   */\n  calculateRotationAxis(vec1, vec2) {\n    this._rotationMatrix.extractRotation(this._cameraMatrixState);\n    this._quat.setFromRotationMatrix(this._rotationMatrix);\n    this._rotationAxis.crossVectors(vec1, vec2).applyQuaternion(this._quat);\n    return this._rotationAxis.normalize().clone();\n  }\n\n  /**\n   * Calculates the trackball radius so that gizmo's diameter will be 2/3 of the minimum side of the camera frustum.\n   *\n   * @private\n   * @param {Camera} camera - The camera.\n   * @returns {number} The trackball radius.\n   */\n  calculateTbRadius(camera) {\n    const distance = camera.position.distanceTo(this._gizmos.position);\n    if (camera.type == 'PerspectiveCamera') {\n      const halfFovV = MathUtils.DEG2RAD * camera.fov * 0.5; //vertical fov/2 in radians\n      const halfFovH = Math.atan(camera.aspect * Math.tan(halfFovV)); //horizontal fov/2 in radians\n      return Math.tan(Math.min(halfFovV, halfFovH)) * distance * this.radiusFactor;\n    } else if (camera.type == 'OrthographicCamera') {\n      return Math.min(camera.top, camera.right) * this.radiusFactor;\n    }\n  }\n\n  /**\n   * Focus operation consist of positioning the point of interest in front of the camera and a slightly zoom in.\n   *\n   * @private\n   * @param {Vector3} point - The point of interest.\n   * @param {number} size - Scale factor.\n   * @param {number} [amount=1] - Amount of operation to be completed (used for focus animations, default is complete full operation).\n   */\n  focus(point, size, amount = 1) {\n    //move center of camera (along with gizmos) towards point of interest\n    _offset.copy(point).sub(this._gizmos.position).multiplyScalar(amount);\n    this._translationMatrix.makeTranslation(_offset.x, _offset.y, _offset.z);\n    _gizmoMatrixStateTemp.copy(this._gizmoMatrixState);\n    this._gizmoMatrixState.premultiply(this._translationMatrix);\n    this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n    _cameraMatrixStateTemp.copy(this._cameraMatrixState);\n    this._cameraMatrixState.premultiply(this._translationMatrix);\n    this._cameraMatrixState.decompose(this.object.position, this.object.quaternion, this.object.scale);\n\n    //apply zoom\n    if (this.enableZoom) {\n      this.applyTransformMatrix(this.scale(size, this._gizmos.position));\n    }\n    this._gizmoMatrixState.copy(_gizmoMatrixStateTemp);\n    this._cameraMatrixState.copy(_cameraMatrixStateTemp);\n  }\n\n  /**\n   * Creates a grid if necessary and adds it to the scene.\n   *\n   * @private\n   */\n  drawGrid() {\n    if (this.scene != null) {\n      const color = 0x888888;\n      const multiplier = 3;\n      let size, divisions, maxLength, tick;\n      if (this.object.isOrthographicCamera) {\n        const width = this.object.right - this.object.left;\n        const height = this.object.bottom - this.object.top;\n        maxLength = Math.max(width, height);\n        tick = maxLength / 20;\n        size = maxLength / this.object.zoom * multiplier;\n        divisions = size / tick * this.object.zoom;\n      } else if (this.object.isPerspectiveCamera) {\n        const distance = this.object.position.distanceTo(this._gizmos.position);\n        const halfFovV = MathUtils.DEG2RAD * this.object.fov * 0.5;\n        const halfFovH = Math.atan(this.object.aspect * Math.tan(halfFovV));\n        maxLength = Math.tan(Math.max(halfFovV, halfFovH)) * distance * 2;\n        tick = maxLength / 20;\n        size = maxLength * multiplier;\n        divisions = size / tick;\n      }\n      if (this._grid == null) {\n        this._grid = new GridHelper(size, divisions, color, color);\n        this._grid.position.copy(this._gizmos.position);\n        this._gridPosition.copy(this._grid.position);\n        this._grid.quaternion.copy(this.object.quaternion);\n        this._grid.rotateX(Math.PI * 0.5);\n        this.scene.add(this._grid);\n      }\n    }\n  }\n  dispose() {\n    if (this._animationId != -1) {\n      window.cancelAnimationFrame(this._animationId);\n    }\n    this.disconnect();\n    if (this.scene !== null) this.scene.remove(this._gizmos);\n    this.disposeGrid();\n  }\n\n  /**\n   * Removes the grid from the scene.\n   */\n  disposeGrid() {\n    if (this._grid != null && this.scene != null) {\n      this.scene.remove(this._grid);\n      this._grid = null;\n    }\n  }\n\n  /**\n   * Computes the easing out cubic function for ease out effect in animation.\n   *\n   * @private\n   * @param {number} t - The absolute progress of the animation in the bound of `0` (beginning of the) and `1` (ending of animation).\n   * @returns {number} Result of easing out cubic at time `t`.\n   */\n  easeOutCubic(t) {\n    return 1 - Math.pow(1 - t, 3);\n  }\n\n  /**\n   * Makes rotation gizmos more or less visible.\n   *\n   * @param {boolean} isActive - If set to `true`, gizmos are more visible.\n   */\n  activateGizmos(isActive) {\n    const gizmoX = this._gizmos.children[0];\n    const gizmoY = this._gizmos.children[1];\n    const gizmoZ = this._gizmos.children[2];\n    if (isActive) {\n      gizmoX.material.setValues({\n        opacity: 1\n      });\n      gizmoY.material.setValues({\n        opacity: 1\n      });\n      gizmoZ.material.setValues({\n        opacity: 1\n      });\n    } else {\n      gizmoX.material.setValues({\n        opacity: 0.6\n      });\n      gizmoY.material.setValues({\n        opacity: 0.6\n      });\n      gizmoZ.material.setValues({\n        opacity: 0.6\n      });\n    }\n  }\n\n  /**\n   * Calculates the cursor position in NDC.\n   *\n   * @private\n   * @param {number} cursorX - Cursor horizontal coordinate within the canvas.\n   * @param {number} cursorY - Cursor vertical coordinate within the canvas.\n   * @param {HTMLElement} canvas - The canvas where the renderer draws its output.\n   * @returns {Vector2} Cursor normalized position inside the canvas.\n   */\n  getCursorNDC(cursorX, cursorY, canvas) {\n    const canvasRect = canvas.getBoundingClientRect();\n    this._v2_1.setX((cursorX - canvasRect.left) / canvasRect.width * 2 - 1);\n    this._v2_1.setY((canvasRect.bottom - cursorY) / canvasRect.height * 2 - 1);\n    return this._v2_1.clone();\n  }\n\n  /**\n   * Calculates the cursor position inside the canvas x/y coordinates with the origin being in the center of the canvas.\n   *\n   * @private\n   * @param {number} cursorX - Cursor horizontal coordinate within the canvas.\n   * @param {number} cursorY - Cursor vertical coordinate within the canvas.\n   * @param {HTMLElement} canvas - The canvas where the renderer draws its output.\n   * @returns {Vector2} Cursor position inside the canvas.\n   */\n  getCursorPosition(cursorX, cursorY, canvas) {\n    this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas));\n    this._v2_1.x *= (this.object.right - this.object.left) * 0.5;\n    this._v2_1.y *= (this.object.top - this.object.bottom) * 0.5;\n    return this._v2_1.clone();\n  }\n\n  /**\n   * Sets the camera to be controlled.  Must be called in order to set a new camera to be controlled.\n   *\n   * @param {Camera} camera - The camera to be controlled.\n   */\n  setCamera(camera) {\n    camera.lookAt(this.target);\n    camera.updateMatrix();\n\n    //setting state\n    if (camera.type == 'PerspectiveCamera') {\n      this._fov0 = camera.fov;\n      this._fovState = camera.fov;\n    }\n    this._cameraMatrixState0.copy(camera.matrix);\n    this._cameraMatrixState.copy(this._cameraMatrixState0);\n    this._cameraProjectionState.copy(camera.projectionMatrix);\n    this._zoom0 = camera.zoom;\n    this._zoomState = this._zoom0;\n    this._initialNear = camera.near;\n    this._nearPos0 = camera.position.distanceTo(this.target) - camera.near;\n    this._nearPos = this._initialNear;\n    this._initialFar = camera.far;\n    this._farPos0 = camera.position.distanceTo(this.target) - camera.far;\n    this._farPos = this._initialFar;\n    this._up0.copy(camera.up);\n    this._upState.copy(camera.up);\n    this.object = camera;\n    this.object.updateProjectionMatrix();\n\n    //making gizmos\n    this._tbRadius = this.calculateTbRadius(camera);\n    this.makeGizmos(this.target, this._tbRadius);\n  }\n\n  /**\n   * Sets gizmos visibility.\n   *\n   * @param {boolean} value - Value of gizmos visibility.\n   */\n  setGizmosVisible(value) {\n    this._gizmos.visible = value;\n    this.dispatchEvent(_changeEvent);\n  }\n\n  /**\n   * Sets gizmos radius factor and redraws gizmos.\n   *\n   * @param {number} value - Value of radius factor.\n   */\n  setTbRadius(value) {\n    this.radiusFactor = value;\n    this._tbRadius = this.calculateTbRadius(this.object);\n    const curve = new EllipseCurve(0, 0, this._tbRadius, this._tbRadius);\n    const points = curve.getPoints(this._curvePts);\n    const curveGeometry = new BufferGeometry().setFromPoints(points);\n    for (const gizmo in this._gizmos.children) {\n      this._gizmos.children[gizmo].geometry = curveGeometry;\n    }\n    this.dispatchEvent(_changeEvent);\n  }\n\n  /**\n   * Creates the rotation gizmos matching trackball center and radius.\n   *\n   * @private\n   * @param {Vector3} tbCenter - The trackball center.\n   * @param {number} tbRadius - The trackball radius.\n   */\n  makeGizmos(tbCenter, tbRadius) {\n    const curve = new EllipseCurve(0, 0, tbRadius, tbRadius);\n    const points = curve.getPoints(this._curvePts);\n\n    //geometry\n    const curveGeometry = new BufferGeometry().setFromPoints(points);\n\n    //material\n    const curveMaterialX = new LineBasicMaterial({\n      color: 0xff8080,\n      fog: false,\n      transparent: true,\n      opacity: 0.6\n    });\n    const curveMaterialY = new LineBasicMaterial({\n      color: 0x80ff80,\n      fog: false,\n      transparent: true,\n      opacity: 0.6\n    });\n    const curveMaterialZ = new LineBasicMaterial({\n      color: 0x8080ff,\n      fog: false,\n      transparent: true,\n      opacity: 0.6\n    });\n\n    //line\n    const gizmoX = new Line(curveGeometry, curveMaterialX);\n    const gizmoY = new Line(curveGeometry, curveMaterialY);\n    const gizmoZ = new Line(curveGeometry, curveMaterialZ);\n    const rotation = Math.PI * 0.5;\n    gizmoX.rotation.x = rotation;\n    gizmoY.rotation.y = rotation;\n\n    //setting state\n    this._gizmoMatrixState0.identity().setPosition(tbCenter);\n    this._gizmoMatrixState.copy(this._gizmoMatrixState0);\n    if (this.object.zoom !== 1) {\n      //adapt gizmos size to camera zoom\n      const size = 1 / this.object.zoom;\n      this._scaleMatrix.makeScale(size, size, size);\n      this._translationMatrix.makeTranslation(-tbCenter.x, -tbCenter.y, -tbCenter.z);\n      this._gizmoMatrixState.premultiply(this._translationMatrix).premultiply(this._scaleMatrix);\n      this._translationMatrix.makeTranslation(tbCenter.x, tbCenter.y, tbCenter.z);\n      this._gizmoMatrixState.premultiply(this._translationMatrix);\n    }\n    this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n    //\n\n    this._gizmos.traverse(function (object) {\n      if (object.isLine) {\n        object.geometry.dispose();\n        object.material.dispose();\n      }\n    });\n    this._gizmos.clear();\n\n    //\n\n    this._gizmos.add(gizmoX);\n    this._gizmos.add(gizmoY);\n    this._gizmos.add(gizmoZ);\n  }\n\n  /**\n   * Performs animation for focus operation.\n   *\n   * @private\n   * @param {number} time - Instant in which this function is called as performance.now().\n   * @param {Vector3} point - Point of interest for focus operation.\n   * @param {Matrix4} cameraMatrix - Camera matrix.\n   * @param {Matrix4} gizmoMatrix - Gizmos matrix.\n   */\n  onFocusAnim(time, point, cameraMatrix, gizmoMatrix) {\n    if (this._timeStart == -1) {\n      //animation start\n      this._timeStart = time;\n    }\n    if (this._state == STATE.ANIMATION_FOCUS) {\n      const deltaTime = time - this._timeStart;\n      const animTime = deltaTime / this.focusAnimationTime;\n      this._gizmoMatrixState.copy(gizmoMatrix);\n      if (animTime >= 1) {\n        //animation end\n\n        this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n        this.focus(point, this.scaleFactor);\n        this._timeStart = -1;\n        this.updateTbState(STATE.IDLE, false);\n        this.activateGizmos(false);\n        this.dispatchEvent(_changeEvent);\n      } else {\n        const amount = this.easeOutCubic(animTime);\n        const size = 1 - amount + this.scaleFactor * amount;\n        this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n        this.focus(point, size, amount);\n        this.dispatchEvent(_changeEvent);\n        const self = this;\n        this._animationId = window.requestAnimationFrame(function (t) {\n          self.onFocusAnim(t, point, cameraMatrix, gizmoMatrix.clone());\n        });\n      }\n    } else {\n      //interrupt animation\n\n      this._animationId = -1;\n      this._timeStart = -1;\n    }\n  }\n\n  /**\n   * Performs animation for rotation operation.\n   *\n   * @private\n   * @param {number} time - Instant in which this function is called as performance.now().\n   * @param {Vector3} rotationAxis - Rotation axis.\n   * @param {number} w0 - Initial angular velocity.\n   */\n  onRotationAnim(time, rotationAxis, w0) {\n    if (this._timeStart == -1) {\n      //animation start\n      this._anglePrev = 0;\n      this._angleCurrent = 0;\n      this._timeStart = time;\n    }\n    if (this._state == STATE.ANIMATION_ROTATE) {\n      //w = w0 + alpha * t\n      const deltaTime = (time - this._timeStart) / 1000;\n      const w = w0 + -this.dampingFactor * deltaTime;\n      if (w > 0) {\n        //tetha = 0.5 * alpha * t^2 + w0 * t + tetha0\n        this._angleCurrent = 0.5 * -this.dampingFactor * Math.pow(deltaTime, 2) + w0 * deltaTime + 0;\n        this.applyTransformMatrix(this.rotate(rotationAxis, this._angleCurrent));\n        this.dispatchEvent(_changeEvent);\n        const self = this;\n        this._animationId = window.requestAnimationFrame(function (t) {\n          self.onRotationAnim(t, rotationAxis, w0);\n        });\n      } else {\n        this._animationId = -1;\n        this._timeStart = -1;\n        this.updateTbState(STATE.IDLE, false);\n        this.activateGizmos(false);\n        this.dispatchEvent(_changeEvent);\n      }\n    } else {\n      //interrupt animation\n\n      this._animationId = -1;\n      this._timeStart = -1;\n      if (this._state != STATE.ROTATE) {\n        this.activateGizmos(false);\n        this.dispatchEvent(_changeEvent);\n      }\n    }\n  }\n\n  /**\n   * Performs pan operation moving camera between two points.\n   *\n   * @private\n   * @param {Vector3} p0 - Initial point.\n   * @param {Vector3} p1 - Ending point.\n   * @param {boolean} [adjust=false] - If movement should be adjusted considering camera distance (Perspective only).\n   * @returns {Object}\n   */\n  pan(p0, p1, adjust = false) {\n    const movement = p0.clone().sub(p1);\n    if (this.object.isOrthographicCamera) {\n      //adjust movement amount\n      movement.multiplyScalar(1 / this.object.zoom);\n    } else if (this.object.isPerspectiveCamera && adjust) {\n      //adjust movement amount\n      this._v3_1.setFromMatrixPosition(this._cameraMatrixState0); //camera's initial position\n      this._v3_2.setFromMatrixPosition(this._gizmoMatrixState0); //gizmo's initial position\n      const distanceFactor = this._v3_1.distanceTo(this._v3_2) / this.object.position.distanceTo(this._gizmos.position);\n      movement.multiplyScalar(1 / distanceFactor);\n    }\n    this._v3_1.set(movement.x, movement.y, 0).applyQuaternion(this.object.quaternion);\n    this._m4_1.makeTranslation(this._v3_1.x, this._v3_1.y, this._v3_1.z);\n    this.setTransformationMatrices(this._m4_1, this._m4_1);\n    return _transformation;\n  }\n\n  /**\n   * Resets the controls.\n   */\n  reset() {\n    this.target.copy(this._target0);\n    this.object.zoom = this._zoom0;\n    if (this.object.isPerspectiveCamera) {\n      this.object.fov = this._fov0;\n    }\n    this.object.near = this._nearPos;\n    this.object.far = this._farPos;\n    this._cameraMatrixState.copy(this._cameraMatrixState0);\n    this._cameraMatrixState.decompose(this.object.position, this.object.quaternion, this.object.scale);\n    this.object.up.copy(this._up0);\n    this.object.updateMatrix();\n    this.object.updateProjectionMatrix();\n    this._gizmoMatrixState.copy(this._gizmoMatrixState0);\n    this._gizmoMatrixState0.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n    this._gizmos.updateMatrix();\n    this._tbRadius = this.calculateTbRadius(this.object);\n    this.makeGizmos(this._gizmos.position, this._tbRadius);\n    this.object.lookAt(this._gizmos.position);\n    this.updateTbState(STATE.IDLE, false);\n    this.dispatchEvent(_changeEvent);\n  }\n\n  /**\n   * Rotates the camera around an axis passing by trackball's center.\n   *\n   * @private\n   * @param {Vector3} axis - Rotation axis.\n   * @param {number} angle - Angle in radians.\n   * @returns {Object} Object with 'camera' field containing transformation matrix resulting from the operation to be applied to the camera.\n   */\n  rotate(axis, angle) {\n    const point = this._gizmos.position; //rotation center\n    this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z);\n    this._rotationMatrix.makeRotationAxis(axis, -angle);\n\n    //rotate camera\n    this._m4_1.makeTranslation(point.x, point.y, point.z);\n    this._m4_1.multiply(this._rotationMatrix);\n    this._m4_1.multiply(this._translationMatrix);\n    this.setTransformationMatrices(this._m4_1);\n    return _transformation;\n  }\n\n  /**\n   * Copy the current state to clipboard (as a readable JSON text).\n   */\n  copyState() {\n    let state;\n    if (this.object.isOrthographicCamera) {\n      state = JSON.stringify({\n        arcballState: {\n          cameraFar: this.object.far,\n          cameraMatrix: this.object.matrix,\n          cameraNear: this.object.near,\n          cameraUp: this.object.up,\n          cameraZoom: this.object.zoom,\n          gizmoMatrix: this._gizmos.matrix,\n          target: this.target\n        }\n      });\n    } else if (this.object.isPerspectiveCamera) {\n      state = JSON.stringify({\n        arcballState: {\n          cameraFar: this.object.far,\n          cameraFov: this.object.fov,\n          cameraMatrix: this.object.matrix,\n          cameraNear: this.object.near,\n          cameraUp: this.object.up,\n          cameraZoom: this.object.zoom,\n          gizmoMatrix: this._gizmos.matrix,\n          target: this.target\n        }\n      });\n    }\n    navigator.clipboard.writeText(state);\n  }\n\n  /**\n   * Set the controls state from the clipboard, assumes that the clipboard stores a JSON\n   * text as saved from `copyState()`.\n   */\n  pasteState() {\n    const self = this;\n    navigator.clipboard.readText().then(function resolved(value) {\n      self.setStateFromJSON(value);\n    });\n  }\n\n  /**\n   * Saves the current state of the control. This can later be recover with `reset()`.\n   */\n  saveState() {\n    this.object.updateMatrix();\n    this._gizmos.updateMatrix();\n    this._target0.copy(this.target);\n    this._cameraMatrixState0.copy(this.object.matrix);\n    this._gizmoMatrixState0.copy(this._gizmos.matrix);\n    this._nearPos = this.object.near;\n    this._farPos = this.object.far;\n    this._zoom0 = this.object.zoom;\n    this._up0.copy(this.object.up);\n    if (this.object.isPerspectiveCamera) {\n      this._fov0 = this.object.fov;\n    }\n  }\n\n  /**\n   * Performs uniform scale operation around a given point.\n   *\n   * @private\n   * @param {number} size - Scale factor.\n   * @param {Vector3} point - Point around which scale.\n   * @param {boolean} scaleGizmos - If gizmos should be scaled (Perspective only).\n   * @returns {Object} Object with 'camera' and 'gizmo' fields containing transformation matrices resulting from the operation to be applied to the camera and gizmos.\n   */\n  scale(size, point, scaleGizmos = true) {\n    _scalePointTemp.copy(point);\n    let sizeInverse = 1 / size;\n    if (this.object.isOrthographicCamera) {\n      //camera zoom\n      this.object.zoom = this._zoomState;\n      this.object.zoom *= size;\n\n      //check min and max zoom\n      if (this.object.zoom > this.maxZoom) {\n        this.object.zoom = this.maxZoom;\n        sizeInverse = this._zoomState / this.maxZoom;\n      } else if (this.object.zoom < this.minZoom) {\n        this.object.zoom = this.minZoom;\n        sizeInverse = this._zoomState / this.minZoom;\n      }\n      this.object.updateProjectionMatrix();\n      this._v3_1.setFromMatrixPosition(this._gizmoMatrixState); //gizmos position\n\n      //scale gizmos so they appear in the same spot having the same dimension\n      this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse);\n      this._translationMatrix.makeTranslation(-this._v3_1.x, -this._v3_1.y, -this._v3_1.z);\n      this._m4_2.makeTranslation(this._v3_1.x, this._v3_1.y, this._v3_1.z).multiply(this._scaleMatrix);\n      this._m4_2.multiply(this._translationMatrix);\n\n      //move camera and gizmos to obtain pinch effect\n      _scalePointTemp.sub(this._v3_1);\n      const amount = _scalePointTemp.clone().multiplyScalar(sizeInverse);\n      _scalePointTemp.sub(amount);\n      this._m4_1.makeTranslation(_scalePointTemp.x, _scalePointTemp.y, _scalePointTemp.z);\n      this._m4_2.premultiply(this._m4_1);\n      this.setTransformationMatrices(this._m4_1, this._m4_2);\n      return _transformation;\n    } else if (this.object.isPerspectiveCamera) {\n      this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n      this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\n\n      //move camera\n      let distance = this._v3_1.distanceTo(_scalePointTemp);\n      let amount = distance - distance * sizeInverse;\n\n      //check min and max distance\n      const newDistance = distance - amount;\n      if (newDistance < this.minDistance) {\n        sizeInverse = this.minDistance / distance;\n        amount = distance - distance * sizeInverse;\n      } else if (newDistance > this.maxDistance) {\n        sizeInverse = this.maxDistance / distance;\n        amount = distance - distance * sizeInverse;\n      }\n      _offset.copy(_scalePointTemp).sub(this._v3_1).normalize().multiplyScalar(amount);\n      this._m4_1.makeTranslation(_offset.x, _offset.y, _offset.z);\n      if (scaleGizmos) {\n        //scale gizmos so they appear in the same spot having the same dimension\n        const pos = this._v3_2;\n        distance = pos.distanceTo(_scalePointTemp);\n        amount = distance - distance * sizeInverse;\n        _offset.copy(_scalePointTemp).sub(this._v3_2).normalize().multiplyScalar(amount);\n        this._translationMatrix.makeTranslation(pos.x, pos.y, pos.z);\n        this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse);\n        this._m4_2.makeTranslation(_offset.x, _offset.y, _offset.z).multiply(this._translationMatrix);\n        this._m4_2.multiply(this._scaleMatrix);\n        this._translationMatrix.makeTranslation(-pos.x, -pos.y, -pos.z);\n        this._m4_2.multiply(this._translationMatrix);\n        this.setTransformationMatrices(this._m4_1, this._m4_2);\n      } else {\n        this.setTransformationMatrices(this._m4_1);\n      }\n      return _transformation;\n    }\n  }\n\n  /**\n   * Sets camera fov.\n   *\n   * @private\n   * @param {number} value - The FOV to be set.\n   */\n  setFov(value) {\n    if (this.object.isPerspectiveCamera) {\n      this.object.fov = MathUtils.clamp(value, this.minFov, this.maxFov);\n      this.object.updateProjectionMatrix();\n    }\n  }\n\n  /**\n   * Sets values in transformation object.\n   *\n   * @private\n   * @param {Matrix4} [camera=null] - Transformation to be applied to the camera.\n   * @param {Matrix4} [gizmos=null] - Transformation to be applied to gizmos.\n   */\n  setTransformationMatrices(camera = null, gizmos = null) {\n    if (camera != null) {\n      if (_transformation.camera != null) {\n        _transformation.camera.copy(camera);\n      } else {\n        _transformation.camera = camera.clone();\n      }\n    } else {\n      _transformation.camera = null;\n    }\n    if (gizmos != null) {\n      if (_transformation.gizmos != null) {\n        _transformation.gizmos.copy(gizmos);\n      } else {\n        _transformation.gizmos = gizmos.clone();\n      }\n    } else {\n      _transformation.gizmos = null;\n    }\n  }\n\n  /**\n   * Rotates camera around its direction axis passing by a given point by a given angle.\n   *\n   * @private\n   * @param {Vector3} point - The point where the rotation axis is passing trough.\n   * @param {number} angle - Angle in radians.\n   * @returns {Object} The computed transformation matrix.\n   */\n  zRotate(point, angle) {\n    this._rotationMatrix.makeRotationAxis(this._rotationAxis, angle);\n    this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z);\n    this._m4_1.makeTranslation(point.x, point.y, point.z);\n    this._m4_1.multiply(this._rotationMatrix);\n    this._m4_1.multiply(this._translationMatrix);\n    this._v3_1.setFromMatrixPosition(this._gizmoMatrixState).sub(point); //vector from rotation center to gizmos position\n    this._v3_2.copy(this._v3_1).applyAxisAngle(this._rotationAxis, angle); //apply rotation\n    this._v3_2.sub(this._v3_1);\n    this._m4_2.makeTranslation(this._v3_2.x, this._v3_2.y, this._v3_2.z);\n    this.setTransformationMatrices(this._m4_1, this._m4_2);\n    return _transformation;\n  }\n\n  /**\n   * Returns the raycaster that is used for user interaction. This object is shared between all\n   * instances of `ArcballControls`.\n   *\n   * @returns {Raycaster} The internal raycaster.\n   */\n  getRaycaster() {\n    return _raycaster;\n  }\n\n  /**\n   * Unprojects the cursor on the 3D object surface.\n   *\n   * @private\n   * @param {Vector2} cursor - Cursor coordinates in NDC.\n   * @param {Camera} camera - Virtual camera.\n   * @returns {?Vector3} The point of intersection with the model, if exist, null otherwise.\n   */\n  unprojectOnObj(cursor, camera) {\n    const raycaster = this.getRaycaster();\n    raycaster.near = camera.near;\n    raycaster.far = camera.far;\n    raycaster.setFromCamera(cursor, camera);\n    const intersect = raycaster.intersectObjects(this.scene.children, true);\n    for (let i = 0; i < intersect.length; i++) {\n      if (intersect[i].object.uuid != this._gizmos.uuid && intersect[i].face != null) {\n        return intersect[i].point.clone();\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Unproject the cursor on the trackball surface.\n   *\n   * @private\n   * @param {Camera} camera - The virtual camera.\n   * @param {number} cursorX - Cursor horizontal coordinate on screen.\n   * @param {number} cursorY - Cursor vertical coordinate on screen.\n   * @param {HTMLElement} canvas - The canvas where the renderer draws its output.\n   * @param {number} tbRadius - The trackball radius.\n   * @returns {Vector3} The unprojected point on the trackball surface.\n   */\n  unprojectOnTbSurface(camera, cursorX, cursorY, canvas, tbRadius) {\n    if (camera.type == 'OrthographicCamera') {\n      this._v2_1.copy(this.getCursorPosition(cursorX, cursorY, canvas));\n      this._v3_1.set(this._v2_1.x, this._v2_1.y, 0);\n      const x2 = Math.pow(this._v2_1.x, 2);\n      const y2 = Math.pow(this._v2_1.y, 2);\n      const r2 = Math.pow(this._tbRadius, 2);\n      if (x2 + y2 <= r2 * 0.5) {\n        //intersection with sphere\n        this._v3_1.setZ(Math.sqrt(r2 - (x2 + y2)));\n      } else {\n        //intersection with hyperboloid\n        this._v3_1.setZ(r2 * 0.5 / Math.sqrt(x2 + y2));\n      }\n      return this._v3_1;\n    } else if (camera.type == 'PerspectiveCamera') {\n      //unproject cursor on the near plane\n      this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas));\n      this._v3_1.set(this._v2_1.x, this._v2_1.y, -1);\n      this._v3_1.applyMatrix4(camera.projectionMatrixInverse);\n      const rayDir = this._v3_1.clone().normalize(); //unprojected ray direction\n      const cameraGizmoDistance = camera.position.distanceTo(this._gizmos.position);\n      const radius2 = Math.pow(tbRadius, 2);\n\n      //\t  camera\n      //\t\t|\\\n      //\t\t| \\\n      //\t\t|  \\\n      //\th\t|\t\\\n      //\t\t| \t \\\n      //\t\t| \t  \\\n      //\t_ _ | _ _ _\\ _ _  near plane\n      //\t\t\tl\n\n      const h = this._v3_1.z;\n      const l = Math.sqrt(Math.pow(this._v3_1.x, 2) + Math.pow(this._v3_1.y, 2));\n      if (l == 0) {\n        //ray aligned with camera\n        rayDir.set(this._v3_1.x, this._v3_1.y, tbRadius);\n        return rayDir;\n      }\n      const m = h / l;\n      const q = cameraGizmoDistance;\n\n      /*\n       * calculate intersection point between unprojected ray and trackball surface\n       *|y = m * x + q\n       *|x^2 + y^2 = r^2\n       *\n       * (m^2 + 1) * x^2 + (2 * m * q) * x + q^2 - r^2 = 0\n       */\n      let a = Math.pow(m, 2) + 1;\n      let b = 2 * m * q;\n      let c = Math.pow(q, 2) - radius2;\n      let delta = Math.pow(b, 2) - 4 * a * c;\n      if (delta >= 0) {\n        //intersection with sphere\n        this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a));\n        this._v2_1.setY(m * this._v2_1.x + q);\n        const angle = MathUtils.RAD2DEG * this._v2_1.angle();\n        if (angle >= 45) {\n          //if angle between intersection point and X' axis is >= 45°, return that point\n          //otherwise, calculate intersection point with hyperboloid\n\n          const rayLength = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - this._v2_1.y, 2));\n          rayDir.multiplyScalar(rayLength);\n          rayDir.z += cameraGizmoDistance;\n          return rayDir;\n        }\n      }\n\n      //intersection with hyperboloid\n      /*\n       *|y = m * x + q\n       *|y = (1 / x) * (r^2 / 2)\n       *\n       * m * x^2 + q * x - r^2 / 2 = 0\n       */\n\n      a = m;\n      b = q;\n      c = -radius2 * 0.5;\n      delta = Math.pow(b, 2) - 4 * a * c;\n      this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a));\n      this._v2_1.setY(m * this._v2_1.x + q);\n      const rayLength = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - this._v2_1.y, 2));\n      rayDir.multiplyScalar(rayLength);\n      rayDir.z += cameraGizmoDistance;\n      return rayDir;\n    }\n  }\n\n  /**\n   * Unprojects the cursor on the plane passing through the center of the trackball orthogonal to the camera.\n   *\n   * @private\n   * @param {Camera} camera - The virtual camera.\n   * @param {number} cursorX - Cursor horizontal coordinate on screen.\n   * @param {number} cursorY - Cursor vertical coordinate on screen.\n   * @param {HTMLElement} canvas - The canvas where the renderer draws its output.\n   * @param {boolean} [initialDistance=false] - If initial distance between camera and gizmos should be used for calculations instead of current (Perspective only).\n   * @returns {Vector3} The unprojected point on the trackball plane.\n   */\n  unprojectOnTbPlane(camera, cursorX, cursorY, canvas, initialDistance = false) {\n    if (camera.type == 'OrthographicCamera') {\n      this._v2_1.copy(this.getCursorPosition(cursorX, cursorY, canvas));\n      this._v3_1.set(this._v2_1.x, this._v2_1.y, 0);\n      return this._v3_1.clone();\n    } else if (camera.type == 'PerspectiveCamera') {\n      this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas));\n\n      //unproject cursor on the near plane\n      this._v3_1.set(this._v2_1.x, this._v2_1.y, -1);\n      this._v3_1.applyMatrix4(camera.projectionMatrixInverse);\n      const rayDir = this._v3_1.clone().normalize(); //unprojected ray direction\n\n      //\t  camera\n      //\t\t|\\\n      //\t\t| \\\n      //\t\t|  \\\n      //\th\t|\t\\\n      //\t\t| \t \\\n      //\t\t| \t  \\\n      //\t_ _ | _ _ _\\ _ _  near plane\n      //\t\t\tl\n\n      const h = this._v3_1.z;\n      const l = Math.sqrt(Math.pow(this._v3_1.x, 2) + Math.pow(this._v3_1.y, 2));\n      let cameraGizmoDistance;\n      if (initialDistance) {\n        cameraGizmoDistance = this._v3_1.setFromMatrixPosition(this._cameraMatrixState0).distanceTo(this._v3_2.setFromMatrixPosition(this._gizmoMatrixState0));\n      } else {\n        cameraGizmoDistance = camera.position.distanceTo(this._gizmos.position);\n      }\n\n      /*\n       * calculate intersection point between unprojected ray and the plane\n       *|y = mx + q\n       *|y = 0\n       *\n       * x = -q/m\n      */\n      if (l == 0) {\n        //ray aligned with camera\n        rayDir.set(0, 0, 0);\n        return rayDir;\n      }\n      const m = h / l;\n      const q = cameraGizmoDistance;\n      const x = -q / m;\n      const rayLength = Math.sqrt(Math.pow(q, 2) + Math.pow(x, 2));\n      rayDir.multiplyScalar(rayLength);\n      rayDir.z = 0;\n      return rayDir;\n    }\n  }\n\n  /**\n   * Updates camera and gizmos state.\n   *\n   * @private\n   */\n  updateMatrixState() {\n    //update camera and gizmos state\n    this._cameraMatrixState.copy(this.object.matrix);\n    this._gizmoMatrixState.copy(this._gizmos.matrix);\n    if (this.object.isOrthographicCamera) {\n      this._cameraProjectionState.copy(this.object.projectionMatrix);\n      this.object.updateProjectionMatrix();\n      this._zoomState = this.object.zoom;\n    } else if (this.object.isPerspectiveCamera) {\n      this._fovState = this.object.fov;\n    }\n  }\n\n  /**\n   * Updates the trackball FSA.\n   *\n   * @private\n   * @param {STATE} newState - New state of the FSA.\n   * @param {boolean} updateMatrices - If matrices state should be updated.\n   */\n  updateTbState(newState, updateMatrices) {\n    this._state = newState;\n    if (updateMatrices) {\n      this.updateMatrixState();\n    }\n  }\n  update() {\n    if (this.target.equals(this._currentTarget) === false) {\n      this._gizmos.position.copy(this.target); //for correct radius calculation\n      this._tbRadius = this.calculateTbRadius(this.object);\n      this.makeGizmos(this.target, this._tbRadius);\n      this._currentTarget.copy(this.target);\n    }\n\n    //check min/max parameters\n    if (this.object.isOrthographicCamera) {\n      //check zoom\n      if (this.object.zoom > this.maxZoom || this.object.zoom < this.minZoom) {\n        const newZoom = MathUtils.clamp(this.object.zoom, this.minZoom, this.maxZoom);\n        this.applyTransformMatrix(this.scale(newZoom / this.object.zoom, this._gizmos.position, true));\n      }\n    } else if (this.object.isPerspectiveCamera) {\n      //check distance\n      const distance = this.object.position.distanceTo(this._gizmos.position);\n      if (distance > this.maxDistance + _EPS || distance < this.minDistance - _EPS) {\n        const newDistance = MathUtils.clamp(distance, this.minDistance, this.maxDistance);\n        this.applyTransformMatrix(this.scale(newDistance / distance, this._gizmos.position));\n        this.updateMatrixState();\n      }\n\n      //check fov\n      if (this.object.fov < this.minFov || this.object.fov > this.maxFov) {\n        this.object.fov = MathUtils.clamp(this.object.fov, this.minFov, this.maxFov);\n        this.object.updateProjectionMatrix();\n      }\n      const oldRadius = this._tbRadius;\n      this._tbRadius = this.calculateTbRadius(this.object);\n      if (oldRadius < this._tbRadius - _EPS || oldRadius > this._tbRadius + _EPS) {\n        const scale = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3;\n        const newRadius = this._tbRadius / scale;\n        const curve = new EllipseCurve(0, 0, newRadius, newRadius);\n        const points = curve.getPoints(this._curvePts);\n        const curveGeometry = new BufferGeometry().setFromPoints(points);\n        for (const gizmo in this._gizmos.children) {\n          this._gizmos.children[gizmo].geometry = curveGeometry;\n        }\n      }\n    }\n    this.object.lookAt(this._gizmos.position);\n  }\n  setStateFromJSON(json) {\n    const state = JSON.parse(json);\n    if (state.arcballState != undefined) {\n      this.target.fromArray(state.arcballState.target);\n      this._cameraMatrixState.fromArray(state.arcballState.cameraMatrix.elements);\n      this._cameraMatrixState.decompose(this.object.position, this.object.quaternion, this.object.scale);\n      this.object.up.copy(state.arcballState.cameraUp);\n      this.object.near = state.arcballState.cameraNear;\n      this.object.far = state.arcballState.cameraFar;\n      this.object.zoom = state.arcballState.cameraZoom;\n      if (this.object.isPerspectiveCamera) {\n        this.object.fov = state.arcballState.cameraFov;\n      }\n      this._gizmoMatrixState.fromArray(state.arcballState.gizmoMatrix.elements);\n      this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n      this.object.updateMatrix();\n      this.object.updateProjectionMatrix();\n      this._gizmos.updateMatrix();\n      this._tbRadius = this.calculateTbRadius(this.object);\n      const gizmoTmp = new Matrix4().copy(this._gizmoMatrixState0);\n      this.makeGizmos(this._gizmos.position, this._tbRadius);\n      this._gizmoMatrixState0.copy(gizmoTmp);\n      this.object.lookAt(this._gizmos.position);\n      this.updateTbState(STATE.IDLE, false);\n      this.dispatchEvent(_changeEvent);\n    }\n  }\n}\n\n//listeners\n\nfunction onWindowResize() {\n  const scale = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3;\n  this._tbRadius = this.calculateTbRadius(this.object);\n  const newRadius = this._tbRadius / scale;\n  const curve = new EllipseCurve(0, 0, newRadius, newRadius);\n  const points = curve.getPoints(this._curvePts);\n  const curveGeometry = new BufferGeometry().setFromPoints(points);\n  for (const gizmo in this._gizmos.children) {\n    this._gizmos.children[gizmo].geometry = curveGeometry;\n  }\n  this.dispatchEvent(_changeEvent);\n}\nfunction onContextMenu(event) {\n  if (!this.enabled) {\n    return;\n  }\n  for (let i = 0; i < this.mouseActions.length; i++) {\n    if (this.mouseActions[i].mouse == 2) {\n      //prevent only if button 2 is actually used\n      event.preventDefault();\n      break;\n    }\n  }\n}\nfunction onPointerCancel() {\n  this._touchStart.splice(0, this._touchStart.length);\n  this._touchCurrent.splice(0, this._touchCurrent.length);\n  this._input = INPUT.NONE;\n}\nfunction onPointerDown(event) {\n  if (event.button == 0 && event.isPrimary) {\n    this._downValid = true;\n    this._downEvents.push(event);\n    this._downStart = performance.now();\n  } else {\n    this._downValid = false;\n  }\n  if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n    this._touchStart.push(event);\n    this._touchCurrent.push(event);\n    switch (this._input) {\n      case INPUT.NONE:\n        //singleStart\n        this._input = INPUT.ONE_FINGER;\n        this.onSinglePanStart(event, 'ROTATE');\n        window.addEventListener('pointermove', this._onPointerMove);\n        window.addEventListener('pointerup', this._onPointerUp);\n        break;\n      case INPUT.ONE_FINGER:\n      case INPUT.ONE_FINGER_SWITCHED:\n        //doubleStart\n        this._input = INPUT.TWO_FINGER;\n        this.onRotateStart();\n        this.onPinchStart();\n        this.onDoublePanStart();\n        break;\n      case INPUT.TWO_FINGER:\n        //multipleStart\n        this._input = INPUT.MULT_FINGER;\n        this.onTriplePanStart(event);\n        break;\n    }\n  } else if (event.pointerType != 'touch' && this._input == INPUT.NONE) {\n    let modifier = null;\n    if (event.ctrlKey || event.metaKey) {\n      modifier = 'CTRL';\n    } else if (event.shiftKey) {\n      modifier = 'SHIFT';\n    }\n    this._mouseOp = this.getOpFromAction(event.button, modifier);\n    if (this._mouseOp != null) {\n      window.addEventListener('pointermove', this._onPointerMove);\n      window.addEventListener('pointerup', this._onPointerUp);\n\n      //singleStart\n      this._input = INPUT.CURSOR;\n      this._button = event.button;\n      this.onSinglePanStart(event, this._mouseOp);\n    }\n  }\n}\nfunction onPointerMove(event) {\n  if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n    switch (this._input) {\n      case INPUT.ONE_FINGER:\n        //singleMove\n        this.updateTouchEvent(event);\n        this.onSinglePanMove(event, STATE.ROTATE);\n        break;\n      case INPUT.ONE_FINGER_SWITCHED:\n        const movement = this.calculatePointersDistance(this._touchCurrent[0], event) * this._devPxRatio;\n        if (movement >= this._switchSensibility) {\n          //singleMove\n          this._input = INPUT.ONE_FINGER;\n          this.updateTouchEvent(event);\n          this.onSinglePanStart(event, 'ROTATE');\n          break;\n        }\n        break;\n      case INPUT.TWO_FINGER:\n        //rotate/pan/pinchMove\n        this.updateTouchEvent(event);\n        this.onRotateMove();\n        this.onPinchMove();\n        this.onDoublePanMove();\n        break;\n      case INPUT.MULT_FINGER:\n        //multMove\n        this.updateTouchEvent(event);\n        this.onTriplePanMove(event);\n        break;\n    }\n  } else if (event.pointerType != 'touch' && this._input == INPUT.CURSOR) {\n    let modifier = null;\n    if (event.ctrlKey || event.metaKey) {\n      modifier = 'CTRL';\n    } else if (event.shiftKey) {\n      modifier = 'SHIFT';\n    }\n    const mouseOpState = this.getOpStateFromAction(this._button, modifier);\n    if (mouseOpState != null) {\n      this.onSinglePanMove(event, mouseOpState);\n    }\n  }\n\n  //checkDistance\n  if (this._downValid) {\n    const movement = this.calculatePointersDistance(this._downEvents[this._downEvents.length - 1], event) * this._devPxRatio;\n    if (movement > this._movementThreshold) {\n      this._downValid = false;\n    }\n  }\n}\nfunction onPointerUp(event) {\n  if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n    const nTouch = this._touchCurrent.length;\n    for (let i = 0; i < nTouch; i++) {\n      if (this._touchCurrent[i].pointerId == event.pointerId) {\n        this._touchCurrent.splice(i, 1);\n        this._touchStart.splice(i, 1);\n        break;\n      }\n    }\n    switch (this._input) {\n      case INPUT.ONE_FINGER:\n      case INPUT.ONE_FINGER_SWITCHED:\n        //singleEnd\n        window.removeEventListener('pointermove', this._onPointerMove);\n        window.removeEventListener('pointerup', this._onPointerUp);\n        this._input = INPUT.NONE;\n        this.onSinglePanEnd();\n        break;\n      case INPUT.TWO_FINGER:\n        //doubleEnd\n        this.onDoublePanEnd(event);\n        this.onPinchEnd(event);\n        this.onRotateEnd(event);\n\n        //switching to singleStart\n        this._input = INPUT.ONE_FINGER_SWITCHED;\n        break;\n      case INPUT.MULT_FINGER:\n        if (this._touchCurrent.length == 0) {\n          window.removeEventListener('pointermove', this._onPointerMove);\n          window.removeEventListener('pointerup', this._onPointerUp);\n\n          //multCancel\n          this._input = INPUT.NONE;\n          this.onTriplePanEnd();\n        }\n        break;\n    }\n  } else if (event.pointerType != 'touch' && this._input == INPUT.CURSOR) {\n    window.removeEventListener('pointermove', this._onPointerMove);\n    window.removeEventListener('pointerup', this._onPointerUp);\n    this._input = INPUT.NONE;\n    this.onSinglePanEnd();\n    this._button = -1;\n  }\n  if (event.isPrimary) {\n    if (this._downValid) {\n      const downTime = event.timeStamp - this._downEvents[this._downEvents.length - 1].timeStamp;\n      if (downTime <= this._maxDownTime) {\n        if (this._nclicks == 0) {\n          //first valid click detected\n          this._nclicks = 1;\n          this._clickStart = performance.now();\n        } else {\n          const clickInterval = event.timeStamp - this._clickStart;\n          const movement = this.calculatePointersDistance(this._downEvents[1], this._downEvents[0]) * this._devPxRatio;\n          if (clickInterval <= this._maxInterval && movement <= this._posThreshold) {\n            //second valid click detected\n            //fire double tap and reset values\n            this._nclicks = 0;\n            this._downEvents.splice(0, this._downEvents.length);\n            this.onDoubleTap(event);\n          } else {\n            //new 'first click'\n            this._nclicks = 1;\n            this._downEvents.shift();\n            this._clickStart = performance.now();\n          }\n        }\n      } else {\n        this._downValid = false;\n        this._nclicks = 0;\n        this._downEvents.splice(0, this._downEvents.length);\n      }\n    } else {\n      this._nclicks = 0;\n      this._downEvents.splice(0, this._downEvents.length);\n    }\n  }\n}\nfunction onWheel(event) {\n  if (this.enabled && this.enableZoom) {\n    let modifier = null;\n    if (event.ctrlKey || event.metaKey) {\n      modifier = 'CTRL';\n    } else if (event.shiftKey) {\n      modifier = 'SHIFT';\n    }\n    const mouseOp = this.getOpFromAction('WHEEL', modifier);\n    if (mouseOp != null) {\n      event.preventDefault();\n      this.dispatchEvent(_startEvent);\n      const notchDeltaY = 125; //distance of one notch of mouse wheel\n      let sgn = event.deltaY / notchDeltaY;\n      let size = 1;\n      if (sgn > 0) {\n        size = 1 / this.scaleFactor;\n      } else if (sgn < 0) {\n        size = this.scaleFactor;\n      }\n      switch (mouseOp) {\n        case 'ZOOM':\n          this.updateTbState(STATE.SCALE, true);\n          if (sgn > 0) {\n            size = 1 / Math.pow(this.scaleFactor, sgn);\n          } else if (sgn < 0) {\n            size = Math.pow(this.scaleFactor, -sgn);\n          }\n          if (this.cursorZoom && this.enablePan) {\n            let scalePoint;\n            if (this.object.isOrthographicCamera) {\n              scalePoint = this.unprojectOnTbPlane(this.object, event.clientX, event.clientY, this.domElement).applyQuaternion(this.object.quaternion).multiplyScalar(1 / this.object.zoom).add(this._gizmos.position);\n            } else if (this.object.isPerspectiveCamera) {\n              scalePoint = this.unprojectOnTbPlane(this.object, event.clientX, event.clientY, this.domElement).applyQuaternion(this.object.quaternion).add(this._gizmos.position);\n            }\n            this.applyTransformMatrix(this.scale(size, scalePoint));\n          } else {\n            this.applyTransformMatrix(this.scale(size, this._gizmos.position));\n          }\n          if (this._grid != null) {\n            this.disposeGrid();\n            this.drawGrid();\n          }\n          this.updateTbState(STATE.IDLE, false);\n          this.dispatchEvent(_changeEvent);\n          this.dispatchEvent(_endEvent);\n          break;\n        case 'FOV':\n          if (this.object.isPerspectiveCamera) {\n            this.updateTbState(STATE.FOV, true);\n\n            //Vertigo effect\n\n            //\t  fov / 2\n            //\t\t|\\\n            //\t\t| \\\n            //\t\t|  \\\n            //\tx\t|\t\\\n            //\t\t| \t \\\n            //\t\t| \t  \\\n            //\t\t| _ _ _\\\n            //\t\t\ty\n\n            //check for iOs shift shortcut\n            if (event.deltaX != 0) {\n              sgn = event.deltaX / notchDeltaY;\n              size = 1;\n              if (sgn > 0) {\n                size = 1 / Math.pow(this.scaleFactor, sgn);\n              } else if (sgn < 0) {\n                size = Math.pow(this.scaleFactor, -sgn);\n              }\n            }\n            this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n            const x = this._v3_1.distanceTo(this._gizmos.position);\n            let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n            //check min and max distance\n            xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);\n            const y = x * Math.tan(MathUtils.DEG2RAD * this.object.fov * 0.5);\n\n            //calculate new fov\n            let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2);\n\n            //check min and max fov\n            if (newFov > this.maxFov) {\n              newFov = this.maxFov;\n            } else if (newFov < this.minFov) {\n              newFov = this.minFov;\n            }\n            const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n            size = x / newDistance;\n            this.setFov(newFov);\n            this.applyTransformMatrix(this.scale(size, this._gizmos.position, false));\n          }\n          if (this._grid != null) {\n            this.disposeGrid();\n            this.drawGrid();\n          }\n          this.updateTbState(STATE.IDLE, false);\n          this.dispatchEvent(_changeEvent);\n          this.dispatchEvent(_endEvent);\n          break;\n      }\n    }\n  }\n}\nexport { ArcballControls };","map":{"version":3,"names":["Controls","GridHelper","EllipseCurve","BufferGeometry","Line","LineBasicMaterial","Raycaster","Group","Box3","Sphere","Quaternion","Vector2","Vector3","Matrix4","MathUtils","STATE","IDLE","Symbol","ROTATE","PAN","SCALE","FOV","FOCUS","ZROTATE","TOUCH_MULTI","ANIMATION_FOCUS","ANIMATION_ROTATE","INPUT","NONE","ONE_FINGER","ONE_FINGER_SWITCHED","TWO_FINGER","MULT_FINGER","CURSOR","_center","x","y","_transformation","camera","gizmos","_changeEvent","type","_startEvent","_endEvent","_raycaster","_offset","_gizmoMatrixStateTemp","_cameraMatrixStateTemp","_scalePointTemp","_EPS","ArcballControls","constructor","domElement","scene","target","_currentTarget","radiusFactor","mouseActions","_mouseOp","_v2_1","_v3_1","_v3_2","_m4_1","_m4_2","_quat","_translationMatrix","_rotationMatrix","_scaleMatrix","_rotationAxis","_cameraMatrixState","_cameraProjectionState","_fovState","_upState","_zoomState","_nearPos","_farPos","_gizmoMatrixState","_up0","_zoom0","_fov0","_initialNear","_nearPos0","_initialFar","_farPos0","_cameraMatrixState0","_gizmoMatrixState0","_target0","_button","_touchStart","_touchCurrent","_input","_switchSensibility","_startFingerDistance","_currentFingerDistance","_startFingerRotation","_currentFingerRotation","_devPxRatio","_downValid","_nclicks","_downEvents","_downStart","_clickStart","_maxDownTime","_maxInterval","_posThreshold","_movementThreshold","_currentCursorPosition","_startCursorPosition","_grid","_gridPosition","_gizmos","_curvePts","_timeStart","_animationId","focusAnimationTime","_timePrev","_timeCurrent","_anglePrev","_angleCurrent","_cursorPosPrev","_cursorPosCurr","_wPrev","_wCurr","adjustNearFar","scaleFactor","dampingFactor","wMax","enableAnimations","enableGrid","cursorZoom","minFov","maxFov","rotateSpeed","enablePan","enableRotate","enableZoom","enableGizmos","enableFocus","minDistance","maxDistance","Infinity","minZoom","maxZoom","_tbRadius","_state","setCamera","add","initializeMouseActions","_onContextMenu","onContextMenu","bind","_onWheel","onWheel","_onPointerUp","onPointerUp","_onPointerMove","onPointerMove","_onPointerDown","onPointerDown","_onPointerCancel","onPointerCancel","_onWindowResize","onWindowResize","connect","element","style","touchAction","window","devicePixelRatio","addEventListener","disconnect","removeEventListener","onSinglePanStart","event","operation","enabled","dispatchEvent","setCenter","clientX","clientY","cancelAnimationFrame","activateGizmos","updateTbState","copy","unprojectOnTbPlane","object","drawGrid","unprojectOnTbSurface","performance","now","isPerspectiveCamera","setY","getCursorNDC","onSinglePanMove","opState","restart","applyTransformMatrix","pan","disposeGrid","distance","distanceTo","angle","angleTo","amount","Math","max","rotate","calculateRotationAxis","calculateAngularSpeed","screenNotches","movement","size","pow","setFromMatrixPosition","scale","position","xNew","clamp","tan","DEG2RAD","newFov","RAD2DEG","atan","newDistance","setFov","sub","normalize","multiplyScalar","makeTranslation","z","onSinglePanEnd","deltaTime","w","abs","self","requestAnimationFrame","t","rotationAxis","onRotationAnim","min","onDoubleTap","hitP","unprojectOnObj","onFocusAnim","focus","onDoublePanStart","onDoublePanMove","onDoublePanEnd","onRotateStart","getAngle","getWorldDirection","onRotateMove","rotationPoint","applyQuaternion","quaternion","zoom","zRotate","onRotateEnd","onPinchStart","calculatePointersDistance","onPinchMove","scalePoint","isOrthographicCamera","onPinchEnd","onTriplePanStart","nFingers","length","i","onTriplePanMove","onTriplePanEnd","setMouseAction","compareMouseAction","action1","action2","mouse","key","operationInput","mouseInput","keyInput","state","includes","action","splice","push","unsetMouseAction","getOpFromAction","getOpStateFromAction","p1","p2","atan2","PI","updateTouchEvent","pointerId","transformation","premultiply","decompose","updateMatrix","up","calculateTbRadius","cameraDistance","bb","setFromObject","sphere","getBoundingSphere","adjustedNearPosition","radius","center","regularNearPosition","minNearPos","near","adjustedFarPosition","regularFarPosition","minFarPos","far","updateProjectionMatrix","update","p0","t0","t1","s","sqrt","vec1","vec2","extractRotation","setFromRotationMatrix","crossVectors","clone","halfFovV","fov","halfFovH","aspect","top","right","point","color","multiplier","divisions","maxLength","tick","width","left","height","bottom","rotateX","dispose","remove","easeOutCubic","isActive","gizmoX","children","gizmoY","gizmoZ","material","setValues","opacity","cursorX","cursorY","canvas","canvasRect","getBoundingClientRect","setX","getCursorPosition","lookAt","matrix","projectionMatrix","makeGizmos","setGizmosVisible","value","visible","setTbRadius","curve","points","getPoints","curveGeometry","setFromPoints","gizmo","geometry","tbCenter","tbRadius","curveMaterialX","fog","transparent","curveMaterialY","curveMaterialZ","rotation","identity","setPosition","makeScale","traverse","isLine","clear","time","cameraMatrix","gizmoMatrix","animTime","w0","adjust","distanceFactor","set","setTransformationMatrices","reset","axis","makeRotationAxis","multiply","copyState","JSON","stringify","arcballState","cameraFar","cameraNear","cameraUp","cameraZoom","cameraFov","navigator","clipboard","writeText","pasteState","readText","then","resolved","setStateFromJSON","saveState","scaleGizmos","sizeInverse","pos","applyAxisAngle","getRaycaster","cursor","raycaster","setFromCamera","intersect","intersectObjects","uuid","face","x2","y2","r2","setZ","applyMatrix4","projectionMatrixInverse","rayDir","cameraGizmoDistance","radius2","h","l","m","q","a","b","c","delta","rayLength","initialDistance","updateMatrixState","newState","updateMatrices","equals","newZoom","oldRadius","newRadius","json","parse","undefined","fromArray","elements","gizmoTmp","preventDefault","button","isPrimary","pointerType","modifier","ctrlKey","metaKey","shiftKey","mouseOpState","nTouch","downTime","timeStamp","clickInterval","shift","mouseOp","notchDeltaY","sgn","deltaY","deltaX"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/controls/ArcballControls.js"],"sourcesContent":["import {\n\tControls,\n\tGridHelper,\n\tEllipseCurve,\n\tBufferGeometry,\n\tLine,\n\tLineBasicMaterial,\n\tRaycaster,\n\tGroup,\n\tBox3,\n\tSphere,\n\tQuaternion,\n\tVector2,\n\tVector3,\n\tMatrix4,\n\tMathUtils\n} from 'three';\n\n//trackball state\nconst STATE = {\n\n\tIDLE: Symbol(),\n\tROTATE: Symbol(),\n\tPAN: Symbol(),\n\tSCALE: Symbol(),\n\tFOV: Symbol(),\n\tFOCUS: Symbol(),\n\tZROTATE: Symbol(),\n\tTOUCH_MULTI: Symbol(),\n\tANIMATION_FOCUS: Symbol(),\n\tANIMATION_ROTATE: Symbol()\n\n};\n\nconst INPUT = {\n\n\tNONE: Symbol(),\n\tONE_FINGER: Symbol(),\n\tONE_FINGER_SWITCHED: Symbol(),\n\tTWO_FINGER: Symbol(),\n\tMULT_FINGER: Symbol(),\n\tCURSOR: Symbol()\n\n};\n\n//cursor center coordinates\nconst _center = {\n\n\tx: 0,\n\ty: 0\n\n};\n\n//transformation matrices for gizmos and camera\nconst _transformation = {\n\n\tcamera: new Matrix4(),\n\tgizmos: new Matrix4()\n\n};\n\n/**\n * Fires when the camera has been transformed by the controls.\n *\n * @event ArcballControls#change\n * @type {Object}\n */\nconst _changeEvent = { type: 'change' };\n\n/**\n * Fires when an interaction was initiated.\n *\n * @event ArcballControls#start\n * @type {Object}\n */\nconst _startEvent = { type: 'start' };\n\n/**\n * Fires when an interaction has finished.\n *\n * @event ArcballControls#end\n * @type {Object}\n */\nconst _endEvent = { type: 'end' };\n\nconst _raycaster = new Raycaster();\nconst _offset = new Vector3();\n\nconst _gizmoMatrixStateTemp = new Matrix4();\nconst _cameraMatrixStateTemp = new Matrix4();\nconst _scalePointTemp = new Vector3();\n\nconst _EPS = 0.000001;\n\n/**\n * Arcball controls allow the camera to be controlled by a virtual trackball with full touch support and advanced navigation functionality.\n * Cursor/finger positions and movements are mapped over a virtual trackball surface represented by a gizmo and mapped in intuitive and\n * consistent camera movements. Dragging cursor/fingers will cause camera to orbit around the center of the trackball in a conservative\n * way (returning to the starting point will make the camera return to its starting orientation).\n *\n * In addition to supporting pan, zoom and pinch gestures, Arcball controls provide focus< functionality with a double click/tap for intuitively\n * moving the object's point of interest in the center of the virtual trackball. Focus allows a much better inspection and navigation in complex\n * environment. Moreover Arcball controls allow FOV manipulation (in a vertigo-style method) and z-rotation. Saving and restoring of Camera State\n * is supported also through clipboard (use ctrl+c and ctrl+v shortcuts for copy and paste the state).\n *\n * Unlike {@link OrbitControls} and {@link TrackballControls}, `ArcballControls` doesn't require `update()` to be called externally in an\n * animation loop when animations are on.\n *\n * @augments Controls\n * @three_import import { ArcballControls } from 'three/addons/controls/ArcballControls.js';\n */\nclass ArcballControls extends Controls {\n\n\t/**\n\t * Constructs a new controls instance.\n\t *\n\t * @param {Camera} camera - The camera to be controlled. The camera must not be a child of another object, unless that object is the scene itself.\n\t * @param {?HTMLDOMElement} [domElement=null] - The HTML element used for event listeners.\n\t * @param {?Scene} [scene=null] The scene rendered by the camera. If not given, gizmos cannot be shown.\n\t */\n\tconstructor( camera, domElement = null, scene = null ) {\n\n\t\tsuper( camera, domElement );\n\n\t\t/**\n\t\t * The scene rendered by the camera. If not given, gizmos cannot be shown.\n\t\t *\n\t\t * @type {?Scene}\n\t\t * @default null\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * The control's focus point.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.target = new Vector3();\n\t\tthis._currentTarget = new Vector3();\n\n\t\t/**\n\t\t * The size of the gizmo relative to the screen width and height.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0.67\n\t\t */\n\t\tthis.radiusFactor = 0.67;\n\n\t\t/**\n\t\t * Holds the mouse actions of this controls. This property is maintained by the methods\n\t\t * `setMouseAction()` and `unsetMouseAction()`.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.mouseActions = [];\n\t\tthis._mouseOp = null;\n\n\n\t\t//global vectors and matrices that are used in some operations to avoid creating new objects every time (e.g. every time cursor moves)\n\t\tthis._v2_1 = new Vector2();\n\t\tthis._v3_1 = new Vector3();\n\t\tthis._v3_2 = new Vector3();\n\n\t\tthis._m4_1 = new Matrix4();\n\t\tthis._m4_2 = new Matrix4();\n\n\t\tthis._quat = new Quaternion();\n\n\t\t//transformation matrices\n\t\tthis._translationMatrix = new Matrix4(); //matrix for translation operation\n\t\tthis._rotationMatrix = new Matrix4(); //matrix for rotation operation\n\t\tthis._scaleMatrix = new Matrix4(); //matrix for scaling operation\n\n\t\tthis._rotationAxis = new Vector3(); //axis for rotate operation\n\n\n\t\t//camera state\n\t\tthis._cameraMatrixState = new Matrix4();\n\t\tthis._cameraProjectionState = new Matrix4();\n\n\t\tthis._fovState = 1;\n\t\tthis._upState = new Vector3();\n\t\tthis._zoomState = 1;\n\t\tthis._nearPos = 0;\n\t\tthis._farPos = 0;\n\n\t\tthis._gizmoMatrixState = new Matrix4();\n\n\t\t//initial values\n\t\tthis._up0 = new Vector3();\n\t\tthis._zoom0 = 1;\n\t\tthis._fov0 = 0;\n\t\tthis._initialNear = 0;\n\t\tthis._nearPos0 = 0;\n\t\tthis._initialFar = 0;\n\t\tthis._farPos0 = 0;\n\t\tthis._cameraMatrixState0 = new Matrix4();\n\t\tthis._gizmoMatrixState0 = new Matrix4();\n\t\tthis._target0 = new Vector3();\n\n\t\t//pointers array\n\t\tthis._button = - 1;\n\t\tthis._touchStart = [];\n\t\tthis._touchCurrent = [];\n\t\tthis._input = INPUT.NONE;\n\n\t\t//two fingers touch interaction\n\t\tthis._switchSensibility = 32;\t//minimum movement to be performed to fire single pan start after the second finger has been released\n\t\tthis._startFingerDistance = 0; //distance between two fingers\n\t\tthis._currentFingerDistance = 0;\n\t\tthis._startFingerRotation = 0; //amount of rotation performed with two fingers\n\t\tthis._currentFingerRotation = 0;\n\n\t\t//double tap\n\t\tthis._devPxRatio = 0;\n\t\tthis._downValid = true;\n\t\tthis._nclicks = 0;\n\t\tthis._downEvents = [];\n\t\tthis._downStart = 0;\t//pointerDown time\n\t\tthis._clickStart = 0;\t//first click time\n\t\tthis._maxDownTime = 250;\n\t\tthis._maxInterval = 300;\n\t\tthis._posThreshold = 24;\n\t\tthis._movementThreshold = 24;\n\n\t\t//cursor positions\n\t\tthis._currentCursorPosition = new Vector3();\n\t\tthis._startCursorPosition = new Vector3();\n\n\t\t//grid\n\t\tthis._grid = null; //grid to be visualized during pan operation\n\t\tthis._gridPosition = new Vector3();\n\n\t\t//gizmos\n\t\tthis._gizmos = new Group();\n\t\tthis._curvePts = 128;\n\n\n\t\t//animations\n\t\tthis._timeStart = - 1; //initial time\n\t\tthis._animationId = - 1;\n\n\t\t/**\n\t\t * Duration of focus animations in ms.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 500\n\t\t */\n\t\tthis.focusAnimationTime = 500;\n\n\t\t//rotate animation\n\t\tthis._timePrev = 0; //time at which previous rotate operation has been detected\n\t\tthis._timeCurrent = 0; //time at which current rotate operation has been detected\n\t\tthis._anglePrev = 0; //angle of previous rotation\n\t\tthis._angleCurrent = 0; //angle of current rotation\n\t\tthis._cursorPosPrev = new Vector3();\t//cursor position when previous rotate operation has been detected\n\t\tthis._cursorPosCurr = new Vector3();//cursor position when current rotate operation has been detected\n\t\tthis._wPrev = 0; //angular velocity of the previous rotate operation\n\t\tthis._wCurr = 0; //angular velocity of the current rotate operation\n\n\t\t//parameters\n\n\t\t/**\n\t\t * If set to `true`, the camera's near and far values will be adjusted every time zoom is\n\t\t * performed trying to maintain the same visible portion given by initial near and far\n\t\t * values. Only works with perspective cameras.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.adjustNearFar = false;\n\n\t\t/**\n\t\t * The scaling factor used when performing zoom operation.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1.1\n\t\t */\n\t\tthis.scaleFactor = 1.1;\n\n\t\t/**\n\t\t * The damping inertia used if 'enableAnimations` is set to `true`.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 25\n\t\t */\n\t\tthis.dampingFactor = 25;\n\n\t\t/**\n\t\t * Maximum angular velocity allowed on rotation animation start.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 20\n\t\t */\n\t\tthis.wMax = 20;\n\n\t\t/**\n\t\t * Set to `true` to enable animations for rotation (damping) and focus operation.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.enableAnimations = true;\n\n\t\t/**\n\t\t * If set to `true`, a grid will appear when panning operation is being performed\n\t\t * (desktop interaction only).\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.enableGrid = false;\n\n\t\t/**\n\t\t * Set to `true` to make zoom become cursor centered.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.cursorZoom = false;\n\n\t\t/**\n\t\t * The minimum FOV in degrees.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 5\n\t\t */\n\t\tthis.minFov = 5;\n\n\t\t/**\n\t\t * The maximum FOV in degrees.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 90\n\t\t */\n\t\tthis.maxFov = 90;\n\n\t\t/**\n\t\t * Speed of rotation.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.rotateSpeed = 1;\n\n\t\t/**\n\t\t * Enable or disable camera panning.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.enablePan = true;\n\n\t\t/**\n\t\t * Enable or disable camera rotation.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.enableRotate = true;\n\n\t\t/**\n\t\t * Enable or disable camera zoom.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.enableZoom = true;\n\n\t\t/**\n\t\t * Enable or disable gizmos.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.enableGizmos = true;\n\n\t\t/**\n\t\t * Enable or disable camera focusing on double-tap (or click) operations.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.enableFocus = true;\n\n\t\t/**\n\t\t * How far you can dolly in. For perspective cameras only.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.minDistance = 0;\n\n\t\t/**\n\t\t * How far you can dolly out. For perspective cameras only.\n\t\t *\n\t\t * @type {number}\n\t\t * @default Infinity\n\t\t */\n\t\tthis.maxDistance = Infinity;\n\n\t\t/**\n\t\t * How far you can zoom in. For orthographic cameras only.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.minZoom = 0;\n\n\t\t/**\n\t\t * How far you can zoom out. For orthographic cameras only.\n\t\t *\n\t\t * @type {number}\n\t\t * @default Infinity\n\t\t */\n\t\tthis.maxZoom = Infinity;\n\n\t\t//trackball parameters\n\t\tthis._tbRadius = 1;\n\n\t\t//FSA\n\t\tthis._state = STATE.IDLE;\n\n\t\tthis.setCamera( camera );\n\n\t\tif ( this.scene != null ) {\n\n\t\t\tthis.scene.add( this._gizmos );\n\n\t\t}\n\n\t\tthis.initializeMouseActions();\n\n\t\t// event listeners\n\n\t\tthis._onContextMenu = onContextMenu.bind( this );\n\t\tthis._onWheel = onWheel.bind( this );\n\t\tthis._onPointerUp = onPointerUp.bind( this );\n\t\tthis._onPointerMove = onPointerMove.bind( this );\n\t\tthis._onPointerDown = onPointerDown.bind( this );\n\t\tthis._onPointerCancel = onPointerCancel.bind( this );\n\t\tthis._onWindowResize = onWindowResize.bind( this );\n\n\t\tif ( domElement !== null ) {\n\n\t\t\tthis.connect( domElement );\n\n\t\t}\n\n\t}\n\n\tconnect( element ) {\n\n\t\tsuper.connect( element );\n\n\t\tthis.domElement.style.touchAction = 'none';\n\t\tthis._devPxRatio = window.devicePixelRatio;\n\n\t\tthis.domElement.addEventListener( 'contextmenu', this._onContextMenu );\n\t\tthis.domElement.addEventListener( 'wheel', this._onWheel );\n\t\tthis.domElement.addEventListener( 'pointerdown', this._onPointerDown );\n\t\tthis.domElement.addEventListener( 'pointercancel', this._onPointerCancel );\n\n\t\twindow.addEventListener( 'resize', this._onWindowResize );\n\n\t}\n\n\tdisconnect() {\n\n\t\tthis.domElement.removeEventListener( 'pointerdown', this._onPointerDown );\n\t\tthis.domElement.removeEventListener( 'pointercancel', this._onPointerCancel );\n\t\tthis.domElement.removeEventListener( 'wheel', this._onWheel );\n\t\tthis.domElement.removeEventListener( 'contextmenu', this._onContextMenu );\n\n\t\twindow.removeEventListener( 'pointermove', this._onPointerMove );\n\t\twindow.removeEventListener( 'pointerup', this._onPointerUp );\n\n\t\twindow.removeEventListener( 'resize', this._onWindowResize );\n\n\t}\n\n\tonSinglePanStart( event, operation ) {\n\n\t\tif ( this.enabled ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tthis.setCenter( event.clientX, event.clientY );\n\n\t\t\tswitch ( operation ) {\n\n\t\t\t\tcase 'PAN':\n\n\t\t\t\t\tif ( ! this.enablePan ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this._animationId != - 1 ) {\n\n\t\t\t\t\t\tcancelAnimationFrame( this._animationId );\n\t\t\t\t\t\tthis._animationId = - 1;\n\t\t\t\t\t\tthis._timeStart = - 1;\n\n\t\t\t\t\t\tthis.activateGizmos( false );\n\t\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateTbState( STATE.PAN, true );\n\t\t\t\t\tthis._startCursorPosition.copy( this.unprojectOnTbPlane( this.object, _center.x, _center.y, this.domElement ) );\n\t\t\t\t\tif ( this.enableGrid ) {\n\n\t\t\t\t\t\tthis.drawGrid();\n\t\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ROTATE':\n\n\t\t\t\t\tif ( ! this.enableRotate ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this._animationId != - 1 ) {\n\n\t\t\t\t\t\tcancelAnimationFrame( this._animationId );\n\t\t\t\t\t\tthis._animationId = - 1;\n\t\t\t\t\t\tthis._timeStart = - 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateTbState( STATE.ROTATE, true );\n\t\t\t\t\tthis._startCursorPosition.copy( this.unprojectOnTbSurface( this.object, _center.x, _center.y, this.domElement, this._tbRadius ) );\n\t\t\t\t\tthis.activateGizmos( true );\n\t\t\t\t\tif ( this.enableAnimations ) {\n\n\t\t\t\t\t\tthis._timePrev = this._timeCurrent = performance.now();\n\t\t\t\t\t\tthis._angleCurrent = this._anglePrev = 0;\n\t\t\t\t\t\tthis._cursorPosPrev.copy( this._startCursorPosition );\n\t\t\t\t\t\tthis._cursorPosCurr.copy( this._cursorPosPrev );\n\t\t\t\t\t\tthis._wCurr = 0;\n\t\t\t\t\t\tthis._wPrev = this._wCurr;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'FOV':\n\n\t\t\t\t\tif ( ! this.object.isPerspectiveCamera || ! this.enableZoom ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this._animationId != - 1 ) {\n\n\t\t\t\t\t\tcancelAnimationFrame( this._animationId );\n\t\t\t\t\t\tthis._animationId = - 1;\n\t\t\t\t\t\tthis._timeStart = - 1;\n\n\t\t\t\t\t\tthis.activateGizmos( false );\n\t\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateTbState( STATE.FOV, true );\n\t\t\t\t\tthis._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\t\t\t\t\tthis._currentCursorPosition.copy( this._startCursorPosition );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZOOM':\n\n\t\t\t\t\tif ( ! this.enableZoom ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this._animationId != - 1 ) {\n\n\t\t\t\t\t\tcancelAnimationFrame( this._animationId );\n\t\t\t\t\t\tthis._animationId = - 1;\n\t\t\t\t\t\tthis._timeStart = - 1;\n\n\t\t\t\t\t\tthis.activateGizmos( false );\n\t\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateTbState( STATE.SCALE, true );\n\t\t\t\t\tthis._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\t\t\t\t\tthis._currentCursorPosition.copy( this._startCursorPosition );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tonSinglePanMove( event, opState ) {\n\n\t\tif ( this.enabled ) {\n\n\t\t\tconst restart = opState != this._state;\n\t\t\tthis.setCenter( event.clientX, event.clientY );\n\n\t\t\tswitch ( opState ) {\n\n\t\t\t\tcase STATE.PAN:\n\n\t\t\t\t\tif ( this.enablePan ) {\n\n\t\t\t\t\t\tif ( restart ) {\n\n\t\t\t\t\t\t\t//switch to pan operation\n\n\t\t\t\t\t\t\tthis.dispatchEvent( _endEvent );\n\t\t\t\t\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\t\t\t\t\tthis.updateTbState( opState, true );\n\t\t\t\t\t\t\tthis._startCursorPosition.copy( this.unprojectOnTbPlane( this.object, _center.x, _center.y, this.domElement ) );\n\t\t\t\t\t\t\tif ( this.enableGrid ) {\n\n\t\t\t\t\t\t\t\tthis.drawGrid();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.activateGizmos( false );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t//continue with pan operation\n\t\t\t\t\t\t\tthis._currentCursorPosition.copy( this.unprojectOnTbPlane( this.object, _center.x, _center.y, this.domElement ) );\n\t\t\t\t\t\t\tthis.applyTransformMatrix( this.pan( this._startCursorPosition, this._currentCursorPosition ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.ROTATE:\n\n\t\t\t\t\tif ( this.enableRotate ) {\n\n\t\t\t\t\t\tif ( restart ) {\n\n\t\t\t\t\t\t\t//switch to rotate operation\n\n\t\t\t\t\t\t\tthis.dispatchEvent( _endEvent );\n\t\t\t\t\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\t\t\t\t\tthis.updateTbState( opState, true );\n\t\t\t\t\t\t\tthis._startCursorPosition.copy( this.unprojectOnTbSurface( this.object, _center.x, _center.y, this.domElement, this._tbRadius ) );\n\n\t\t\t\t\t\t\tif ( this.enableGrid ) {\n\n\t\t\t\t\t\t\t\tthis.disposeGrid();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.activateGizmos( true );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t//continue with rotate operation\n\t\t\t\t\t\t\tthis._currentCursorPosition.copy( this.unprojectOnTbSurface( this.object, _center.x, _center.y, this.domElement, this._tbRadius ) );\n\n\t\t\t\t\t\t\tconst distance = this._startCursorPosition.distanceTo( this._currentCursorPosition );\n\t\t\t\t\t\t\tconst angle = this._startCursorPosition.angleTo( this._currentCursorPosition );\n\t\t\t\t\t\t\tconst amount = Math.max( distance / this._tbRadius, angle ) * this.rotateSpeed; //effective rotation angle\n\n\t\t\t\t\t\t\tthis.applyTransformMatrix( this.rotate( this.calculateRotationAxis( this._startCursorPosition, this._currentCursorPosition ), amount ) );\n\n\t\t\t\t\t\t\tif ( this.enableAnimations ) {\n\n\t\t\t\t\t\t\t\tthis._timePrev = this._timeCurrent;\n\t\t\t\t\t\t\t\tthis._timeCurrent = performance.now();\n\t\t\t\t\t\t\t\tthis._anglePrev = this._angleCurrent;\n\t\t\t\t\t\t\t\tthis._angleCurrent = amount;\n\t\t\t\t\t\t\t\tthis._cursorPosPrev.copy( this._cursorPosCurr );\n\t\t\t\t\t\t\t\tthis._cursorPosCurr.copy( this._currentCursorPosition );\n\t\t\t\t\t\t\t\tthis._wPrev = this._wCurr;\n\t\t\t\t\t\t\t\tthis._wCurr = this.calculateAngularSpeed( this._anglePrev, this._angleCurrent, this._timePrev, this._timeCurrent );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.SCALE:\n\n\t\t\t\t\tif ( this.enableZoom ) {\n\n\t\t\t\t\t\tif ( restart ) {\n\n\t\t\t\t\t\t\t//switch to zoom operation\n\n\t\t\t\t\t\t\tthis.dispatchEvent( _endEvent );\n\t\t\t\t\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\t\t\t\t\tthis.updateTbState( opState, true );\n\t\t\t\t\t\t\tthis._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\t\t\t\t\t\t\tthis._currentCursorPosition.copy( this._startCursorPosition );\n\n\t\t\t\t\t\t\tif ( this.enableGrid ) {\n\n\t\t\t\t\t\t\t\tthis.disposeGrid();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.activateGizmos( false );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t//continue with zoom operation\n\t\t\t\t\t\t\tconst screenNotches = 8;\t//how many wheel notches corresponds to a full screen pan\n\t\t\t\t\t\t\tthis._currentCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\n\t\t\t\t\t\t\tconst movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n\n\t\t\t\t\t\t\tlet size = 1;\n\n\t\t\t\t\t\t\tif ( movement < 0 ) {\n\n\t\t\t\t\t\t\t\tsize = 1 / ( Math.pow( this.scaleFactor, - movement * screenNotches ) );\n\n\t\t\t\t\t\t\t} else if ( movement > 0 ) {\n\n\t\t\t\t\t\t\t\tsize = Math.pow( this.scaleFactor, movement * screenNotches );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis._v3_1.setFromMatrixPosition( this._gizmoMatrixState );\n\n\t\t\t\t\t\t\tthis.applyTransformMatrix( this.scale( size, this._v3_1 ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.FOV:\n\n\t\t\t\t\tif ( this.enableZoom && this.object.isPerspectiveCamera ) {\n\n\t\t\t\t\t\tif ( restart ) {\n\n\t\t\t\t\t\t\t//switch to fov operation\n\n\t\t\t\t\t\t\tthis.dispatchEvent( _endEvent );\n\t\t\t\t\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\t\t\t\t\tthis.updateTbState( opState, true );\n\t\t\t\t\t\t\tthis._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\t\t\t\t\t\t\tthis._currentCursorPosition.copy( this._startCursorPosition );\n\n\t\t\t\t\t\t\tif ( this.enableGrid ) {\n\n\t\t\t\t\t\t\t\tthis.disposeGrid();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.activateGizmos( false );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t//continue with fov operation\n\t\t\t\t\t\t\tconst screenNotches = 8;\t//how many wheel notches corresponds to a full screen pan\n\t\t\t\t\t\t\tthis._currentCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\n\t\t\t\t\t\t\tconst movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n\n\t\t\t\t\t\t\tlet size = 1;\n\n\t\t\t\t\t\t\tif ( movement < 0 ) {\n\n\t\t\t\t\t\t\t\tsize = 1 / ( Math.pow( this.scaleFactor, - movement * screenNotches ) );\n\n\t\t\t\t\t\t\t} else if ( movement > 0 ) {\n\n\t\t\t\t\t\t\t\tsize = Math.pow( this.scaleFactor, movement * screenNotches );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis._v3_1.setFromMatrixPosition( this._cameraMatrixState );\n\t\t\t\t\t\t\tconst x = this._v3_1.distanceTo( this._gizmos.position );\n\t\t\t\t\t\t\tlet xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n\t\t\t\t\t\t\t//check min and max distance\n\t\t\t\t\t\t\txNew = MathUtils.clamp( xNew, this.minDistance, this.maxDistance );\n\n\t\t\t\t\t\t\tconst y = x * Math.tan( MathUtils.DEG2RAD * this._fovState * 0.5 );\n\n\t\t\t\t\t\t\t//calculate new fov\n\t\t\t\t\t\t\tlet newFov = MathUtils.RAD2DEG * ( Math.atan( y / xNew ) * 2 );\n\n\t\t\t\t\t\t\t//check min and max fov\n\t\t\t\t\t\t\tnewFov = MathUtils.clamp( newFov, this.minFov, this.maxFov );\n\n\t\t\t\t\t\t\tconst newDistance = y / Math.tan( MathUtils.DEG2RAD * ( newFov / 2 ) );\n\t\t\t\t\t\t\tsize = x / newDistance;\n\t\t\t\t\t\t\tthis._v3_2.setFromMatrixPosition( this._gizmoMatrixState );\n\n\t\t\t\t\t\t\tthis.setFov( newFov );\n\t\t\t\t\t\t\tthis.applyTransformMatrix( this.scale( size, this._v3_2, false ) );\n\n\t\t\t\t\t\t\t//adjusting distance\n\t\t\t\t\t\t\t_offset.copy( this._gizmos.position ).sub( this.object.position ).normalize().multiplyScalar( newDistance / x );\n\t\t\t\t\t\t\tthis._m4_1.makeTranslation( _offset.x, _offset.y, _offset.z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t}\n\n\t}\n\n\tonSinglePanEnd() {\n\n\t\tif ( this._state == STATE.ROTATE ) {\n\n\n\t\t\tif ( ! this.enableRotate ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( this.enableAnimations ) {\n\n\t\t\t\t//perform rotation animation\n\t\t\t\tconst deltaTime = ( performance.now() - this._timeCurrent );\n\t\t\t\tif ( deltaTime < 120 ) {\n\n\t\t\t\t\tconst w = Math.abs( ( this._wPrev + this._wCurr ) / 2 );\n\n\t\t\t\t\tconst self = this;\n\t\t\t\t\tthis._animationId = window.requestAnimationFrame( function ( t ) {\n\n\t\t\t\t\t\tself.updateTbState( STATE.ANIMATION_ROTATE, true );\n\t\t\t\t\t\tconst rotationAxis = self.calculateRotationAxis( self._cursorPosPrev, self._cursorPosCurr );\n\n\t\t\t\t\t\tself.onRotationAnim( t, rotationAxis, Math.min( w, self.wMax ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t//cursor has been standing still for over 120 ms since last movement\n\t\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\t\t\t\t\tthis.activateGizmos( false );\n\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\t\t\t\tthis.activateGizmos( false );\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t}\n\n\t\t} else if ( this._state == STATE.PAN || this._state == STATE.IDLE ) {\n\n\t\t\tthis.updateTbState( STATE.IDLE, false );\n\n\t\t\tif ( this.enableGrid ) {\n\n\t\t\t\tthis.disposeGrid();\n\n\t\t\t}\n\n\t\t\tthis.activateGizmos( false );\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\n\t\t}\n\n\t\tthis.dispatchEvent( _endEvent );\n\n\t}\n\n\tonDoubleTap( event ) {\n\n\t\tif ( this.enabled && this.enablePan && this.enableFocus && this.scene != null ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tthis.setCenter( event.clientX, event.clientY );\n\t\t\tconst hitP = this.unprojectOnObj( this.getCursorNDC( _center.x, _center.y, this.domElement ), this.object );\n\n\t\t\tif ( hitP != null && this.enableAnimations ) {\n\n\t\t\t\tconst self = this;\n\t\t\t\tif ( this._animationId != - 1 ) {\n\n\t\t\t\t\twindow.cancelAnimationFrame( this._animationId );\n\n\t\t\t\t}\n\n\t\t\t\tthis._timeStart = - 1;\n\t\t\t\tthis._animationId = window.requestAnimationFrame( function ( t ) {\n\n\t\t\t\t\tself.updateTbState( STATE.ANIMATION_FOCUS, true );\n\t\t\t\t\tself.onFocusAnim( t, hitP, self._cameraMatrixState, self._gizmoMatrixState );\n\n\t\t\t\t} );\n\n\t\t\t} else if ( hitP != null && ! this.enableAnimations ) {\n\n\t\t\t\tthis.updateTbState( STATE.FOCUS, true );\n\t\t\t\tthis.focus( hitP, this.scaleFactor );\n\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.dispatchEvent( _endEvent );\n\n\t}\n\n\tonDoublePanStart() {\n\n\t\tif ( this.enabled && this.enablePan ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tthis.updateTbState( STATE.PAN, true );\n\n\t\t\tthis.setCenter( ( this._touchCurrent[ 0 ].clientX + this._touchCurrent[ 1 ].clientX ) / 2, ( this._touchCurrent[ 0 ].clientY + this._touchCurrent[ 1 ].clientY ) / 2 );\n\t\t\tthis._startCursorPosition.copy( this.unprojectOnTbPlane( this.object, _center.x, _center.y, this.domElement, true ) );\n\t\t\tthis._currentCursorPosition.copy( this._startCursorPosition );\n\n\t\t\tthis.activateGizmos( false );\n\n\t\t}\n\n\t}\n\n\tonDoublePanMove() {\n\n\t\tif ( this.enabled && this.enablePan ) {\n\n\t\t\tthis.setCenter( ( this._touchCurrent[ 0 ].clientX + this._touchCurrent[ 1 ].clientX ) / 2, ( this._touchCurrent[ 0 ].clientY + this._touchCurrent[ 1 ].clientY ) / 2 );\n\n\t\t\tif ( this._state != STATE.PAN ) {\n\n\t\t\t\tthis.updateTbState( STATE.PAN, true );\n\t\t\t\tthis._startCursorPosition.copy( this._currentCursorPosition );\n\n\t\t\t}\n\n\t\t\tthis._currentCursorPosition.copy( this.unprojectOnTbPlane( this.object, _center.x, _center.y, this.domElement, true ) );\n\t\t\tthis.applyTransformMatrix( this.pan( this._startCursorPosition, this._currentCursorPosition, true ) );\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t}\n\n\t}\n\n\tonDoublePanEnd() {\n\n\t\tthis.updateTbState( STATE.IDLE, false );\n\t\tthis.dispatchEvent( _endEvent );\n\n\t}\n\n\tonRotateStart() {\n\n\t\tif ( this.enabled && this.enableRotate ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tthis.updateTbState( STATE.ZROTATE, true );\n\n\t\t\t//this._startFingerRotation = event.rotation;\n\n\t\t\tthis._startFingerRotation = this.getAngle( this._touchCurrent[ 1 ], this._touchCurrent[ 0 ] ) + this.getAngle( this._touchStart[ 1 ], this._touchStart[ 0 ] );\n\t\t\tthis._currentFingerRotation = this._startFingerRotation;\n\n\t\t\tthis.object.getWorldDirection( this._rotationAxis ); //rotation axis\n\n\t\t\tif ( ! this.enablePan && ! this.enableZoom ) {\n\n\t\t\t\tthis.activateGizmos( true );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tonRotateMove() {\n\n\t\tif ( this.enabled && this.enableRotate ) {\n\n\t\t\tthis.setCenter( ( this._touchCurrent[ 0 ].clientX + this._touchCurrent[ 1 ].clientX ) / 2, ( this._touchCurrent[ 0 ].clientY + this._touchCurrent[ 1 ].clientY ) / 2 );\n\t\t\tlet rotationPoint;\n\n\t\t\tif ( this._state != STATE.ZROTATE ) {\n\n\t\t\t\tthis.updateTbState( STATE.ZROTATE, true );\n\t\t\t\tthis._startFingerRotation = this._currentFingerRotation;\n\n\t\t\t}\n\n\t\t\t//this._currentFingerRotation = event.rotation;\n\t\t\tthis._currentFingerRotation = this.getAngle( this._touchCurrent[ 1 ], this._touchCurrent[ 0 ] ) + this.getAngle( this._touchStart[ 1 ], this._touchStart[ 0 ] );\n\n\t\t\tif ( ! this.enablePan ) {\n\n\t\t\t\trotationPoint = new Vector3().setFromMatrixPosition( this._gizmoMatrixState );\n\n\t\t\t} else {\n\n\t\t\t\tthis._v3_2.setFromMatrixPosition( this._gizmoMatrixState );\n\t\t\t\trotationPoint = this.unprojectOnTbPlane( this.object, _center.x, _center.y, this.domElement ).applyQuaternion( this.object.quaternion ).multiplyScalar( 1 / this.object.zoom ).add( this._v3_2 );\n\n\t\t\t}\n\n\t\t\tconst amount = MathUtils.DEG2RAD * ( this._startFingerRotation - this._currentFingerRotation );\n\n\t\t\tthis.applyTransformMatrix( this.zRotate( rotationPoint, amount ) );\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t}\n\n\t}\n\n\tonRotateEnd() {\n\n\t\tthis.updateTbState( STATE.IDLE, false );\n\t\tthis.activateGizmos( false );\n\t\tthis.dispatchEvent( _endEvent );\n\n\t}\n\n\tonPinchStart() {\n\n\t\tif ( this.enabled && this.enableZoom ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\t\t\tthis.updateTbState( STATE.SCALE, true );\n\n\t\t\tthis._startFingerDistance = this.calculatePointersDistance( this._touchCurrent[ 0 ], this._touchCurrent[ 1 ] );\n\t\t\tthis._currentFingerDistance = this._startFingerDistance;\n\n\t\t\tthis.activateGizmos( false );\n\n\t\t}\n\n\t}\n\n\tonPinchMove() {\n\n\t\tif ( this.enabled && this.enableZoom ) {\n\n\t\t\tthis.setCenter( ( this._touchCurrent[ 0 ].clientX + this._touchCurrent[ 1 ].clientX ) / 2, ( this._touchCurrent[ 0 ].clientY + this._touchCurrent[ 1 ].clientY ) / 2 );\n\t\t\tconst minDistance = 12; //minimum distance between fingers (in css pixels)\n\n\t\t\tif ( this._state != STATE.SCALE ) {\n\n\t\t\t\tthis._startFingerDistance = this._currentFingerDistance;\n\t\t\t\tthis.updateTbState( STATE.SCALE, true );\n\n\t\t\t}\n\n\t\t\tthis._currentFingerDistance = Math.max( this.calculatePointersDistance( this._touchCurrent[ 0 ], this._touchCurrent[ 1 ] ), minDistance * this._devPxRatio );\n\t\t\tconst amount = this._currentFingerDistance / this._startFingerDistance;\n\n\t\t\tlet scalePoint;\n\n\t\t\tif ( ! this.enablePan ) {\n\n\t\t\t\tscalePoint = this._gizmos.position;\n\n\t\t\t} else {\n\n\t\t\t\tif ( this.object.isOrthographicCamera ) {\n\n\t\t\t\t\tscalePoint = this.unprojectOnTbPlane( this.object, _center.x, _center.y, this.domElement )\n\t\t\t\t\t\t.applyQuaternion( this.object.quaternion )\n\t\t\t\t\t\t.multiplyScalar( 1 / this.object.zoom )\n\t\t\t\t\t\t.add( this._gizmos.position );\n\n\t\t\t\t} else if ( this.object.isPerspectiveCamera ) {\n\n\t\t\t\t\tscalePoint = this.unprojectOnTbPlane( this.object, _center.x, _center.y, this.domElement )\n\t\t\t\t\t\t.applyQuaternion( this.object.quaternion )\n\t\t\t\t\t\t.add( this._gizmos.position );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.applyTransformMatrix( this.scale( amount, scalePoint ) );\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t}\n\n\t}\n\n\tonPinchEnd() {\n\n\t\tthis.updateTbState( STATE.IDLE, false );\n\t\tthis.dispatchEvent( _endEvent );\n\n\t}\n\n\tonTriplePanStart() {\n\n\t\tif ( this.enabled && this.enableZoom ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tthis.updateTbState( STATE.SCALE, true );\n\n\t\t\t//const center = event.center;\n\t\t\tlet clientX = 0;\n\t\t\tlet clientY = 0;\n\t\t\tconst nFingers = this._touchCurrent.length;\n\n\t\t\tfor ( let i = 0; i < nFingers; i ++ ) {\n\n\t\t\t\tclientX += this._touchCurrent[ i ].clientX;\n\t\t\t\tclientY += this._touchCurrent[ i ].clientY;\n\n\t\t\t}\n\n\t\t\tthis.setCenter( clientX / nFingers, clientY / nFingers );\n\n\t\t\tthis._startCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\t\t\tthis._currentCursorPosition.copy( this._startCursorPosition );\n\n\t\t}\n\n\t}\n\n\tonTriplePanMove() {\n\n\t\tif ( this.enabled && this.enableZoom ) {\n\n\t\t\t//\t  fov / 2\n\t\t\t//\t\t|\\\n\t\t\t//\t\t| \\\n\t\t\t//\t\t|  \\\n\t\t\t//\tx\t|\t\\\n\t\t\t//\t\t| \t \\\n\t\t\t//\t\t| \t  \\\n\t\t\t//\t\t| _ _ _\\\n\t\t\t//\t\t\ty\n\n\t\t\t//const center = event.center;\n\t\t\tlet clientX = 0;\n\t\t\tlet clientY = 0;\n\t\t\tconst nFingers = this._touchCurrent.length;\n\n\t\t\tfor ( let i = 0; i < nFingers; i ++ ) {\n\n\t\t\t\tclientX += this._touchCurrent[ i ].clientX;\n\t\t\t\tclientY += this._touchCurrent[ i ].clientY;\n\n\t\t\t}\n\n\t\t\tthis.setCenter( clientX / nFingers, clientY / nFingers );\n\n\t\t\tconst screenNotches = 8;\t//how many wheel notches corresponds to a full screen pan\n\t\t\tthis._currentCursorPosition.setY( this.getCursorNDC( _center.x, _center.y, this.domElement ).y * 0.5 );\n\n\t\t\tconst movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n\n\t\t\tlet size = 1;\n\n\t\t\tif ( movement < 0 ) {\n\n\t\t\t\tsize = 1 / ( Math.pow( this.scaleFactor, - movement * screenNotches ) );\n\n\t\t\t} else if ( movement > 0 ) {\n\n\t\t\t\tsize = Math.pow( this.scaleFactor, movement * screenNotches );\n\n\t\t\t}\n\n\t\t\tthis._v3_1.setFromMatrixPosition( this._cameraMatrixState );\n\t\t\tconst x = this._v3_1.distanceTo( this._gizmos.position );\n\t\t\tlet xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n\t\t\t//check min and max distance\n\t\t\txNew = MathUtils.clamp( xNew, this.minDistance, this.maxDistance );\n\n\t\t\tconst y = x * Math.tan( MathUtils.DEG2RAD * this._fovState * 0.5 );\n\n\t\t\t//calculate new fov\n\t\t\tlet newFov = MathUtils.RAD2DEG * ( Math.atan( y / xNew ) * 2 );\n\n\t\t\t//check min and max fov\n\t\t\tnewFov = MathUtils.clamp( newFov, this.minFov, this.maxFov );\n\n\t\t\tconst newDistance = y / Math.tan( MathUtils.DEG2RAD * ( newFov / 2 ) );\n\t\t\tsize = x / newDistance;\n\t\t\tthis._v3_2.setFromMatrixPosition( this._gizmoMatrixState );\n\n\t\t\tthis.setFov( newFov );\n\t\t\tthis.applyTransformMatrix( this.scale( size, this._v3_2, false ) );\n\n\t\t\t//adjusting distance\n\t\t\t_offset.copy( this._gizmos.position ).sub( this.object.position ).normalize().multiplyScalar( newDistance / x );\n\t\t\tthis._m4_1.makeTranslation( _offset.x, _offset.y, _offset.z );\n\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t}\n\n\t}\n\n\tonTriplePanEnd() {\n\n\t\tthis.updateTbState( STATE.IDLE, false );\n\t\tthis.dispatchEvent( _endEvent );\n\t\t//this.dispatchEvent( _changeEvent );\n\n\t}\n\n\t/**\n\t * Set _center's x/y coordinates.\n\t *\n\t * @private\n\t * @param {number} clientX - The x coordinate.\n\t * @param {number} clientY - The y coordinate.\n\t */\n\tsetCenter( clientX, clientY ) {\n\n\t\t_center.x = clientX;\n\t\t_center.y = clientY;\n\n\t}\n\n\t/**\n\t * Set default mouse actions.\n\t *\n\t * @private\n\t */\n\tinitializeMouseActions() {\n\n\t\tthis.setMouseAction( 'PAN', 0, 'CTRL' );\n\t\tthis.setMouseAction( 'PAN', 2 );\n\n\t\tthis.setMouseAction( 'ROTATE', 0 );\n\n\t\tthis.setMouseAction( 'ZOOM', 'WHEEL' );\n\t\tthis.setMouseAction( 'ZOOM', 1 );\n\n\t\tthis.setMouseAction( 'FOV', 'WHEEL', 'SHIFT' );\n\t\tthis.setMouseAction( 'FOV', 1, 'SHIFT' );\n\n\n\t}\n\n\t/**\n\t * Compare two mouse actions.\n\t *\n\t * @private\n\t * @param {Object} action1 - The first mouse action.\n\t * @param {Object} action2 - The second mouse action.\n\t * @returns {boolean} `true` if action1 and action 2 are the same mouse action, `false` otherwise.\n\t */\n\tcompareMouseAction( action1, action2 ) {\n\n\t\tif ( action1.operation == action2.operation ) {\n\n\t\t\tif ( action1.mouse == action2.mouse && action1.key == action2.key ) {\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Set a new mouse action by specifying the operation to be performed and a mouse/key combination. In case of conflict, replaces the existing one.\n\t *\n\t * @param {'PAN'|'ROTATE'|'ZOOM'|'FOV'} operation - The operation to be performed ('PAN', 'ROTATE', 'ZOOM', 'FOV').\n\t * @param {0|1|2|'WHEEL'} mouse - A mouse button (0, 1, 2) or 'WHEEL' for wheel notches.\n\t * @param {'CTRL'|'SHIFT'|null} [key=null] - The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed.\n\t * @returns {boolean} `true` if the mouse action has been successfully added, `false` otherwise.\n\t */\n\tsetMouseAction( operation, mouse, key = null ) {\n\n\t\tconst operationInput = [ 'PAN', 'ROTATE', 'ZOOM', 'FOV' ];\n\t\tconst mouseInput = [ 0, 1, 2, 'WHEEL' ];\n\t\tconst keyInput = [ 'CTRL', 'SHIFT', null ];\n\t\tlet state;\n\n\t\tif ( ! operationInput.includes( operation ) || ! mouseInput.includes( mouse ) || ! keyInput.includes( key ) ) {\n\n\t\t\t//invalid parameters\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( mouse == 'WHEEL' ) {\n\n\t\t\tif ( operation != 'ZOOM' && operation != 'FOV' ) {\n\n\t\t\t\t//cannot associate 2D operation to 1D input\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tswitch ( operation ) {\n\n\t\t\tcase 'PAN':\n\n\t\t\t\tstate = STATE.PAN;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ROTATE':\n\n\t\t\t\tstate = STATE.ROTATE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZOOM':\n\n\t\t\t\tstate = STATE.SCALE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'FOV':\n\n\t\t\t\tstate = STATE.FOV;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tconst action = {\n\n\t\t\toperation: operation,\n\t\t\tmouse: mouse,\n\t\t\tkey: key,\n\t\t\tstate: state\n\n\t\t};\n\n\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\tif ( this.mouseActions[ i ].mouse == action.mouse && this.mouseActions[ i ].key == action.key ) {\n\n\t\t\t\tthis.mouseActions.splice( i, 1, action );\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.mouseActions.push( action );\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Remove a mouse action by specifying its mouse/key combination.\n\t *\n\t * @param {0|1|2|'WHEEL'} mouse - A mouse button (0, 1, 2) or 'WHEEL' for wheel notches.\n\t * @param {'CTRL'|'SHIFT'|null} key - The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed.\n\t * @returns {boolean} `true` if the operation has been successfully removed, `false` otherwise.\n\t */\n\tunsetMouseAction( mouse, key = null ) {\n\n\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\tif ( this.mouseActions[ i ].mouse == mouse && this.mouseActions[ i ].key == key ) {\n\n\t\t\t\tthis.mouseActions.splice( i, 1 );\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Return the operation associated to a mouse/keyboard combination.\n\t *\n\t * @private\n\t * @param {0|1|2|'WHEEL'} mouse - Mouse button index (0, 1, 2) or 'WHEEL' for wheel notches.\n\t * @param {'CTRL'|'SHIFT'|null} key - Keyboard modifier.\n\t * @returns {'PAN'|'ROTATE'|'ZOOM'|'FOV'|null} The operation if it has been found, `null` otherwise.\n\t */\n\tgetOpFromAction( mouse, key ) {\n\n\t\tlet action;\n\n\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\taction = this.mouseActions[ i ];\n\t\t\tif ( action.mouse == mouse && action.key == key ) {\n\n\t\t\t\treturn action.operation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( key != null ) {\n\n\t\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\t\taction = this.mouseActions[ i ];\n\t\t\t\tif ( action.mouse == mouse && action.key == null ) {\n\n\t\t\t\t\treturn action.operation;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Get the operation associated to mouse and key combination and returns the corresponding FSA state.\n\t *\n\t * @private\n\t * @param {0|1|2} mouse - Mouse button index (0, 1, 2)\n\t * @param {'CTRL'|'SHIFT'|null} key - Keyboard modifier\n\t * @returns {?STATE} The FSA state obtained from the operation associated to mouse/keyboard combination.\n\t */\n\tgetOpStateFromAction( mouse, key ) {\n\n\t\tlet action;\n\n\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\taction = this.mouseActions[ i ];\n\t\t\tif ( action.mouse == mouse && action.key == key ) {\n\n\t\t\t\treturn action.state;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( key != null ) {\n\n\t\t\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\t\t\taction = this.mouseActions[ i ];\n\t\t\t\tif ( action.mouse == mouse && action.key == null ) {\n\n\t\t\t\t\treturn action.state;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Calculate the angle between two pointers.\n\t *\n\t * @private\n\t * @param {PointerEvent} p1 - The first pointer event.\n\t * @param {PointerEvent} p2 - The second pointer event.\n\t * @returns {number} The angle between two pointers in degrees.\n\t */\n\tgetAngle( p1, p2 ) {\n\n\t\treturn Math.atan2( p2.clientY - p1.clientY, p2.clientX - p1.clientX ) * 180 / Math.PI;\n\n\t}\n\n\t/**\n\t * Updates a PointerEvent inside current pointerevents array.\n\t *\n\t * @private\n\t * @param {PointerEvent} event - The pointer event.\n\t */\n\tupdateTouchEvent( event ) {\n\n\t\tfor ( let i = 0; i < this._touchCurrent.length; i ++ ) {\n\n\t\t\tif ( this._touchCurrent[ i ].pointerId == event.pointerId ) {\n\n\t\t\t\tthis._touchCurrent.splice( i, 1, event );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Applies a transformation matrix, to the camera and gizmos.\n\t *\n\t * @private\n\t * @param {Object} transformation - Object containing matrices to apply to camera and gizmos.\n\t */\n\tapplyTransformMatrix( transformation ) {\n\n\t\tif ( transformation.camera != null ) {\n\n\t\t\tthis._m4_1.copy( this._cameraMatrixState ).premultiply( transformation.camera );\n\t\t\tthis._m4_1.decompose( this.object.position, this.object.quaternion, this.object.scale );\n\t\t\tthis.object.updateMatrix();\n\n\t\t\t//update camera up vector\n\t\t\tif ( this._state == STATE.ROTATE || this._state == STATE.ZROTATE || this._state == STATE.ANIMATION_ROTATE ) {\n\n\t\t\t\tthis.object.up.copy( this._upState ).applyQuaternion( this.object.quaternion );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( transformation.gizmos != null ) {\n\n\t\t\tthis._m4_1.copy( this._gizmoMatrixState ).premultiply( transformation.gizmos );\n\t\t\tthis._m4_1.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\t\t\tthis._gizmos.updateMatrix();\n\n\t\t}\n\n\t\tif ( this._state == STATE.SCALE || this._state == STATE.FOCUS || this._state == STATE.ANIMATION_FOCUS ) {\n\n\t\t\tthis._tbRadius = this.calculateTbRadius( this.object );\n\n\t\t\tif ( this.adjustNearFar ) {\n\n\t\t\t\tconst cameraDistance = this.object.position.distanceTo( this._gizmos.position );\n\n\t\t\t\tconst bb = new Box3();\n\t\t\t\tbb.setFromObject( this._gizmos );\n\t\t\t\tconst sphere = new Sphere();\n\t\t\t\tbb.getBoundingSphere( sphere );\n\n\t\t\t\tconst adjustedNearPosition = Math.max( this._nearPos0, sphere.radius + sphere.center.length() );\n\t\t\t\tconst regularNearPosition = cameraDistance - this._initialNear;\n\n\t\t\t\tconst minNearPos = Math.min( adjustedNearPosition, regularNearPosition );\n\t\t\t\tthis.object.near = cameraDistance - minNearPos;\n\n\n\t\t\t\tconst adjustedFarPosition = Math.min( this._farPos0, - sphere.radius + sphere.center.length() );\n\t\t\t\tconst regularFarPosition = cameraDistance - this._initialFar;\n\n\t\t\t\tconst minFarPos = Math.min( adjustedFarPosition, regularFarPosition );\n\t\t\t\tthis.object.far = cameraDistance - minFarPos;\n\n\t\t\t\tthis.object.updateProjectionMatrix();\n\n\t\t\t} else {\n\n\t\t\t\tlet update = false;\n\n\t\t\t\tif ( this.object.near != this._initialNear ) {\n\n\t\t\t\t\tthis.object.near = this._initialNear;\n\t\t\t\t\tupdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.object.far != this._initialFar ) {\n\n\t\t\t\t\tthis.object.far = this._initialFar;\n\t\t\t\t\tupdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( update ) {\n\n\t\t\t\t\tthis.object.updateProjectionMatrix();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Calculates the angular speed.\n\t *\n\t * @private\n\t * @param {number} p0 - Position at t0.\n\t * @param {number} p1 - Position at t1.\n\t * @param {number} t0 - Initial time in milliseconds.\n\t * @param {number} t1 - Ending time in milliseconds.\n\t * @returns {number} The angular speed.\n\t */\n\tcalculateAngularSpeed( p0, p1, t0, t1 ) {\n\n\t\tconst s = p1 - p0;\n\t\tconst t = ( t1 - t0 ) / 1000;\n\t\tif ( t == 0 ) {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\treturn s / t;\n\n\t}\n\n\t/**\n\t * Calculates the distance between two pointers.\n\t *\n\t * @private\n\t * @param {PointerEvent} p0 - The first pointer.\n\t * @param {PointerEvent} p1 - The second pointer.\n\t * @returns {number} The distance between the two pointers.\n\t */\n\tcalculatePointersDistance( p0, p1 ) {\n\n\t\treturn Math.sqrt( Math.pow( p1.clientX - p0.clientX, 2 ) + Math.pow( p1.clientY - p0.clientY, 2 ) );\n\n\t}\n\n\t/**\n\t * Calculates the rotation axis as the vector perpendicular between two vectors.\n\t *\n\t * @private\n\t * @param {Vector3} vec1 - The first vector.\n\t * @param {Vector3} vec2 - The second vector.\n\t * @returns {Vector3} The normalized rotation axis.\n\t */\n\tcalculateRotationAxis( vec1, vec2 ) {\n\n\t\tthis._rotationMatrix.extractRotation( this._cameraMatrixState );\n\t\tthis._quat.setFromRotationMatrix( this._rotationMatrix );\n\n\t\tthis._rotationAxis.crossVectors( vec1, vec2 ).applyQuaternion( this._quat );\n\t\treturn this._rotationAxis.normalize().clone();\n\n\t}\n\n\t/**\n\t * Calculates the trackball radius so that gizmo's diameter will be 2/3 of the minimum side of the camera frustum.\n\t *\n\t * @private\n\t * @param {Camera} camera - The camera.\n\t * @returns {number} The trackball radius.\n\t */\n\tcalculateTbRadius( camera ) {\n\n\t\tconst distance = camera.position.distanceTo( this._gizmos.position );\n\n\t\tif ( camera.type == 'PerspectiveCamera' ) {\n\n\t\t\tconst halfFovV = MathUtils.DEG2RAD * camera.fov * 0.5; //vertical fov/2 in radians\n\t\t\tconst halfFovH = Math.atan( ( camera.aspect ) * Math.tan( halfFovV ) ); //horizontal fov/2 in radians\n\t\t\treturn Math.tan( Math.min( halfFovV, halfFovH ) ) * distance * this.radiusFactor;\n\n\t\t} else if ( camera.type == 'OrthographicCamera' ) {\n\n\t\t\treturn Math.min( camera.top, camera.right ) * this.radiusFactor;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Focus operation consist of positioning the point of interest in front of the camera and a slightly zoom in.\n\t *\n\t * @private\n\t * @param {Vector3} point - The point of interest.\n\t * @param {number} size - Scale factor.\n\t * @param {number} [amount=1] - Amount of operation to be completed (used for focus animations, default is complete full operation).\n\t */\n\tfocus( point, size, amount = 1 ) {\n\n\t\t//move center of camera (along with gizmos) towards point of interest\n\t\t_offset.copy( point ).sub( this._gizmos.position ).multiplyScalar( amount );\n\t\tthis._translationMatrix.makeTranslation( _offset.x, _offset.y, _offset.z );\n\n\t\t_gizmoMatrixStateTemp.copy( this._gizmoMatrixState );\n\t\tthis._gizmoMatrixState.premultiply( this._translationMatrix );\n\t\tthis._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\n\t\t_cameraMatrixStateTemp.copy( this._cameraMatrixState );\n\t\tthis._cameraMatrixState.premultiply( this._translationMatrix );\n\t\tthis._cameraMatrixState.decompose( this.object.position, this.object.quaternion, this.object.scale );\n\n\t\t//apply zoom\n\t\tif ( this.enableZoom ) {\n\n\t\t\tthis.applyTransformMatrix( this.scale( size, this._gizmos.position ) );\n\n\t\t}\n\n\t\tthis._gizmoMatrixState.copy( _gizmoMatrixStateTemp );\n\t\tthis._cameraMatrixState.copy( _cameraMatrixStateTemp );\n\n\t}\n\n\t/**\n\t * Creates a grid if necessary and adds it to the scene.\n\t *\n\t * @private\n\t */\n\tdrawGrid() {\n\n\t\tif ( this.scene != null ) {\n\n\t\t\tconst color = 0x888888;\n\t\t\tconst multiplier = 3;\n\t\t\tlet size, divisions, maxLength, tick;\n\n\t\t\tif ( this.object.isOrthographicCamera ) {\n\n\t\t\t\tconst width = this.object.right - this.object.left;\n\t\t\t\tconst height = this.object.bottom - this.object.top;\n\n\t\t\t\tmaxLength = Math.max( width, height );\n\t\t\t\ttick = maxLength / 20;\n\n\t\t\t\tsize = maxLength / this.object.zoom * multiplier;\n\t\t\t\tdivisions = size / tick * this.object.zoom;\n\n\t\t\t} else if ( this.object.isPerspectiveCamera ) {\n\n\t\t\t\tconst distance = this.object.position.distanceTo( this._gizmos.position );\n\t\t\t\tconst halfFovV = MathUtils.DEG2RAD * this.object.fov * 0.5;\n\t\t\t\tconst halfFovH = Math.atan( ( this.object.aspect ) * Math.tan( halfFovV ) );\n\n\t\t\t\tmaxLength = Math.tan( Math.max( halfFovV, halfFovH ) ) * distance * 2;\n\t\t\t\ttick = maxLength / 20;\n\n\t\t\t\tsize = maxLength * multiplier;\n\t\t\t\tdivisions = size / tick;\n\n\t\t\t}\n\n\t\t\tif ( this._grid == null ) {\n\n\t\t\t\tthis._grid = new GridHelper( size, divisions, color, color );\n\t\t\t\tthis._grid.position.copy( this._gizmos.position );\n\t\t\t\tthis._gridPosition.copy( this._grid.position );\n\t\t\t\tthis._grid.quaternion.copy( this.object.quaternion );\n\t\t\t\tthis._grid.rotateX( Math.PI * 0.5 );\n\n\t\t\t\tthis.scene.add( this._grid );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tif ( this._animationId != - 1 ) {\n\n\t\t\twindow.cancelAnimationFrame( this._animationId );\n\n\t\t}\n\n\t\tthis.disconnect();\n\n\t\tif ( this.scene !== null ) this.scene.remove( this._gizmos );\n\t\tthis.disposeGrid();\n\n\t}\n\n\t/**\n\t * Removes the grid from the scene.\n\t */\n\tdisposeGrid() {\n\n\t\tif ( this._grid != null && this.scene != null ) {\n\n\t\t\tthis.scene.remove( this._grid );\n\t\t\tthis._grid = null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Computes the easing out cubic function for ease out effect in animation.\n\t *\n\t * @private\n\t * @param {number} t - The absolute progress of the animation in the bound of `0` (beginning of the) and `1` (ending of animation).\n\t * @returns {number} Result of easing out cubic at time `t`.\n\t */\n\teaseOutCubic( t ) {\n\n\t\treturn 1 - Math.pow( 1 - t, 3 );\n\n\t}\n\n\t/**\n\t * Makes rotation gizmos more or less visible.\n\t *\n\t * @param {boolean} isActive - If set to `true`, gizmos are more visible.\n\t */\n\tactivateGizmos( isActive ) {\n\n\t\tconst gizmoX = this._gizmos.children[ 0 ];\n\t\tconst gizmoY = this._gizmos.children[ 1 ];\n\t\tconst gizmoZ = this._gizmos.children[ 2 ];\n\n\t\tif ( isActive ) {\n\n\t\t\tgizmoX.material.setValues( { opacity: 1 } );\n\t\t\tgizmoY.material.setValues( { opacity: 1 } );\n\t\t\tgizmoZ.material.setValues( { opacity: 1 } );\n\n\t\t} else {\n\n\t\t\tgizmoX.material.setValues( { opacity: 0.6 } );\n\t\t\tgizmoY.material.setValues( { opacity: 0.6 } );\n\t\t\tgizmoZ.material.setValues( { opacity: 0.6 } );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Calculates the cursor position in NDC.\n\t *\n\t * @private\n\t * @param {number} cursorX - Cursor horizontal coordinate within the canvas.\n\t * @param {number} cursorY - Cursor vertical coordinate within the canvas.\n\t * @param {HTMLElement} canvas - The canvas where the renderer draws its output.\n\t * @returns {Vector2} Cursor normalized position inside the canvas.\n\t */\n\tgetCursorNDC( cursorX, cursorY, canvas ) {\n\n\t\tconst canvasRect = canvas.getBoundingClientRect();\n\t\tthis._v2_1.setX( ( ( cursorX - canvasRect.left ) / canvasRect.width ) * 2 - 1 );\n\t\tthis._v2_1.setY( ( ( canvasRect.bottom - cursorY ) / canvasRect.height ) * 2 - 1 );\n\t\treturn this._v2_1.clone();\n\n\t}\n\n\t/**\n\t * Calculates the cursor position inside the canvas x/y coordinates with the origin being in the center of the canvas.\n\t *\n\t * @private\n\t * @param {number} cursorX - Cursor horizontal coordinate within the canvas.\n\t * @param {number} cursorY - Cursor vertical coordinate within the canvas.\n\t * @param {HTMLElement} canvas - The canvas where the renderer draws its output.\n\t * @returns {Vector2} Cursor position inside the canvas.\n\t */\n\tgetCursorPosition( cursorX, cursorY, canvas ) {\n\n\t\tthis._v2_1.copy( this.getCursorNDC( cursorX, cursorY, canvas ) );\n\t\tthis._v2_1.x *= ( this.object.right - this.object.left ) * 0.5;\n\t\tthis._v2_1.y *= ( this.object.top - this.object.bottom ) * 0.5;\n\t\treturn this._v2_1.clone();\n\n\t}\n\n\t/**\n\t * Sets the camera to be controlled.  Must be called in order to set a new camera to be controlled.\n\t *\n\t * @param {Camera} camera - The camera to be controlled.\n\t */\n\tsetCamera( camera ) {\n\n\t\tcamera.lookAt( this.target );\n\t\tcamera.updateMatrix();\n\n\t\t//setting state\n\t\tif ( camera.type == 'PerspectiveCamera' ) {\n\n\t\t\tthis._fov0 = camera.fov;\n\t\t\tthis._fovState = camera.fov;\n\n\t\t}\n\n\t\tthis._cameraMatrixState0.copy( camera.matrix );\n\t\tthis._cameraMatrixState.copy( this._cameraMatrixState0 );\n\t\tthis._cameraProjectionState.copy( camera.projectionMatrix );\n\t\tthis._zoom0 = camera.zoom;\n\t\tthis._zoomState = this._zoom0;\n\n\t\tthis._initialNear = camera.near;\n\t\tthis._nearPos0 = camera.position.distanceTo( this.target ) - camera.near;\n\t\tthis._nearPos = this._initialNear;\n\n\t\tthis._initialFar = camera.far;\n\t\tthis._farPos0 = camera.position.distanceTo( this.target ) - camera.far;\n\t\tthis._farPos = this._initialFar;\n\n\t\tthis._up0.copy( camera.up );\n\t\tthis._upState.copy( camera.up );\n\n\t\tthis.object = camera;\n\t\tthis.object.updateProjectionMatrix();\n\n\t\t//making gizmos\n\t\tthis._tbRadius = this.calculateTbRadius( camera );\n\t\tthis.makeGizmos( this.target, this._tbRadius );\n\n\t}\n\n\t/**\n\t * Sets gizmos visibility.\n\t *\n\t * @param {boolean} value - Value of gizmos visibility.\n\t */\n\tsetGizmosVisible( value ) {\n\n\t\tthis._gizmos.visible = value;\n\t\tthis.dispatchEvent( _changeEvent );\n\n\t}\n\n\t/**\n\t * Sets gizmos radius factor and redraws gizmos.\n\t *\n\t * @param {number} value - Value of radius factor.\n\t */\n\tsetTbRadius( value ) {\n\n\t\tthis.radiusFactor = value;\n\t\tthis._tbRadius = this.calculateTbRadius( this.object );\n\n\t\tconst curve = new EllipseCurve( 0, 0, this._tbRadius, this._tbRadius );\n\t\tconst points = curve.getPoints( this._curvePts );\n\t\tconst curveGeometry = new BufferGeometry().setFromPoints( points );\n\n\n\t\tfor ( const gizmo in this._gizmos.children ) {\n\n\t\t\tthis._gizmos.children[ gizmo ].geometry = curveGeometry;\n\n\t\t}\n\n\t\tthis.dispatchEvent( _changeEvent );\n\n\t}\n\n\t/**\n\t * Creates the rotation gizmos matching trackball center and radius.\n\t *\n\t * @private\n\t * @param {Vector3} tbCenter - The trackball center.\n\t * @param {number} tbRadius - The trackball radius.\n\t */\n\tmakeGizmos( tbCenter, tbRadius ) {\n\n\t\tconst curve = new EllipseCurve( 0, 0, tbRadius, tbRadius );\n\t\tconst points = curve.getPoints( this._curvePts );\n\n\t\t//geometry\n\t\tconst curveGeometry = new BufferGeometry().setFromPoints( points );\n\n\t\t//material\n\t\tconst curveMaterialX = new LineBasicMaterial( { color: 0xff8080, fog: false, transparent: true, opacity: 0.6 } );\n\t\tconst curveMaterialY = new LineBasicMaterial( { color: 0x80ff80, fog: false, transparent: true, opacity: 0.6 } );\n\t\tconst curveMaterialZ = new LineBasicMaterial( { color: 0x8080ff, fog: false, transparent: true, opacity: 0.6 } );\n\n\t\t//line\n\t\tconst gizmoX = new Line( curveGeometry, curveMaterialX );\n\t\tconst gizmoY = new Line( curveGeometry, curveMaterialY );\n\t\tconst gizmoZ = new Line( curveGeometry, curveMaterialZ );\n\n\t\tconst rotation = Math.PI * 0.5;\n\t\tgizmoX.rotation.x = rotation;\n\t\tgizmoY.rotation.y = rotation;\n\n\n\t\t//setting state\n\t\tthis._gizmoMatrixState0.identity().setPosition( tbCenter );\n\t\tthis._gizmoMatrixState.copy( this._gizmoMatrixState0 );\n\n\t\tif ( this.object.zoom !== 1 ) {\n\n\t\t\t//adapt gizmos size to camera zoom\n\t\t\tconst size = 1 / this.object.zoom;\n\t\t\tthis._scaleMatrix.makeScale( size, size, size );\n\t\t\tthis._translationMatrix.makeTranslation( - tbCenter.x, - tbCenter.y, - tbCenter.z );\n\n\t\t\tthis._gizmoMatrixState.premultiply( this._translationMatrix ).premultiply( this._scaleMatrix );\n\t\t\tthis._translationMatrix.makeTranslation( tbCenter.x, tbCenter.y, tbCenter.z );\n\t\t\tthis._gizmoMatrixState.premultiply( this._translationMatrix );\n\n\t\t}\n\n\t\tthis._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\n\t\t//\n\n\t\tthis._gizmos.traverse( function ( object ) {\n\n\t\t\tif ( object.isLine ) {\n\n\t\t\t\tobject.geometry.dispose();\n\t\t\t\tobject.material.dispose();\n\n\t\t\t}\n\n\t\t} );\n\n\t\tthis._gizmos.clear();\n\n\t\t//\n\n\t\tthis._gizmos.add( gizmoX );\n\t\tthis._gizmos.add( gizmoY );\n\t\tthis._gizmos.add( gizmoZ );\n\n\t}\n\n\t/**\n\t * Performs animation for focus operation.\n\t *\n\t * @private\n\t * @param {number} time - Instant in which this function is called as performance.now().\n\t * @param {Vector3} point - Point of interest for focus operation.\n\t * @param {Matrix4} cameraMatrix - Camera matrix.\n\t * @param {Matrix4} gizmoMatrix - Gizmos matrix.\n\t */\n\tonFocusAnim( time, point, cameraMatrix, gizmoMatrix ) {\n\n\t\tif ( this._timeStart == - 1 ) {\n\n\t\t\t//animation start\n\t\t\tthis._timeStart = time;\n\n\t\t}\n\n\t\tif ( this._state == STATE.ANIMATION_FOCUS ) {\n\n\t\t\tconst deltaTime = time - this._timeStart;\n\t\t\tconst animTime = deltaTime / this.focusAnimationTime;\n\n\t\t\tthis._gizmoMatrixState.copy( gizmoMatrix );\n\n\t\t\tif ( animTime >= 1 ) {\n\n\t\t\t\t//animation end\n\n\t\t\t\tthis._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\n\t\t\t\tthis.focus( point, this.scaleFactor );\n\n\t\t\t\tthis._timeStart = - 1;\n\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\t\t\t\tthis.activateGizmos( false );\n\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t} else {\n\n\t\t\t\tconst amount = this.easeOutCubic( animTime );\n\t\t\t\tconst size = ( ( 1 - amount ) + ( this.scaleFactor * amount ) );\n\n\t\t\t\tthis._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\t\t\t\tthis.focus( point, size, amount );\n\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\t\t\t\tconst self = this;\n\t\t\t\tthis._animationId = window.requestAnimationFrame( function ( t ) {\n\n\t\t\t\t\tself.onFocusAnim( t, point, cameraMatrix, gizmoMatrix.clone() );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t//interrupt animation\n\n\t\t\tthis._animationId = - 1;\n\t\t\tthis._timeStart = - 1;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Performs animation for rotation operation.\n\t *\n\t * @private\n\t * @param {number} time - Instant in which this function is called as performance.now().\n\t * @param {Vector3} rotationAxis - Rotation axis.\n\t * @param {number} w0 - Initial angular velocity.\n\t */\n\tonRotationAnim( time, rotationAxis, w0 ) {\n\n\t\tif ( this._timeStart == - 1 ) {\n\n\t\t\t//animation start\n\t\t\tthis._anglePrev = 0;\n\t\t\tthis._angleCurrent = 0;\n\t\t\tthis._timeStart = time;\n\n\t\t}\n\n\t\tif ( this._state == STATE.ANIMATION_ROTATE ) {\n\n\t\t\t//w = w0 + alpha * t\n\t\t\tconst deltaTime = ( time - this._timeStart ) / 1000;\n\t\t\tconst w = w0 + ( ( - this.dampingFactor ) * deltaTime );\n\n\t\t\tif ( w > 0 ) {\n\n\t\t\t\t//tetha = 0.5 * alpha * t^2 + w0 * t + tetha0\n\t\t\t\tthis._angleCurrent = 0.5 * ( - this.dampingFactor ) * Math.pow( deltaTime, 2 ) + w0 * deltaTime + 0;\n\t\t\t\tthis.applyTransformMatrix( this.rotate( rotationAxis, this._angleCurrent ) );\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\t\t\t\tconst self = this;\n\t\t\t\tthis._animationId = window.requestAnimationFrame( function ( t ) {\n\n\t\t\t\t\tself.onRotationAnim( t, rotationAxis, w0 );\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\tthis._animationId = - 1;\n\t\t\t\tthis._timeStart = - 1;\n\n\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\t\t\t\tthis.activateGizmos( false );\n\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t//interrupt animation\n\n\t\t\tthis._animationId = - 1;\n\t\t\tthis._timeStart = - 1;\n\n\t\t\tif ( this._state != STATE.ROTATE ) {\n\n\t\t\t\tthis.activateGizmos( false );\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\t/**\n\t * Performs pan operation moving camera between two points.\n\t *\n\t * @private\n\t * @param {Vector3} p0 - Initial point.\n\t * @param {Vector3} p1 - Ending point.\n\t * @param {boolean} [adjust=false] - If movement should be adjusted considering camera distance (Perspective only).\n\t * @returns {Object}\n\t */\n\tpan( p0, p1, adjust = false ) {\n\n\t\tconst movement = p0.clone().sub( p1 );\n\n\t\tif ( this.object.isOrthographicCamera ) {\n\n\t\t\t//adjust movement amount\n\t\t\tmovement.multiplyScalar( 1 / this.object.zoom );\n\n\t\t} else if ( this.object.isPerspectiveCamera && adjust ) {\n\n\t\t\t//adjust movement amount\n\t\t\tthis._v3_1.setFromMatrixPosition( this._cameraMatrixState0 );\t//camera's initial position\n\t\t\tthis._v3_2.setFromMatrixPosition( this._gizmoMatrixState0 );\t//gizmo's initial position\n\t\t\tconst distanceFactor = this._v3_1.distanceTo( this._v3_2 ) / this.object.position.distanceTo( this._gizmos.position );\n\t\t\tmovement.multiplyScalar( 1 / distanceFactor );\n\n\t\t}\n\n\t\tthis._v3_1.set( movement.x, movement.y, 0 ).applyQuaternion( this.object.quaternion );\n\n\t\tthis._m4_1.makeTranslation( this._v3_1.x, this._v3_1.y, this._v3_1.z );\n\n\t\tthis.setTransformationMatrices( this._m4_1, this._m4_1 );\n\t\treturn _transformation;\n\n\t}\n\n\t/**\n\t * Resets the controls.\n\t */\n\treset() {\n\n\t\tthis.target.copy( this._target0 );\n\t\tthis.object.zoom = this._zoom0;\n\n\t\tif ( this.object.isPerspectiveCamera ) {\n\n\t\t\tthis.object.fov = this._fov0;\n\n\t\t}\n\n\t\tthis.object.near = this._nearPos;\n\t\tthis.object.far = this._farPos;\n\t\tthis._cameraMatrixState.copy( this._cameraMatrixState0 );\n\t\tthis._cameraMatrixState.decompose( this.object.position, this.object.quaternion, this.object.scale );\n\t\tthis.object.up.copy( this._up0 );\n\n\t\tthis.object.updateMatrix();\n\t\tthis.object.updateProjectionMatrix();\n\n\t\tthis._gizmoMatrixState.copy( this._gizmoMatrixState0 );\n\t\tthis._gizmoMatrixState0.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\t\tthis._gizmos.updateMatrix();\n\n\t\tthis._tbRadius = this.calculateTbRadius( this.object );\n\t\tthis.makeGizmos( this._gizmos.position, this._tbRadius );\n\n\t\tthis.object.lookAt( this._gizmos.position );\n\n\t\tthis.updateTbState( STATE.IDLE, false );\n\n\t\tthis.dispatchEvent( _changeEvent );\n\n\t}\n\n\t/**\n\t * Rotates the camera around an axis passing by trackball's center.\n\t *\n\t * @private\n\t * @param {Vector3} axis - Rotation axis.\n\t * @param {number} angle - Angle in radians.\n\t * @returns {Object} Object with 'camera' field containing transformation matrix resulting from the operation to be applied to the camera.\n\t */\n\trotate( axis, angle ) {\n\n\t\tconst point = this._gizmos.position; //rotation center\n\t\tthis._translationMatrix.makeTranslation( - point.x, - point.y, - point.z );\n\t\tthis._rotationMatrix.makeRotationAxis( axis, - angle );\n\n\t\t//rotate camera\n\t\tthis._m4_1.makeTranslation( point.x, point.y, point.z );\n\t\tthis._m4_1.multiply( this._rotationMatrix );\n\t\tthis._m4_1.multiply( this._translationMatrix );\n\n\t\tthis.setTransformationMatrices( this._m4_1 );\n\n\t\treturn _transformation;\n\n\t}\n\n\t/**\n\t * Copy the current state to clipboard (as a readable JSON text).\n\t */\n\tcopyState() {\n\n\t\tlet state;\n\t\tif ( this.object.isOrthographicCamera ) {\n\n\t\t\tstate = JSON.stringify( {\n\t\t\t\tarcballState: {\n\t\t\t\t\tcameraFar: this.object.far,\n\t\t\t\t\tcameraMatrix: this.object.matrix,\n\t\t\t\t\tcameraNear: this.object.near,\n\t\t\t\t\tcameraUp: this.object.up,\n\t\t\t\t\tcameraZoom: this.object.zoom,\n\t\t\t\t\tgizmoMatrix: this._gizmos.matrix,\n\t\t\t\t\ttarget: this.target\n\n\t\t\t\t}\n\t\t\t} );\n\n\t\t} else if ( this.object.isPerspectiveCamera ) {\n\n\t\t\tstate = JSON.stringify( {\n\t\t\t\tarcballState: {\n\t\t\t\t\tcameraFar: this.object.far,\n\t\t\t\t\tcameraFov: this.object.fov,\n\t\t\t\t\tcameraMatrix: this.object.matrix,\n\t\t\t\t\tcameraNear: this.object.near,\n\t\t\t\t\tcameraUp: this.object.up,\n\t\t\t\t\tcameraZoom: this.object.zoom,\n\t\t\t\t\tgizmoMatrix: this._gizmos.matrix,\n\t\t\t\t\ttarget: this.target\n\n\t\t\t\t}\n\t\t\t} );\n\n\t\t}\n\n\t\tnavigator.clipboard.writeText( state );\n\n\t}\n\n\t/**\n\t * Set the controls state from the clipboard, assumes that the clipboard stores a JSON\n\t * text as saved from `copyState()`.\n\t */\n\tpasteState() {\n\n\t\tconst self = this;\n\t\tnavigator.clipboard.readText().then( function resolved( value ) {\n\n\t\t\tself.setStateFromJSON( value );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Saves the current state of the control. This can later be recover with `reset()`.\n\t */\n\tsaveState() {\n\n\t\tthis.object.updateMatrix();\n\t\tthis._gizmos.updateMatrix();\n\n\t\tthis._target0.copy( this.target );\n\t\tthis._cameraMatrixState0.copy( this.object.matrix );\n\t\tthis._gizmoMatrixState0.copy( this._gizmos.matrix );\n\t\tthis._nearPos = this.object.near;\n\t\tthis._farPos = this.object.far;\n\t\tthis._zoom0 = this.object.zoom;\n\t\tthis._up0.copy( this.object.up );\n\n\t\tif ( this.object.isPerspectiveCamera ) {\n\n\t\t\tthis._fov0 = this.object.fov;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Performs uniform scale operation around a given point.\n\t *\n\t * @private\n\t * @param {number} size - Scale factor.\n\t * @param {Vector3} point - Point around which scale.\n\t * @param {boolean} scaleGizmos - If gizmos should be scaled (Perspective only).\n\t * @returns {Object} Object with 'camera' and 'gizmo' fields containing transformation matrices resulting from the operation to be applied to the camera and gizmos.\n\t */\n\tscale( size, point, scaleGizmos = true ) {\n\n\t\t_scalePointTemp.copy( point );\n\t\tlet sizeInverse = 1 / size;\n\n\t\tif ( this.object.isOrthographicCamera ) {\n\n\t\t\t//camera zoom\n\t\t\tthis.object.zoom = this._zoomState;\n\t\t\tthis.object.zoom *= size;\n\n\t\t\t//check min and max zoom\n\t\t\tif ( this.object.zoom > this.maxZoom ) {\n\n\t\t\t\tthis.object.zoom = this.maxZoom;\n\t\t\t\tsizeInverse = this._zoomState / this.maxZoom;\n\n\t\t\t} else if ( this.object.zoom < this.minZoom ) {\n\n\t\t\t\tthis.object.zoom = this.minZoom;\n\t\t\t\tsizeInverse = this._zoomState / this.minZoom;\n\n\t\t\t}\n\n\t\t\tthis.object.updateProjectionMatrix();\n\n\t\t\tthis._v3_1.setFromMatrixPosition( this._gizmoMatrixState );\t//gizmos position\n\n\t\t\t//scale gizmos so they appear in the same spot having the same dimension\n\t\t\tthis._scaleMatrix.makeScale( sizeInverse, sizeInverse, sizeInverse );\n\t\t\tthis._translationMatrix.makeTranslation( - this._v3_1.x, - this._v3_1.y, - this._v3_1.z );\n\n\t\t\tthis._m4_2.makeTranslation( this._v3_1.x, this._v3_1.y, this._v3_1.z ).multiply( this._scaleMatrix );\n\t\t\tthis._m4_2.multiply( this._translationMatrix );\n\n\n\t\t\t//move camera and gizmos to obtain pinch effect\n\t\t\t_scalePointTemp.sub( this._v3_1 );\n\n\t\t\tconst amount = _scalePointTemp.clone().multiplyScalar( sizeInverse );\n\t\t\t_scalePointTemp.sub( amount );\n\n\t\t\tthis._m4_1.makeTranslation( _scalePointTemp.x, _scalePointTemp.y, _scalePointTemp.z );\n\t\t\tthis._m4_2.premultiply( this._m4_1 );\n\n\t\t\tthis.setTransformationMatrices( this._m4_1, this._m4_2 );\n\t\t\treturn _transformation;\n\n\t\t} else if ( this.object.isPerspectiveCamera ) {\n\n\t\t\tthis._v3_1.setFromMatrixPosition( this._cameraMatrixState );\n\t\t\tthis._v3_2.setFromMatrixPosition( this._gizmoMatrixState );\n\n\t\t\t//move camera\n\t\t\tlet distance = this._v3_1.distanceTo( _scalePointTemp );\n\t\t\tlet amount = distance - ( distance * sizeInverse );\n\n\t\t\t//check min and max distance\n\t\t\tconst newDistance = distance - amount;\n\t\t\tif ( newDistance < this.minDistance ) {\n\n\t\t\t\tsizeInverse = this.minDistance / distance;\n\t\t\t\tamount = distance - ( distance * sizeInverse );\n\n\t\t\t} else if ( newDistance > this.maxDistance ) {\n\n\t\t\t\tsizeInverse = this.maxDistance / distance;\n\t\t\t\tamount = distance - ( distance * sizeInverse );\n\n\t\t\t}\n\n\t\t\t_offset.copy( _scalePointTemp ).sub( this._v3_1 ).normalize().multiplyScalar( amount );\n\n\t\t\tthis._m4_1.makeTranslation( _offset.x, _offset.y, _offset.z );\n\n\n\t\t\tif ( scaleGizmos ) {\n\n\t\t\t\t//scale gizmos so they appear in the same spot having the same dimension\n\t\t\t\tconst pos = this._v3_2;\n\n\t\t\t\tdistance = pos.distanceTo( _scalePointTemp );\n\t\t\t\tamount = distance - ( distance * sizeInverse );\n\t\t\t\t_offset.copy( _scalePointTemp ).sub( this._v3_2 ).normalize().multiplyScalar( amount );\n\n\t\t\t\tthis._translationMatrix.makeTranslation( pos.x, pos.y, pos.z );\n\t\t\t\tthis._scaleMatrix.makeScale( sizeInverse, sizeInverse, sizeInverse );\n\n\t\t\t\tthis._m4_2.makeTranslation( _offset.x, _offset.y, _offset.z ).multiply( this._translationMatrix );\n\t\t\t\tthis._m4_2.multiply( this._scaleMatrix );\n\n\t\t\t\tthis._translationMatrix.makeTranslation( - pos.x, - pos.y, - pos.z );\n\n\t\t\t\tthis._m4_2.multiply( this._translationMatrix );\n\t\t\t\tthis.setTransformationMatrices( this._m4_1, this._m4_2 );\n\n\n\t\t\t} else {\n\n\t\t\t\tthis.setTransformationMatrices( this._m4_1 );\n\n\t\t\t}\n\n\t\t\treturn _transformation;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets camera fov.\n\t *\n\t * @private\n\t * @param {number} value - The FOV to be set.\n\t */\n\tsetFov( value ) {\n\n\t\tif ( this.object.isPerspectiveCamera ) {\n\n\t\t\tthis.object.fov = MathUtils.clamp( value, this.minFov, this.maxFov );\n\t\t\tthis.object.updateProjectionMatrix();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets values in transformation object.\n\t *\n\t * @private\n\t * @param {Matrix4} [camera=null] - Transformation to be applied to the camera.\n\t * @param {Matrix4} [gizmos=null] - Transformation to be applied to gizmos.\n\t */\n\tsetTransformationMatrices( camera = null, gizmos = null ) {\n\n\t\tif ( camera != null ) {\n\n\t\t\tif ( _transformation.camera != null ) {\n\n\t\t\t\t_transformation.camera.copy( camera );\n\n\t\t\t} else {\n\n\t\t\t\t_transformation.camera = camera.clone();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_transformation.camera = null;\n\n\t\t}\n\n\t\tif ( gizmos != null ) {\n\n\t\t\tif ( _transformation.gizmos != null ) {\n\n\t\t\t\t_transformation.gizmos.copy( gizmos );\n\n\t\t\t} else {\n\n\t\t\t\t_transformation.gizmos = gizmos.clone();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_transformation.gizmos = null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Rotates camera around its direction axis passing by a given point by a given angle.\n\t *\n\t * @private\n\t * @param {Vector3} point - The point where the rotation axis is passing trough.\n\t * @param {number} angle - Angle in radians.\n\t * @returns {Object} The computed transformation matrix.\n\t */\n\tzRotate( point, angle ) {\n\n\t\tthis._rotationMatrix.makeRotationAxis( this._rotationAxis, angle );\n\t\tthis._translationMatrix.makeTranslation( - point.x, - point.y, - point.z );\n\n\t\tthis._m4_1.makeTranslation( point.x, point.y, point.z );\n\t\tthis._m4_1.multiply( this._rotationMatrix );\n\t\tthis._m4_1.multiply( this._translationMatrix );\n\n\t\tthis._v3_1.setFromMatrixPosition( this._gizmoMatrixState ).sub( point );\t//vector from rotation center to gizmos position\n\t\tthis._v3_2.copy( this._v3_1 ).applyAxisAngle( this._rotationAxis, angle );\t//apply rotation\n\t\tthis._v3_2.sub( this._v3_1 );\n\n\t\tthis._m4_2.makeTranslation( this._v3_2.x, this._v3_2.y, this._v3_2.z );\n\n\t\tthis.setTransformationMatrices( this._m4_1, this._m4_2 );\n\t\treturn _transformation;\n\n\t}\n\n\t/**\n\t * Returns the raycaster that is used for user interaction. This object is shared between all\n\t * instances of `ArcballControls`.\n\t *\n\t * @returns {Raycaster} The internal raycaster.\n\t */\n\tgetRaycaster() {\n\n\t\treturn _raycaster;\n\n\t}\n\n\n\t/**\n\t * Unprojects the cursor on the 3D object surface.\n\t *\n\t * @private\n\t * @param {Vector2} cursor - Cursor coordinates in NDC.\n\t * @param {Camera} camera - Virtual camera.\n\t * @returns {?Vector3} The point of intersection with the model, if exist, null otherwise.\n\t */\n\tunprojectOnObj( cursor, camera ) {\n\n\t\tconst raycaster = this.getRaycaster();\n\t\traycaster.near = camera.near;\n\t\traycaster.far = camera.far;\n\t\traycaster.setFromCamera( cursor, camera );\n\n\t\tconst intersect = raycaster.intersectObjects( this.scene.children, true );\n\n\t\tfor ( let i = 0; i < intersect.length; i ++ ) {\n\n\t\t\tif ( intersect[ i ].object.uuid != this._gizmos.uuid && intersect[ i ].face != null ) {\n\n\t\t\t\treturn intersect[ i ].point.clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Unproject the cursor on the trackball surface.\n\t *\n\t * @private\n\t * @param {Camera} camera - The virtual camera.\n\t * @param {number} cursorX - Cursor horizontal coordinate on screen.\n\t * @param {number} cursorY - Cursor vertical coordinate on screen.\n\t * @param {HTMLElement} canvas - The canvas where the renderer draws its output.\n\t * @param {number} tbRadius - The trackball radius.\n\t * @returns {Vector3} The unprojected point on the trackball surface.\n\t */\n\tunprojectOnTbSurface( camera, cursorX, cursorY, canvas, tbRadius ) {\n\n\t\tif ( camera.type == 'OrthographicCamera' ) {\n\n\t\t\tthis._v2_1.copy( this.getCursorPosition( cursorX, cursorY, canvas ) );\n\t\t\tthis._v3_1.set( this._v2_1.x, this._v2_1.y, 0 );\n\n\t\t\tconst x2 = Math.pow( this._v2_1.x, 2 );\n\t\t\tconst y2 = Math.pow( this._v2_1.y, 2 );\n\t\t\tconst r2 = Math.pow( this._tbRadius, 2 );\n\n\t\t\tif ( x2 + y2 <= r2 * 0.5 ) {\n\n\t\t\t\t//intersection with sphere\n\t\t\t\tthis._v3_1.setZ( Math.sqrt( r2 - ( x2 + y2 ) ) );\n\n\t\t\t} else {\n\n\t\t\t\t//intersection with hyperboloid\n\t\t\t\tthis._v3_1.setZ( ( r2 * 0.5 ) / ( Math.sqrt( x2 + y2 ) ) );\n\n\t\t\t}\n\n\t\t\treturn this._v3_1;\n\n\t\t} else if ( camera.type == 'PerspectiveCamera' ) {\n\n\t\t\t//unproject cursor on the near plane\n\t\t\tthis._v2_1.copy( this.getCursorNDC( cursorX, cursorY, canvas ) );\n\n\t\t\tthis._v3_1.set( this._v2_1.x, this._v2_1.y, - 1 );\n\t\t\tthis._v3_1.applyMatrix4( camera.projectionMatrixInverse );\n\n\t\t\tconst rayDir = this._v3_1.clone().normalize(); //unprojected ray direction\n\t\t\tconst cameraGizmoDistance = camera.position.distanceTo( this._gizmos.position );\n\t\t\tconst radius2 = Math.pow( tbRadius, 2 );\n\n\t\t\t//\t  camera\n\t\t\t//\t\t|\\\n\t\t\t//\t\t| \\\n\t\t\t//\t\t|  \\\n\t\t\t//\th\t|\t\\\n\t\t\t//\t\t| \t \\\n\t\t\t//\t\t| \t  \\\n\t\t\t//\t_ _ | _ _ _\\ _ _  near plane\n\t\t\t//\t\t\tl\n\n\t\t\tconst h = this._v3_1.z;\n\t\t\tconst l = Math.sqrt( Math.pow( this._v3_1.x, 2 ) + Math.pow( this._v3_1.y, 2 ) );\n\n\t\t\tif ( l == 0 ) {\n\n\t\t\t\t//ray aligned with camera\n\t\t\t\trayDir.set( this._v3_1.x, this._v3_1.y, tbRadius );\n\t\t\t\treturn rayDir;\n\n\t\t\t}\n\n\t\t\tconst m = h / l;\n\t\t\tconst q = cameraGizmoDistance;\n\n\t\t\t/*\n\t\t\t * calculate intersection point between unprojected ray and trackball surface\n\t\t\t *|y = m * x + q\n\t\t\t *|x^2 + y^2 = r^2\n\t\t\t *\n\t\t\t * (m^2 + 1) * x^2 + (2 * m * q) * x + q^2 - r^2 = 0\n\t\t\t */\n\t\t\tlet a = Math.pow( m, 2 ) + 1;\n\t\t\tlet b = 2 * m * q;\n\t\t\tlet c = Math.pow( q, 2 ) - radius2;\n\t\t\tlet delta = Math.pow( b, 2 ) - ( 4 * a * c );\n\n\t\t\tif ( delta >= 0 ) {\n\n\t\t\t\t//intersection with sphere\n\t\t\t\tthis._v2_1.setX( ( - b - Math.sqrt( delta ) ) / ( 2 * a ) );\n\t\t\t\tthis._v2_1.setY( m * this._v2_1.x + q );\n\n\t\t\t\tconst angle = MathUtils.RAD2DEG * this._v2_1.angle();\n\n\t\t\t\tif ( angle >= 45 ) {\n\n\t\t\t\t\t//if angle between intersection point and X' axis is >= 45°, return that point\n\t\t\t\t\t//otherwise, calculate intersection point with hyperboloid\n\n\t\t\t\t\tconst rayLength = Math.sqrt( Math.pow( this._v2_1.x, 2 ) + Math.pow( ( cameraGizmoDistance - this._v2_1.y ), 2 ) );\n\t\t\t\t\trayDir.multiplyScalar( rayLength );\n\t\t\t\t\trayDir.z += cameraGizmoDistance;\n\t\t\t\t\treturn rayDir;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//intersection with hyperboloid\n\t\t\t/*\n\t\t\t *|y = m * x + q\n\t\t\t *|y = (1 / x) * (r^2 / 2)\n\t\t\t *\n\t\t\t * m * x^2 + q * x - r^2 / 2 = 0\n\t\t\t */\n\n\t\t\ta = m;\n\t\t\tb = q;\n\t\t\tc = - radius2 * 0.5;\n\t\t\tdelta = Math.pow( b, 2 ) - ( 4 * a * c );\n\t\t\tthis._v2_1.setX( ( - b - Math.sqrt( delta ) ) / ( 2 * a ) );\n\t\t\tthis._v2_1.setY( m * this._v2_1.x + q );\n\n\t\t\tconst rayLength = Math.sqrt( Math.pow( this._v2_1.x, 2 ) + Math.pow( ( cameraGizmoDistance - this._v2_1.y ), 2 ) );\n\n\t\t\trayDir.multiplyScalar( rayLength );\n\t\t\trayDir.z += cameraGizmoDistance;\n\t\t\treturn rayDir;\n\n\t\t}\n\n\t}\n\n\n\t/**\n\t * Unprojects the cursor on the plane passing through the center of the trackball orthogonal to the camera.\n\t *\n\t * @private\n\t * @param {Camera} camera - The virtual camera.\n\t * @param {number} cursorX - Cursor horizontal coordinate on screen.\n\t * @param {number} cursorY - Cursor vertical coordinate on screen.\n\t * @param {HTMLElement} canvas - The canvas where the renderer draws its output.\n\t * @param {boolean} [initialDistance=false] - If initial distance between camera and gizmos should be used for calculations instead of current (Perspective only).\n\t * @returns {Vector3} The unprojected point on the trackball plane.\n\t */\n\tunprojectOnTbPlane( camera, cursorX, cursorY, canvas, initialDistance = false ) {\n\n\t\tif ( camera.type == 'OrthographicCamera' ) {\n\n\t\t\tthis._v2_1.copy( this.getCursorPosition( cursorX, cursorY, canvas ) );\n\t\t\tthis._v3_1.set( this._v2_1.x, this._v2_1.y, 0 );\n\n\t\t\treturn this._v3_1.clone();\n\n\t\t} else if ( camera.type == 'PerspectiveCamera' ) {\n\n\t\t\tthis._v2_1.copy( this.getCursorNDC( cursorX, cursorY, canvas ) );\n\n\t\t\t//unproject cursor on the near plane\n\t\t\tthis._v3_1.set( this._v2_1.x, this._v2_1.y, - 1 );\n\t\t\tthis._v3_1.applyMatrix4( camera.projectionMatrixInverse );\n\n\t\t\tconst rayDir = this._v3_1.clone().normalize(); //unprojected ray direction\n\n\t\t\t//\t  camera\n\t\t\t//\t\t|\\\n\t\t\t//\t\t| \\\n\t\t\t//\t\t|  \\\n\t\t\t//\th\t|\t\\\n\t\t\t//\t\t| \t \\\n\t\t\t//\t\t| \t  \\\n\t\t\t//\t_ _ | _ _ _\\ _ _  near plane\n\t\t\t//\t\t\tl\n\n\t\t\tconst h = this._v3_1.z;\n\t\t\tconst l = Math.sqrt( Math.pow( this._v3_1.x, 2 ) + Math.pow( this._v3_1.y, 2 ) );\n\t\t\tlet cameraGizmoDistance;\n\n\t\t\tif ( initialDistance ) {\n\n\t\t\t\tcameraGizmoDistance = this._v3_1.setFromMatrixPosition( this._cameraMatrixState0 ).distanceTo( this._v3_2.setFromMatrixPosition( this._gizmoMatrixState0 ) );\n\n\t\t\t} else {\n\n\t\t\t\tcameraGizmoDistance = camera.position.distanceTo( this._gizmos.position );\n\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * calculate intersection point between unprojected ray and the plane\n\t\t\t *|y = mx + q\n\t\t\t *|y = 0\n\t\t\t *\n\t\t\t * x = -q/m\n\t\t\t*/\n\t\t\tif ( l == 0 ) {\n\n\t\t\t\t//ray aligned with camera\n\t\t\t\trayDir.set( 0, 0, 0 );\n\t\t\t\treturn rayDir;\n\n\t\t\t}\n\n\t\t\tconst m = h / l;\n\t\t\tconst q = cameraGizmoDistance;\n\t\t\tconst x = - q / m;\n\n\t\t\tconst rayLength = Math.sqrt( Math.pow( q, 2 ) + Math.pow( x, 2 ) );\n\t\t\trayDir.multiplyScalar( rayLength );\n\t\t\trayDir.z = 0;\n\t\t\treturn rayDir;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates camera and gizmos state.\n\t *\n\t * @private\n\t */\n\tupdateMatrixState() {\n\n\t\t//update camera and gizmos state\n\t\tthis._cameraMatrixState.copy( this.object.matrix );\n\t\tthis._gizmoMatrixState.copy( this._gizmos.matrix );\n\n\t\tif ( this.object.isOrthographicCamera ) {\n\n\t\t\tthis._cameraProjectionState.copy( this.object.projectionMatrix );\n\t\t\tthis.object.updateProjectionMatrix();\n\t\t\tthis._zoomState = this.object.zoom;\n\n\t\t} else if ( this.object.isPerspectiveCamera ) {\n\n\t\t\tthis._fovState = this.object.fov;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the trackball FSA.\n\t *\n\t * @private\n\t * @param {STATE} newState - New state of the FSA.\n\t * @param {boolean} updateMatrices - If matrices state should be updated.\n\t */\n\tupdateTbState( newState, updateMatrices ) {\n\n\t\tthis._state = newState;\n\t\tif ( updateMatrices ) {\n\n\t\t\tthis.updateMatrixState();\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tif ( this.target.equals( this._currentTarget ) === false ) {\n\n\t\t\tthis._gizmos.position.copy( this.target );\t//for correct radius calculation\n\t\t\tthis._tbRadius = this.calculateTbRadius( this.object );\n\t\t\tthis.makeGizmos( this.target, this._tbRadius );\n\t\t\tthis._currentTarget.copy( this.target );\n\n\t\t}\n\n\t\t//check min/max parameters\n\t\tif ( this.object.isOrthographicCamera ) {\n\n\t\t\t//check zoom\n\t\t\tif ( this.object.zoom > this.maxZoom || this.object.zoom < this.minZoom ) {\n\n\t\t\t\tconst newZoom = MathUtils.clamp( this.object.zoom, this.minZoom, this.maxZoom );\n\t\t\t\tthis.applyTransformMatrix( this.scale( newZoom / this.object.zoom, this._gizmos.position, true ) );\n\n\t\t\t}\n\n\t\t} else if ( this.object.isPerspectiveCamera ) {\n\n\t\t\t//check distance\n\t\t\tconst distance = this.object.position.distanceTo( this._gizmos.position );\n\n\t\t\tif ( distance > this.maxDistance + _EPS || distance < this.minDistance - _EPS ) {\n\n\t\t\t\tconst newDistance = MathUtils.clamp( distance, this.minDistance, this.maxDistance );\n\t\t\t\tthis.applyTransformMatrix( this.scale( newDistance / distance, this._gizmos.position ) );\n\t\t\t\tthis.updateMatrixState();\n\n\t\t\t}\n\n\t\t\t//check fov\n\t\t\tif ( this.object.fov < this.minFov || this.object.fov > this.maxFov ) {\n\n\t\t\t\tthis.object.fov = MathUtils.clamp( this.object.fov, this.minFov, this.maxFov );\n\t\t\t\tthis.object.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tconst oldRadius = this._tbRadius;\n\t\t\tthis._tbRadius = this.calculateTbRadius( this.object );\n\n\t\t\tif ( oldRadius < this._tbRadius - _EPS || oldRadius > this._tbRadius + _EPS ) {\n\n\t\t\t\tconst scale = ( this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z ) / 3;\n\t\t\t\tconst newRadius = this._tbRadius / scale;\n\t\t\t\tconst curve = new EllipseCurve( 0, 0, newRadius, newRadius );\n\t\t\t\tconst points = curve.getPoints( this._curvePts );\n\t\t\t\tconst curveGeometry = new BufferGeometry().setFromPoints( points );\n\n\t\t\t\tfor ( const gizmo in this._gizmos.children ) {\n\n\t\t\t\t\tthis._gizmos.children[ gizmo ].geometry = curveGeometry;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.object.lookAt( this._gizmos.position );\n\n\t}\n\n\tsetStateFromJSON( json ) {\n\n\t\tconst state = JSON.parse( json );\n\n\t\tif ( state.arcballState != undefined ) {\n\n\t\t\tthis.target.fromArray( state.arcballState.target );\n\n\t\t\tthis._cameraMatrixState.fromArray( state.arcballState.cameraMatrix.elements );\n\t\t\tthis._cameraMatrixState.decompose( this.object.position, this.object.quaternion, this.object.scale );\n\n\t\t\tthis.object.up.copy( state.arcballState.cameraUp );\n\t\t\tthis.object.near = state.arcballState.cameraNear;\n\t\t\tthis.object.far = state.arcballState.cameraFar;\n\n\t\t\tthis.object.zoom = state.arcballState.cameraZoom;\n\n\t\t\tif ( this.object.isPerspectiveCamera ) {\n\n\t\t\t\tthis.object.fov = state.arcballState.cameraFov;\n\n\t\t\t}\n\n\t\t\tthis._gizmoMatrixState.fromArray( state.arcballState.gizmoMatrix.elements );\n\t\t\tthis._gizmoMatrixState.decompose( this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale );\n\n\t\t\tthis.object.updateMatrix();\n\t\t\tthis.object.updateProjectionMatrix();\n\n\t\t\tthis._gizmos.updateMatrix();\n\n\t\t\tthis._tbRadius = this.calculateTbRadius( this.object );\n\t\t\tconst gizmoTmp = new Matrix4().copy( this._gizmoMatrixState0 );\n\t\t\tthis.makeGizmos( this._gizmos.position, this._tbRadius );\n\t\t\tthis._gizmoMatrixState0.copy( gizmoTmp );\n\n\t\t\tthis.object.lookAt( this._gizmos.position );\n\t\t\tthis.updateTbState( STATE.IDLE, false );\n\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t}\n\n\t}\n\n}\n\n//listeners\n\nfunction onWindowResize() {\n\n\tconst scale = ( this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z ) / 3;\n\tthis._tbRadius = this.calculateTbRadius( this.object );\n\n\tconst newRadius = this._tbRadius / scale;\n\tconst curve = new EllipseCurve( 0, 0, newRadius, newRadius );\n\tconst points = curve.getPoints( this._curvePts );\n\tconst curveGeometry = new BufferGeometry().setFromPoints( points );\n\n\n\tfor ( const gizmo in this._gizmos.children ) {\n\n\t\tthis._gizmos.children[ gizmo ].geometry = curveGeometry;\n\n\t}\n\n\tthis.dispatchEvent( _changeEvent );\n\n}\n\nfunction onContextMenu( event ) {\n\n\tif ( ! this.enabled ) {\n\n\t\treturn;\n\n\t}\n\n\tfor ( let i = 0; i < this.mouseActions.length; i ++ ) {\n\n\t\tif ( this.mouseActions[ i ].mouse == 2 ) {\n\n\t\t\t//prevent only if button 2 is actually used\n\t\t\tevent.preventDefault();\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n}\n\nfunction onPointerCancel() {\n\n\tthis._touchStart.splice( 0, this._touchStart.length );\n\tthis._touchCurrent.splice( 0, this._touchCurrent.length );\n\tthis._input = INPUT.NONE;\n\n}\n\nfunction onPointerDown( event ) {\n\n\tif ( event.button == 0 && event.isPrimary ) {\n\n\t\tthis._downValid = true;\n\t\tthis._downEvents.push( event );\n\t\tthis._downStart = performance.now();\n\n\t} else {\n\n\t\tthis._downValid = false;\n\n\t}\n\n\tif ( event.pointerType == 'touch' && this._input != INPUT.CURSOR ) {\n\n\t\tthis._touchStart.push( event );\n\t\tthis._touchCurrent.push( event );\n\n\t\tswitch ( this._input ) {\n\n\t\t\tcase INPUT.NONE:\n\n\t\t\t\t//singleStart\n\t\t\t\tthis._input = INPUT.ONE_FINGER;\n\t\t\t\tthis.onSinglePanStart( event, 'ROTATE' );\n\n\t\t\t\twindow.addEventListener( 'pointermove', this._onPointerMove );\n\t\t\t\twindow.addEventListener( 'pointerup', this._onPointerUp );\n\n\t\t\t\tbreak;\n\n\t\t\tcase INPUT.ONE_FINGER:\n\t\t\tcase INPUT.ONE_FINGER_SWITCHED:\n\n\t\t\t\t//doubleStart\n\t\t\t\tthis._input = INPUT.TWO_FINGER;\n\n\t\t\t\tthis.onRotateStart();\n\t\t\t\tthis.onPinchStart();\n\t\t\t\tthis.onDoublePanStart();\n\n\t\t\t\tbreak;\n\n\t\t\tcase INPUT.TWO_FINGER:\n\n\t\t\t\t//multipleStart\n\t\t\t\tthis._input = INPUT.MULT_FINGER;\n\t\t\t\tthis.onTriplePanStart( event );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t} else if ( event.pointerType != 'touch' && this._input == INPUT.NONE ) {\n\n\t\tlet modifier = null;\n\n\t\tif ( event.ctrlKey || event.metaKey ) {\n\n\t\t\tmodifier = 'CTRL';\n\n\t\t} else if ( event.shiftKey ) {\n\n\t\t\tmodifier = 'SHIFT';\n\n\t\t}\n\n\t\tthis._mouseOp = this.getOpFromAction( event.button, modifier );\n\t\tif ( this._mouseOp != null ) {\n\n\t\t\twindow.addEventListener( 'pointermove', this._onPointerMove );\n\t\t\twindow.addEventListener( 'pointerup', this._onPointerUp );\n\n\t\t\t//singleStart\n\t\t\tthis._input = INPUT.CURSOR;\n\t\t\tthis._button = event.button;\n\t\t\tthis.onSinglePanStart( event, this._mouseOp );\n\n\t\t}\n\n\t}\n\n}\n\nfunction onPointerMove( event ) {\n\n\tif ( event.pointerType == 'touch' && this._input != INPUT.CURSOR ) {\n\n\t\tswitch ( this._input ) {\n\n\t\t\tcase INPUT.ONE_FINGER:\n\n\t\t\t\t//singleMove\n\t\t\t\tthis.updateTouchEvent( event );\n\n\t\t\t\tthis.onSinglePanMove( event, STATE.ROTATE );\n\t\t\t\tbreak;\n\n\t\t\tcase INPUT.ONE_FINGER_SWITCHED:\n\n\t\t\t\tconst movement = this.calculatePointersDistance( this._touchCurrent[ 0 ], event ) * this._devPxRatio;\n\n\t\t\t\tif ( movement >= this._switchSensibility ) {\n\n\t\t\t\t\t//singleMove\n\t\t\t\t\tthis._input = INPUT.ONE_FINGER;\n\t\t\t\t\tthis.updateTouchEvent( event );\n\n\t\t\t\t\tthis.onSinglePanStart( event, 'ROTATE' );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase INPUT.TWO_FINGER:\n\n\t\t\t\t//rotate/pan/pinchMove\n\t\t\t\tthis.updateTouchEvent( event );\n\n\t\t\t\tthis.onRotateMove();\n\t\t\t\tthis.onPinchMove();\n\t\t\t\tthis.onDoublePanMove();\n\n\t\t\t\tbreak;\n\n\t\t\tcase INPUT.MULT_FINGER:\n\n\t\t\t\t//multMove\n\t\t\t\tthis.updateTouchEvent( event );\n\n\t\t\t\tthis.onTriplePanMove( event );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t} else if ( event.pointerType != 'touch' && this._input == INPUT.CURSOR ) {\n\n\t\tlet modifier = null;\n\n\t\tif ( event.ctrlKey || event.metaKey ) {\n\n\t\t\tmodifier = 'CTRL';\n\n\t\t} else if ( event.shiftKey ) {\n\n\t\t\tmodifier = 'SHIFT';\n\n\t\t}\n\n\t\tconst mouseOpState = this.getOpStateFromAction( this._button, modifier );\n\n\t\tif ( mouseOpState != null ) {\n\n\t\t\tthis.onSinglePanMove( event, mouseOpState );\n\n\t\t}\n\n\t}\n\n\t//checkDistance\n\tif ( this._downValid ) {\n\n\t\tconst movement = this.calculatePointersDistance( this._downEvents[ this._downEvents.length - 1 ], event ) * this._devPxRatio;\n\t\tif ( movement > this._movementThreshold ) {\n\n\t\t\tthis._downValid = false;\n\n\t\t}\n\n\t}\n\n}\n\nfunction onPointerUp( event ) {\n\n\tif ( event.pointerType == 'touch' && this._input != INPUT.CURSOR ) {\n\n\t\tconst nTouch = this._touchCurrent.length;\n\n\t\tfor ( let i = 0; i < nTouch; i ++ ) {\n\n\t\t\tif ( this._touchCurrent[ i ].pointerId == event.pointerId ) {\n\n\t\t\t\tthis._touchCurrent.splice( i, 1 );\n\t\t\t\tthis._touchStart.splice( i, 1 );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tswitch ( this._input ) {\n\n\t\t\tcase INPUT.ONE_FINGER:\n\t\t\tcase INPUT.ONE_FINGER_SWITCHED:\n\n\t\t\t\t//singleEnd\n\t\t\t\twindow.removeEventListener( 'pointermove', this._onPointerMove );\n\t\t\t\twindow.removeEventListener( 'pointerup', this._onPointerUp );\n\n\t\t\t\tthis._input = INPUT.NONE;\n\t\t\t\tthis.onSinglePanEnd();\n\n\t\t\t\tbreak;\n\n\t\t\tcase INPUT.TWO_FINGER:\n\n\t\t\t\t//doubleEnd\n\t\t\t\tthis.onDoublePanEnd( event );\n\t\t\t\tthis.onPinchEnd( event );\n\t\t\t\tthis.onRotateEnd( event );\n\n\t\t\t\t//switching to singleStart\n\t\t\t\tthis._input = INPUT.ONE_FINGER_SWITCHED;\n\n\t\t\t\tbreak;\n\n\t\t\tcase INPUT.MULT_FINGER:\n\n\t\t\t\tif ( this._touchCurrent.length == 0 ) {\n\n\t\t\t\t\twindow.removeEventListener( 'pointermove', this._onPointerMove );\n\t\t\t\t\twindow.removeEventListener( 'pointerup', this._onPointerUp );\n\n\t\t\t\t\t//multCancel\n\t\t\t\t\tthis._input = INPUT.NONE;\n\t\t\t\t\tthis.onTriplePanEnd();\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t} else if ( event.pointerType != 'touch' && this._input == INPUT.CURSOR ) {\n\n\t\twindow.removeEventListener( 'pointermove', this._onPointerMove );\n\t\twindow.removeEventListener( 'pointerup', this._onPointerUp );\n\n\t\tthis._input = INPUT.NONE;\n\t\tthis.onSinglePanEnd();\n\t\tthis._button = - 1;\n\n\t}\n\n\tif ( event.isPrimary ) {\n\n\t\tif ( this._downValid ) {\n\n\t\t\tconst downTime = event.timeStamp - this._downEvents[ this._downEvents.length - 1 ].timeStamp;\n\n\t\t\tif ( downTime <= this._maxDownTime ) {\n\n\t\t\t\tif ( this._nclicks == 0 ) {\n\n\t\t\t\t\t//first valid click detected\n\t\t\t\t\tthis._nclicks = 1;\n\t\t\t\t\tthis._clickStart = performance.now();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst clickInterval = event.timeStamp - this._clickStart;\n\t\t\t\t\tconst movement = this.calculatePointersDistance( this._downEvents[ 1 ], this._downEvents[ 0 ] ) * this._devPxRatio;\n\n\t\t\t\t\tif ( clickInterval <= this._maxInterval && movement <= this._posThreshold ) {\n\n\t\t\t\t\t\t//second valid click detected\n\t\t\t\t\t\t//fire double tap and reset values\n\t\t\t\t\t\tthis._nclicks = 0;\n\t\t\t\t\t\tthis._downEvents.splice( 0, this._downEvents.length );\n\t\t\t\t\t\tthis.onDoubleTap( event );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t//new 'first click'\n\t\t\t\t\t\tthis._nclicks = 1;\n\t\t\t\t\t\tthis._downEvents.shift();\n\t\t\t\t\t\tthis._clickStart = performance.now();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis._downValid = false;\n\t\t\t\tthis._nclicks = 0;\n\t\t\t\tthis._downEvents.splice( 0, this._downEvents.length );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis._nclicks = 0;\n\t\t\tthis._downEvents.splice( 0, this._downEvents.length );\n\n\t\t}\n\n\t}\n\n}\n\nfunction onWheel( event ) {\n\n\tif ( this.enabled && this.enableZoom ) {\n\n\t\tlet modifier = null;\n\n\t\tif ( event.ctrlKey || event.metaKey ) {\n\n\t\t\tmodifier = 'CTRL';\n\n\t\t} else if ( event.shiftKey ) {\n\n\t\t\tmodifier = 'SHIFT';\n\n\t\t}\n\n\t\tconst mouseOp = this.getOpFromAction( 'WHEEL', modifier );\n\n\t\tif ( mouseOp != null ) {\n\n\t\t\tevent.preventDefault();\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t\tconst notchDeltaY = 125; //distance of one notch of mouse wheel\n\t\t\tlet sgn = event.deltaY / notchDeltaY;\n\n\t\t\tlet size = 1;\n\n\t\t\tif ( sgn > 0 ) {\n\n\t\t\t\tsize = 1 / this.scaleFactor;\n\n\t\t\t} else if ( sgn < 0 ) {\n\n\t\t\t\tsize = this.scaleFactor;\n\n\t\t\t}\n\n\t\t\tswitch ( mouseOp ) {\n\n\t\t\t\tcase 'ZOOM':\n\n\t\t\t\t\tthis.updateTbState( STATE.SCALE, true );\n\n\t\t\t\t\tif ( sgn > 0 ) {\n\n\t\t\t\t\t\tsize = 1 / ( Math.pow( this.scaleFactor, sgn ) );\n\n\t\t\t\t\t} else if ( sgn < 0 ) {\n\n\t\t\t\t\t\tsize = Math.pow( this.scaleFactor, - sgn );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this.cursorZoom && this.enablePan ) {\n\n\t\t\t\t\t\tlet scalePoint;\n\n\t\t\t\t\t\tif ( this.object.isOrthographicCamera ) {\n\n\t\t\t\t\t\t\tscalePoint = this.unprojectOnTbPlane( this.object, event.clientX, event.clientY, this.domElement ).applyQuaternion( this.object.quaternion ).multiplyScalar( 1 / this.object.zoom ).add( this._gizmos.position );\n\n\t\t\t\t\t\t} else if ( this.object.isPerspectiveCamera ) {\n\n\t\t\t\t\t\t\tscalePoint = this.unprojectOnTbPlane( this.object, event.clientX, event.clientY, this.domElement ).applyQuaternion( this.object.quaternion ).add( this._gizmos.position );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.applyTransformMatrix( this.scale( size, scalePoint ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.applyTransformMatrix( this.scale( size, this._gizmos.position ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this._grid != null ) {\n\n\t\t\t\t\t\tthis.disposeGrid();\n\t\t\t\t\t\tthis.drawGrid();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\n\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\t\t\t\t\tthis.dispatchEvent( _endEvent );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'FOV':\n\n\t\t\t\t\tif ( this.object.isPerspectiveCamera ) {\n\n\t\t\t\t\t\tthis.updateTbState( STATE.FOV, true );\n\n\n\t\t\t\t\t\t//Vertigo effect\n\n\t\t\t\t\t\t//\t  fov / 2\n\t\t\t\t\t\t//\t\t|\\\n\t\t\t\t\t\t//\t\t| \\\n\t\t\t\t\t\t//\t\t|  \\\n\t\t\t\t\t\t//\tx\t|\t\\\n\t\t\t\t\t\t//\t\t| \t \\\n\t\t\t\t\t\t//\t\t| \t  \\\n\t\t\t\t\t\t//\t\t| _ _ _\\\n\t\t\t\t\t\t//\t\t\ty\n\n\t\t\t\t\t\t//check for iOs shift shortcut\n\t\t\t\t\t\tif ( event.deltaX != 0 ) {\n\n\t\t\t\t\t\t\tsgn = event.deltaX / notchDeltaY;\n\n\t\t\t\t\t\t\tsize = 1;\n\n\t\t\t\t\t\t\tif ( sgn > 0 ) {\n\n\t\t\t\t\t\t\t\tsize = 1 / ( Math.pow( this.scaleFactor, sgn ) );\n\n\t\t\t\t\t\t\t} else if ( sgn < 0 ) {\n\n\t\t\t\t\t\t\t\tsize = Math.pow( this.scaleFactor, - sgn );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._v3_1.setFromMatrixPosition( this._cameraMatrixState );\n\t\t\t\t\t\tconst x = this._v3_1.distanceTo( this._gizmos.position );\n\t\t\t\t\t\tlet xNew = x / size;\t//distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n\t\t\t\t\t\t//check min and max distance\n\t\t\t\t\t\txNew = MathUtils.clamp( xNew, this.minDistance, this.maxDistance );\n\n\t\t\t\t\t\tconst y = x * Math.tan( MathUtils.DEG2RAD * this.object.fov * 0.5 );\n\n\t\t\t\t\t\t//calculate new fov\n\t\t\t\t\t\tlet newFov = MathUtils.RAD2DEG * ( Math.atan( y / xNew ) * 2 );\n\n\t\t\t\t\t\t//check min and max fov\n\t\t\t\t\t\tif ( newFov > this.maxFov ) {\n\n\t\t\t\t\t\t\tnewFov = this.maxFov;\n\n\t\t\t\t\t\t} else if ( newFov < this.minFov ) {\n\n\t\t\t\t\t\t\tnewFov = this.minFov;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst newDistance = y / Math.tan( MathUtils.DEG2RAD * ( newFov / 2 ) );\n\t\t\t\t\t\tsize = x / newDistance;\n\n\t\t\t\t\t\tthis.setFov( newFov );\n\t\t\t\t\t\tthis.applyTransformMatrix( this.scale( size, this._gizmos.position, false ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this._grid != null ) {\n\n\t\t\t\t\t\tthis.disposeGrid();\n\t\t\t\t\t\tthis.drawGrid();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateTbState( STATE.IDLE, false );\n\n\t\t\t\t\tthis.dispatchEvent( _changeEvent );\n\t\t\t\t\tthis.dispatchEvent( _endEvent );\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexport { ArcballControls };\n"],"mappings":"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AC;IACpC,IAAI,CAAC6G,MAAM,GAAG,CAAC,CAAC,CAAC;IACjB,IAAI,CAACC,MAAM,GAAG,CAAC,CAAC,CAAC;;IAEjB;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,aAAa,GAAG,KAAK;;IAE1B;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,WAAW,GAAG,GAAG;;IAEtB;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,aAAa,GAAG,EAAE;;IAEvB;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,IAAI,GAAG,EAAE;;IAEd;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,gBAAgB,GAAG,IAAI;;IAE5B;AACF;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,UAAU,GAAG,KAAK;;IAEvB;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,UAAU,GAAG,KAAK;;IAEvB;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,MAAM,GAAG,CAAC;;IAEf;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,MAAM,GAAG,EAAE;;IAEhB;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,WAAW,GAAG,CAAC;;IAEpB;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,SAAS,GAAG,IAAI;;IAErB;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,YAAY,GAAG,IAAI;;IAExB;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,UAAU,GAAG,IAAI;;IAEtB;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,YAAY,GAAG,IAAI;;IAExB;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,WAAW,GAAG,IAAI;;IAEvB;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,WAAW,GAAG,CAAC;;IAEpB;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,WAAW,GAAGC,QAAQ;;IAE3B;AACF;AACA;AA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}