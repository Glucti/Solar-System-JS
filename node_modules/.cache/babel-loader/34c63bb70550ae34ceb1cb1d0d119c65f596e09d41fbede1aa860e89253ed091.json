{"ast":null,"code":"import { Color, LightProbe, LinearSRGBColorSpace, SphericalHarmonics3, Vector3, SRGBColorSpace, NoColorSpace, HalfFloatType, DataUtils, WebGLCoordinateSystem } from 'three';\n\n/**\n * Utility class for creating instances of {@link LightProbe}.\n *\n * @hideconstructor\n * @three_import import { LightProbeGenerator } from 'three/addons/lights/LightProbeGenerator.js';\n */\nclass LightProbeGenerator {\n  /**\n   * Creates a light probe from the given (radiance) environment map.\n   * The method expects that the environment map is represented as a cube texture.\n   *\n   * @param {CubeTexture} cubeTexture - The environment map.\n   * @return {LightProbe} The created light probe.\n   */\n  static fromCubeTexture(cubeTexture) {\n    // https://www.ppsloan.org/publications/StupidSH36.pdf\n\n    let totalWeight = 0;\n    const coord = new Vector3();\n    const dir = new Vector3();\n    const color = new Color();\n    const shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    const sh = new SphericalHarmonics3();\n    const shCoefficients = sh.coefficients;\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n      const image = cubeTexture.image[faceIndex];\n      const width = image.width;\n      const height = image.height;\n      const canvas = document.createElement('canvas');\n      canvas.width = width;\n      canvas.height = height;\n      const context = canvas.getContext('2d');\n      context.drawImage(image, 0, 0, width, height);\n      const imageData = context.getImageData(0, 0, width, height);\n      const data = imageData.data;\n      const imageWidth = imageData.width; // assumed to be square\n\n      const pixelSize = 2 / imageWidth;\n      for (let i = 0, il = data.length; i < il; i += 4) {\n        // RGBA assumed\n\n        // pixel color\n        color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255);\n\n        // convert to linear color space\n        convertColorToLinear(color, cubeTexture.colorSpace);\n\n        // pixel coordinate on unit cube\n\n        const pixelIndex = i / 4;\n        const col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;\n        const row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;\n        switch (faceIndex) {\n          case 0:\n            coord.set(-1, row, -col);\n            break;\n          case 1:\n            coord.set(1, row, col);\n            break;\n          case 2:\n            coord.set(-col, 1, -row);\n            break;\n          case 3:\n            coord.set(-col, -1, row);\n            break;\n          case 4:\n            coord.set(-col, row, 1);\n            break;\n          case 5:\n            coord.set(col, row, -1);\n            break;\n        }\n\n        // weight assigned to this pixel\n\n        const lengthSq = coord.lengthSq();\n        const weight = 4 / (Math.sqrt(lengthSq) * lengthSq);\n        totalWeight += weight;\n\n        // direction vector to this pixel\n        dir.copy(coord).normalize();\n\n        // evaluate SH basis functions in direction dir\n        SphericalHarmonics3.getBasisAt(dir, shBasis);\n\n        // accumulate\n        for (let j = 0; j < 9; j++) {\n          shCoefficients[j].x += shBasis[j] * color.r * weight;\n          shCoefficients[j].y += shBasis[j] * color.g * weight;\n          shCoefficients[j].z += shBasis[j] * color.b * weight;\n        }\n      }\n    }\n\n    // normalize\n    const norm = 4 * Math.PI / totalWeight;\n    for (let j = 0; j < 9; j++) {\n      shCoefficients[j].x *= norm;\n      shCoefficients[j].y *= norm;\n      shCoefficients[j].z *= norm;\n    }\n    return new LightProbe(sh);\n  }\n\n  /**\n   * Creates a light probe from the given (radiance) environment map.\n   * The method expects that the environment map is represented as a cube render target.\n   *\n   * The cube render target must be in RGBA so `cubeRenderTarget.texture.format` must be\n   * set to {@link RGBAFormat}.\n   *\n   * @async\n   * @param {WebGPURenderer|WebGLRenderer} renderer - The renderer.\n   * @param {CubeRenderTarget|WebGLCubeRenderTarget} cubeRenderTarget - The environment map.\n   * @return {Promise<LightProbe>} A Promise that resolves with the created light probe.\n   */\n  static async fromCubeRenderTarget(renderer, cubeRenderTarget) {\n    const flip = renderer.coordinateSystem === WebGLCoordinateSystem ? -1 : 1;\n\n    // The renderTarget must be set to RGBA in order to make readRenderTargetPixels works\n    let totalWeight = 0;\n    const coord = new Vector3();\n    const dir = new Vector3();\n    const color = new Color();\n    const shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    const sh = new SphericalHarmonics3();\n    const shCoefficients = sh.coefficients;\n    const dataType = cubeRenderTarget.texture.type;\n    const imageWidth = cubeRenderTarget.width; // assumed to be square\n\n    let data;\n    if (renderer.isWebGLRenderer) {\n      if (dataType === HalfFloatType) {\n        data = new Uint16Array(imageWidth * imageWidth * 4);\n      } else {\n        // assuming UnsignedByteType\n\n        data = new Uint8Array(imageWidth * imageWidth * 4);\n      }\n    }\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n      if (renderer.isWebGLRenderer) {\n        await renderer.readRenderTargetPixelsAsync(cubeRenderTarget, 0, 0, imageWidth, imageWidth, data, faceIndex);\n      } else {\n        data = await renderer.readRenderTargetPixelsAsync(cubeRenderTarget, 0, 0, imageWidth, imageWidth, 0, faceIndex);\n      }\n      const pixelSize = 2 / imageWidth;\n      for (let i = 0, il = data.length; i < il; i += 4) {\n        // RGBA assumed\n\n        let r, g, b;\n        if (dataType === HalfFloatType) {\n          r = DataUtils.fromHalfFloat(data[i]);\n          g = DataUtils.fromHalfFloat(data[i + 1]);\n          b = DataUtils.fromHalfFloat(data[i + 2]);\n        } else {\n          r = data[i] / 255;\n          g = data[i + 1] / 255;\n          b = data[i + 2] / 255;\n        }\n\n        // pixel color\n        color.setRGB(r, g, b);\n\n        // convert to linear color space\n        convertColorToLinear(color, cubeRenderTarget.texture.colorSpace);\n\n        // pixel coordinate on unit cube\n\n        const pixelIndex = i / 4;\n        const col = (1 - (pixelIndex % imageWidth + 0.5) * pixelSize) * flip;\n        const row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;\n        switch (faceIndex) {\n          case 0:\n            coord.set(-1 * flip, row, col * flip);\n            break;\n          case 1:\n            coord.set(1 * flip, row, -col * flip);\n            break;\n          case 2:\n            coord.set(col, 1, -row);\n            break;\n          case 3:\n            coord.set(col, -1, row);\n            break;\n          case 4:\n            coord.set(col, row, 1);\n            break;\n          case 5:\n            coord.set(-col, row, -1);\n            break;\n        }\n\n        // weight assigned to this pixel\n\n        const lengthSq = coord.lengthSq();\n        const weight = 4 / (Math.sqrt(lengthSq) * lengthSq);\n        totalWeight += weight;\n\n        // direction vector to this pixel\n        dir.copy(coord).normalize();\n\n        // evaluate SH basis functions in direction dir\n        SphericalHarmonics3.getBasisAt(dir, shBasis);\n\n        // accumulate\n        for (let j = 0; j < 9; j++) {\n          shCoefficients[j].x += shBasis[j] * color.r * weight;\n          shCoefficients[j].y += shBasis[j] * color.g * weight;\n          shCoefficients[j].z += shBasis[j] * color.b * weight;\n        }\n      }\n    }\n\n    // normalize\n    const norm = 4 * Math.PI / totalWeight;\n    for (let j = 0; j < 9; j++) {\n      shCoefficients[j].x *= norm;\n      shCoefficients[j].y *= norm;\n      shCoefficients[j].z *= norm;\n    }\n    return new LightProbe(sh);\n  }\n}\nfunction convertColorToLinear(color, colorSpace) {\n  switch (colorSpace) {\n    case SRGBColorSpace:\n      color.convertSRGBToLinear();\n      break;\n    case LinearSRGBColorSpace:\n    case NoColorSpace:\n      break;\n    default:\n      console.warn('WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported color space.');\n      break;\n  }\n  return color;\n}\nexport { LightProbeGenerator };","map":{"version":3,"names":["Color","LightProbe","LinearSRGBColorSpace","SphericalHarmonics3","Vector3","SRGBColorSpace","NoColorSpace","HalfFloatType","DataUtils","WebGLCoordinateSystem","LightProbeGenerator","fromCubeTexture","cubeTexture","totalWeight","coord","dir","color","shBasis","sh","shCoefficients","coefficients","faceIndex","image","width","height","canvas","document","createElement","context","getContext","drawImage","imageData","getImageData","data","imageWidth","pixelSize","i","il","length","setRGB","convertColorToLinear","colorSpace","pixelIndex","col","row","Math","floor","set","lengthSq","weight","sqrt","copy","normalize","getBasisAt","j","x","r","y","g","z","b","norm","PI","fromCubeRenderTarget","renderer","cubeRenderTarget","flip","coordinateSystem","dataType","texture","type","isWebGLRenderer","Uint16Array","Uint8Array","readRenderTargetPixelsAsync","fromHalfFloat","convertSRGBToLinear","console","warn"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/lights/LightProbeGenerator.js"],"sourcesContent":["import {\n\tColor,\n\tLightProbe,\n\tLinearSRGBColorSpace,\n\tSphericalHarmonics3,\n\tVector3,\n\tSRGBColorSpace,\n\tNoColorSpace,\n\tHalfFloatType,\n\tDataUtils,\n\tWebGLCoordinateSystem\n} from 'three';\n\n/**\n * Utility class for creating instances of {@link LightProbe}.\n *\n * @hideconstructor\n * @three_import import { LightProbeGenerator } from 'three/addons/lights/LightProbeGenerator.js';\n */\nclass LightProbeGenerator {\n\n\t/**\n\t * Creates a light probe from the given (radiance) environment map.\n\t * The method expects that the environment map is represented as a cube texture.\n\t *\n\t * @param {CubeTexture} cubeTexture - The environment map.\n\t * @return {LightProbe} The created light probe.\n\t */\n\tstatic fromCubeTexture( cubeTexture ) {\n\n\t\t// https://www.ppsloan.org/publications/StupidSH36.pdf\n\n\t\tlet totalWeight = 0;\n\n\t\tconst coord = new Vector3();\n\n\t\tconst dir = new Vector3();\n\n\t\tconst color = new Color();\n\n\t\tconst shBasis = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];\n\n\t\tconst sh = new SphericalHarmonics3();\n\t\tconst shCoefficients = sh.coefficients;\n\n\t\tfor ( let faceIndex = 0; faceIndex < 6; faceIndex ++ ) {\n\n\t\t\tconst image = cubeTexture.image[ faceIndex ];\n\n\t\t\tconst width = image.width;\n\t\t\tconst height = image.height;\n\n\t\t\tconst canvas = document.createElement( 'canvas' );\n\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = height;\n\n\t\t\tconst context = canvas.getContext( '2d' );\n\n\t\t\tcontext.drawImage( image, 0, 0, width, height );\n\n\t\t\tconst imageData = context.getImageData( 0, 0, width, height );\n\n\t\t\tconst data = imageData.data;\n\n\t\t\tconst imageWidth = imageData.width; // assumed to be square\n\n\t\t\tconst pixelSize = 2 / imageWidth;\n\n\t\t\tfor ( let i = 0, il = data.length; i < il; i += 4 ) { // RGBA assumed\n\n\t\t\t\t// pixel color\n\t\t\t\tcolor.setRGB( data[ i ] / 255, data[ i + 1 ] / 255, data[ i + 2 ] / 255 );\n\n\t\t\t\t// convert to linear color space\n\t\t\t\tconvertColorToLinear( color, cubeTexture.colorSpace );\n\n\t\t\t\t// pixel coordinate on unit cube\n\n\t\t\t\tconst pixelIndex = i / 4;\n\n\t\t\t\tconst col = - 1 + ( pixelIndex % imageWidth + 0.5 ) * pixelSize;\n\n\t\t\t\tconst row = 1 - ( Math.floor( pixelIndex / imageWidth ) + 0.5 ) * pixelSize;\n\n\t\t\t\tswitch ( faceIndex ) {\n\n\t\t\t\t\tcase 0: coord.set( - 1, row, - col ); break;\n\n\t\t\t\t\tcase 1: coord.set( 1, row, col ); break;\n\n\t\t\t\t\tcase 2: coord.set( - col, 1, - row ); break;\n\n\t\t\t\t\tcase 3: coord.set( - col, - 1, row ); break;\n\n\t\t\t\t\tcase 4: coord.set( - col, row, 1 ); break;\n\n\t\t\t\t\tcase 5: coord.set( col, row, - 1 ); break;\n\n\t\t\t\t}\n\n\t\t\t\t// weight assigned to this pixel\n\n\t\t\t\tconst lengthSq = coord.lengthSq();\n\n\t\t\t\tconst weight = 4 / ( Math.sqrt( lengthSq ) * lengthSq );\n\n\t\t\t\ttotalWeight += weight;\n\n\t\t\t\t// direction vector to this pixel\n\t\t\t\tdir.copy( coord ).normalize();\n\n\t\t\t\t// evaluate SH basis functions in direction dir\n\t\t\t\tSphericalHarmonics3.getBasisAt( dir, shBasis );\n\n\t\t\t\t// accumulate\n\t\t\t\tfor ( let j = 0; j < 9; j ++ ) {\n\n\t\t\t\t\tshCoefficients[ j ].x += shBasis[ j ] * color.r * weight;\n\t\t\t\t\tshCoefficients[ j ].y += shBasis[ j ] * color.g * weight;\n\t\t\t\t\tshCoefficients[ j ].z += shBasis[ j ] * color.b * weight;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// normalize\n\t\tconst norm = ( 4 * Math.PI ) / totalWeight;\n\n\t\tfor ( let j = 0; j < 9; j ++ ) {\n\n\t\t\tshCoefficients[ j ].x *= norm;\n\t\t\tshCoefficients[ j ].y *= norm;\n\t\t\tshCoefficients[ j ].z *= norm;\n\n\t\t}\n\n\t\treturn new LightProbe( sh );\n\n\t}\n\n\t/**\n\t * Creates a light probe from the given (radiance) environment map.\n\t * The method expects that the environment map is represented as a cube render target.\n\t *\n\t * The cube render target must be in RGBA so `cubeRenderTarget.texture.format` must be\n\t * set to {@link RGBAFormat}.\n\t *\n\t * @async\n\t * @param {WebGPURenderer|WebGLRenderer} renderer - The renderer.\n\t * @param {CubeRenderTarget|WebGLCubeRenderTarget} cubeRenderTarget - The environment map.\n\t * @return {Promise<LightProbe>} A Promise that resolves with the created light probe.\n\t */\n\tstatic async fromCubeRenderTarget( renderer, cubeRenderTarget ) {\n\n\t\tconst flip = renderer.coordinateSystem === WebGLCoordinateSystem ? - 1 : 1;\n\n\t\t// The renderTarget must be set to RGBA in order to make readRenderTargetPixels works\n\t\tlet totalWeight = 0;\n\n\t\tconst coord = new Vector3();\n\n\t\tconst dir = new Vector3();\n\n\t\tconst color = new Color();\n\n\t\tconst shBasis = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];\n\n\t\tconst sh = new SphericalHarmonics3();\n\t\tconst shCoefficients = sh.coefficients;\n\n\t\tconst dataType = cubeRenderTarget.texture.type;\n\t\tconst imageWidth = cubeRenderTarget.width; // assumed to be square\n\n\t\tlet data;\n\n\t\tif ( renderer.isWebGLRenderer ) {\n\n\t\t\tif ( dataType === HalfFloatType ) {\n\n\t\t\t\tdata = new Uint16Array( imageWidth * imageWidth * 4 );\n\n\t\t\t} else {\n\n\t\t\t\t// assuming UnsignedByteType\n\n\t\t\t\tdata = new Uint8Array( imageWidth * imageWidth * 4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let faceIndex = 0; faceIndex < 6; faceIndex ++ ) {\n\n\t\t\tif ( renderer.isWebGLRenderer ) {\n\n\t\t\t\tawait renderer.readRenderTargetPixelsAsync( cubeRenderTarget, 0, 0, imageWidth, imageWidth, data, faceIndex );\n\n\t\t\t} else {\n\n\t\t\t\tdata = await renderer.readRenderTargetPixelsAsync( cubeRenderTarget, 0, 0, imageWidth, imageWidth, 0, faceIndex );\n\n\t\t\t}\n\n\t\t\tconst pixelSize = 2 / imageWidth;\n\n\t\t\tfor ( let i = 0, il = data.length; i < il; i += 4 ) { // RGBA assumed\n\n\t\t\t\tlet r, g, b;\n\n\t\t\t\tif ( dataType === HalfFloatType ) {\n\n\t\t\t\t\tr = DataUtils.fromHalfFloat( data[ i ] );\n\t\t\t\t\tg = DataUtils.fromHalfFloat( data[ i + 1 ] );\n\t\t\t\t\tb = DataUtils.fromHalfFloat( data[ i + 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tr = data[ i ] / 255;\n\t\t\t\t\tg = data[ i + 1 ] / 255;\n\t\t\t\t\tb = data[ i + 2 ] / 255;\n\n\t\t\t\t}\n\n\t\t\t\t// pixel color\n\t\t\t\tcolor.setRGB( r, g, b );\n\n\t\t\t\t// convert to linear color space\n\t\t\t\tconvertColorToLinear( color, cubeRenderTarget.texture.colorSpace );\n\n\t\t\t\t// pixel coordinate on unit cube\n\n\t\t\t\tconst pixelIndex = i / 4;\n\n\t\t\t\tconst col = ( 1 - ( pixelIndex % imageWidth + 0.5 ) * pixelSize ) * flip;\n\n\t\t\t\tconst row = 1 - ( Math.floor( pixelIndex / imageWidth ) + 0.5 ) * pixelSize;\n\n\t\t\t\tswitch ( faceIndex ) {\n\n\t\t\t\t\tcase 0: coord.set( - 1 * flip, row, col * flip ); break;\n\n\t\t\t\t\tcase 1: coord.set( 1 * flip, row, - col * flip ); break;\n\n\t\t\t\t\tcase 2: coord.set( col, 1, - row ); break;\n\n\t\t\t\t\tcase 3: coord.set( col, - 1, row ); break;\n\n\t\t\t\t\tcase 4: coord.set( col, row, 1 ); break;\n\n\t\t\t\t\tcase 5: coord.set( - col, row, - 1 ); break;\n\n\t\t\t\t}\n\n\t\t\t\t// weight assigned to this pixel\n\n\t\t\t\tconst lengthSq = coord.lengthSq();\n\n\t\t\t\tconst weight = 4 / ( Math.sqrt( lengthSq ) * lengthSq );\n\n\t\t\t\ttotalWeight += weight;\n\n\t\t\t\t// direction vector to this pixel\n\t\t\t\tdir.copy( coord ).normalize();\n\n\t\t\t\t// evaluate SH basis functions in direction dir\n\t\t\t\tSphericalHarmonics3.getBasisAt( dir, shBasis );\n\n\t\t\t\t// accumulate\n\t\t\t\tfor ( let j = 0; j < 9; j ++ ) {\n\n\t\t\t\t\tshCoefficients[ j ].x += shBasis[ j ] * color.r * weight;\n\t\t\t\t\tshCoefficients[ j ].y += shBasis[ j ] * color.g * weight;\n\t\t\t\t\tshCoefficients[ j ].z += shBasis[ j ] * color.b * weight;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// normalize\n\t\tconst norm = ( 4 * Math.PI ) / totalWeight;\n\n\t\tfor ( let j = 0; j < 9; j ++ ) {\n\n\t\t\tshCoefficients[ j ].x *= norm;\n\t\t\tshCoefficients[ j ].y *= norm;\n\t\t\tshCoefficients[ j ].z *= norm;\n\n\t\t}\n\n\t\treturn new LightProbe( sh );\n\n\t}\n\n}\n\nfunction convertColorToLinear( color, colorSpace ) {\n\n\tswitch ( colorSpace ) {\n\n\t\tcase SRGBColorSpace:\n\n\t\t\tcolor.convertSRGBToLinear();\n\t\t\tbreak;\n\n\t\tcase LinearSRGBColorSpace:\n\t\tcase NoColorSpace:\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tconsole.warn( 'WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported color space.' );\n\t\t\tbreak;\n\n\t}\n\n\treturn color;\n\n}\n\nexport { LightProbeGenerator };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}