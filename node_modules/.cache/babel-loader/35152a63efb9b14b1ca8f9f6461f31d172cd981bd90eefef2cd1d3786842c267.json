{"ast":null,"code":"import { Vector3 } from 'three';\n\n/**\n * An exporter for STL.\n *\n * STL files describe only the surface geometry of a three-dimensional object without\n * any representation of color, texture or other common model attributes. The STL format\n * specifies both ASCII and binary representations, with binary being more compact.\n * STL files contain no scale information or indexes, and the units are arbitrary.\n *\n * ```js\n * const exporter = new STLExporter();\n * const data = exporter.parse( mesh, { binary: true } );\n * ```\n *\n * @three_import import { STLExporter } from 'three/addons/exporters/STLExporter.js';\n */\nclass STLExporter {\n  /**\n   * Parses the given 3D object and generates the STL output.\n   *\n   * If the 3D object is composed of multiple children and geometry, they are merged into a single mesh in the file.\n   *\n   * @param {Object3D} scene - A scene, mesh or any other 3D object containing meshes to encode.\n   * @param {STLExporter~Options} options - The export options.\n   * @return {string|ArrayBuffer} The exported STL.\n   */\n  parse(scene, options = {}) {\n    options = Object.assign({\n      binary: false\n    }, options);\n    const binary = options.binary;\n\n    //\n\n    const objects = [];\n    let triangles = 0;\n    scene.traverse(function (object) {\n      if (object.isMesh) {\n        const geometry = object.geometry;\n        const index = geometry.index;\n        const positionAttribute = geometry.getAttribute('position');\n        triangles += index !== null ? index.count / 3 : positionAttribute.count / 3;\n        objects.push({\n          object3d: object,\n          geometry: geometry\n        });\n      }\n    });\n    let output;\n    let offset = 80; // skip header\n\n    if (binary === true) {\n      const bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;\n      const arrayBuffer = new ArrayBuffer(bufferLength);\n      output = new DataView(arrayBuffer);\n      output.setUint32(offset, triangles, true);\n      offset += 4;\n    } else {\n      output = '';\n      output += 'solid exported\\n';\n    }\n    const vA = new Vector3();\n    const vB = new Vector3();\n    const vC = new Vector3();\n    const cb = new Vector3();\n    const ab = new Vector3();\n    const normal = new Vector3();\n    for (let i = 0, il = objects.length; i < il; i++) {\n      const object = objects[i].object3d;\n      const geometry = objects[i].geometry;\n      const index = geometry.index;\n      const positionAttribute = geometry.getAttribute('position');\n      if (index !== null) {\n        // indexed geometry\n\n        for (let j = 0; j < index.count; j += 3) {\n          const a = index.getX(j + 0);\n          const b = index.getX(j + 1);\n          const c = index.getX(j + 2);\n          writeFace(a, b, c, positionAttribute, object);\n        }\n      } else {\n        // non-indexed geometry\n\n        for (let j = 0; j < positionAttribute.count; j += 3) {\n          const a = j + 0;\n          const b = j + 1;\n          const c = j + 2;\n          writeFace(a, b, c, positionAttribute, object);\n        }\n      }\n    }\n    if (binary === false) {\n      output += 'endsolid exported\\n';\n    }\n    return output;\n    function writeFace(a, b, c, positionAttribute, object) {\n      vA.fromBufferAttribute(positionAttribute, a);\n      vB.fromBufferAttribute(positionAttribute, b);\n      vC.fromBufferAttribute(positionAttribute, c);\n      if (object.isSkinnedMesh === true) {\n        object.applyBoneTransform(a, vA);\n        object.applyBoneTransform(b, vB);\n        object.applyBoneTransform(c, vC);\n      }\n      vA.applyMatrix4(object.matrixWorld);\n      vB.applyMatrix4(object.matrixWorld);\n      vC.applyMatrix4(object.matrixWorld);\n      writeNormal(vA, vB, vC);\n      writeVertex(vA);\n      writeVertex(vB);\n      writeVertex(vC);\n      if (binary === true) {\n        output.setUint16(offset, 0, true);\n        offset += 2;\n      } else {\n        output += '\\t\\tendloop\\n';\n        output += '\\tendfacet\\n';\n      }\n    }\n    function writeNormal(vA, vB, vC) {\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab).normalize();\n      normal.copy(cb).normalize();\n      if (binary === true) {\n        output.setFloat32(offset, normal.x, true);\n        offset += 4;\n        output.setFloat32(offset, normal.y, true);\n        offset += 4;\n        output.setFloat32(offset, normal.z, true);\n        offset += 4;\n      } else {\n        output += '\\tfacet normal ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\\n';\n        output += '\\t\\touter loop\\n';\n      }\n    }\n    function writeVertex(vertex) {\n      if (binary === true) {\n        output.setFloat32(offset, vertex.x, true);\n        offset += 4;\n        output.setFloat32(offset, vertex.y, true);\n        offset += 4;\n        output.setFloat32(offset, vertex.z, true);\n        offset += 4;\n      } else {\n        output += '\\t\\t\\tvertex ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n      }\n    }\n  }\n}\n\n/**\n * Export options of `STLExporter`.\n *\n * @typedef {Object} STLExporter~Options\n * @property {boolean} [binary=false] - Whether to export in binary format or ASCII.\n **/\n\nexport { STLExporter };","map":{"version":3,"names":["Vector3","STLExporter","parse","scene","options","Object","assign","binary","objects","triangles","traverse","object","isMesh","geometry","index","positionAttribute","getAttribute","count","push","object3d","output","offset","bufferLength","arrayBuffer","ArrayBuffer","DataView","setUint32","vA","vB","vC","cb","ab","normal","i","il","length","j","a","getX","b","c","writeFace","fromBufferAttribute","isSkinnedMesh","applyBoneTransform","applyMatrix4","matrixWorld","writeNormal","writeVertex","setUint16","subVectors","cross","normalize","copy","setFloat32","x","y","z","vertex"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/exporters/STLExporter.js"],"sourcesContent":["import { Vector3 } from 'three';\n\n/**\n * An exporter for STL.\n *\n * STL files describe only the surface geometry of a three-dimensional object without\n * any representation of color, texture or other common model attributes. The STL format\n * specifies both ASCII and binary representations, with binary being more compact.\n * STL files contain no scale information or indexes, and the units are arbitrary.\n *\n * ```js\n * const exporter = new STLExporter();\n * const data = exporter.parse( mesh, { binary: true } );\n * ```\n *\n * @three_import import { STLExporter } from 'three/addons/exporters/STLExporter.js';\n */\nclass STLExporter {\n\n\t/**\n\t * Parses the given 3D object and generates the STL output.\n\t *\n\t * If the 3D object is composed of multiple children and geometry, they are merged into a single mesh in the file.\n\t *\n\t * @param {Object3D} scene - A scene, mesh or any other 3D object containing meshes to encode.\n\t * @param {STLExporter~Options} options - The export options.\n\t * @return {string|ArrayBuffer} The exported STL.\n\t */\n\tparse( scene, options = {} ) {\n\n\t\toptions = Object.assign( {\n\t\t\tbinary: false\n\t\t}, options );\n\n\t\tconst binary = options.binary;\n\n\t\t//\n\n\t\tconst objects = [];\n\t\tlet triangles = 0;\n\n\t\tscene.traverse( function ( object ) {\n\n\t\t\tif ( object.isMesh ) {\n\n\t\t\t\tconst geometry = object.geometry;\n\n\t\t\t\tconst index = geometry.index;\n\t\t\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\t\t\ttriangles += ( index !== null ) ? ( index.count / 3 ) : ( positionAttribute.count / 3 );\n\n\t\t\t\tobjects.push( {\n\t\t\t\t\tobject3d: object,\n\t\t\t\t\tgeometry: geometry\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tlet output;\n\t\tlet offset = 80; // skip header\n\n\t\tif ( binary === true ) {\n\n\t\t\tconst bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;\n\t\t\tconst arrayBuffer = new ArrayBuffer( bufferLength );\n\t\t\toutput = new DataView( arrayBuffer );\n\t\t\toutput.setUint32( offset, triangles, true ); offset += 4;\n\n\t\t} else {\n\n\t\t\toutput = '';\n\t\t\toutput += 'solid exported\\n';\n\n\t\t}\n\n\t\tconst vA = new Vector3();\n\t\tconst vB = new Vector3();\n\t\tconst vC = new Vector3();\n\t\tconst cb = new Vector3();\n\t\tconst ab = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\tfor ( let i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\tconst object = objects[ i ].object3d;\n\t\t\tconst geometry = objects[ i ].geometry;\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\t// indexed geometry\n\n\t\t\t\tfor ( let j = 0; j < index.count; j += 3 ) {\n\n\t\t\t\t\tconst a = index.getX( j + 0 );\n\t\t\t\t\tconst b = index.getX( j + 1 );\n\t\t\t\t\tconst c = index.getX( j + 2 );\n\n\t\t\t\t\twriteFace( a, b, c, positionAttribute, object );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed geometry\n\n\t\t\t\tfor ( let j = 0; j < positionAttribute.count; j += 3 ) {\n\n\t\t\t\t\tconst a = j + 0;\n\t\t\t\t\tconst b = j + 1;\n\t\t\t\t\tconst c = j + 2;\n\n\t\t\t\t\twriteFace( a, b, c, positionAttribute, object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( binary === false ) {\n\n\t\t\toutput += 'endsolid exported\\n';\n\n\t\t}\n\n\t\treturn output;\n\n\t\tfunction writeFace( a, b, c, positionAttribute, object ) {\n\n\t\t\tvA.fromBufferAttribute( positionAttribute, a );\n\t\t\tvB.fromBufferAttribute( positionAttribute, b );\n\t\t\tvC.fromBufferAttribute( positionAttribute, c );\n\n\t\t\tif ( object.isSkinnedMesh === true ) {\n\n\t\t\t\tobject.applyBoneTransform( a, vA );\n\t\t\t\tobject.applyBoneTransform( b, vB );\n\t\t\t\tobject.applyBoneTransform( c, vC );\n\n\t\t\t}\n\n\t\t\tvA.applyMatrix4( object.matrixWorld );\n\t\t\tvB.applyMatrix4( object.matrixWorld );\n\t\t\tvC.applyMatrix4( object.matrixWorld );\n\n\t\t\twriteNormal( vA, vB, vC );\n\n\t\t\twriteVertex( vA );\n\t\t\twriteVertex( vB );\n\t\t\twriteVertex( vC );\n\n\t\t\tif ( binary === true ) {\n\n\t\t\t\toutput.setUint16( offset, 0, true ); offset += 2;\n\n\t\t\t} else {\n\n\t\t\t\toutput += '\\t\\tendloop\\n';\n\t\t\t\toutput += '\\tendfacet\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction writeNormal( vA, vB, vC ) {\n\n\t\t\tcb.subVectors( vC, vB );\n\t\t\tab.subVectors( vA, vB );\n\t\t\tcb.cross( ab ).normalize();\n\n\t\t\tnormal.copy( cb ).normalize();\n\n\t\t\tif ( binary === true ) {\n\n\t\t\t\toutput.setFloat32( offset, normal.x, true ); offset += 4;\n\t\t\t\toutput.setFloat32( offset, normal.y, true ); offset += 4;\n\t\t\t\toutput.setFloat32( offset, normal.z, true ); offset += 4;\n\n\t\t\t} else {\n\n\t\t\t\toutput += '\\tfacet normal ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\\n';\n\t\t\t\toutput += '\\t\\touter loop\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction writeVertex( vertex ) {\n\n\t\t\tif ( binary === true ) {\n\n\t\t\t\toutput.setFloat32( offset, vertex.x, true ); offset += 4;\n\t\t\t\toutput.setFloat32( offset, vertex.y, true ); offset += 4;\n\t\t\t\toutput.setFloat32( offset, vertex.z, true ); offset += 4;\n\n\t\t\t} else {\n\n\t\t\t\toutput += '\\t\\t\\tvertex ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Export options of `STLExporter`.\n *\n * @typedef {Object} STLExporter~Options\n * @property {boolean} [binary=false] - Whether to export in binary format or ASCII.\n **/\n\nexport { STLExporter };\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,OAAO;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,WAAW,CAAC;EAEjB;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCC,KAAKA,CAAEC,KAAK,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAG;IAE5BA,OAAO,GAAGC,MAAM,CAACC,MAAM,CAAE;MACxBC,MAAM,EAAE;IACT,CAAC,EAAEH,OAAQ,CAAC;IAEZ,MAAMG,MAAM,GAAGH,OAAO,CAACG,MAAM;;IAE7B;;IAEA,MAAMC,OAAO,GAAG,EAAE;IAClB,IAAIC,SAAS,GAAG,CAAC;IAEjBN,KAAK,CAACO,QAAQ,CAAE,UAAWC,MAAM,EAAG;MAEnC,IAAKA,MAAM,CAACC,MAAM,EAAG;QAEpB,MAAMC,QAAQ,GAAGF,MAAM,CAACE,QAAQ;QAEhC,MAAMC,KAAK,GAAGD,QAAQ,CAACC,KAAK;QAC5B,MAAMC,iBAAiB,GAAGF,QAAQ,CAACG,YAAY,CAAE,UAAW,CAAC;QAE7DP,SAAS,IAAMK,KAAK,KAAK,IAAI,GAAOA,KAAK,CAACG,KAAK,GAAG,CAAC,GAAOF,iBAAiB,CAACE,KAAK,GAAG,CAAG;QAEvFT,OAAO,CAACU,IAAI,CAAE;UACbC,QAAQ,EAAER,MAAM;UAChBE,QAAQ,EAAEA;QACX,CAAE,CAAC;MAEJ;IAED,CAAE,CAAC;IAEH,IAAIO,MAAM;IACV,IAAIC,MAAM,GAAG,EAAE,CAAC,CAAC;;IAEjB,IAAKd,MAAM,KAAK,IAAI,EAAG;MAEtB,MAAMe,YAAY,GAAGb,SAAS,GAAG,CAAC,GAAGA,SAAS,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC;MACnE,MAAMc,WAAW,GAAG,IAAIC,WAAW,CAAEF,YAAa,CAAC;MACnDF,MAAM,GAAG,IAAIK,QAAQ,CAAEF,WAAY,CAAC;MACpCH,MAAM,CAACM,SAAS,CAAEL,MAAM,EAAEZ,SAAS,EAAE,IAAK,CAAC;MAAEY,MAAM,IAAI,CAAC;IAEzD,CAAC,MAAM;MAEND,MAAM,GAAG,EAAE;MACXA,MAAM,IAAI,kBAAkB;IAE7B;IAEA,MAAMO,EAAE,GAAG,IAAI3B,OAAO,CAAC,CAAC;IACxB,MAAM4B,EAAE,GAAG,IAAI5B,OAAO,CAAC,CAAC;IACxB,MAAM6B,EAAE,GAAG,IAAI7B,OAAO,CAAC,CAAC;IACxB,MAAM8B,EAAE,GAAG,IAAI9B,OAAO,CAAC,CAAC;IACxB,MAAM+B,EAAE,GAAG,IAAI/B,OAAO,CAAC,CAAC;IACxB,MAAMgC,MAAM,GAAG,IAAIhC,OAAO,CAAC,CAAC;IAE5B,KAAM,IAAIiC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG1B,OAAO,CAAC2B,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAG,EAAG;MAEpD,MAAMtB,MAAM,GAAGH,OAAO,CAAEyB,CAAC,CAAE,CAACd,QAAQ;MACpC,MAAMN,QAAQ,GAAGL,OAAO,CAAEyB,CAAC,CAAE,CAACpB,QAAQ;MAEtC,MAAMC,KAAK,GAAGD,QAAQ,CAACC,KAAK;MAC5B,MAAMC,iBAAiB,GAAGF,QAAQ,CAACG,YAAY,CAAE,UAAW,CAAC;MAE7D,IAAKF,KAAK,KAAK,IAAI,EAAG;QAErB;;QAEA,KAAM,IAAIsB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGtB,KAAK,CAACG,KAAK,EAAEmB,CAAC,IAAI,CAAC,EAAG;UAE1C,MAAMC,CAAC,GAAGvB,KAAK,CAACwB,IAAI,CAAEF,CAAC,GAAG,CAAE,CAAC;UAC7B,MAAMG,CAAC,GAAGzB,KAAK,CAACwB,IAAI,CAAEF,CAAC,GAAG,CAAE,CAAC;UAC7B,MAAMI,CAAC,GAAG1B,KAAK,CAACwB,IAAI,CAAEF,CAAC,GAAG,CAAE,CAAC;UAE7BK,SAAS,CAAEJ,CAAC,EAAEE,CAAC,EAAEC,CAAC,EAAEzB,iBAAiB,EAAEJ,MAAO,CAAC;QAEhD;MAED,CAAC,MAAM;QAEN;;QAEA,KAAM,IAAIyB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrB,iBAAiB,CAACE,KAAK,EAAEmB,CAAC,IAAI,CAAC,EAAG;UAEtD,MAAMC,CAAC,GAAGD,CAAC,GAAG,CAAC;UACf,MAAMG,CAAC,GAAGH,CAAC,GAAG,CAAC;UACf,MAAMI,CAAC,GAAGJ,CAAC,GAAG,CAAC;UAEfK,SAAS,CAAEJ,CAAC,EAAEE,CAAC,EAAEC,CAAC,EAAEzB,iBAAiB,EAAEJ,MAAO,CAAC;QAEhD;MAED;IAED;IAEA,IAAKJ,MAAM,KAAK,KAAK,EAAG;MAEvBa,MAAM,IAAI,qBAAqB;IAEhC;IAEA,OAAOA,MAAM;IAEb,SAASqB,SAASA,CAAEJ,CAAC,EAAEE,CAAC,EAAEC,CAAC,EAAEzB,iBAAiB,EAAEJ,MAAM,EAAG;MAExDgB,EAAE,CAACe,mBAAmB,CAAE3B,iBAAiB,EAAEsB,CAAE,CAAC;MAC9CT,EAAE,CAACc,mBAAmB,CAAE3B,iBAAiB,EAAEwB,CAAE,CAAC;MAC9CV,EAAE,CAACa,mBAAmB,CAAE3B,iBAAiB,EAAEyB,CAAE,CAAC;MAE9C,IAAK7B,MAAM,CAACgC,aAAa,KAAK,IAAI,EAAG;QAEpChC,MAAM,CAACiC,kBAAkB,CAAEP,CAAC,EAAEV,EAAG,CAAC;QAClChB,MAAM,CAACiC,kBAAkB,CAAEL,CAAC,EAAEX,EAAG,CAAC;QAClCjB,MAAM,CAACiC,kBAAkB,CAAEJ,CAAC,EAAEX,EAAG,CAAC;MAEnC;MAEAF,EAAE,CAACkB,YAAY,CAAElC,MAAM,CAACmC,WAAY,CAAC;MACrClB,EAAE,CAACiB,YAAY,CAAElC,MAAM,CAACmC,WAAY,CAAC;MACrCjB,EAAE,CAACgB,YAAY,CAAElC,MAAM,CAACmC,WAAY,CAAC;MAErCC,WAAW,CAAEpB,EAAE,EAAEC,EAAE,EAAEC,EAAG,CAAC;MAEzBmB,WAAW,CAAErB,EAAG,CAAC;MACjBqB,WAAW,CAAEpB,EAAG,CAAC;MACjBoB,WAAW,CAAEnB,EAAG,CAAC;MAEjB,IAAKtB,MAAM,KAAK,IAAI,EAAG;QAEtBa,MAAM,CAAC6B,SAAS,CAAE5B,MAAM,EAAE,CAAC,EAAE,IAAK,CAAC;QAAEA,MAAM,IAAI,CAAC;MAEjD,CAAC,MAAM;QAEND,MAAM,IAAI,eAAe;QACzBA,MAAM,IAAI,cAAc;MAEzB;IAED;IAEA,SAAS2B,WAAWA,CAAEpB,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAG;MAElCC,EAAE,CAACoB,UAAU,CAAErB,EAAE,EAAED,EAAG,CAAC;MACvBG,EAAE,CAACmB,UAAU,CAAEvB,EAAE,EAAEC,EAAG,CAAC;MACvBE,EAAE,CAACqB,KAAK,CAAEpB,EAAG,CAAC,CAACqB,SAAS,CAAC,CAAC;MAE1BpB,MAAM,CAACqB,IAAI,CAAEvB,EAAG,CAAC,CAACsB,SAAS,CAAC,CAAC;MAE7B,IAAK7C,MAAM,KAAK,IAAI,EAAG;QAEtBa,MAAM,CAACkC,UAAU,CAAEjC,MAAM,EAAEW,MAAM,CAACuB,CAAC,EAAE,IAAK,CAAC;QAAElC,MAAM,IAAI,CAAC;QACxDD,MAAM,CAACkC,UAAU,CAAEjC,MAAM,EAAEW,MAAM,CAACwB,CAAC,EAAE,IAAK,CAAC;QAAEnC,MAAM,IAAI,CAAC;QACxDD,MAAM,CAACkC,UAAU,CAAEjC,MAAM,EAAEW,MAAM,CAACyB,CAAC,EAAE,IAAK,CAAC;QAAEpC,MAAM,IAAI,CAAC;MAEzD,CAAC,MAAM;QAEND,MAAM,IAAI,iBAAiB,GAAGY,MAAM,CAACuB,CAAC,GAAG,GAAG,GAAGvB,MAAM,CAACwB,CAAC,GAAG,GAAG,GAAGxB,MAAM,CAACyB,CAAC,GAAG,IAAI;QAC/ErC,MAAM,IAAI,kBAAkB;MAE7B;IAED;IAEA,SAAS4B,WAAWA,CAAEU,MAAM,EAAG;MAE9B,IAAKnD,MAAM,KAAK,IAAI,EAAG;QAEtBa,MAAM,CAACkC,UAAU,CAAEjC,MAAM,EAAEqC,MAAM,CAACH,CAAC,EAAE,IAAK,CAAC;QAAElC,MAAM,IAAI,CAAC;QACxDD,MAAM,CAACkC,UAAU,CAAEjC,MAAM,EAAEqC,MAAM,CAACF,CAAC,EAAE,IAAK,CAAC;QAAEnC,MAAM,IAAI,CAAC;QACxDD,MAAM,CAACkC,UAAU,CAAEjC,MAAM,EAAEqC,MAAM,CAACD,CAAC,EAAE,IAAK,CAAC;QAAEpC,MAAM,IAAI,CAAC;MAEzD,CAAC,MAAM;QAEND,MAAM,IAAI,eAAe,GAAGsC,MAAM,CAACH,CAAC,GAAG,GAAG,GAAGG,MAAM,CAACF,CAAC,GAAG,GAAG,GAAGE,MAAM,CAACD,CAAC,GAAG,IAAI;MAE9E;IAED;EAED;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASxD,WAAW","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}