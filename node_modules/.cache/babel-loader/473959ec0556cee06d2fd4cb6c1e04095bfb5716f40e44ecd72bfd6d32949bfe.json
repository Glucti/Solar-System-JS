{"ast":null,"code":"import { Color, Matrix4, Mesh, PerspectiveCamera, Plane, ShaderMaterial, UniformsUtils, Vector3, Vector4, WebGLRenderTarget, HalfFloatType } from 'three';\n\n/**\n * Can be used to create a flat, reflective surface like a mirror.\n *\n * Note that this class can only be used with {@link WebGLRenderer}.\n * When using {@link WebGPURenderer}, use {@link ReflectorNode}.\n *\n * ```js\n * const geometry = new THREE.PlaneGeometry( 100, 100 );\n *\n * const reflector = new Reflector( geometry, {\n * \tclipBias: 0.003,\n * \ttextureWidth: window.innerWidth * window.devicePixelRatio,\n * \ttextureHeight: window.innerHeight * window.devicePixelRatio,\n * \tcolor: 0xc1cbcb\n * } );\n *\n * scene.add( reflector );\n * ```\n *\n * @augments Mesh\n * @three_import import { Reflector } from 'three/addons/objects/Reflector.js';\n */\nclass Reflector extends Mesh {\n  /**\n   * Constructs a new reflector.\n   *\n   * @param {BufferGeometry} geometry - The reflector's geometry.\n   * @param {Reflector~Options} [options] - The configuration options.\n   */\n  constructor(geometry, options = {}) {\n    super(geometry);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {boolean}\n     * @readonly\n     * @default true\n     */\n    this.isReflector = true;\n    this.type = 'Reflector';\n\n    /**\n     * Whether to force an update, no matter if the reflector\n     * is in view or not.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    this.forceUpdate = false;\n\n    /**\n     * The reflector's virtual camera. This is used to render\n     * the scene from the mirror's point of view.\n     *\n     * @type {PerspectiveCamera}\n     */\n    this.camera = new PerspectiveCamera();\n    const scope = this;\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7F7F7F);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || Reflector.ReflectorShader;\n    const multisample = options.multisample !== undefined ? options.multisample : 4;\n\n    //\n\n    const reflectorPlane = new Plane();\n    const normal = new Vector3();\n    const reflectorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const clipPlane = new Vector4();\n    const view = new Vector3();\n    const target = new Vector3();\n    const q = new Vector4();\n    const textureMatrix = new Matrix4();\n    const virtualCamera = this.camera;\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample,\n      type: HalfFloatType\n    });\n    const material = new ShaderMaterial({\n      name: shader.name !== undefined ? shader.name : 'unspecified',\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms['tDiffuse'].value = renderTarget.texture;\n    material.uniforms['color'].value = color;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n    this.material = material;\n    this.onBeforeRender = function (renderer, scene, camera) {\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition);\n\n      // Avoid rendering when reflector is facing away unless forcing an update\n      const isFacingAway = view.dot(normal) > 0;\n      if (isFacingAway === true && this.forceUpdate === false) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far; // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n\n      // Update the texture matrix\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n\n      // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n      const projectionMatrix = virtualCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1.0;\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n\n      // Calculate the scaled plane vector\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q));\n\n      // Replacing the third row of the projection matrix\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w;\n\n      // Render\n      scope.visible = false;\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      renderer.xr.enabled = false; // Avoid camera modification\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget);\n\n      // Restore viewport\n\n      const viewport = camera.viewport;\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n      scope.visible = true;\n      this.forceUpdate = false;\n    };\n\n    /**\n     * Returns the reflector's internal render target.\n     *\n     * @return {WebGLRenderTarget} The internal render target\n     */\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n\n    /**\n     * Frees the GPU-related resources allocated by this instance. Call this\n     * method whenever this instance is no longer used in your app.\n     */\n    this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n  }\n}\nReflector.ReflectorShader = {\n  name: 'ReflectorShader',\n  uniforms: {\n    'color': {\n      value: null\n    },\n    'tDiffuse': {\n      value: null\n    },\n    'textureMatrix': {\n      value: null\n    }\n  },\n  vertexShader: /* glsl */`\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`,\n  fragmentShader: /* glsl */`\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\n\t\t}`\n};\n\n/**\n * Constructor options of `Reflector`.\n *\n * @typedef {Object} Reflector~Options\n * @property {number|Color|string} [color=0x7F7F7F] - The reflector's color.\n * @property {number} [textureWidth=512] - The texture width. A higher value results in more clear reflections but is also more expensive.\n * @property {number} [textureHeight=512] - The texture height. A higher value results in more clear reflections but is also more expensive.\n * @property {number} [clipBias=0] - The clip bias.\n * @property {Object} [shader] - Can be used to pass in a custom shader that defines how the reflective view is projected onto the reflector's geometry.\n * @property {number} [multisample=4] - How many samples to use for MSAA. `0` disables MSAA.\n **/\n\nexport { Reflector };","map":{"version":3,"names":["Color","Matrix4","Mesh","PerspectiveCamera","Plane","ShaderMaterial","UniformsUtils","Vector3","Vector4","WebGLRenderTarget","HalfFloatType","Reflector","constructor","geometry","options","isReflector","type","forceUpdate","camera","scope","color","undefined","textureWidth","textureHeight","clipBias","shader","ReflectorShader","multisample","reflectorPlane","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","virtualCamera","renderTarget","samples","material","name","uniforms","clone","fragmentShader","vertexShader","value","texture","onBeforeRender","renderer","scene","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","isFacingAway","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","visible","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","dispose"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/objects/Reflector.js"],"sourcesContent":["import {\n\tColor,\n\tMatrix4,\n\tMesh,\n\tPerspectiveCamera,\n\tPlane,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector3,\n\tVector4,\n\tWebGLRenderTarget,\n\tHalfFloatType\n} from 'three';\n\n/**\n * Can be used to create a flat, reflective surface like a mirror.\n *\n * Note that this class can only be used with {@link WebGLRenderer}.\n * When using {@link WebGPURenderer}, use {@link ReflectorNode}.\n *\n * ```js\n * const geometry = new THREE.PlaneGeometry( 100, 100 );\n *\n * const reflector = new Reflector( geometry, {\n * \tclipBias: 0.003,\n * \ttextureWidth: window.innerWidth * window.devicePixelRatio,\n * \ttextureHeight: window.innerHeight * window.devicePixelRatio,\n * \tcolor: 0xc1cbcb\n * } );\n *\n * scene.add( reflector );\n * ```\n *\n * @augments Mesh\n * @three_import import { Reflector } from 'three/addons/objects/Reflector.js';\n */\nclass Reflector extends Mesh {\n\n\t/**\n\t * Constructs a new reflector.\n\t *\n\t * @param {BufferGeometry} geometry - The reflector's geometry.\n\t * @param {Reflector~Options} [options] - The configuration options.\n\t */\n\tconstructor( geometry, options = {} ) {\n\n\t\tsuper( geometry );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isReflector = true;\n\n\t\tthis.type = 'Reflector';\n\n\t\t/**\n\t\t * Whether to force an update, no matter if the reflector\n\t\t * is in view or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.forceUpdate = false;\n\n\t\t/**\n\t\t * The reflector's virtual camera. This is used to render\n\t\t * the scene from the mirror's point of view.\n\t\t *\n\t\t * @type {PerspectiveCamera}\n\t\t */\n\t\tthis.camera = new PerspectiveCamera();\n\n\t\tconst scope = this;\n\n\t\tconst color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );\n\t\tconst textureWidth = options.textureWidth || 512;\n\t\tconst textureHeight = options.textureHeight || 512;\n\t\tconst clipBias = options.clipBias || 0;\n\t\tconst shader = options.shader || Reflector.ReflectorShader;\n\t\tconst multisample = ( options.multisample !== undefined ) ? options.multisample : 4;\n\n\t\t//\n\n\t\tconst reflectorPlane = new Plane();\n\t\tconst normal = new Vector3();\n\t\tconst reflectorWorldPosition = new Vector3();\n\t\tconst cameraWorldPosition = new Vector3();\n\t\tconst rotationMatrix = new Matrix4();\n\t\tconst lookAtPosition = new Vector3( 0, 0, - 1 );\n\t\tconst clipPlane = new Vector4();\n\n\t\tconst view = new Vector3();\n\t\tconst target = new Vector3();\n\t\tconst q = new Vector4();\n\n\t\tconst textureMatrix = new Matrix4();\n\t\tconst virtualCamera = this.camera;\n\n\t\tconst renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, { samples: multisample, type: HalfFloatType } );\n\n\t\tconst material = new ShaderMaterial( {\n\t\t\tname: ( shader.name !== undefined ) ? shader.name : 'unspecified',\n\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tvertexShader: shader.vertexShader\n\t\t} );\n\n\t\tmaterial.uniforms[ 'tDiffuse' ].value = renderTarget.texture;\n\t\tmaterial.uniforms[ 'color' ].value = color;\n\t\tmaterial.uniforms[ 'textureMatrix' ].value = textureMatrix;\n\n\t\tthis.material = material;\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\treflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\tnormal.set( 0, 0, 1 );\n\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\tview.subVectors( reflectorWorldPosition, cameraWorldPosition );\n\n\t\t\t// Avoid rendering when reflector is facing away unless forcing an update\n\t\t\tconst isFacingAway = view.dot( normal ) > 0;\n\n\t\t\tif ( isFacingAway === true && this.forceUpdate === false ) return;\n\n\t\t\tview.reflect( normal ).negate();\n\t\t\tview.add( reflectorWorldPosition );\n\n\t\t\trotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t\tlookAtPosition.set( 0, 0, - 1 );\n\t\t\tlookAtPosition.applyMatrix4( rotationMatrix );\n\t\t\tlookAtPosition.add( cameraWorldPosition );\n\n\t\t\ttarget.subVectors( reflectorWorldPosition, lookAtPosition );\n\t\t\ttarget.reflect( normal ).negate();\n\t\t\ttarget.add( reflectorWorldPosition );\n\n\t\t\tvirtualCamera.position.copy( view );\n\t\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\t\tvirtualCamera.up.applyMatrix4( rotationMatrix );\n\t\t\tvirtualCamera.up.reflect( normal );\n\t\t\tvirtualCamera.lookAt( target );\n\n\t\t\tvirtualCamera.far = camera.far; // Used in WebGLBackground\n\n\t\t\tvirtualCamera.updateMatrixWorld();\n\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\t// Update the texture matrix\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\t\t\ttextureMatrix.multiply( virtualCamera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( virtualCamera.matrixWorldInverse );\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t\treflectorPlane.setFromNormalAndCoplanarPoint( normal, reflectorWorldPosition );\n\t\t\treflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\t\tclipPlane.set( reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant );\n\n\t\t\tconst projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t\tq.z = - 1.0;\n\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t\t// Calculate the scaled plane vector\n\t\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\n\n\t\t\t// Replacing the third row of the projection matrix\n\t\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\n\t\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t\t// Render\n\t\t\tscope.visible = false;\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\n\t\t\trenderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\trenderer.render( scene, virtualCamera );\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t// Restore viewport\n\n\t\t\tconst viewport = camera.viewport;\n\n\t\t\tif ( viewport !== undefined ) {\n\n\t\t\t\trenderer.state.viewport( viewport );\n\n\t\t\t}\n\n\t\t\tscope.visible = true;\n\t\t\tthis.forceUpdate = false;\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the reflector's internal render target.\n\t\t *\n\t\t * @return {WebGLRenderTarget} The internal render target\n\t\t */\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t\t/**\n\t\t * Frees the GPU-related resources allocated by this instance. Call this\n\t\t * method whenever this instance is no longer used in your app.\n\t\t */\n\t\tthis.dispose = function () {\n\n\t\t\trenderTarget.dispose();\n\t\t\tscope.material.dispose();\n\n\t\t};\n\n\t}\n\n}\n\nReflector.ReflectorShader = {\n\n\tname: 'ReflectorShader',\n\n\tuniforms: {\n\n\t\t'color': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tDiffuse': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'textureMatrix': {\n\t\t\tvalue: null\n\t\t}\n\n\t},\n\n\tvertexShader: /* glsl */`\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\n\t\t}`\n};\n\n/**\n * Constructor options of `Reflector`.\n *\n * @typedef {Object} Reflector~Options\n * @property {number|Color|string} [color=0x7F7F7F] - The reflector's color.\n * @property {number} [textureWidth=512] - The texture width. A higher value results in more clear reflections but is also more expensive.\n * @property {number} [textureHeight=512] - The texture height. A higher value results in more clear reflections but is also more expensive.\n * @property {number} [clipBias=0] - The clip bias.\n * @property {Object} [shader] - Can be used to pass in a custom shader that defines how the reflective view is projected onto the reflector's geometry.\n * @property {number} [multisample=4] - How many samples to use for MSAA. `0` disables MSAA.\n **/\n\nexport { Reflector };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}