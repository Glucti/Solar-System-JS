{"ast":null,"code":"import { Object3D } from 'three';\nimport { XRHandPrimitiveModel } from './XRHandPrimitiveModel.js';\nimport { XRHandMeshModel } from './XRHandMeshModel.js';\n\n/**\n * Represents a XR hand model.\n *\n * @augments Object3D\n */\nclass XRHandModel extends Object3D {\n  /**\n   * Constructs a new XR hand model.\n   *\n   * @param {Group} controller - The hand controller.\n   */\n  constructor(controller) {\n    super();\n\n    /**\n     * The hand controller.\n     *\n     * @type {Group}\n     */\n    this.controller = controller;\n\n    /**\n     * The motion controller.\n     *\n     * @type {?MotionController}\n     * @default null\n     */\n    this.motionController = null;\n\n    /**\n     * The controller's environment map.\n     *\n     * @type {?Texture}\n     * @default null\n     */\n    this.envMap = null;\n\n    /**\n     * The model mesh.\n     *\n     * @type {Mesh}\n     * @default null\n     */\n    this.mesh = null;\n  }\n\n  /**\n   * Overwritten with a custom implementation. Makes sure the motion controller updates the mesh.\n   *\n   * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even\n   * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.\n   */\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n    if (this.motionController) {\n      this.motionController.updateMesh();\n    }\n  }\n}\n\n/**\n * Similar to {@link XRControllerModelFactory}, this class allows to create hand models\n * for WebXR controllers that can be added as a visual representation to your scene.\n *\n * ```js\n * const handModelFactory = new XRHandModelFactory();\n *\n * const hand = renderer.xr.getHand( 0 );\n * hand.add( handModelFactory.createHandModel( hand ) );\n * scene.add( hand );\n * ```\n *\n * @three_import import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';\n */\nclass XRHandModelFactory {\n  /**\n   * Constructs a new XR hand model factory.\n   *\n   * @param {?GLTFLoader} [gltfLoader=null] - A glTF loader that is used to load hand models.\n   * @param {?Function} [onLoad=null] - A callback that is executed when a hand model has been loaded.\n   */\n  constructor(gltfLoader = null, onLoad = null) {\n    /**\n     * A glTF loader that is used to load hand models.\n     *\n     * @type {?GLTFLoader}\n     * @default null\n     */\n    this.gltfLoader = gltfLoader;\n\n    /**\n     * The path to the model repository.\n     *\n     * @type {?string}\n     * @default null\n     */\n    this.path = null;\n\n    /**\n     * A callback that is executed when a hand model has been loaded.\n     *\n     * @type {?Function}\n     * @default null\n     */\n    this.onLoad = onLoad;\n  }\n\n  /**\n   * Sets the path to the hand model repository.\n   *\n   * @param {string} path - The path to set.\n   * @return {XRHandModelFactory} A reference to this instance.\n   */\n  setPath(path) {\n    this.path = path;\n    return this;\n  }\n\n  /**\n   * Creates a controller model for the given WebXR hand controller.\n   *\n   * @param {Group} controller - The hand controller.\n   * @param {('spheres'|'boxes'|'mesh')} [profile] - The model profile that defines the model type.\n   * @return {XRHandModel} The XR hand model.\n   */\n  createHandModel(controller, profile) {\n    const handModel = new XRHandModel(controller);\n    controller.addEventListener('connected', event => {\n      const xrInputSource = event.data;\n      if (xrInputSource.hand && !handModel.motionController) {\n        handModel.xrInputSource = xrInputSource;\n\n        // @todo Detect profile if not provided\n        if (profile === undefined || profile === 'spheres') {\n          handModel.motionController = new XRHandPrimitiveModel(handModel, controller, this.path, xrInputSource.handedness, {\n            primitive: 'sphere'\n          });\n        } else if (profile === 'boxes') {\n          handModel.motionController = new XRHandPrimitiveModel(handModel, controller, this.path, xrInputSource.handedness, {\n            primitive: 'box'\n          });\n        } else if (profile === 'mesh') {\n          handModel.motionController = new XRHandMeshModel(handModel, controller, this.path, xrInputSource.handedness, this.gltfLoader, this.onLoad);\n        }\n      }\n      controller.visible = true;\n    });\n    controller.addEventListener('disconnected', () => {\n      controller.visible = false;\n      // handModel.motionController = null;\n      // handModel.remove( scene );\n      // scene = null;\n    });\n    return handModel;\n  }\n}\nexport { XRHandModelFactory };","map":{"version":3,"names":["Object3D","XRHandPrimitiveModel","XRHandMeshModel","XRHandModel","constructor","controller","motionController","envMap","mesh","updateMatrixWorld","force","updateMesh","XRHandModelFactory","gltfLoader","onLoad","path","setPath","createHandModel","profile","handModel","addEventListener","event","xrInputSource","data","hand","undefined","handedness","primitive","visible"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/webxr/XRHandModelFactory.js"],"sourcesContent":["import {\n\tObject3D\n} from 'three';\n\nimport {\n\tXRHandPrimitiveModel\n} from './XRHandPrimitiveModel.js';\n\nimport {\n\tXRHandMeshModel\n} from './XRHandMeshModel.js';\n\n/**\n * Represents a XR hand model.\n *\n * @augments Object3D\n */\nclass XRHandModel extends Object3D {\n\n\t/**\n\t * Constructs a new XR hand model.\n\t *\n\t * @param {Group} controller - The hand controller.\n\t */\n\tconstructor( controller ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The hand controller.\n\t\t *\n\t\t * @type {Group}\n\t\t */\n\t\tthis.controller = controller;\n\n\t\t/**\n\t\t * The motion controller.\n\t\t *\n\t\t * @type {?MotionController}\n\t\t * @default null\n\t\t */\n\t\tthis.motionController = null;\n\n\t\t/**\n\t\t * The controller's environment map.\n\t\t *\n\t\t * @type {?Texture}\n\t\t * @default null\n\t\t */\n\t\tthis.envMap = null;\n\n\t\t/**\n\t\t * The model mesh.\n\t\t *\n\t\t * @type {Mesh}\n\t\t * @default null\n\t\t */\n\t\tthis.mesh = null;\n\n\t}\n\n\t/**\n\t * Overwritten with a custom implementation. Makes sure the motion controller updates the mesh.\n\t *\n\t * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even\n\t * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.\n\t */\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( this.motionController ) {\n\n\t\t\tthis.motionController.updateMesh();\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Similar to {@link XRControllerModelFactory}, this class allows to create hand models\n * for WebXR controllers that can be added as a visual representation to your scene.\n *\n * ```js\n * const handModelFactory = new XRHandModelFactory();\n *\n * const hand = renderer.xr.getHand( 0 );\n * hand.add( handModelFactory.createHandModel( hand ) );\n * scene.add( hand );\n * ```\n *\n * @three_import import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';\n */\nclass XRHandModelFactory {\n\n\t/**\n\t * Constructs a new XR hand model factory.\n\t *\n\t * @param {?GLTFLoader} [gltfLoader=null] - A glTF loader that is used to load hand models.\n\t * @param {?Function} [onLoad=null] - A callback that is executed when a hand model has been loaded.\n\t */\n\tconstructor( gltfLoader = null, onLoad = null ) {\n\n\t\t/**\n\t\t * A glTF loader that is used to load hand models.\n\t\t *\n\t\t * @type {?GLTFLoader}\n\t\t * @default null\n\t\t */\n\t\tthis.gltfLoader = gltfLoader;\n\n\t\t/**\n\t\t * The path to the model repository.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.path = null;\n\n\t\t/**\n\t\t * A callback that is executed when a hand model has been loaded.\n\t\t *\n\t\t * @type {?Function}\n\t\t * @default null\n\t\t */\n\t\tthis.onLoad = onLoad;\n\n\t}\n\n\t/**\n\t * Sets the path to the hand model repository.\n\t *\n\t * @param {string} path - The path to set.\n\t * @return {XRHandModelFactory} A reference to this instance.\n\t */\n\tsetPath( path ) {\n\n\t\tthis.path = path;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Creates a controller model for the given WebXR hand controller.\n\t *\n\t * @param {Group} controller - The hand controller.\n\t * @param {('spheres'|'boxes'|'mesh')} [profile] - The model profile that defines the model type.\n\t * @return {XRHandModel} The XR hand model.\n\t */\n\tcreateHandModel( controller, profile ) {\n\n\t\tconst handModel = new XRHandModel( controller );\n\n\t\tcontroller.addEventListener( 'connected', ( event ) => {\n\n\t\t\tconst xrInputSource = event.data;\n\n\t\t\tif ( xrInputSource.hand && ! handModel.motionController ) {\n\n\t\t\t\thandModel.xrInputSource = xrInputSource;\n\n\t\t\t\t// @todo Detect profile if not provided\n\t\t\t\tif ( profile === undefined || profile === 'spheres' ) {\n\n\t\t\t\t\thandModel.motionController = new XRHandPrimitiveModel( handModel, controller, this.path, xrInputSource.handedness, { primitive: 'sphere' } );\n\n\t\t\t\t} else if ( profile === 'boxes' ) {\n\n\t\t\t\t\thandModel.motionController = new XRHandPrimitiveModel( handModel, controller, this.path, xrInputSource.handedness, { primitive: 'box' } );\n\n\t\t\t\t} else if ( profile === 'mesh' ) {\n\n\t\t\t\t\thandModel.motionController = new XRHandMeshModel( handModel, controller, this.path, xrInputSource.handedness, this.gltfLoader, this.onLoad );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcontroller.visible = true;\n\n\t\t} );\n\n\t\tcontroller.addEventListener( 'disconnected', () => {\n\n\t\t\tcontroller.visible = false;\n\t\t\t// handModel.motionController = null;\n\t\t\t// handModel.remove( scene );\n\t\t\t// scene = null;\n\n\t\t} );\n\n\t\treturn handModel;\n\n\t}\n\n}\n\nexport { XRHandModelFactory };\n"],"mappings":"AAAA,SACCA,QAAQ,QACF,OAAO;AAEd,SACCC,oBAAoB,QACd,2BAA2B;AAElC,SACCC,eAAe,QACT,sBAAsB;;AAE7B;AACA;AACA;AACA;AACA;AACA,MAAMC,WAAW,SAASH,QAAQ,CAAC;EAElC;AACD;AACA;AACA;AACA;EACCI,WAAWA,CAAEC,UAAU,EAAG;IAEzB,KAAK,CAAC,CAAC;;IAEP;AACF;AACA;AACA;AACA;IACE,IAAI,CAACA,UAAU,GAAGA,UAAU;;IAE5B;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,gBAAgB,GAAG,IAAI;;IAE5B;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,MAAM,GAAG,IAAI;;IAElB;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,IAAI,GAAG,IAAI;EAEjB;;EAEA;AACD;AACA;AACA;AACA;AACA;EACCC,iBAAiBA,CAAEC,KAAK,EAAG;IAE1B,KAAK,CAACD,iBAAiB,CAAEC,KAAM,CAAC;IAEhC,IAAK,IAAI,CAACJ,gBAAgB,EAAG;MAE5B,IAAI,CAACA,gBAAgB,CAACK,UAAU,CAAC,CAAC;IAEnC;EAED;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,kBAAkB,CAAC;EAExB;AACD;AACA;AACA;AACA;AACA;EACCR,WAAWA,CAAES,UAAU,GAAG,IAAI,EAAEC,MAAM,GAAG,IAAI,EAAG;IAE/C;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACD,UAAU,GAAGA,UAAU;;IAE5B;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACE,IAAI,GAAG,IAAI;;IAEhB;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACD,MAAM,GAAGA,MAAM;EAErB;;EAEA;AACD;AACA;AACA;AACA;AACA;EACCE,OAAOA,CAAED,IAAI,EAAG;IAEf,IAAI,CAACA,IAAI,GAAGA,IAAI;IAEhB,OAAO,IAAI;EAEZ;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;EACCE,eAAeA,CAAEZ,UAAU,EAAEa,OAAO,EAAG;IAEtC,MAAMC,SAAS,GAAG,IAAIhB,WAAW,CAAEE,UAAW,CAAC;IAE/CA,UAAU,CAACe,gBAAgB,CAAE,WAAW,EAAIC,KAAK,IAAM;MAEtD,MAAMC,aAAa,GAAGD,KAAK,CAACE,IAAI;MAEhC,IAAKD,aAAa,CAACE,IAAI,IAAI,CAAEL,SAAS,CAACb,gBAAgB,EAAG;QAEzDa,SAAS,CAACG,aAAa,GAAGA,aAAa;;QAEvC;QACA,IAAKJ,OAAO,KAAKO,SAAS,IAAIP,OAAO,KAAK,SAAS,EAAG;UAErDC,SAAS,CAACb,gBAAgB,GAAG,IAAIL,oBAAoB,CAAEkB,SAAS,EAAEd,UAAU,EAAE,IAAI,CAACU,IAAI,EAAEO,aAAa,CAACI,UAAU,EAAE;YAAEC,SAAS,EAAE;UAAS,CAAE,CAAC;QAE7I,CAAC,MAAM,IAAKT,OAAO,KAAK,OAAO,EAAG;UAEjCC,SAAS,CAACb,gBAAgB,GAAG,IAAIL,oBAAoB,CAAEkB,SAAS,EAAEd,UAAU,EAAE,IAAI,CAACU,IAAI,EAAEO,aAAa,CAACI,UAAU,EAAE;YAAEC,SAAS,EAAE;UAAM,CAAE,CAAC;QAE1I,CAAC,MAAM,IAAKT,OAAO,KAAK,MAAM,EAAG;UAEhCC,SAAS,CAACb,gBAAgB,GAAG,IAAIJ,eAAe,CAAEiB,SAAS,EAAEd,UAAU,EAAE,IAAI,CAACU,IAAI,EAAEO,aAAa,CAACI,UAAU,EAAE,IAAI,CAACb,UAAU,EAAE,IAAI,CAACC,MAAO,CAAC;QAE7I;MAED;MAEAT,UAAU,CAACuB,OAAO,GAAG,IAAI;IAE1B,CAAE,CAAC;IAEHvB,UAAU,CAACe,gBAAgB,CAAE,cAAc,EAAE,MAAM;MAElDf,UAAU,CAACuB,OAAO,GAAG,KAAK;MAC1B;MACA;MACA;IAED,CAAE,CAAC;IAEH,OAAOT,SAAS;EAEjB;AAED;AAEA,SAASP,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}