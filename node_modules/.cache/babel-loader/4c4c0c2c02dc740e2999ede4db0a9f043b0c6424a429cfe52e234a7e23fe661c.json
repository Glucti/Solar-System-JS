{"ast":null,"code":"import { BufferGeometry, FileLoader, Float32BufferAttribute, Group, LineBasicMaterial, LineSegments, Loader } from 'three';\n\n/**\n * A loader for the GCode format.\n *\n * GCode files are usually used for 3D printing or CNC applications.\n *\n * ```js\n * const loader = new GCodeLoader();\n * const object = await loader.loadAsync( 'models/gcode/benchy.gcode' );\n * scene.add( object );\n * ```\n *\n * @augments Loader\n * @three_import import { GCodeLoader } from 'three/addons/loaders/GCodeLoader.js';\n */\nclass GCodeLoader extends Loader {\n  /**\n   * Constructs a new GCode loader.\n   *\n   * @param {LoadingManager} [manager] - The loading manager.\n   */\n  constructor(manager) {\n    super(manager);\n\n    /**\n     * Whether to split layers or not.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    this.splitLayer = false;\n  }\n\n  /**\n   * Starts loading from the given URL and passes the loaded GCode asset\n   * to the `onLoad()` callback.\n   *\n   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n   * @param {function(Group)} onLoad - Executed when the loading process has been finished.\n   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n   * @param {onErrorCallback} onError - Executed when errors occur.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  /**\n   * Parses the given GCode data and returns a group with lines.\n   *\n   * @param {string} data - The raw Gcode data as a string.\n   * @return {Group} The parsed GCode asset.\n   */\n  parse(data) {\n    let state = {\n      x: 0,\n      y: 0,\n      z: 0,\n      e: 0,\n      f: 0,\n      extruding: false,\n      relative: false\n    };\n    const layers = [];\n    let currentLayer = undefined;\n    const pathMaterial = new LineBasicMaterial({\n      color: 0xFF0000\n    });\n    pathMaterial.name = 'path';\n    const extrudingMaterial = new LineBasicMaterial({\n      color: 0x00FF00\n    });\n    extrudingMaterial.name = 'extruded';\n    function newLayer(line) {\n      currentLayer = {\n        vertex: [],\n        pathVertex: [],\n        z: line.z\n      };\n      layers.push(currentLayer);\n    }\n\n    //Create lie segment between p1 and p2\n    function addSegment(p1, p2) {\n      if (currentLayer === undefined) {\n        newLayer(p1);\n      }\n      if (state.extruding) {\n        currentLayer.vertex.push(p1.x, p1.y, p1.z);\n        currentLayer.vertex.push(p2.x, p2.y, p2.z);\n      } else {\n        currentLayer.pathVertex.push(p1.x, p1.y, p1.z);\n        currentLayer.pathVertex.push(p2.x, p2.y, p2.z);\n      }\n    }\n    function delta(v1, v2) {\n      return state.relative ? v2 : v2 - v1;\n    }\n    function absolute(v1, v2) {\n      return state.relative ? v1 + v2 : v2;\n    }\n    const lines = data.replace(/;.+/g, '').split('\\n');\n    for (let i = 0; i < lines.length; i++) {\n      const tokens = lines[i].split(' ');\n      const cmd = tokens[0].toUpperCase();\n\n      //Arguments\n      const args = {};\n      tokens.splice(1).forEach(function (token) {\n        if (token[0] !== undefined) {\n          const key = token[0].toLowerCase();\n          const value = parseFloat(token.substring(1));\n          args[key] = value;\n        }\n      });\n\n      //Process commands\n      //G0/G1 – Linear Movement\n      if (cmd === 'G0' || cmd === 'G1') {\n        const line = {\n          x: args.x !== undefined ? absolute(state.x, args.x) : state.x,\n          y: args.y !== undefined ? absolute(state.y, args.y) : state.y,\n          z: args.z !== undefined ? absolute(state.z, args.z) : state.z,\n          e: args.e !== undefined ? absolute(state.e, args.e) : state.e,\n          f: args.f !== undefined ? absolute(state.f, args.f) : state.f\n        };\n\n        //Layer change detection is or made by watching Z, it's made by watching when we extrude at a new Z position\n        if (delta(state.e, line.e) > 0) {\n          state.extruding = delta(state.e, line.e) > 0;\n          if (currentLayer == undefined || line.z != currentLayer.z) {\n            newLayer(line);\n          }\n        }\n        addSegment(state, line);\n        state = line;\n      } else if (cmd === 'G2' || cmd === 'G3') {\n\n        //G2/G3 - Arc Movement ( G2 clock wise and G3 counter clock wise )\n        //console.warn( 'THREE.GCodeLoader: Arc command not supported' );\n      } else if (cmd === 'G90') {\n        //G90: Set to Absolute Positioning\n        state.relative = false;\n      } else if (cmd === 'G91') {\n        //G91: Set to state.relative Positioning\n        state.relative = true;\n      } else if (cmd === 'G92') {\n        //G92: Set Position\n        const line = state;\n        line.x = args.x !== undefined ? args.x : line.x;\n        line.y = args.y !== undefined ? args.y : line.y;\n        line.z = args.z !== undefined ? args.z : line.z;\n        line.e = args.e !== undefined ? args.e : line.e;\n      } else {\n\n        //console.warn( 'THREE.GCodeLoader: Command not supported:' + cmd );\n      }\n    }\n    function addObject(vertex, extruding, i) {\n      const geometry = new BufferGeometry();\n      geometry.setAttribute('position', new Float32BufferAttribute(vertex, 3));\n      const segments = new LineSegments(geometry, extruding ? extrudingMaterial : pathMaterial);\n      segments.name = 'layer' + i;\n      object.add(segments);\n    }\n    const object = new Group();\n    object.name = 'gcode';\n    if (this.splitLayer) {\n      for (let i = 0; i < layers.length; i++) {\n        const layer = layers[i];\n        addObject(layer.vertex, true, i);\n        addObject(layer.pathVertex, false, i);\n      }\n    } else {\n      const vertex = [],\n        pathVertex = [];\n      for (let i = 0; i < layers.length; i++) {\n        const layer = layers[i];\n        const layerVertex = layer.vertex;\n        const layerPathVertex = layer.pathVertex;\n        for (let j = 0; j < layerVertex.length; j++) {\n          vertex.push(layerVertex[j]);\n        }\n        for (let j = 0; j < layerPathVertex.length; j++) {\n          pathVertex.push(layerPathVertex[j]);\n        }\n      }\n      addObject(vertex, true, layers.length);\n      addObject(pathVertex, false, layers.length);\n    }\n    object.rotation.set(-Math.PI / 2, 0, 0);\n    return object;\n  }\n}\nexport { GCodeLoader };","map":{"version":3,"names":["BufferGeometry","FileLoader","Float32BufferAttribute","Group","LineBasicMaterial","LineSegments","Loader","GCodeLoader","constructor","manager","splitLayer","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","data","state","x","y","z","f","extruding","relative","layers","currentLayer","undefined","pathMaterial","color","name","extrudingMaterial","newLayer","line","vertex","pathVertex","push","addSegment","p1","p2","delta","v1","v2","absolute","lines","replace","split","i","length","tokens","cmd","toUpperCase","args","splice","forEach","token","key","toLowerCase","value","parseFloat","substring","addObject","geometry","setAttribute","segments","object","add","layer","layerVertex","layerPathVertex","j","rotation","set","Math","PI"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/loaders/GCodeLoader.js"],"sourcesContent":["import {\n\tBufferGeometry,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tGroup,\n\tLineBasicMaterial,\n\tLineSegments,\n\tLoader\n} from 'three';\n\n/**\n * A loader for the GCode format.\n *\n * GCode files are usually used for 3D printing or CNC applications.\n *\n * ```js\n * const loader = new GCodeLoader();\n * const object = await loader.loadAsync( 'models/gcode/benchy.gcode' );\n * scene.add( object );\n * ```\n *\n * @augments Loader\n * @three_import import { GCodeLoader } from 'three/addons/loaders/GCodeLoader.js';\n */\nclass GCodeLoader extends Loader {\n\n\t/**\n\t * Constructs a new GCode loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * Whether to split layers or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.splitLayer = false;\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded GCode asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(Group)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given GCode data and returns a group with lines.\n\t *\n\t * @param {string} data - The raw Gcode data as a string.\n\t * @return {Group} The parsed GCode asset.\n\t */\n\tparse( data ) {\n\n\t\tlet state = { x: 0, y: 0, z: 0, e: 0, f: 0, extruding: false, relative: false };\n\t\tconst layers = [];\n\n\t\tlet currentLayer = undefined;\n\n\t\tconst pathMaterial = new LineBasicMaterial( { color: 0xFF0000 } );\n\t\tpathMaterial.name = 'path';\n\n\t\tconst extrudingMaterial = new LineBasicMaterial( { color: 0x00FF00 } );\n\t\textrudingMaterial.name = 'extruded';\n\n\t\tfunction newLayer( line ) {\n\n\t\t\tcurrentLayer = { vertex: [], pathVertex: [], z: line.z };\n\t\t\tlayers.push( currentLayer );\n\n\t\t}\n\n\t\t//Create lie segment between p1 and p2\n\t\tfunction addSegment( p1, p2 ) {\n\n\t\t\tif ( currentLayer === undefined ) {\n\n\t\t\t\tnewLayer( p1 );\n\n\t\t\t}\n\n\t\t\tif ( state.extruding ) {\n\n\t\t\t\tcurrentLayer.vertex.push( p1.x, p1.y, p1.z );\n\t\t\t\tcurrentLayer.vertex.push( p2.x, p2.y, p2.z );\n\n\t\t\t} else {\n\n\t\t\t\tcurrentLayer.pathVertex.push( p1.x, p1.y, p1.z );\n\t\t\t\tcurrentLayer.pathVertex.push( p2.x, p2.y, p2.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction delta( v1, v2 ) {\n\n\t\t\treturn state.relative ? v2 : v2 - v1;\n\n\t\t}\n\n\t\tfunction absolute( v1, v2 ) {\n\n\t\t\treturn state.relative ? v1 + v2 : v2;\n\n\t\t}\n\n\t\tconst lines = data.replace( /;.+/g, '' ).split( '\\n' );\n\n\t\tfor ( let i = 0; i < lines.length; i ++ ) {\n\n\t\t\tconst tokens = lines[ i ].split( ' ' );\n\t\t\tconst cmd = tokens[ 0 ].toUpperCase();\n\n\t\t\t//Arguments\n\t\t\tconst args = {};\n\t\t\ttokens.splice( 1 ).forEach( function ( token ) {\n\n\t\t\t\tif ( token[ 0 ] !== undefined ) {\n\n\t\t\t\t\tconst key = token[ 0 ].toLowerCase();\n\t\t\t\t\tconst value = parseFloat( token.substring( 1 ) );\n\t\t\t\t\targs[ key ] = value;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t//Process commands\n\t\t\t//G0/G1 – Linear Movement\n\t\t\tif ( cmd === 'G0' || cmd === 'G1' ) {\n\n\t\t\t\tconst line = {\n\t\t\t\t\tx: args.x !== undefined ? absolute( state.x, args.x ) : state.x,\n\t\t\t\t\ty: args.y !== undefined ? absolute( state.y, args.y ) : state.y,\n\t\t\t\t\tz: args.z !== undefined ? absolute( state.z, args.z ) : state.z,\n\t\t\t\t\te: args.e !== undefined ? absolute( state.e, args.e ) : state.e,\n\t\t\t\t\tf: args.f !== undefined ? absolute( state.f, args.f ) : state.f,\n\t\t\t\t};\n\n\t\t\t\t//Layer change detection is or made by watching Z, it's made by watching when we extrude at a new Z position\n\t\t\t\tif ( delta( state.e, line.e ) > 0 ) {\n\n\t\t\t\t\tstate.extruding = delta( state.e, line.e ) > 0;\n\n\t\t\t\t\tif ( currentLayer == undefined || line.z != currentLayer.z ) {\n\n\t\t\t\t\t\tnewLayer( line );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\taddSegment( state, line );\n\t\t\t\tstate = line;\n\n\t\t\t} else if ( cmd === 'G2' || cmd === 'G3' ) {\n\n\t\t\t\t//G2/G3 - Arc Movement ( G2 clock wise and G3 counter clock wise )\n\t\t\t\t//console.warn( 'THREE.GCodeLoader: Arc command not supported' );\n\n\t\t\t} else if ( cmd === 'G90' ) {\n\n\t\t\t\t//G90: Set to Absolute Positioning\n\t\t\t\tstate.relative = false;\n\n\t\t\t} else if ( cmd === 'G91' ) {\n\n\t\t\t\t//G91: Set to state.relative Positioning\n\t\t\t\tstate.relative = true;\n\n\t\t\t} else if ( cmd === 'G92' ) {\n\n\t\t\t\t//G92: Set Position\n\t\t\t\tconst line = state;\n\t\t\t\tline.x = args.x !== undefined ? args.x : line.x;\n\t\t\t\tline.y = args.y !== undefined ? args.y : line.y;\n\t\t\t\tline.z = args.z !== undefined ? args.z : line.z;\n\t\t\t\tline.e = args.e !== undefined ? args.e : line.e;\n\n\t\t\t} else {\n\n\t\t\t\t//console.warn( 'THREE.GCodeLoader: Command not supported:' + cmd );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addObject( vertex, extruding, i ) {\n\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertex, 3 ) );\n\t\t\tconst segments = new LineSegments( geometry, extruding ? extrudingMaterial : pathMaterial );\n\t\t\tsegments.name = 'layer' + i;\n\t\t\tobject.add( segments );\n\n\t\t}\n\n\t\tconst object = new Group();\n\t\tobject.name = 'gcode';\n\n\t\tif ( this.splitLayer ) {\n\n\t\t\tfor ( let i = 0; i < layers.length; i ++ ) {\n\n\t\t\t\tconst layer = layers[ i ];\n\t\t\t\taddObject( layer.vertex, true, i );\n\t\t\t\taddObject( layer.pathVertex, false, i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst vertex = [],\n\t\t\t\tpathVertex = [];\n\n\t\t\tfor ( let i = 0; i < layers.length; i ++ ) {\n\n\t\t\t\tconst layer = layers[ i ];\n\t\t\t\tconst layerVertex = layer.vertex;\n\t\t\t\tconst layerPathVertex = layer.pathVertex;\n\n\t\t\t\tfor ( let j = 0; j < layerVertex.length; j ++ ) {\n\n\t\t\t\t\tvertex.push( layerVertex[ j ] );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0; j < layerPathVertex.length; j ++ ) {\n\n\t\t\t\t\tpathVertex.push( layerPathVertex[ j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\taddObject( vertex, true, layers.length );\n\t\t\taddObject( pathVertex, false, layers.length );\n\n\t\t}\n\n\t\tobject.rotation.set( - Math.PI / 2, 0, 0 );\n\n\t\treturn object;\n\n\t}\n\n}\n\nexport { GCodeLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}