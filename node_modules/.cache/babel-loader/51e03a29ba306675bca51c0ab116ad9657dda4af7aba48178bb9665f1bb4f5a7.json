{"ast":null,"code":"import { BufferGeometry, Color, FileLoader, Float32BufferAttribute, Int32BufferAttribute, Loader, Points, PointsMaterial, SRGBColorSpace } from 'three';\n\n/**\n * A loader for the Point Cloud Data (PCD) format.\n *\n * PCDLoader supports ASCII and (compressed) binary files as well as the following PCD fields:\n * - x y z\n * - rgb\n * - normal_x normal_y normal_z\n * - intensity\n * - label\n *\n * ```js\n * const loader = new PCDLoader();\n *\n * const points = await loader.loadAsync( './models/pcd/binary/Zaghetto.pcd' );\n * points.geometry.center(); // optional\n * points.geometry.rotateX( Math.PI ); // optional\n * scene.add( points );\n * ```\n *\n * @augments Loader\n * @three_import import { PCDLoader } from 'three/addons/loaders/PCDLoader.js';\n */\nclass PCDLoader extends Loader {\n  /**\n   * Constructs a new PCD loader.\n   *\n   * @param {LoadingManager} [manager] - The loading manager.\n   */\n  constructor(manager) {\n    super(manager);\n\n    /**\n     * Whether to use little Endian or not.\n     *\n     * @type {boolean}\n     * @default true\n     */\n    this.littleEndian = true;\n  }\n\n  /**\n   * Starts loading from the given URL and passes the loaded PCD asset\n   * to the `onLoad()` callback.\n   *\n   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n   * @param {function(Points)} onLoad - Executed when the loading process has been finished.\n   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n   * @param {onErrorCallback} onError - Executed when errors occur.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (data) {\n      try {\n        onLoad(scope.parse(data));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  /**\n   * Get dataview value by field type and size.\n   *\n   * @param {DataView} dataview - The DataView to read from.\n   * @param {number} offset - The offset to start reading from.\n   * @param {'F' | 'U' | 'I'} type - Field type.\n   * @param {number} size - Field size.\n   * @returns {number} Field value.\n   */\n  _getDataView(dataview, offset, type, size) {\n    switch (type) {\n      case 'F':\n        {\n          if (size === 8) {\n            return dataview.getFloat64(offset, this.littleEndian);\n          }\n          return dataview.getFloat32(offset, this.littleEndian);\n        }\n      case 'I':\n        {\n          if (size === 1) {\n            return dataview.getInt8(offset);\n          }\n          if (size === 2) {\n            return dataview.getInt16(offset, this.littleEndian);\n          }\n          return dataview.getInt32(offset, this.littleEndian);\n        }\n      case 'U':\n        {\n          if (size === 1) {\n            return dataview.getUint8(offset);\n          }\n          if (size === 2) {\n            return dataview.getUint16(offset, this.littleEndian);\n          }\n          return dataview.getUint32(offset, this.littleEndian);\n        }\n    }\n  }\n\n  /**\n   * Parses the given PCD data and returns a point cloud.\n   *\n   * @param {ArrayBuffer} data - The raw PCD data as an array buffer.\n   * @return {Points} The parsed point cloud.\n   */\n  parse(data) {\n    // from https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js\n\n    function decompressLZF(inData, outLength) {\n      const inLength = inData.length;\n      const outData = new Uint8Array(outLength);\n      let inPtr = 0;\n      let outPtr = 0;\n      let ctrl;\n      let len;\n      let ref;\n      do {\n        ctrl = inData[inPtr++];\n        if (ctrl < 1 << 5) {\n          ctrl++;\n          if (outPtr + ctrl > outLength) throw new Error('Output buffer is not large enough');\n          if (inPtr + ctrl > inLength) throw new Error('Invalid compressed data');\n          do {\n            outData[outPtr++] = inData[inPtr++];\n          } while (--ctrl);\n        } else {\n          len = ctrl >> 5;\n          ref = outPtr - ((ctrl & 0x1f) << 8) - 1;\n          if (inPtr >= inLength) throw new Error('Invalid compressed data');\n          if (len === 7) {\n            len += inData[inPtr++];\n            if (inPtr >= inLength) throw new Error('Invalid compressed data');\n          }\n          ref -= inData[inPtr++];\n          if (outPtr + len + 2 > outLength) throw new Error('Output buffer is not large enough');\n          if (ref < 0) throw new Error('Invalid compressed data');\n          if (ref >= outPtr) throw new Error('Invalid compressed data');\n          do {\n            outData[outPtr++] = outData[ref++];\n          } while (--len + 2);\n        }\n      } while (inPtr < inLength);\n      return outData;\n    }\n    function parseHeader(binaryData) {\n      const PCDheader = {};\n      const buffer = new Uint8Array(binaryData);\n      let data = '',\n        line = '',\n        i = 0,\n        end = false;\n      const max = buffer.length;\n      while (i < max && end === false) {\n        const char = String.fromCharCode(buffer[i++]);\n        if (char === '\\n' || char === '\\r') {\n          if (line.trim().toLowerCase().startsWith('data')) {\n            end = true;\n          }\n          line = '';\n        } else {\n          line += char;\n        }\n        data += char;\n      }\n      const result1 = data.search(/[\\r\\n]DATA\\s(\\S*)\\s/i);\n      const result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec(data.slice(result1 - 1));\n      PCDheader.data = result2[1];\n      PCDheader.headerLen = result2[0].length + result1;\n      PCDheader.str = data.slice(0, PCDheader.headerLen);\n\n      // remove comments\n\n      PCDheader.str = PCDheader.str.replace(/#.*/gi, '');\n\n      // parse\n\n      PCDheader.version = /^VERSION (.*)/im.exec(PCDheader.str);\n      PCDheader.fields = /^FIELDS (.*)/im.exec(PCDheader.str);\n      PCDheader.size = /^SIZE (.*)/im.exec(PCDheader.str);\n      PCDheader.type = /^TYPE (.*)/im.exec(PCDheader.str);\n      PCDheader.count = /^COUNT (.*)/im.exec(PCDheader.str);\n      PCDheader.width = /^WIDTH (.*)/im.exec(PCDheader.str);\n      PCDheader.height = /^HEIGHT (.*)/im.exec(PCDheader.str);\n      PCDheader.viewpoint = /^VIEWPOINT (.*)/im.exec(PCDheader.str);\n      PCDheader.points = /^POINTS (.*)/im.exec(PCDheader.str);\n\n      // evaluate\n\n      if (PCDheader.version !== null) PCDheader.version = parseFloat(PCDheader.version[1]);\n      PCDheader.fields = PCDheader.fields !== null ? PCDheader.fields[1].split(' ') : [];\n      if (PCDheader.type !== null) PCDheader.type = PCDheader.type[1].split(' ');\n      if (PCDheader.width !== null) PCDheader.width = parseInt(PCDheader.width[1]);\n      if (PCDheader.height !== null) PCDheader.height = parseInt(PCDheader.height[1]);\n      if (PCDheader.viewpoint !== null) PCDheader.viewpoint = PCDheader.viewpoint[1];\n      if (PCDheader.points !== null) PCDheader.points = parseInt(PCDheader.points[1], 10);\n      if (PCDheader.points === null) PCDheader.points = PCDheader.width * PCDheader.height;\n      if (PCDheader.size !== null) {\n        PCDheader.size = PCDheader.size[1].split(' ').map(function (x) {\n          return parseInt(x, 10);\n        });\n      }\n      if (PCDheader.count !== null) {\n        PCDheader.count = PCDheader.count[1].split(' ').map(function (x) {\n          return parseInt(x, 10);\n        });\n      } else {\n        PCDheader.count = [];\n        for (let i = 0, l = PCDheader.fields.length; i < l; i++) {\n          PCDheader.count.push(1);\n        }\n      }\n      PCDheader.offset = {};\n      let sizeSum = 0;\n      for (let i = 0, l = PCDheader.fields.length; i < l; i++) {\n        if (PCDheader.data === 'ascii') {\n          PCDheader.offset[PCDheader.fields[i]] = i;\n        } else {\n          PCDheader.offset[PCDheader.fields[i]] = sizeSum;\n          sizeSum += PCDheader.size[i] * PCDheader.count[i];\n        }\n      }\n\n      // for binary only\n\n      PCDheader.rowSize = sizeSum;\n      return PCDheader;\n    }\n\n    // parse header\n\n    const PCDheader = parseHeader(data);\n\n    // parse data\n\n    const position = [];\n    const normal = [];\n    const color = [];\n    const intensity = [];\n    const label = [];\n    const c = new Color();\n\n    // ascii\n\n    if (PCDheader.data === 'ascii') {\n      const offset = PCDheader.offset;\n      const textData = new TextDecoder().decode(data);\n      const pcdData = textData.slice(PCDheader.headerLen);\n      const lines = pcdData.split('\\n');\n      for (let i = 0, l = lines.length; i < l; i++) {\n        if (lines[i] === '') continue;\n        const line = lines[i].split(' ');\n        if (offset.x !== undefined) {\n          position.push(parseFloat(line[offset.x]));\n          position.push(parseFloat(line[offset.y]));\n          position.push(parseFloat(line[offset.z]));\n        }\n        if (offset.rgb !== undefined) {\n          const rgb_field_index = PCDheader.fields.findIndex(field => field === 'rgb');\n          const rgb_type = PCDheader.type[rgb_field_index];\n          const float = parseFloat(line[offset.rgb]);\n          let rgb = float;\n          if (rgb_type === 'F') {\n            // treat float values as int\n            // https://github.com/daavoo/pyntcloud/pull/204/commits/7b4205e64d5ed09abe708b2e91b615690c24d518\n            const farr = new Float32Array(1);\n            farr[0] = float;\n            rgb = new Int32Array(farr.buffer)[0];\n          }\n          const r = (rgb >> 16 & 0x0000ff) / 255;\n          const g = (rgb >> 8 & 0x0000ff) / 255;\n          const b = (rgb >> 0 & 0x0000ff) / 255;\n          c.setRGB(r, g, b, SRGBColorSpace);\n          color.push(c.r, c.g, c.b);\n        }\n        if (offset.normal_x !== undefined) {\n          normal.push(parseFloat(line[offset.normal_x]));\n          normal.push(parseFloat(line[offset.normal_y]));\n          normal.push(parseFloat(line[offset.normal_z]));\n        }\n        if (offset.intensity !== undefined) {\n          intensity.push(parseFloat(line[offset.intensity]));\n        }\n        if (offset.label !== undefined) {\n          label.push(parseInt(line[offset.label]));\n        }\n      }\n    }\n\n    // binary-compressed\n\n    // normally data in PCD files are organized as array of structures: XYZRGBXYZRGB\n    // binary compressed PCD files organize their data as structure of arrays: XXYYZZRGBRGB\n    // that requires a totally different parsing approach compared to non-compressed data\n\n    if (PCDheader.data === 'binary_compressed') {\n      const sizes = new Uint32Array(data.slice(PCDheader.headerLen, PCDheader.headerLen + 8));\n      const compressedSize = sizes[0];\n      const decompressedSize = sizes[1];\n      const decompressed = decompressLZF(new Uint8Array(data, PCDheader.headerLen + 8, compressedSize), decompressedSize);\n      const dataview = new DataView(decompressed.buffer);\n      const offset = PCDheader.offset;\n      for (let i = 0; i < PCDheader.points; i++) {\n        if (offset.x !== undefined) {\n          const xIndex = PCDheader.fields.indexOf('x');\n          const yIndex = PCDheader.fields.indexOf('y');\n          const zIndex = PCDheader.fields.indexOf('z');\n          position.push(this._getDataView(dataview, PCDheader.points * offset.x + PCDheader.size[xIndex] * i, PCDheader.type[xIndex], PCDheader.size[xIndex]));\n          position.push(this._getDataView(dataview, PCDheader.points * offset.y + PCDheader.size[yIndex] * i, PCDheader.type[yIndex], PCDheader.size[yIndex]));\n          position.push(this._getDataView(dataview, PCDheader.points * offset.z + PCDheader.size[zIndex] * i, PCDheader.type[zIndex], PCDheader.size[zIndex]));\n        }\n        if (offset.rgb !== undefined) {\n          const rgbIndex = PCDheader.fields.indexOf('rgb');\n          const r = dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[rgbIndex] * i + 2) / 255.0;\n          const g = dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[rgbIndex] * i + 1) / 255.0;\n          const b = dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[rgbIndex] * i + 0) / 255.0;\n          c.setRGB(r, g, b, SRGBColorSpace);\n          color.push(c.r, c.g, c.b);\n        }\n        if (offset.normal_x !== undefined) {\n          const xIndex = PCDheader.fields.indexOf('normal_x');\n          const yIndex = PCDheader.fields.indexOf('normal_y');\n          const zIndex = PCDheader.fields.indexOf('normal_z');\n          normal.push(this._getDataView(dataview, PCDheader.points * offset.normal_x + PCDheader.size[xIndex] * i, PCDheader.type[xIndex], PCDheader.size[xIndex]));\n          normal.push(this._getDataView(dataview, PCDheader.points * offset.normal_y + PCDheader.size[yIndex] * i, PCDheader.type[yIndex], PCDheader.size[yIndex]));\n          normal.push(this._getDataView(dataview, PCDheader.points * offset.normal_z + PCDheader.size[zIndex] * i, PCDheader.type[zIndex], PCDheader.size[zIndex]));\n        }\n        if (offset.intensity !== undefined) {\n          const intensityIndex = PCDheader.fields.indexOf('intensity');\n          intensity.push(this._getDataView(dataview, PCDheader.points * offset.intensity + PCDheader.size[intensityIndex] * i, PCDheader.type[intensityIndex], PCDheader.size[intensityIndex]));\n        }\n        if (offset.label !== undefined) {\n          const labelIndex = PCDheader.fields.indexOf('label');\n          label.push(dataview.getInt32(PCDheader.points * offset.label + PCDheader.size[labelIndex] * i, this.littleEndian));\n        }\n      }\n    }\n\n    // binary\n\n    if (PCDheader.data === 'binary') {\n      const dataview = new DataView(data, PCDheader.headerLen);\n      const offset = PCDheader.offset;\n      for (let i = 0, row = 0; i < PCDheader.points; i++, row += PCDheader.rowSize) {\n        if (offset.x !== undefined) {\n          const xIndex = PCDheader.fields.indexOf('x');\n          const yIndex = PCDheader.fields.indexOf('y');\n          const zIndex = PCDheader.fields.indexOf('z');\n          position.push(this._getDataView(dataview, row + offset.x, PCDheader.type[xIndex], PCDheader.size[xIndex]));\n          position.push(this._getDataView(dataview, row + offset.y, PCDheader.type[yIndex], PCDheader.size[yIndex]));\n          position.push(this._getDataView(dataview, row + offset.z, PCDheader.type[zIndex], PCDheader.size[zIndex]));\n        }\n        if (offset.rgb !== undefined) {\n          const r = dataview.getUint8(row + offset.rgb + 2) / 255.0;\n          const g = dataview.getUint8(row + offset.rgb + 1) / 255.0;\n          const b = dataview.getUint8(row + offset.rgb + 0) / 255.0;\n          c.setRGB(r, g, b, SRGBColorSpace);\n          color.push(c.r, c.g, c.b);\n        }\n        if (offset.normal_x !== undefined) {\n          const xIndex = PCDheader.fields.indexOf('normal_x');\n          const yIndex = PCDheader.fields.indexOf('normal_y');\n          const zIndex = PCDheader.fields.indexOf('normal_z');\n          normal.push(this._getDataView(dataview, row + offset.normal_x, PCDheader.type[xIndex], PCDheader.size[xIndex]));\n          normal.push(this._getDataView(dataview, row + offset.normal_y, PCDheader.type[yIndex], PCDheader.size[yIndex]));\n          normal.push(this._getDataView(dataview, row + offset.normal_z, PCDheader.type[zIndex], PCDheader.size[zIndex]));\n        }\n        if (offset.intensity !== undefined) {\n          const intensityIndex = PCDheader.fields.indexOf('intensity');\n          intensity.push(this._getDataView(dataview, row + offset.intensity, PCDheader.type[intensityIndex], PCDheader.size[intensityIndex]));\n        }\n        if (offset.label !== undefined) {\n          label.push(dataview.getInt32(row + offset.label, this.littleEndian));\n        }\n      }\n    }\n\n    // build geometry\n\n    const geometry = new BufferGeometry();\n    if (position.length > 0) geometry.setAttribute('position', new Float32BufferAttribute(position, 3));\n    if (normal.length > 0) geometry.setAttribute('normal', new Float32BufferAttribute(normal, 3));\n    if (color.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color, 3));\n    if (intensity.length > 0) geometry.setAttribute('intensity', new Float32BufferAttribute(intensity, 1));\n    if (label.length > 0) geometry.setAttribute('label', new Int32BufferAttribute(label, 1));\n    geometry.computeBoundingSphere();\n\n    // build material\n\n    const material = new PointsMaterial({\n      size: 0.005\n    });\n    if (color.length > 0) {\n      material.vertexColors = true;\n    }\n\n    // build point cloud\n\n    return new Points(geometry, material);\n  }\n}\nexport { PCDLoader };","map":{"version":3,"names":["BufferGeometry","Color","FileLoader","Float32BufferAttribute","Int32BufferAttribute","Loader","Points","PointsMaterial","SRGBColorSpace","PCDLoader","constructor","manager","littleEndian","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","data","parse","e","console","error","itemError","_getDataView","dataview","offset","type","size","getFloat64","getFloat32","getInt8","getInt16","getInt32","getUint8","getUint16","getUint32","decompressLZF","inData","outLength","inLength","length","outData","Uint8Array","inPtr","outPtr","ctrl","len","ref","Error","parseHeader","binaryData","PCDheader","buffer","line","i","end","max","char","String","fromCharCode","trim","toLowerCase","startsWith","result1","search","result2","exec","slice","headerLen","str","replace","version","fields","count","width","height","viewpoint","points","parseFloat","split","parseInt","map","x","l","push","sizeSum","rowSize","position","normal","color","intensity","label","c","textData","TextDecoder","decode","pcdData","lines","undefined","y","z","rgb","rgb_field_index","findIndex","field","rgb_type","float","farr","Float32Array","Int32Array","r","g","b","setRGB","normal_x","normal_y","normal_z","sizes","Uint32Array","compressedSize","decompressedSize","decompressed","DataView","xIndex","indexOf","yIndex","zIndex","rgbIndex","intensityIndex","labelIndex","row","geometry","setAttribute","computeBoundingSphere","material","vertexColors"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/loaders/PCDLoader.js"],"sourcesContent":["import {\n\tBufferGeometry,\n\tColor,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tInt32BufferAttribute,\n\tLoader,\n\tPoints,\n\tPointsMaterial,\n\tSRGBColorSpace\n} from 'three';\n\n/**\n * A loader for the Point Cloud Data (PCD) format.\n *\n * PCDLoader supports ASCII and (compressed) binary files as well as the following PCD fields:\n * - x y z\n * - rgb\n * - normal_x normal_y normal_z\n * - intensity\n * - label\n *\n * ```js\n * const loader = new PCDLoader();\n *\n * const points = await loader.loadAsync( './models/pcd/binary/Zaghetto.pcd' );\n * points.geometry.center(); // optional\n * points.geometry.rotateX( Math.PI ); // optional\n * scene.add( points );\n * ```\n *\n * @augments Loader\n * @three_import import { PCDLoader } from 'three/addons/loaders/PCDLoader.js';\n */\nclass PCDLoader extends Loader {\n\n\t/**\n\t * Constructs a new PCD loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * Whether to use little Endian or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.littleEndian = true;\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded PCD asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(Points)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( data ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Get dataview value by field type and size.\n\t *\n\t * @param {DataView} dataview - The DataView to read from.\n\t * @param {number} offset - The offset to start reading from.\n\t * @param {'F' | 'U' | 'I'} type - Field type.\n\t * @param {number} size - Field size.\n\t * @returns {number} Field value.\n\t */\n\t_getDataView( dataview, offset, type, size ) {\n\n\t\tswitch ( type ) {\n\n\t\t\tcase 'F': {\n\n\t\t\t\tif ( size === 8 ) {\n\n\t\t\t\t\treturn dataview.getFloat64( offset, this.littleEndian );\n\n\t\t\t\t}\n\n\t\t\t\treturn dataview.getFloat32( offset, this.littleEndian );\n\n\t\t\t}\n\n\t\t\tcase 'I': {\n\n\t\t\t\tif ( size === 1 ) {\n\n\t\t\t\t\treturn dataview.getInt8( offset );\n\n\t\t\t\t}\n\n\t\t\t\tif ( size === 2 ) {\n\n\t\t\t\t\treturn dataview.getInt16( offset, this.littleEndian );\n\n\t\t\t\t}\n\n\t\t\t\treturn dataview.getInt32( offset, this.littleEndian );\n\n\t\t\t}\n\n\t\t\tcase 'U': {\n\n\t\t\t\tif ( size === 1 ) {\n\n\t\t\t\t\treturn dataview.getUint8( offset );\n\n\t\t\t\t}\n\n\t\t\t\tif ( size === 2 ) {\n\n\t\t\t\t\treturn dataview.getUint16( offset, this.littleEndian );\n\n\t\t\t\t}\n\n\t\t\t\treturn dataview.getUint32( offset, this.littleEndian );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Parses the given PCD data and returns a point cloud.\n\t *\n\t * @param {ArrayBuffer} data - The raw PCD data as an array buffer.\n\t * @return {Points} The parsed point cloud.\n\t */\n\tparse( data ) {\n\n\t\t// from https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js\n\n\t\tfunction decompressLZF( inData, outLength ) {\n\n\t\t\tconst inLength = inData.length;\n\t\t\tconst outData = new Uint8Array( outLength );\n\t\t\tlet inPtr = 0;\n\t\t\tlet outPtr = 0;\n\t\t\tlet ctrl;\n\t\t\tlet len;\n\t\t\tlet ref;\n\t\t\tdo {\n\n\t\t\t\tctrl = inData[ inPtr ++ ];\n\t\t\t\tif ( ctrl < ( 1 << 5 ) ) {\n\n\t\t\t\t\tctrl ++;\n\t\t\t\t\tif ( outPtr + ctrl > outLength ) throw new Error( 'Output buffer is not large enough' );\n\t\t\t\t\tif ( inPtr + ctrl > inLength ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\tdo {\n\n\t\t\t\t\t\toutData[ outPtr ++ ] = inData[ inPtr ++ ];\n\n\t\t\t\t\t} while ( -- ctrl );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlen = ctrl >> 5;\n\t\t\t\t\tref = outPtr - ( ( ctrl & 0x1f ) << 8 ) - 1;\n\t\t\t\t\tif ( inPtr >= inLength ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\tif ( len === 7 ) {\n\n\t\t\t\t\t\tlen += inData[ inPtr ++ ];\n\t\t\t\t\t\tif ( inPtr >= inLength ) throw new Error( 'Invalid compressed data' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tref -= inData[ inPtr ++ ];\n\t\t\t\t\tif ( outPtr + len + 2 > outLength ) throw new Error( 'Output buffer is not large enough' );\n\t\t\t\t\tif ( ref < 0 ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\tif ( ref >= outPtr ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\tdo {\n\n\t\t\t\t\t\toutData[ outPtr ++ ] = outData[ ref ++ ];\n\n\t\t\t\t\t} while ( -- len + 2 );\n\n\t\t\t\t}\n\n\t\t\t} while ( inPtr < inLength );\n\n\t\t\treturn outData;\n\n\t\t}\n\n\t\tfunction parseHeader( binaryData ) {\n\n\t\t\tconst PCDheader = {};\n\n\t\t\tconst buffer = new Uint8Array( binaryData );\n\n\t\t\tlet data = '', line = '', i = 0, end = false;\n\n\t\t\tconst max = buffer.length;\n\n\t\t\twhile ( i < max && end === false ) {\n\n\t\t\t\tconst char = String.fromCharCode( buffer[ i ++ ] );\n\n\t\t\t\tif ( char === '\\n' || char === '\\r' ) {\n\n\t\t\t\t\tif ( line.trim().toLowerCase().startsWith( 'data' ) ) {\n\n\t\t\t\t\t\tend = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tline = '';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tline += char;\n\n\t\t\t\t}\n\n\t\t\t\tdata += char;\n\n\t\t\t}\n\n\t\t\tconst result1 = data.search( /[\\r\\n]DATA\\s(\\S*)\\s/i );\n\t\t\tconst result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec( data.slice( result1 - 1 ) );\n\n\t\t\tPCDheader.data = result2[ 1 ];\n\t\t\tPCDheader.headerLen = result2[ 0 ].length + result1;\n\t\t\tPCDheader.str = data.slice( 0, PCDheader.headerLen );\n\n\t\t\t// remove comments\n\n\t\t\tPCDheader.str = PCDheader.str.replace( /#.*/gi, '' );\n\n\t\t\t// parse\n\n\t\t\tPCDheader.version = /^VERSION (.*)/im.exec( PCDheader.str );\n\t\t\tPCDheader.fields = /^FIELDS (.*)/im.exec( PCDheader.str );\n\t\t\tPCDheader.size = /^SIZE (.*)/im.exec( PCDheader.str );\n\t\t\tPCDheader.type = /^TYPE (.*)/im.exec( PCDheader.str );\n\t\t\tPCDheader.count = /^COUNT (.*)/im.exec( PCDheader.str );\n\t\t\tPCDheader.width = /^WIDTH (.*)/im.exec( PCDheader.str );\n\t\t\tPCDheader.height = /^HEIGHT (.*)/im.exec( PCDheader.str );\n\t\t\tPCDheader.viewpoint = /^VIEWPOINT (.*)/im.exec( PCDheader.str );\n\t\t\tPCDheader.points = /^POINTS (.*)/im.exec( PCDheader.str );\n\n\t\t\t// evaluate\n\n\t\t\tif ( PCDheader.version !== null )\n\t\t\t\tPCDheader.version = parseFloat( PCDheader.version[ 1 ] );\n\n\t\t\tPCDheader.fields = ( PCDheader.fields !== null ) ? PCDheader.fields[ 1 ].split( ' ' ) : [];\n\n\t\t\tif ( PCDheader.type !== null )\n\t\t\t\tPCDheader.type = PCDheader.type[ 1 ].split( ' ' );\n\n\t\t\tif ( PCDheader.width !== null )\n\t\t\t\tPCDheader.width = parseInt( PCDheader.width[ 1 ] );\n\n\t\t\tif ( PCDheader.height !== null )\n\t\t\t\tPCDheader.height = parseInt( PCDheader.height[ 1 ] );\n\n\t\t\tif ( PCDheader.viewpoint !== null )\n\t\t\t\tPCDheader.viewpoint = PCDheader.viewpoint[ 1 ];\n\n\t\t\tif ( PCDheader.points !== null )\n\t\t\t\tPCDheader.points = parseInt( PCDheader.points[ 1 ], 10 );\n\n\t\t\tif ( PCDheader.points === null )\n\t\t\t\tPCDheader.points = PCDheader.width * PCDheader.height;\n\n\t\t\tif ( PCDheader.size !== null ) {\n\n\t\t\t\tPCDheader.size = PCDheader.size[ 1 ].split( ' ' ).map( function ( x ) {\n\n\t\t\t\t\treturn parseInt( x, 10 );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( PCDheader.count !== null ) {\n\n\t\t\t\tPCDheader.count = PCDheader.count[ 1 ].split( ' ' ).map( function ( x ) {\n\n\t\t\t\t\treturn parseInt( x, 10 );\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\tPCDheader.count = [];\n\n\t\t\t\tfor ( let i = 0, l = PCDheader.fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tPCDheader.count.push( 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tPCDheader.offset = {};\n\n\t\t\tlet sizeSum = 0;\n\n\t\t\tfor ( let i = 0, l = PCDheader.fields.length; i < l; i ++ ) {\n\n\t\t\t\tif ( PCDheader.data === 'ascii' ) {\n\n\t\t\t\t\tPCDheader.offset[ PCDheader.fields[ i ] ] = i;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tPCDheader.offset[ PCDheader.fields[ i ] ] = sizeSum;\n\t\t\t\t\tsizeSum += PCDheader.size[ i ] * PCDheader.count[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// for binary only\n\n\t\t\tPCDheader.rowSize = sizeSum;\n\n\t\t\treturn PCDheader;\n\n\t\t}\n\n\t\t// parse header\n\n\t\tconst PCDheader = parseHeader( data );\n\n\t\t// parse data\n\n\t\tconst position = [];\n\t\tconst normal = [];\n\t\tconst color = [];\n\t\tconst intensity = [];\n\t\tconst label = [];\n\n\t\tconst c = new Color();\n\n\t\t// ascii\n\n\t\tif ( PCDheader.data === 'ascii' ) {\n\n\t\t\tconst offset = PCDheader.offset;\n\t\t\tconst textData = new TextDecoder().decode( data );\n\t\t\tconst pcdData = textData.slice( PCDheader.headerLen );\n\t\t\tconst lines = pcdData.split( '\\n' );\n\n\t\t\tfor ( let i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\t\tif ( lines[ i ] === '' ) continue;\n\n\t\t\t\tconst line = lines[ i ].split( ' ' );\n\n\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\tposition.push( parseFloat( line[ offset.x ] ) );\n\t\t\t\t\tposition.push( parseFloat( line[ offset.y ] ) );\n\t\t\t\t\tposition.push( parseFloat( line[ offset.z ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\tconst rgb_field_index = PCDheader.fields.findIndex( ( field ) => field === 'rgb' );\n\t\t\t\t\tconst rgb_type = PCDheader.type[ rgb_field_index ];\n\n\t\t\t\t\tconst float = parseFloat( line[ offset.rgb ] );\n\t\t\t\t\tlet rgb = float;\n\n\t\t\t\t\tif ( rgb_type === 'F' ) {\n\n\t\t\t\t\t\t// treat float values as int\n\t\t\t\t\t\t// https://github.com/daavoo/pyntcloud/pull/204/commits/7b4205e64d5ed09abe708b2e91b615690c24d518\n\t\t\t\t\t\tconst farr = new Float32Array( 1 );\n\t\t\t\t\t\tfarr[ 0 ] = float;\n\t\t\t\t\t\trgb = new Int32Array( farr.buffer )[ 0 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst r = ( ( rgb >> 16 ) & 0x0000ff ) / 255;\n\t\t\t\t\tconst g = ( ( rgb >> 8 ) & 0x0000ff ) / 255;\n\t\t\t\t\tconst b = ( ( rgb >> 0 ) & 0x0000ff ) / 255;\n\n\t\t\t\t\tc.setRGB( r, g, b, SRGBColorSpace );\n\n\t\t\t\t\tcolor.push( c.r, c.g, c.b );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_x ] ) );\n\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_y ] ) );\n\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_z ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.intensity !== undefined ) {\n\n\t\t\t\t\tintensity.push( parseFloat( line[ offset.intensity ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.label !== undefined ) {\n\n\t\t\t\t\tlabel.push( parseInt( line[ offset.label ] ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// binary-compressed\n\n\t\t// normally data in PCD files are organized as array of structures: XYZRGBXYZRGB\n\t\t// binary compressed PCD files organize their data as structure of arrays: XXYYZZRGBRGB\n\t\t// that requires a totally different parsing approach compared to non-compressed data\n\n\t\tif ( PCDheader.data === 'binary_compressed' ) {\n\n\t\t\tconst sizes = new Uint32Array( data.slice( PCDheader.headerLen, PCDheader.headerLen + 8 ) );\n\t\t\tconst compressedSize = sizes[ 0 ];\n\t\t\tconst decompressedSize = sizes[ 1 ];\n\t\t\tconst decompressed = decompressLZF( new Uint8Array( data, PCDheader.headerLen + 8, compressedSize ), decompressedSize );\n\t\t\tconst dataview = new DataView( decompressed.buffer );\n\n\t\t\tconst offset = PCDheader.offset;\n\n\t\t\tfor ( let i = 0; i < PCDheader.points; i ++ ) {\n\n\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\tconst xIndex = PCDheader.fields.indexOf( 'x' );\n\t\t\t\t\tconst yIndex = PCDheader.fields.indexOf( 'y' );\n\t\t\t\t\tconst zIndex = PCDheader.fields.indexOf( 'z' );\n\t\t\t\t\tposition.push( this._getDataView( dataview, ( PCDheader.points * offset.x ) + PCDheader.size[ xIndex ] * i, PCDheader.type[ xIndex ], PCDheader.size[ xIndex ] ) );\n\t\t\t\t\tposition.push( this._getDataView( dataview, ( PCDheader.points * offset.y ) + PCDheader.size[ yIndex ] * i, PCDheader.type[ yIndex ], PCDheader.size[ yIndex ] ) );\n\t\t\t\t\tposition.push( this._getDataView( dataview, ( PCDheader.points * offset.z ) + PCDheader.size[ zIndex ] * i, PCDheader.type[ zIndex ], PCDheader.size[ zIndex ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\tconst rgbIndex = PCDheader.fields.indexOf( 'rgb' );\n\n\t\t\t\t\tconst r = dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ rgbIndex ] * i + 2 ) / 255.0;\n\t\t\t\t\tconst g = dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ rgbIndex ] * i + 1 ) / 255.0;\n\t\t\t\t\tconst b = dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ rgbIndex ] * i + 0 ) / 255.0;\n\n\t\t\t\t\tc.setRGB( r, g, b, SRGBColorSpace );\n\n\t\t\t\t\tcolor.push( c.r, c.g, c.b );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\tconst xIndex = PCDheader.fields.indexOf( 'normal_x' );\n\t\t\t\t\tconst yIndex = PCDheader.fields.indexOf( 'normal_y' );\n\t\t\t\t\tconst zIndex = PCDheader.fields.indexOf( 'normal_z' );\n\t\t\t\t\tnormal.push( this._getDataView( dataview, ( PCDheader.points * offset.normal_x ) + PCDheader.size[ xIndex ] * i, PCDheader.type[ xIndex ], PCDheader.size[ xIndex ] ) );\n\t\t\t\t\tnormal.push( this._getDataView( dataview, ( PCDheader.points * offset.normal_y ) + PCDheader.size[ yIndex ] * i, PCDheader.type[ yIndex ], PCDheader.size[ yIndex ] ) );\n\t\t\t\t\tnormal.push( this._getDataView( dataview, ( PCDheader.points * offset.normal_z ) + PCDheader.size[ zIndex ] * i, PCDheader.type[ zIndex ], PCDheader.size[ zIndex ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.intensity !== undefined ) {\n\n\t\t\t\t\tconst intensityIndex = PCDheader.fields.indexOf( 'intensity' );\n\t\t\t\t\tintensity.push( this._getDataView( dataview, ( PCDheader.points * offset.intensity ) + PCDheader.size[ intensityIndex ] * i, PCDheader.type[ intensityIndex ], PCDheader.size[ intensityIndex ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.label !== undefined ) {\n\n\t\t\t\t\tconst labelIndex = PCDheader.fields.indexOf( 'label' );\n\t\t\t\t\tlabel.push( dataview.getInt32( ( PCDheader.points * offset.label ) + PCDheader.size[ labelIndex ] * i, this.littleEndian ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// binary\n\n\t\tif ( PCDheader.data === 'binary' ) {\n\n\t\t\tconst dataview = new DataView( data, PCDheader.headerLen );\n\t\t\tconst offset = PCDheader.offset;\n\n\t\t\tfor ( let i = 0, row = 0; i < PCDheader.points; i ++, row += PCDheader.rowSize ) {\n\n\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\tconst xIndex = PCDheader.fields.indexOf( 'x' );\n\t\t\t\t\tconst yIndex = PCDheader.fields.indexOf( 'y' );\n\t\t\t\t\tconst zIndex = PCDheader.fields.indexOf( 'z' );\n\t\t\t\t\tposition.push( this._getDataView( dataview, row + offset.x, PCDheader.type[ xIndex ], PCDheader.size[ xIndex ] ) );\n\t\t\t\t\tposition.push( this._getDataView( dataview, row + offset.y, PCDheader.type[ yIndex ], PCDheader.size[ yIndex ] ) );\n\t\t\t\t\tposition.push( this._getDataView( dataview, row + offset.z, PCDheader.type[ zIndex ], PCDheader.size[ zIndex ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\tconst r = dataview.getUint8( row + offset.rgb + 2 ) / 255.0;\n\t\t\t\t\tconst g = dataview.getUint8( row + offset.rgb + 1 ) / 255.0;\n\t\t\t\t\tconst b = dataview.getUint8( row + offset.rgb + 0 ) / 255.0;\n\n\t\t\t\t\tc.setRGB( r, g, b, SRGBColorSpace );\n\n\t\t\t\t\tcolor.push( c.r, c.g, c.b );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\tconst xIndex = PCDheader.fields.indexOf( 'normal_x' );\n\t\t\t\t\tconst yIndex = PCDheader.fields.indexOf( 'normal_y' );\n\t\t\t\t\tconst zIndex = PCDheader.fields.indexOf( 'normal_z' );\n\t\t\t\t\tnormal.push( this._getDataView( dataview, row + offset.normal_x, PCDheader.type[ xIndex ], PCDheader.size[ xIndex ] ) );\n\t\t\t\t\tnormal.push( this._getDataView( dataview, row + offset.normal_y, PCDheader.type[ yIndex ], PCDheader.size[ yIndex ] ) );\n\t\t\t\t\tnormal.push( this._getDataView( dataview, row + offset.normal_z, PCDheader.type[ zIndex ], PCDheader.size[ zIndex ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.intensity !== undefined ) {\n\n\t\t\t\t\tconst intensityIndex = PCDheader.fields.indexOf( 'intensity' );\n\t\t\t\t\tintensity.push( this._getDataView( dataview, row + offset.intensity, PCDheader.type[ intensityIndex ], PCDheader.size[ intensityIndex ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.label !== undefined ) {\n\n\t\t\t\t\tlabel.push( dataview.getInt32( row + offset.label, this.littleEndian ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tif ( position.length > 0 ) geometry.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\t\tif ( normal.length > 0 ) geometry.setAttribute( 'normal', new Float32BufferAttribute( normal, 3 ) );\n\t\tif ( color.length > 0 ) geometry.setAttribute( 'color', new Float32BufferAttribute( color, 3 ) );\n\t\tif ( intensity.length > 0 ) geometry.setAttribute( 'intensity', new Float32BufferAttribute( intensity, 1 ) );\n\t\tif ( label.length > 0 ) geometry.setAttribute( 'label', new Int32BufferAttribute( label, 1 ) );\n\n\t\tgeometry.computeBoundingSphere();\n\n\t\t// build material\n\n\t\tconst material = new PointsMaterial( { size: 0.005 } );\n\n\t\tif ( color.length > 0 ) {\n\n\t\t\tmaterial.vertexColors = true;\n\n\t\t}\n\n\t\t// build point cloud\n\n\t\treturn new Points( geometry, material );\n\n\t}\n\n}\n\nexport { PCDLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}