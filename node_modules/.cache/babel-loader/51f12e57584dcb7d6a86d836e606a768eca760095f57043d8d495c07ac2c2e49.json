{"ast":null,"code":"import { DataTextureLoader, DataUtils, FloatType, HalfFloatType, NoColorSpace, LinearFilter, LinearSRGBColorSpace, RedFormat, RGBAFormat } from 'three';\nimport * as fflate from '../libs/fflate.module.js';\n\n// Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n// implementation, so I have preserved their copyright notices.\n\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n\n// // End of OpenEXR license -------------------------------------------------\n\n/**\n * A loader for the OpenEXR texture format.\n *\n * `EXRLoader` currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\n *\n * ```js\n * const loader = new EXRLoader();\n * const texture = await loader.loadAsync( 'textures/memorial.exr' );\n * ```\n *\n * @augments DataTextureLoader\n * @three_import import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';\n */\nclass EXRLoader extends DataTextureLoader {\n  /**\n   * Constructs a new EXR loader.\n   *\n   * @param {LoadingManager} [manager] - The loading manager.\n   */\n  constructor(manager) {\n    super(manager);\n\n    /**\n     * The texture type.\n     *\n     * @type {(HalfFloatType|FloatType)}\n     * @default HalfFloatType\n     */\n    this.type = HalfFloatType;\n  }\n\n  /**\n   * Parses the given EXR texture data.\n   *\n   * @param {ArrayBuffer} buffer - The raw texture data.\n   * @return {DataTextureLoader~TexData} An object representing the parsed texture data.\n   */\n  parse(buffer) {\n    const USHORT_RANGE = 1 << 16;\n    const BITMAP_SIZE = USHORT_RANGE >> 3;\n    const HUF_ENCBITS = 16; // literal (value) bit length\n    const HUF_DECBITS = 14; // decoding bit size (>= 8)\n\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1; // encoding table size\n    const HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size\n    const HUF_DECMASK = HUF_DECSIZE - 1;\n    const NBITS = 16;\n    const A_OFFSET = 1 << NBITS - 1;\n    const MOD_MASK = (1 << NBITS) - 1;\n    const SHORT_ZEROCODE_RUN = 59;\n    const LONG_ZEROCODE_RUN = 63;\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n    const ULONG_SIZE = 8;\n    const FLOAT32_SIZE = 4;\n    const INT32_SIZE = 4;\n    const INT16_SIZE = 2;\n    const INT8_SIZE = 1;\n    const STATIC_HUFFMAN = 0;\n    const DEFLATE = 1;\n    const UNKNOWN = 0;\n    const LOSSY_DCT = 1;\n    const RLE = 2;\n    const logBase = Math.pow(2.7182818, 2.2);\n    function reverseLutFromBitmap(bitmap, lut) {\n      let k = 0;\n      for (let i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n          lut[k++] = i;\n        }\n      }\n      const n = k - 1;\n      while (k < USHORT_RANGE) lut[k++] = 0;\n      return n;\n    }\n    function hufClearDecTable(hdec) {\n      for (let i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {};\n        hdec[i].len = 0;\n        hdec[i].lit = 0;\n        hdec[i].p = null;\n      }\n    }\n    const getBitsReturn = {\n      l: 0,\n      c: 0,\n      lc: 0\n    };\n    function getBits(nBits, c, lc, uInt8Array, inOffset) {\n      while (lc < nBits) {\n        c = c << 8 | parseUint8Array(uInt8Array, inOffset);\n        lc += 8;\n      }\n      lc -= nBits;\n      getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n      getBitsReturn.c = c;\n      getBitsReturn.lc = lc;\n    }\n    const hufTableBuffer = new Array(59);\n    function hufCanonicalCodeTable(hcode) {\n      for (let i = 0; i <= 58; ++i) hufTableBuffer[i] = 0;\n      for (let i = 0; i < HUF_ENCSIZE; ++i) hufTableBuffer[hcode[i]] += 1;\n      let c = 0;\n      for (let i = 58; i > 0; --i) {\n        const nc = c + hufTableBuffer[i] >> 1;\n        hufTableBuffer[i] = c;\n        c = nc;\n      }\n      for (let i = 0; i < HUF_ENCSIZE; ++i) {\n        const l = hcode[i];\n        if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n      }\n    }\n    function hufUnpackEncTable(uInt8Array, inOffset, ni, im, iM, hcode) {\n      const p = inOffset;\n      let c = 0;\n      let lc = 0;\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni) return false;\n        getBits(6, c, lc, uInt8Array, p);\n        const l = getBitsReturn.l;\n        c = getBitsReturn.c;\n        lc = getBitsReturn.lc;\n        hcode[im] = l;\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw new Error('Something wrong with hufUnpackEncTable');\n          }\n          getBits(8, c, lc, uInt8Array, p);\n          let zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n          c = getBitsReturn.c;\n          lc = getBitsReturn.lc;\n          if (im + zerun > iM + 1) {\n            throw new Error('Something wrong with hufUnpackEncTable');\n          }\n          while (zerun--) hcode[im++] = 0;\n          im--;\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          let zerun = l - SHORT_ZEROCODE_RUN + 2;\n          if (im + zerun > iM + 1) {\n            throw new Error('Something wrong with hufUnpackEncTable');\n          }\n          while (zerun--) hcode[im++] = 0;\n          im--;\n        }\n      }\n      hufCanonicalCodeTable(hcode);\n    }\n    function hufLength(code) {\n      return code & 63;\n    }\n    function hufCode(code) {\n      return code >> 6;\n    }\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        const c = hufCode(hcode[im]);\n        const l = hufLength(hcode[im]);\n        if (c >> l) {\n          throw new Error('Invalid table entry');\n        }\n        if (l > HUF_DECBITS) {\n          const pl = hdecod[c >> l - HUF_DECBITS];\n          if (pl.len) {\n            throw new Error('Invalid table entry');\n          }\n          pl.lit++;\n          if (pl.p) {\n            const p = pl.p;\n            pl.p = new Array(pl.lit);\n            for (let i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i];\n            }\n          } else {\n            pl.p = new Array(1);\n          }\n          pl.p[pl.lit - 1] = im;\n        } else if (l) {\n          let plOffset = 0;\n          for (let i = 1 << HUF_DECBITS - l; i > 0; i--) {\n            const pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n            if (pl.len || pl.p) {\n              throw new Error('Invalid table entry');\n            }\n            pl.len = l;\n            pl.lit = im;\n            plOffset++;\n          }\n        }\n      }\n      return true;\n    }\n    const getCharReturn = {\n      c: 0,\n      lc: 0\n    };\n    function getChar(c, lc, uInt8Array, inOffset) {\n      c = c << 8 | parseUint8Array(uInt8Array, inOffset);\n      lc += 8;\n      getCharReturn.c = c;\n      getCharReturn.lc = lc;\n    }\n    const getCodeReturn = {\n      c: 0,\n      lc: 0\n    };\n    function getCode(po, rlc, c, lc, uInt8Array, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array, inOffset);\n          c = getCharReturn.c;\n          lc = getCharReturn.lc;\n        }\n        lc -= 8;\n        let cs = c >> lc;\n        cs = new Uint8Array([cs])[0];\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false;\n        }\n        const s = outBuffer[outBufferOffset.value - 1];\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s;\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po;\n      } else {\n        return false;\n      }\n      getCodeReturn.c = c;\n      getCodeReturn.lc = lc;\n    }\n    function UInt16(value) {\n      return value & 0xFFFF;\n    }\n    function Int16(value) {\n      const ref = UInt16(value);\n      return ref > 0x7FFF ? ref - 0x10000 : ref;\n    }\n    const wdec14Return = {\n      a: 0,\n      b: 0\n    };\n    function wdec14(l, h) {\n      const ls = Int16(l);\n      const hs = Int16(h);\n      const hi = hs;\n      const ai = ls + (hi & 1) + (hi >> 1);\n      const as = ai;\n      const bs = ai - hi;\n      wdec14Return.a = as;\n      wdec14Return.b = bs;\n    }\n    function wdec16(l, h) {\n      const m = UInt16(l);\n      const d = UInt16(h);\n      const bb = m - (d >> 1) & MOD_MASK;\n      const aa = d + bb - A_OFFSET & MOD_MASK;\n      wdec14Return.a = aa;\n      wdec14Return.b = bb;\n    }\n    function wav2Decode(buffer, j, nx, ox, ny, oy, mx) {\n      const w14 = mx < 1 << 14;\n      const n = nx > ny ? ny : nx;\n      let p = 1;\n      let p2;\n      let py;\n      while (p <= n) p <<= 1;\n      p >>= 1;\n      p2 = p;\n      p >>= 1;\n      while (p >= 1) {\n        py = 0;\n        const ey = py + oy * (ny - p2);\n        const oy1 = oy * p;\n        const oy2 = oy * p2;\n        const ox1 = ox * p;\n        const ox2 = ox * p2;\n        let i00, i01, i10, i11;\n        for (; py <= ey; py += oy2) {\n          let px = py;\n          const ex = py + ox * (nx - p2);\n          for (; px <= ex; px += ox2) {\n            const p01 = px + ox1;\n            const p10 = px + oy1;\n            const p11 = p10 + ox1;\n            if (w14) {\n              wdec14(buffer[px + j], buffer[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec14(buffer[p01 + j], buffer[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec14(i00, i01);\n              buffer[px + j] = wdec14Return.a;\n              buffer[p01 + j] = wdec14Return.b;\n              wdec14(i10, i11);\n              buffer[p10 + j] = wdec14Return.a;\n              buffer[p11 + j] = wdec14Return.b;\n            } else {\n              wdec16(buffer[px + j], buffer[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec16(buffer[p01 + j], buffer[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec16(i00, i01);\n              buffer[px + j] = wdec14Return.a;\n              buffer[p01 + j] = wdec14Return.b;\n              wdec16(i10, i11);\n              buffer[p10 + j] = wdec14Return.a;\n              buffer[p11 + j] = wdec14Return.b;\n            }\n          }\n          if (nx & p) {\n            const p10 = px + oy1;\n            if (w14) wdec14(buffer[px + j], buffer[p10 + j]);else wdec16(buffer[px + j], buffer[p10 + j]);\n            i00 = wdec14Return.a;\n            buffer[p10 + j] = wdec14Return.b;\n            buffer[px + j] = i00;\n          }\n        }\n        if (ny & p) {\n          let px = py;\n          const ex = py + ox * (nx - p2);\n          for (; px <= ex; px += ox2) {\n            const p01 = px + ox1;\n            if (w14) wdec14(buffer[px + j], buffer[p01 + j]);else wdec16(buffer[px + j], buffer[p01 + j]);\n            i00 = wdec14Return.a;\n            buffer[p01 + j] = wdec14Return.b;\n            buffer[px + j] = i00;\n          }\n        }\n        p2 = p;\n        p >>= 1;\n      }\n      return py;\n    }\n    function hufDecode(encodingTable, decodingTable, uInt8Array, inOffset, ni, rlc, no, outBuffer, outOffset) {\n      let c = 0;\n      let lc = 0;\n      const outBufferEndOffset = no;\n      const inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array, inOffset);\n        c = getCharReturn.c;\n        lc = getCharReturn.lc;\n        while (lc >= HUF_DECBITS) {\n          const index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n          const pl = decodingTable[index];\n          if (pl.len) {\n            lc -= pl.len;\n            getCode(pl.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset);\n            c = getCodeReturn.c;\n            lc = getCodeReturn.lc;\n          } else {\n            if (!pl.p) {\n              throw new Error('hufDecode issues');\n            }\n            let j;\n            for (j = 0; j < pl.lit; j++) {\n              const l = hufLength(encodingTable[pl.p[j]]);\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n              }\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                  lc -= l;\n                  getCode(pl.p[j], rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                  c = getCodeReturn.c;\n                  lc = getCodeReturn.lc;\n                  break;\n                }\n              }\n            }\n            if (j == pl.lit) {\n              throw new Error('hufDecode issues');\n            }\n          }\n        }\n      }\n      const i = 8 - ni & 7;\n      c >>= i;\n      lc -= i;\n      while (lc > 0) {\n        const pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n        if (pl.len) {\n          lc -= pl.len;\n          getCode(pl.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset);\n          c = getCodeReturn.c;\n          lc = getCodeReturn.lc;\n        } else {\n          throw new Error('hufDecode issues');\n        }\n      }\n      return true;\n    }\n    function hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      const outOffset = {\n        value: 0\n      };\n      const initialInOffset = inOffset.value;\n      const im = parseUint32(inDataView, inOffset);\n      const iM = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      const nBits = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw new Error('Something wrong with HUF_ENCSIZE');\n      }\n      const freq = new Array(HUF_ENCSIZE);\n      const hdec = new Array(HUF_DECSIZE);\n      hufClearDecTable(hdec);\n      const ni = nCompressed - (inOffset.value - initialInOffset);\n      hufUnpackEncTable(uInt8Array, inOffset, ni, im, iM, freq);\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw new Error('Something wrong with hufUncompress');\n      }\n      hufBuildDecTable(freq, im, iM, hdec);\n      hufDecode(freq, hdec, uInt8Array, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n    }\n    function applyLut(lut, data, nData) {\n      for (let i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]];\n      }\n    }\n    function predictor(source) {\n      for (let t = 1; t < source.length; t++) {\n        const d = source[t - 1] + source[t] - 128;\n        source[t] = d;\n      }\n    }\n    function interleaveScalar(source, out) {\n      let t1 = 0;\n      let t2 = Math.floor((source.length + 1) / 2);\n      let s = 0;\n      const stop = source.length - 1;\n      while (true) {\n        if (s > stop) break;\n        out[s++] = source[t1++];\n        if (s > stop) break;\n        out[s++] = source[t2++];\n      }\n    }\n    function decodeRunLength(source) {\n      let size = source.byteLength;\n      const out = new Array();\n      let p = 0;\n      const reader = new DataView(source);\n      while (size > 0) {\n        const l = reader.getInt8(p++);\n        if (l < 0) {\n          const count = -l;\n          size -= count + 1;\n          for (let i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++));\n          }\n        } else {\n          const count = l;\n          size -= 2;\n          const value = reader.getUint8(p++);\n          for (let i = 0; i < count + 1; i++) {\n            out.push(value);\n          }\n        }\n      }\n      return out;\n    }\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      let dataView = new DataView(outBuffer.buffer);\n      const width = channelData[cscSet.idx[0]].width;\n      const height = channelData[cscSet.idx[0]].height;\n      const numComp = 3;\n      const numFullBlocksX = Math.floor(width / 8.0);\n      const numBlocksX = Math.ceil(width / 8.0);\n      const numBlocksY = Math.ceil(height / 8.0);\n      const leftoverX = width - (numBlocksX - 1) * 8;\n      const leftoverY = height - (numBlocksY - 1) * 8;\n      const currAcComp = {\n        value: 0\n      };\n      const currDcComp = new Array(numComp);\n      const dctData = new Array(numComp);\n      const halfZigBlock = new Array(numComp);\n      const rowBlock = new Array(numComp);\n      const rowOffsets = new Array(numComp);\n      for (let comp = 0; comp < numComp; ++comp) {\n        rowOffsets[comp] = rowPtrs[cscSet.idx[comp]];\n        currDcComp[comp] = comp < 1 ? 0 : currDcComp[comp - 1] + numBlocksX * numBlocksY;\n        dctData[comp] = new Float32Array(64);\n        halfZigBlock[comp] = new Uint16Array(64);\n        rowBlock[comp] = new Uint16Array(numBlocksX * 64);\n      }\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        let maxY = 8;\n        if (blocky == numBlocksY - 1) maxY = leftoverY;\n        let maxX = 8;\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1) maxX = leftoverX;\n          for (let comp = 0; comp < numComp; ++comp) {\n            halfZigBlock[comp].fill(0);\n\n            // set block DC component\n            halfZigBlock[comp][0] = dcBuffer[currDcComp[comp]++];\n            // set block AC components\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp]);\n\n            // UnZigZag block to float\n            unZigZag(halfZigBlock[comp], dctData[comp]);\n            // decode float dct\n            dctInverse(dctData[comp]);\n          }\n          if (numComp == 3) {\n            csc709Inverse(dctData);\n          }\n          for (let comp = 0; comp < numComp; ++comp) {\n            convertToHalf(dctData[comp], rowBlock[comp], blockx * 64);\n          }\n        } // blockx\n\n        let offset = 0;\n        for (let comp = 0; comp < numComp; ++comp) {\n          const type = channelData[cscSet.idx[comp]].type;\n          for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n            offset = rowOffsets[comp][y];\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y & 0x7) * 8;\n              dataView.setUint16(offset + 0 * INT16_SIZE * type, rowBlock[comp][src + 0], true);\n              dataView.setUint16(offset + 1 * INT16_SIZE * type, rowBlock[comp][src + 1], true);\n              dataView.setUint16(offset + 2 * INT16_SIZE * type, rowBlock[comp][src + 2], true);\n              dataView.setUint16(offset + 3 * INT16_SIZE * type, rowBlock[comp][src + 3], true);\n              dataView.setUint16(offset + 4 * INT16_SIZE * type, rowBlock[comp][src + 4], true);\n              dataView.setUint16(offset + 5 * INT16_SIZE * type, rowBlock[comp][src + 5], true);\n              dataView.setUint16(offset + 6 * INT16_SIZE * type, rowBlock[comp][src + 6], true);\n              dataView.setUint16(offset + 7 * INT16_SIZE * type, rowBlock[comp][src + 7], true);\n              offset += 8 * INT16_SIZE * type;\n            }\n          }\n\n          // handle partial X blocks\n          if (numFullBlocksX != numBlocksX) {\n            for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n              const offset = rowOffsets[comp][y] + 8 * numFullBlocksX * INT16_SIZE * type;\n              const src = numFullBlocksX * 64 + (y & 0x7) * 8;\n              for (let x = 0; x < maxX; ++x) {\n                dataView.setUint16(offset + x * INT16_SIZE * type, rowBlock[comp][src + x], true);\n              }\n            }\n          }\n        } // comp\n      } // blocky\n\n      const halfRow = new Uint16Array(width);\n      dataView = new DataView(outBuffer.buffer);\n\n      // convert channels back to float, if needed\n      for (let comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true;\n        const type = channelData[cscSet.idx[comp]].type;\n        if (channelData[comp].type != 2) continue;\n        for (let y = 0; y < height; ++y) {\n          const offset = rowOffsets[comp][y];\n          for (let x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset + x * INT16_SIZE * type, true);\n          }\n          for (let x = 0; x < width; ++x) {\n            dataView.setFloat32(offset + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n          }\n        }\n      }\n    }\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      let acValue;\n      let dctComp = 1;\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value];\n        if (acValue == 0xff00) {\n          dctComp = 64;\n        } else if (acValue >> 8 == 0xff) {\n          dctComp += acValue & 0xff;\n        } else {\n          halfZigBlock[dctComp] = acValue;\n          dctComp++;\n        }\n        currAcComp.value++;\n      }\n    }\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0]);\n      dst[1] = decodeFloat16(src[1]);\n      dst[2] = decodeFloat16(src[5]);\n      dst[3] = decodeFloat16(src[6]);\n      dst[4] = decodeFloat16(src[14]);\n      dst[5] = decodeFloat16(src[15]);\n      dst[6] = decodeFloat16(src[27]);\n      dst[7] = decodeFloat16(src[28]);\n      dst[8] = decodeFloat16(src[2]);\n      dst[9] = decodeFloat16(src[4]);\n      dst[10] = decodeFloat16(src[7]);\n      dst[11] = decodeFloat16(src[13]);\n      dst[12] = decodeFloat16(src[16]);\n      dst[13] = decodeFloat16(src[26]);\n      dst[14] = decodeFloat16(src[29]);\n      dst[15] = decodeFloat16(src[42]);\n      dst[16] = decodeFloat16(src[3]);\n      dst[17] = decodeFloat16(src[8]);\n      dst[18] = decodeFloat16(src[12]);\n      dst[19] = decodeFloat16(src[17]);\n      dst[20] = decodeFloat16(src[25]);\n      dst[21] = decodeFloat16(src[30]);\n      dst[22] = decodeFloat16(src[41]);\n      dst[23] = decodeFloat16(src[43]);\n      dst[24] = decodeFloat16(src[9]);\n      dst[25] = decodeFloat16(src[11]);\n      dst[26] = decodeFloat16(src[18]);\n      dst[27] = decodeFloat16(src[24]);\n      dst[28] = decodeFloat16(src[31]);\n      dst[29] = decodeFloat16(src[40]);\n      dst[30] = decodeFloat16(src[44]);\n      dst[31] = decodeFloat16(src[53]);\n      dst[32] = decodeFloat16(src[10]);\n      dst[33] = decodeFloat16(src[19]);\n      dst[34] = decodeFloat16(src[23]);\n      dst[35] = decodeFloat16(src[32]);\n      dst[36] = decodeFloat16(src[39]);\n      dst[37] = decodeFloat16(src[45]);\n      dst[38] = decodeFloat16(src[52]);\n      dst[39] = decodeFloat16(src[54]);\n      dst[40] = decodeFloat16(src[20]);\n      dst[41] = decodeFloat16(src[22]);\n      dst[42] = decodeFloat16(src[33]);\n      dst[43] = decodeFloat16(src[38]);\n      dst[44] = decodeFloat16(src[46]);\n      dst[45] = decodeFloat16(src[51]);\n      dst[46] = decodeFloat16(src[55]);\n      dst[47] = decodeFloat16(src[60]);\n      dst[48] = decodeFloat16(src[21]);\n      dst[49] = decodeFloat16(src[34]);\n      dst[50] = decodeFloat16(src[37]);\n      dst[51] = decodeFloat16(src[47]);\n      dst[52] = decodeFloat16(src[50]);\n      dst[53] = decodeFloat16(src[56]);\n      dst[54] = decodeFloat16(src[59]);\n      dst[55] = decodeFloat16(src[61]);\n      dst[56] = decodeFloat16(src[35]);\n      dst[57] = decodeFloat16(src[36]);\n      dst[58] = decodeFloat16(src[48]);\n      dst[59] = decodeFloat16(src[49]);\n      dst[60] = decodeFloat16(src[57]);\n      dst[61] = decodeFloat16(src[58]);\n      dst[62] = decodeFloat16(src[62]);\n      dst[63] = decodeFloat16(src[63]);\n    }\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4.0);\n      const b = 0.5 * Math.cos(3.14159 / 16.0);\n      const c = 0.5 * Math.cos(3.14159 / 8.0);\n      const d = 0.5 * Math.cos(3.0 * 3.14159 / 16.0);\n      const e = 0.5 * Math.cos(5.0 * 3.14159 / 16.0);\n      const f = 0.5 * Math.cos(3.0 * 3.14159 / 8.0);\n      const g = 0.5 * Math.cos(7.0 * 3.14159 / 16.0);\n      const alpha = new Array(4);\n      const beta = new Array(4);\n      const theta = new Array(4);\n      const gamma = new Array(4);\n      for (let row = 0; row < 8; ++row) {\n        const rowPtr = row * 8;\n        alpha[0] = c * data[rowPtr + 2];\n        alpha[1] = f * data[rowPtr + 2];\n        alpha[2] = c * data[rowPtr + 6];\n        alpha[3] = f * data[rowPtr + 6];\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[rowPtr + 0] = gamma[0] + beta[0];\n        data[rowPtr + 1] = gamma[1] + beta[1];\n        data[rowPtr + 2] = gamma[2] + beta[2];\n        data[rowPtr + 3] = gamma[3] + beta[3];\n        data[rowPtr + 4] = gamma[3] - beta[3];\n        data[rowPtr + 5] = gamma[2] - beta[2];\n        data[rowPtr + 6] = gamma[1] - beta[1];\n        data[rowPtr + 7] = gamma[0] - beta[0];\n      }\n      for (let column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column];\n        alpha[1] = f * data[16 + column];\n        alpha[2] = c * data[48 + column];\n        alpha[3] = f * data[48 + column];\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n        theta[0] = a * (data[column] + data[32 + column]);\n        theta[3] = a * (data[column] - data[32 + column]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[0 + column] = gamma[0] + beta[0];\n        data[8 + column] = gamma[1] + beta[1];\n        data[16 + column] = gamma[2] + beta[2];\n        data[24 + column] = gamma[3] + beta[3];\n        data[32 + column] = gamma[3] - beta[3];\n        data[40 + column] = gamma[2] - beta[2];\n        data[48 + column] = gamma[1] - beta[1];\n        data[56 + column] = gamma[0] - beta[0];\n      }\n    }\n    function csc709Inverse(data) {\n      for (let i = 0; i < 64; ++i) {\n        const y = data[0][i];\n        const cb = data[1][i];\n        const cr = data[2][i];\n        data[0][i] = y + 1.5747 * cr;\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n        data[2][i] = y + 1.8556 * cb;\n      }\n    }\n    function convertToHalf(src, dst, idx) {\n      for (let i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));\n      }\n    }\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1.0);\n      }\n    }\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size);\n    }\n    function uncompressRLE(info) {\n      const compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n      const rawBuffer = new Uint8Array(decodeRunLength(compressed));\n      const tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer); // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer); // interleave pixels\n\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressZIP(info) {\n      const compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      const rawBuffer = fflate.unzlibSync(compressed);\n      const tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer); // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer); // interleave pixels\n\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressPIZ(info) {\n      const inDataView = info.viewer;\n      const inOffset = {\n        value: info.offset.value\n      };\n      const outBuffer = new Uint16Array(info.columns * info.lines * (info.inputChannels.length * info.type));\n      const bitmap = new Uint8Array(BITMAP_SIZE);\n\n      // Setup channel info\n      let outBufferEnd = 0;\n      const pizChannelData = new Array(info.inputChannels.length);\n      for (let i = 0, il = info.inputChannels.length; i < il; i++) {\n        pizChannelData[i] = {};\n        pizChannelData[i]['start'] = outBufferEnd;\n        pizChannelData[i]['end'] = pizChannelData[i]['start'];\n        pizChannelData[i]['nx'] = info.columns;\n        pizChannelData[i]['ny'] = info.lines;\n        pizChannelData[i]['size'] = info.type;\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n      }\n\n      // Read range compression data\n\n      const minNonZero = parseUint16(inDataView, inOffset);\n      const maxNonZero = parseUint16(inDataView, inOffset);\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw new Error('Something is wrong with PIZ_COMPRESSION BITMAP_SIZE');\n      }\n      if (minNonZero <= maxNonZero) {\n        for (let i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n        }\n      }\n\n      // Reverse LUT\n      const lut = new Uint16Array(USHORT_RANGE);\n      const maxValue = reverseLutFromBitmap(bitmap, lut);\n      const length = parseUint32(inDataView, inOffset);\n\n      // Huffman decoding\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\n\n      // Wavelet decoding\n      for (let i = 0; i < info.inputChannels.length; ++i) {\n        const cd = pizChannelData[i];\n        for (let j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n        }\n      }\n\n      // Expand the pixel data to their original range\n      applyLut(lut, outBuffer, outBufferEnd);\n\n      // Rearrange the pixel data into the format expected by the caller.\n      let tmpOffset = 0;\n      const tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.inputChannels.length; c++) {\n          const cd = pizChannelData[c];\n          const n = cd.nx * cd.size;\n          const cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n          tmpBuffer.set(cp, tmpOffset);\n          tmpOffset += n * INT16_SIZE;\n          cd.end += n;\n        }\n      }\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressPXR(info) {\n      const compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      const rawBuffer = fflate.unzlibSync(compressed);\n      const byteSize = info.inputChannels.length * info.lines * info.columns * info.totalBytes;\n      const tmpBuffer = new ArrayBuffer(byteSize);\n      const viewer = new DataView(tmpBuffer);\n      let tmpBufferEnd = 0;\n      let writePtr = 0;\n      const ptr = new Array(4);\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.inputChannels.length; c++) {\n          let pixel = 0;\n          const type = info.inputChannels[c].pixelType;\n          switch (type) {\n            case 1:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.columns;\n              tmpBufferEnd = ptr[1] + info.columns;\n              for (let j = 0; j < info.columns; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                pixel += diff;\n                viewer.setUint16(writePtr, pixel, true);\n                writePtr += 2;\n              }\n              break;\n            case 2:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.columns;\n              ptr[2] = ptr[1] + info.columns;\n              tmpBufferEnd = ptr[2] + info.columns;\n              for (let j = 0; j < info.columns; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                pixel += diff;\n                viewer.setUint32(writePtr, pixel, true);\n                writePtr += 4;\n              }\n              break;\n          }\n        }\n      }\n      return viewer;\n    }\n    function uncompressDWA(info) {\n      const inDataView = info.viewer;\n      const inOffset = {\n        value: info.offset.value\n      };\n      const outBuffer = new Uint8Array(info.columns * info.lines * (info.inputChannels.length * info.type * INT16_SIZE));\n\n      // Read compression header information\n      const dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset)\n      };\n      if (dwaHeader.version < 2) throw new Error('EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported');\n\n      // Read channel ruleset information\n      const channelRules = new Array();\n      let ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n      while (ruleSize > 0) {\n        const name = parseNullTerminatedString(inDataView.buffer, inOffset);\n        const value = parseUint8(inDataView, inOffset);\n        const compression = value >> 2 & 3;\n        const csc = (value >> 4) - 1;\n        const index = new Int8Array([csc])[0];\n        const type = parseUint8(inDataView, inOffset);\n        channelRules.push({\n          name: name,\n          index: index,\n          type: type,\n          compression: compression\n        });\n        ruleSize -= name.length + 3;\n      }\n\n      // Classify channels\n      const channels = EXRHeader.channels;\n      const channelData = new Array(info.inputChannels.length);\n      for (let i = 0; i < info.inputChannels.length; ++i) {\n        const cd = channelData[i] = {};\n        const channel = channels[i];\n        cd.name = channel.name;\n        cd.compression = UNKNOWN;\n        cd.decoded = false;\n        cd.type = channel.pixelType;\n        cd.pLinear = channel.pLinear;\n        cd.width = info.columns;\n        cd.height = info.lines;\n      }\n      const cscSet = {\n        idx: new Array(3)\n      };\n      for (let offset = 0; offset < info.inputChannels.length; ++offset) {\n        const cd = channelData[offset];\n        for (let i = 0; i < channelRules.length; ++i) {\n          const rule = channelRules[i];\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression;\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset;\n            }\n            cd.offset = offset;\n          }\n        }\n      }\n      let acBuffer, dcBuffer, rleBuffer;\n\n      // Read DCT - AC component data\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n            hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n            break;\n          case DEFLATE:\n            const compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n            const data = fflate.unzlibSync(compressed);\n            acBuffer = new Uint16Array(data.buffer);\n            inOffset.value += dwaHeader.totalAcUncompressedCount;\n            break;\n        }\n      }\n\n      // Read DCT - DC component data\n      if (dwaHeader.dcCompressedSize > 0) {\n        const zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize\n        };\n        dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n        inOffset.value += dwaHeader.dcCompressedSize;\n      }\n\n      // Read RLE compressed data\n      if (dwaHeader.rleRawSize > 0) {\n        const compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n        const data = fflate.unzlibSync(compressed);\n        rleBuffer = decodeRunLength(data.buffer);\n        inOffset.value += dwaHeader.rleCompressedSize;\n      }\n\n      // Prepare outbuffer data offset\n      let outBufferEnd = 0;\n      const rowOffsets = new Array(channelData.length);\n      for (let i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array();\n      }\n      for (let y = 0; y < info.lines; ++y) {\n        for (let chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd);\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n        }\n      }\n\n      // Lossy DCT decode RGB channels\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);\n\n      // Decode other channels\n      for (let i = 0; i < channelData.length; ++i) {\n        const cd = channelData[i];\n        if (cd.decoded) continue;\n        switch (cd.compression) {\n          case RLE:\n            let row = 0;\n            let rleOffset = 0;\n            for (let y = 0; y < info.lines; ++y) {\n              let rowOffsetBytes = rowOffsets[i][row];\n              for (let x = 0; x < cd.width; ++x) {\n                for (let byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                }\n                rleOffset++;\n              }\n              row++;\n            }\n            break;\n          case LOSSY_DCT: // skip\n\n          default:\n            throw new Error('EXRLoader.parse: unsupported channel compression');\n        }\n      }\n      return new DataView(outBuffer.buffer);\n    }\n    function parseNullTerminatedString(buffer, offset) {\n      const uintBuffer = new Uint8Array(buffer);\n      let endOffset = 0;\n      while (uintBuffer[offset.value + endOffset] != 0) {\n        endOffset += 1;\n      }\n      const stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset));\n      offset.value = offset.value + endOffset + 1;\n      return stringValue;\n    }\n    function parseFixedLengthString(buffer, offset, size) {\n      const stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size));\n      offset.value = offset.value + size;\n      return stringValue;\n    }\n    function parseRational(dataView, offset) {\n      const x = parseInt32(dataView, offset);\n      const y = parseUint32(dataView, offset);\n      return [x, y];\n    }\n    function parseTimecode(dataView, offset) {\n      const x = parseUint32(dataView, offset);\n      const y = parseUint32(dataView, offset);\n      return [x, y];\n    }\n    function parseInt32(dataView, offset) {\n      const Int32 = dataView.getInt32(offset.value, true);\n      offset.value = offset.value + INT32_SIZE;\n      return Int32;\n    }\n    function parseUint32(dataView, offset) {\n      const Uint32 = dataView.getUint32(offset.value, true);\n      offset.value = offset.value + INT32_SIZE;\n      return Uint32;\n    }\n    function parseUint8Array(uInt8Array, offset) {\n      const Uint8 = uInt8Array[offset.value];\n      offset.value = offset.value + INT8_SIZE;\n      return Uint8;\n    }\n    function parseUint8(dataView, offset) {\n      const Uint8 = dataView.getUint8(offset.value);\n      offset.value = offset.value + INT8_SIZE;\n      return Uint8;\n    }\n    const parseInt64 = function (dataView, offset) {\n      let int;\n      if ('getBigInt64' in DataView.prototype) {\n        int = Number(dataView.getBigInt64(offset.value, true));\n      } else {\n        int = dataView.getUint32(offset.value + 4, true) + Number(dataView.getUint32(offset.value, true) << 32);\n      }\n      offset.value += ULONG_SIZE;\n      return int;\n    };\n    function parseFloat32(dataView, offset) {\n      const float = dataView.getFloat32(offset.value, true);\n      offset.value += FLOAT32_SIZE;\n      return float;\n    }\n    function decodeFloat32(dataView, offset) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset));\n    }\n\n    // https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n    function decodeFloat16(binary) {\n      const exponent = (binary & 0x7C00) >> 10,\n        fraction = binary & 0x03FF;\n      return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 0x1F ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 0x400) : 6.103515625e-5 * (fraction / 0x400));\n    }\n    function parseUint16(dataView, offset) {\n      const Uint16 = dataView.getUint16(offset.value, true);\n      offset.value += INT16_SIZE;\n      return Uint16;\n    }\n    function parseFloat16(buffer, offset) {\n      return decodeFloat16(parseUint16(buffer, offset));\n    }\n    function parseChlist(dataView, buffer, offset, size) {\n      const startOffset = offset.value;\n      const channels = [];\n      while (offset.value < startOffset + size - 1) {\n        const name = parseNullTerminatedString(buffer, offset);\n        const pixelType = parseInt32(dataView, offset);\n        const pLinear = parseUint8(dataView, offset);\n        offset.value += 3; // reserved, three chars\n        const xSampling = parseInt32(dataView, offset);\n        const ySampling = parseInt32(dataView, offset);\n        channels.push({\n          name: name,\n          pixelType: pixelType,\n          pLinear: pLinear,\n          xSampling: xSampling,\n          ySampling: ySampling\n        });\n      }\n      offset.value += 1;\n      return channels;\n    }\n    function parseChromaticities(dataView, offset) {\n      const redX = parseFloat32(dataView, offset);\n      const redY = parseFloat32(dataView, offset);\n      const greenX = parseFloat32(dataView, offset);\n      const greenY = parseFloat32(dataView, offset);\n      const blueX = parseFloat32(dataView, offset);\n      const blueY = parseFloat32(dataView, offset);\n      const whiteX = parseFloat32(dataView, offset);\n      const whiteY = parseFloat32(dataView, offset);\n      return {\n        redX: redX,\n        redY: redY,\n        greenX: greenX,\n        greenY: greenY,\n        blueX: blueX,\n        blueY: blueY,\n        whiteX: whiteX,\n        whiteY: whiteY\n      };\n    }\n    function parseCompression(dataView, offset) {\n      const compressionCodes = ['NO_COMPRESSION', 'RLE_COMPRESSION', 'ZIPS_COMPRESSION', 'ZIP_COMPRESSION', 'PIZ_COMPRESSION', 'PXR24_COMPRESSION', 'B44_COMPRESSION', 'B44A_COMPRESSION', 'DWAA_COMPRESSION', 'DWAB_COMPRESSION'];\n      const compression = parseUint8(dataView, offset);\n      return compressionCodes[compression];\n    }\n    function parseBox2i(dataView, offset) {\n      const xMin = parseInt32(dataView, offset);\n      const yMin = parseInt32(dataView, offset);\n      const xMax = parseInt32(dataView, offset);\n      const yMax = parseInt32(dataView, offset);\n      return {\n        xMin: xMin,\n        yMin: yMin,\n        xMax: xMax,\n        yMax: yMax\n      };\n    }\n    function parseLineOrder(dataView, offset) {\n      const lineOrders = ['INCREASING_Y', 'DECREASING_Y', 'RANDOM_Y'];\n      const lineOrder = parseUint8(dataView, offset);\n      return lineOrders[lineOrder];\n    }\n    function parseEnvmap(dataView, offset) {\n      const envmaps = ['ENVMAP_LATLONG', 'ENVMAP_CUBE'];\n      const envmap = parseUint8(dataView, offset);\n      return envmaps[envmap];\n    }\n    function parseTiledesc(dataView, offset) {\n      const levelModes = ['ONE_LEVEL', 'MIPMAP_LEVELS', 'RIPMAP_LEVELS'];\n      const roundingModes = ['ROUND_DOWN', 'ROUND_UP'];\n      const xSize = parseUint32(dataView, offset);\n      const ySize = parseUint32(dataView, offset);\n      const modes = parseUint8(dataView, offset);\n      return {\n        xSize: xSize,\n        ySize: ySize,\n        levelMode: levelModes[modes & 0xf],\n        roundingMode: roundingModes[modes >> 4]\n      };\n    }\n    function parseV2f(dataView, offset) {\n      const x = parseFloat32(dataView, offset);\n      const y = parseFloat32(dataView, offset);\n      return [x, y];\n    }\n    function parseV3f(dataView, offset) {\n      const x = parseFloat32(dataView, offset);\n      const y = parseFloat32(dataView, offset);\n      const z = parseFloat32(dataView, offset);\n      return [x, y, z];\n    }\n    function parseValue(dataView, buffer, offset, type, size) {\n      if (type === 'string' || type === 'stringvector' || type === 'iccProfile') {\n        return parseFixedLengthString(buffer, offset, size);\n      } else if (type === 'chlist') {\n        return parseChlist(dataView, buffer, offset, size);\n      } else if (type === 'chromaticities') {\n        return parseChromaticities(dataView, offset);\n      } else if (type === 'compression') {\n        return parseCompression(dataView, offset);\n      } else if (type === 'box2i') {\n        return parseBox2i(dataView, offset);\n      } else if (type === 'envmap') {\n        return parseEnvmap(dataView, offset);\n      } else if (type === 'tiledesc') {\n        return parseTiledesc(dataView, offset);\n      } else if (type === 'lineOrder') {\n        return parseLineOrder(dataView, offset);\n      } else if (type === 'float') {\n        return parseFloat32(dataView, offset);\n      } else if (type === 'v2f') {\n        return parseV2f(dataView, offset);\n      } else if (type === 'v3f') {\n        return parseV3f(dataView, offset);\n      } else if (type === 'int') {\n        return parseInt32(dataView, offset);\n      } else if (type === 'rational') {\n        return parseRational(dataView, offset);\n      } else if (type === 'timecode') {\n        return parseTimecode(dataView, offset);\n      } else if (type === 'preview') {\n        offset.value += size;\n        return 'skipped';\n      } else {\n        offset.value += size;\n        return undefined;\n      }\n    }\n    function roundLog2(x, mode) {\n      const log2 = Math.log2(x);\n      return mode == 'ROUND_DOWN' ? Math.floor(log2) : Math.ceil(log2);\n    }\n    function calculateTileLevels(tiledesc, w, h) {\n      let num = 0;\n      switch (tiledesc.levelMode) {\n        case 'ONE_LEVEL':\n          num = 1;\n          break;\n        case 'MIPMAP_LEVELS':\n          num = roundLog2(Math.max(w, h), tiledesc.roundingMode) + 1;\n          break;\n        case 'RIPMAP_LEVELS':\n          throw new Error('THREE.EXRLoader: RIPMAP_LEVELS tiles currently unsupported.');\n      }\n      return num;\n    }\n    function calculateTiles(count, dataSize, size, roundingMode) {\n      const tiles = new Array(count);\n      for (let i = 0; i < count; i++) {\n        const b = 1 << i;\n        let s = dataSize / b | 0;\n        if (roundingMode == 'ROUND_UP' && s * b < dataSize) s += 1;\n        const l = Math.max(s, 1);\n        tiles[i] = (l + size - 1) / size | 0;\n      }\n      return tiles;\n    }\n    function parseTiles() {\n      const EXRDecoder = this;\n      const offset = EXRDecoder.offset;\n      const tmpOffset = {\n        value: 0\n      };\n      for (let tile = 0; tile < EXRDecoder.tileCount; tile++) {\n        const tileX = parseInt32(EXRDecoder.viewer, offset);\n        const tileY = parseInt32(EXRDecoder.viewer, offset);\n        offset.value += 8; // skip levels - only parsing top-level\n        EXRDecoder.size = parseUint32(EXRDecoder.viewer, offset);\n        const startX = tileX * EXRDecoder.blockWidth;\n        const startY = tileY * EXRDecoder.blockHeight;\n        EXRDecoder.columns = startX + EXRDecoder.blockWidth > EXRDecoder.width ? EXRDecoder.width - startX : EXRDecoder.blockWidth;\n        EXRDecoder.lines = startY + EXRDecoder.blockHeight > EXRDecoder.height ? EXRDecoder.height - startY : EXRDecoder.blockHeight;\n        const bytesBlockLine = EXRDecoder.columns * EXRDecoder.totalBytes;\n        const isCompressed = EXRDecoder.size < EXRDecoder.lines * bytesBlockLine;\n        const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n        offset.value += EXRDecoder.size;\n        for (let line = 0; line < EXRDecoder.lines; line++) {\n          const lineOffset = line * EXRDecoder.columns * EXRDecoder.totalBytes;\n          for (let channelID = 0; channelID < EXRDecoder.inputChannels.length; channelID++) {\n            const name = EXRHeader.channels[channelID].name;\n            const lOff = EXRDecoder.channelByteOffsets[name] * EXRDecoder.columns;\n            const cOff = EXRDecoder.decodeChannels[name];\n            if (cOff === undefined) continue;\n            tmpOffset.value = lineOffset + lOff;\n            const outLineOffset = (EXRDecoder.height - (1 + startY + line)) * EXRDecoder.outLineWidth;\n            for (let x = 0; x < EXRDecoder.columns; x++) {\n              const outIndex = outLineOffset + (x + startX) * EXRDecoder.outputChannels + cOff;\n              EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n            }\n          }\n        }\n      }\n    }\n    function parseScanline() {\n      const EXRDecoder = this;\n      const offset = EXRDecoder.offset;\n      const tmpOffset = {\n        value: 0\n      };\n      for (let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.blockHeight; scanlineBlockIdx++) {\n        const line = parseInt32(EXRDecoder.viewer, offset) - EXRHeader.dataWindow.yMin; // line_no\n        EXRDecoder.size = parseUint32(EXRDecoder.viewer, offset); // data_len\n        EXRDecoder.lines = line + EXRDecoder.blockHeight > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.blockHeight;\n        const bytesPerLine = EXRDecoder.columns * EXRDecoder.totalBytes;\n        const isCompressed = EXRDecoder.size < EXRDecoder.lines * bytesPerLine;\n        const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n        offset.value += EXRDecoder.size;\n        for (let line_y = 0; line_y < EXRDecoder.blockHeight; line_y++) {\n          const scan_y = scanlineBlockIdx * EXRDecoder.blockHeight;\n          const true_y = line_y + EXRDecoder.scanOrder(scan_y);\n          if (true_y >= EXRDecoder.height) continue;\n          const lineOffset = line_y * bytesPerLine;\n          const outLineOffset = (EXRDecoder.height - 1 - true_y) * EXRDecoder.outLineWidth;\n          for (let channelID = 0; channelID < EXRDecoder.inputChannels.length; channelID++) {\n            const name = EXRHeader.channels[channelID].name;\n            const lOff = EXRDecoder.channelByteOffsets[name] * EXRDecoder.columns;\n            const cOff = EXRDecoder.decodeChannels[name];\n            if (cOff === undefined) continue;\n            tmpOffset.value = lineOffset + lOff;\n            for (let x = 0; x < EXRDecoder.columns; x++) {\n              const outIndex = outLineOffset + x * EXRDecoder.outputChannels + cOff;\n              EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n            }\n          }\n        }\n      }\n    }\n    function parseHeader(dataView, buffer, offset) {\n      const EXRHeader = {};\n      if (dataView.getUint32(0, true) != 20000630) {\n        // magic\n\n        throw new Error('THREE.EXRLoader: Provided file doesn\\'t appear to be in OpenEXR format.');\n      }\n      EXRHeader.version = dataView.getUint8(4);\n      const spec = dataView.getUint8(5); // fullMask\n\n      EXRHeader.spec = {\n        singleTile: !!(spec & 2),\n        longName: !!(spec & 4),\n        deepFormat: !!(spec & 8),\n        multiPart: !!(spec & 16)\n      };\n\n      // start of header\n\n      offset.value = 8; // start at 8 - after pre-amble\n\n      let keepReading = true;\n      while (keepReading) {\n        const attributeName = parseNullTerminatedString(buffer, offset);\n        if (attributeName === '') {\n          keepReading = false;\n        } else {\n          const attributeType = parseNullTerminatedString(buffer, offset);\n          const attributeSize = parseUint32(dataView, offset);\n          const attributeValue = parseValue(dataView, buffer, offset, attributeType, attributeSize);\n          if (attributeValue === undefined) {\n            console.warn(`THREE.EXRLoader: Skipped unknown header attribute type \\'${attributeType}\\'.`);\n          } else {\n            EXRHeader[attributeName] = attributeValue;\n          }\n        }\n      }\n      if ((spec & ~0x06) != 0) {\n        // unsupported deep-image, multi-part\n\n        console.error('THREE.EXRHeader:', EXRHeader);\n        throw new Error('THREE.EXRLoader: Provided file is currently unsupported.');\n      }\n      return EXRHeader;\n    }\n    function setupDecoder(EXRHeader, dataView, uInt8Array, offset, outputType) {\n      const EXRDecoder = {\n        size: 0,\n        viewer: dataView,\n        array: uInt8Array,\n        offset: offset,\n        width: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,\n        height: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,\n        inputChannels: EXRHeader.channels,\n        channelByteOffsets: {},\n        scanOrder: null,\n        totalBytes: null,\n        columns: null,\n        lines: null,\n        type: null,\n        uncompress: null,\n        getter: null,\n        format: null,\n        colorSpace: LinearSRGBColorSpace\n      };\n      switch (EXRHeader.compression) {\n        case 'NO_COMPRESSION':\n          EXRDecoder.blockHeight = 1;\n          EXRDecoder.uncompress = uncompressRAW;\n          break;\n        case 'RLE_COMPRESSION':\n          EXRDecoder.blockHeight = 1;\n          EXRDecoder.uncompress = uncompressRLE;\n          break;\n        case 'ZIPS_COMPRESSION':\n          EXRDecoder.blockHeight = 1;\n          EXRDecoder.uncompress = uncompressZIP;\n          break;\n        case 'ZIP_COMPRESSION':\n          EXRDecoder.blockHeight = 16;\n          EXRDecoder.uncompress = uncompressZIP;\n          break;\n        case 'PIZ_COMPRESSION':\n          EXRDecoder.blockHeight = 32;\n          EXRDecoder.uncompress = uncompressPIZ;\n          break;\n        case 'PXR24_COMPRESSION':\n          EXRDecoder.blockHeight = 16;\n          EXRDecoder.uncompress = uncompressPXR;\n          break;\n        case 'DWAA_COMPRESSION':\n          EXRDecoder.blockHeight = 32;\n          EXRDecoder.uncompress = uncompressDWA;\n          break;\n        case 'DWAB_COMPRESSION':\n          EXRDecoder.blockHeight = 256;\n          EXRDecoder.uncompress = uncompressDWA;\n          break;\n        default:\n          throw new Error('EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported');\n      }\n      const channels = {};\n      for (const channel of EXRHeader.channels) {\n        switch (channel.name) {\n          case 'Y':\n          case 'R':\n          case 'G':\n          case 'B':\n          case 'A':\n            channels[channel.name] = true;\n            EXRDecoder.type = channel.pixelType;\n        }\n      }\n\n      // RGB images will be converted to RGBA format, preventing software emulation in select devices.\n      let fillAlpha = false;\n      if (channels.R && channels.G && channels.B) {\n        fillAlpha = !channels.A;\n        EXRDecoder.outputChannels = 4;\n        EXRDecoder.decodeChannels = {\n          R: 0,\n          G: 1,\n          B: 2,\n          A: 3\n        };\n      } else if (channels.Y) {\n        EXRDecoder.outputChannels = 1;\n        EXRDecoder.decodeChannels = {\n          Y: 0\n        };\n      } else {\n        throw new Error('EXRLoader.parse: file contains unsupported data channels.');\n      }\n      if (EXRDecoder.type == 1) {\n        // half\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat16;\n            break;\n          case HalfFloatType:\n            EXRDecoder.getter = parseUint16;\n            break;\n        }\n      } else if (EXRDecoder.type == 2) {\n        // float\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat32;\n            break;\n          case HalfFloatType:\n            EXRDecoder.getter = decodeFloat32;\n        }\n      } else {\n        throw new Error('EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.');\n      }\n      EXRDecoder.columns = EXRDecoder.width;\n      const size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels;\n      switch (outputType) {\n        case FloatType:\n          EXRDecoder.byteArray = new Float32Array(size);\n\n          // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n          if (fillAlpha) EXRDecoder.byteArray.fill(1, 0, size);\n          break;\n        case HalfFloatType:\n          EXRDecoder.byteArray = new Uint16Array(size);\n          if (fillAlpha) EXRDecoder.byteArray.fill(0x3C00, 0, size); // Uint16Array holds half float data, 0x3C00 is 1\n\n          break;\n        default:\n          console.error('THREE.EXRLoader: unsupported type: ', outputType);\n          break;\n      }\n      let byteOffset = 0;\n      for (const channel of EXRHeader.channels) {\n        if (EXRDecoder.decodeChannels[channel.name] !== undefined) {\n          EXRDecoder.channelByteOffsets[channel.name] = byteOffset;\n        }\n        byteOffset += channel.pixelType * 2;\n      }\n      EXRDecoder.totalBytes = byteOffset;\n      EXRDecoder.outLineWidth = EXRDecoder.width * EXRDecoder.outputChannels;\n      if (EXRHeader.lineOrder === 'INCREASING_Y') {\n        EXRDecoder.scanOrder = y => y;\n      } else {\n        EXRDecoder.scanOrder = y => EXRDecoder.height - 1 - y;\n      }\n      if (EXRDecoder.outputChannels == 4) {\n        EXRDecoder.format = RGBAFormat;\n        EXRDecoder.colorSpace = LinearSRGBColorSpace;\n      } else {\n        EXRDecoder.format = RedFormat;\n        EXRDecoder.colorSpace = NoColorSpace;\n      }\n      if (EXRHeader.spec.singleTile) {\n        EXRDecoder.blockHeight = EXRHeader.tiles.ySize;\n        EXRDecoder.blockWidth = EXRHeader.tiles.xSize;\n        const numXLevels = calculateTileLevels(EXRHeader.tiles, EXRDecoder.width, EXRDecoder.height);\n        // const numYLevels = calculateTileLevels( EXRHeader.tiles, EXRDecoder.width, EXRDecoder.height );\n\n        const numXTiles = calculateTiles(numXLevels, EXRDecoder.width, EXRHeader.tiles.xSize, EXRHeader.tiles.roundingMode);\n        const numYTiles = calculateTiles(numXLevels, EXRDecoder.height, EXRHeader.tiles.ySize, EXRHeader.tiles.roundingMode);\n        EXRDecoder.tileCount = numXTiles[0] * numYTiles[0];\n        for (let l = 0; l < numXLevels; l++) for (let y = 0; y < numYTiles[l]; y++) for (let x = 0; x < numXTiles[l]; x++) parseInt64(dataView, offset); // tileOffset\n\n        EXRDecoder.decode = parseTiles.bind(EXRDecoder);\n      } else {\n        EXRDecoder.blockWidth = EXRDecoder.width;\n        const blockCount = Math.ceil(EXRDecoder.height / EXRDecoder.blockHeight);\n        for (let i = 0; i < blockCount; i++) parseInt64(dataView, offset); // scanlineOffset\n\n        EXRDecoder.decode = parseScanline.bind(EXRDecoder);\n      }\n      return EXRDecoder;\n    }\n\n    // start parsing file [START]\n    const offset = {\n      value: 0\n    };\n    const bufferDataView = new DataView(buffer);\n    const uInt8Array = new Uint8Array(buffer);\n\n    // get header information and validate format.\n    const EXRHeader = parseHeader(bufferDataView, buffer, offset);\n\n    // get input compression information and prepare decoding.\n    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n\n    // parse input data\n    EXRDecoder.decode();\n    return {\n      header: EXRHeader,\n      width: EXRDecoder.width,\n      height: EXRDecoder.height,\n      data: EXRDecoder.byteArray,\n      format: EXRDecoder.format,\n      colorSpace: EXRDecoder.colorSpace,\n      type: this.type\n    };\n  }\n\n  /**\n   * Sets the texture type.\n   *\n   * @param {(HalfFloatType|FloatType)} value - The texture type to set.\n   * @return {RGBMLoader} A reference to this loader.\n   */\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      texture.colorSpace = texData.colorSpace;\n      texture.minFilter = LinearFilter;\n      texture.magFilter = LinearFilter;\n      texture.generateMipmaps = false;\n      texture.flipY = false;\n      if (onLoad) onLoad(texture, texData);\n    }\n    return super.load(url, onLoadCallback, onProgress, onError);\n  }\n}\nexport { EXRLoader };","map":{"version":3,"names":["DataTextureLoader","DataUtils","FloatType","HalfFloatType","NoColorSpace","LinearFilter","LinearSRGBColorSpace","RedFormat","RGBAFormat","fflate","EXRLoader","constructor","manager","type","parse","buffer","USHORT_RANGE","BITMAP_SIZE","HUF_ENCBITS","HUF_DECBITS","HUF_ENCSIZE","HUF_DECSIZE","HUF_DECMASK","NBITS","A_OFFSET","MOD_MASK","SHORT_ZEROCODE_RUN","LONG_ZEROCODE_RUN","SHORTEST_LONG_RUN","ULONG_SIZE","FLOAT32_SIZE","INT32_SIZE","INT16_SIZE","INT8_SIZE","STATIC_HUFFMAN","DEFLATE","UNKNOWN","LOSSY_DCT","RLE","logBase","Math","pow","reverseLutFromBitmap","bitmap","lut","k","i","n","hufClearDecTable","hdec","len","lit","p","getBitsReturn","l","c","lc","getBits","nBits","uInt8Array","inOffset","parseUint8Array","hufTableBuffer","Array","hufCanonicalCodeTable","hcode","nc","hufUnpackEncTable","ni","im","iM","value","Error","zerun","hufLength","code","hufCode","hufBuildDecTable","hdecod","pl","plOffset","getCharReturn","getChar","getCodeReturn","getCode","po","rlc","outBuffer","outBufferOffset","outBufferEndOffset","cs","Uint8Array","s","UInt16","Int16","ref","wdec14Return","a","b","wdec14","h","ls","hs","hi","ai","as","bs","wdec16","m","d","bb","aa","wav2Decode","j","nx","ox","ny","oy","mx","w14","p2","py","ey","oy1","oy2","ox1","ox2","i00","i01","i10","i11","px","ex","p01","p10","p11","hufDecode","encodingTable","decodingTable","no","outOffset","inOffsetEnd","trunc","index","hufUncompress","inDataView","nCompressed","nRaw","initialInOffset","parseUint32","freq","applyLut","data","nData","predictor","source","t","length","interleaveScalar","out","t1","t2","floor","stop","decodeRunLength","size","byteLength","reader","DataView","getInt8","count","push","getUint8","lossyDctDecode","cscSet","rowPtrs","channelData","acBuffer","dcBuffer","dataView","width","idx","height","numComp","numFullBlocksX","numBlocksX","ceil","numBlocksY","leftoverX","leftoverY","currAcComp","currDcComp","dctData","halfZigBlock","rowBlock","rowOffsets","comp","Float32Array","Uint16Array","blocky","maxY","maxX","blockx","fill","unRleAC","unZigZag","dctInverse","csc709Inverse","convertToHalf","offset","y","src","setUint16","x","halfRow","decoded","getUint16","setFloat32","decodeFloat16","acValue","dctComp","dst","cos","e","f","g","alpha","beta","theta","gamma","row","rowPtr","column","cb","cr","toHalfFloat","toLinear","float","sign","abs","uncompressRAW","info","array","uncompressRLE","compressed","viewer","slice","rawBuffer","tmpBuffer","uncompressZIP","unzlibSync","uncompressPIZ","columns","lines","inputChannels","outBufferEnd","pizChannelData","il","minNonZero","parseUint16","maxNonZero","parseUint8","maxValue","cd","start","tmpOffset","cp","end","set","uncompressPXR","byteSize","totalBytes","ArrayBuffer","tmpBufferEnd","writePtr","ptr","pixel","pixelType","diff","setUint32","uncompressDWA","dwaHeader","version","parseInt64","unknownUncompressedSize","unknownCompressedSize","acCompressedSize","dcCompressedSize","rleCompressedSize","rleUncompressedSize","rleRawSize","totalAcUncompressedCount","totalDcUncompressedCount","acCompression","EXRHeader","compression","channelRules","ruleSize","name","parseNullTerminatedString","csc","Int8Array","channels","channel","pLinear","rule","rleBuffer","zlibInfo","chan","rleOffset","rowOffsetBytes","byte","uintBuffer","endOffset","stringValue","TextDecoder","decode","parseFixedLengthString","parseRational","parseInt32","parseTimecode","Int32","getInt32","Uint32","getUint32","Uint8","int","prototype","Number","getBigInt64","parseFloat32","getFloat32","decodeFloat32","binary","exponent","fraction","NaN","Infinity","Uint16","parseFloat16","parseChlist","startOffset","xSampling","ySampling","parseChromaticities","redX","redY","greenX","greenY","blueX","blueY","whiteX","whiteY","parseCompression","compressionCodes","parseBox2i","xMin","yMin","xMax","yMax","parseLineOrder","lineOrders","lineOrder","parseEnvmap","envmaps","envmap","parseTiledesc","levelModes","roundingModes","xSize","ySize","modes","levelMode","roundingMode","parseV2f","parseV3f","z","parseValue","undefined","roundLog2","mode","log2","calculateTileLevels","tiledesc","w","num","max","calculateTiles","dataSize","tiles","parseTiles","EXRDecoder","tile","tileCount","tileX","tileY","startX","blockWidth","startY","blockHeight","bytesBlockLine","isCompressed","uncompress","line","lineOffset","channelID","lOff","channelByteOffsets","cOff","decodeChannels","outLineOffset","outLineWidth","outIndex","outputChannels","byteArray","getter","parseScanline","scanlineBlockIdx","dataWindow","bytesPerLine","line_y","scan_y","true_y","scanOrder","parseHeader","spec","singleTile","longName","deepFormat","multiPart","keepReading","attributeName","attributeType","attributeSize","attributeValue","console","warn","error","setupDecoder","outputType","format","colorSpace","fillAlpha","R","G","B","A","Y","byteOffset","numXLevels","numXTiles","numYTiles","bind","blockCount","bufferDataView","header","setDataType","load","url","onLoad","onProgress","onError","onLoadCallback","texture","texData","minFilter","magFilter","generateMipmaps","flipY"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/loaders/EXRLoader.js"],"sourcesContent":["import {\n\tDataTextureLoader,\n\tDataUtils,\n\tFloatType,\n\tHalfFloatType,\n\tNoColorSpace,\n\tLinearFilter,\n\tLinearSRGBColorSpace,\n\tRedFormat,\n\tRGBAFormat\n} from 'three';\nimport * as fflate from '../libs/fflate.module.js';\n\n// Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n// implementation, so I have preserved their copyright notices.\n\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n\n// // End of OpenEXR license -------------------------------------------------\n\n\n/**\n * A loader for the OpenEXR texture format.\n *\n * `EXRLoader` currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\n *\n * ```js\n * const loader = new EXRLoader();\n * const texture = await loader.loadAsync( 'textures/memorial.exr' );\n * ```\n *\n * @augments DataTextureLoader\n * @three_import import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';\n */\nclass EXRLoader extends DataTextureLoader {\n\n\t/**\n\t * Constructs a new EXR loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * The texture type.\n\t\t *\n\t\t * @type {(HalfFloatType|FloatType)}\n\t\t * @default HalfFloatType\n\t\t */\n\t\tthis.type = HalfFloatType;\n\n\t}\n\n\t/**\n\t * Parses the given EXR texture data.\n\t *\n\t * @param {ArrayBuffer} buffer - The raw texture data.\n\t * @return {DataTextureLoader~TexData} An object representing the parsed texture data.\n\t */\n\tparse( buffer ) {\n\n\t\tconst USHORT_RANGE = ( 1 << 16 );\n\t\tconst BITMAP_SIZE = ( USHORT_RANGE >> 3 );\n\n\t\tconst HUF_ENCBITS = 16; // literal (value) bit length\n\t\tconst HUF_DECBITS = 14; // decoding bit size (>= 8)\n\n\t\tconst HUF_ENCSIZE = ( 1 << HUF_ENCBITS ) + 1; // encoding table size\n\t\tconst HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size\n\t\tconst HUF_DECMASK = HUF_DECSIZE - 1;\n\n\t\tconst NBITS = 16;\n\t\tconst A_OFFSET = 1 << ( NBITS - 1 );\n\t\tconst MOD_MASK = ( 1 << NBITS ) - 1;\n\n\t\tconst SHORT_ZEROCODE_RUN = 59;\n\t\tconst LONG_ZEROCODE_RUN = 63;\n\t\tconst SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n\n\t\tconst ULONG_SIZE = 8;\n\t\tconst FLOAT32_SIZE = 4;\n\t\tconst INT32_SIZE = 4;\n\t\tconst INT16_SIZE = 2;\n\t\tconst INT8_SIZE = 1;\n\n\t\tconst STATIC_HUFFMAN = 0;\n\t\tconst DEFLATE = 1;\n\n\t\tconst UNKNOWN = 0;\n\t\tconst LOSSY_DCT = 1;\n\t\tconst RLE = 2;\n\n\t\tconst logBase = Math.pow( 2.7182818, 2.2 );\n\n\t\tfunction reverseLutFromBitmap( bitmap, lut ) {\n\n\t\t\tlet k = 0;\n\n\t\t\tfor ( let i = 0; i < USHORT_RANGE; ++ i ) {\n\n\t\t\t\tif ( ( i == 0 ) || ( bitmap[ i >> 3 ] & ( 1 << ( i & 7 ) ) ) ) {\n\n\t\t\t\t\tlut[ k ++ ] = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst n = k - 1;\n\n\t\t\twhile ( k < USHORT_RANGE ) lut[ k ++ ] = 0;\n\n\t\t\treturn n;\n\n\t\t}\n\n\t\tfunction hufClearDecTable( hdec ) {\n\n\t\t\tfor ( let i = 0; i < HUF_DECSIZE; i ++ ) {\n\n\t\t\t\thdec[ i ] = {};\n\t\t\t\thdec[ i ].len = 0;\n\t\t\t\thdec[ i ].lit = 0;\n\t\t\t\thdec[ i ].p = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst getBitsReturn = { l: 0, c: 0, lc: 0 };\n\n\t\tfunction getBits( nBits, c, lc, uInt8Array, inOffset ) {\n\n\t\t\twhile ( lc < nBits ) {\n\n\t\t\t\tc = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );\n\t\t\t\tlc += 8;\n\n\t\t\t}\n\n\t\t\tlc -= nBits;\n\n\t\t\tgetBitsReturn.l = ( c >> lc ) & ( ( 1 << nBits ) - 1 );\n\t\t\tgetBitsReturn.c = c;\n\t\t\tgetBitsReturn.lc = lc;\n\n\t\t}\n\n\t\tconst hufTableBuffer = new Array( 59 );\n\n\t\tfunction hufCanonicalCodeTable( hcode ) {\n\n\t\t\tfor ( let i = 0; i <= 58; ++ i ) hufTableBuffer[ i ] = 0;\n\t\t\tfor ( let i = 0; i < HUF_ENCSIZE; ++ i ) hufTableBuffer[ hcode[ i ] ] += 1;\n\n\t\t\tlet c = 0;\n\n\t\t\tfor ( let i = 58; i > 0; -- i ) {\n\n\t\t\t\tconst nc = ( ( c + hufTableBuffer[ i ] ) >> 1 );\n\t\t\t\thufTableBuffer[ i ] = c;\n\t\t\t\tc = nc;\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < HUF_ENCSIZE; ++ i ) {\n\n\t\t\t\tconst l = hcode[ i ];\n\t\t\t\tif ( l > 0 ) hcode[ i ] = l | ( hufTableBuffer[ l ] ++ << 6 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction hufUnpackEncTable( uInt8Array, inOffset, ni, im, iM, hcode ) {\n\n\t\t\tconst p = inOffset;\n\t\t\tlet c = 0;\n\t\t\tlet lc = 0;\n\n\t\t\tfor ( ; im <= iM; im ++ ) {\n\n\t\t\t\tif ( p.value - inOffset.value > ni ) return false;\n\n\t\t\t\tgetBits( 6, c, lc, uInt8Array, p );\n\n\t\t\t\tconst l = getBitsReturn.l;\n\t\t\t\tc = getBitsReturn.c;\n\t\t\t\tlc = getBitsReturn.lc;\n\n\t\t\t\thcode[ im ] = l;\n\n\t\t\t\tif ( l == LONG_ZEROCODE_RUN ) {\n\n\t\t\t\t\tif ( p.value - inOffset.value > ni ) {\n\n\t\t\t\t\t\tthrow new Error( 'Something wrong with hufUnpackEncTable' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgetBits( 8, c, lc, uInt8Array, p );\n\n\t\t\t\t\tlet zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n\t\t\t\t\tc = getBitsReturn.c;\n\t\t\t\t\tlc = getBitsReturn.lc;\n\n\t\t\t\t\tif ( im + zerun > iM + 1 ) {\n\n\t\t\t\t\t\tthrow new Error( 'Something wrong with hufUnpackEncTable' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\twhile ( zerun -- ) hcode[ im ++ ] = 0;\n\n\t\t\t\t\tim --;\n\n\t\t\t\t} else if ( l >= SHORT_ZEROCODE_RUN ) {\n\n\t\t\t\t\tlet zerun = l - SHORT_ZEROCODE_RUN + 2;\n\n\t\t\t\t\tif ( im + zerun > iM + 1 ) {\n\n\t\t\t\t\t\tthrow new Error( 'Something wrong with hufUnpackEncTable' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\twhile ( zerun -- ) hcode[ im ++ ] = 0;\n\n\t\t\t\t\tim --;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thufCanonicalCodeTable( hcode );\n\n\t\t}\n\n\t\tfunction hufLength( code ) {\n\n\t\t\treturn code & 63;\n\n\t\t}\n\n\t\tfunction hufCode( code ) {\n\n\t\t\treturn code >> 6;\n\n\t\t}\n\n\t\tfunction hufBuildDecTable( hcode, im, iM, hdecod ) {\n\n\t\t\tfor ( ; im <= iM; im ++ ) {\n\n\t\t\t\tconst c = hufCode( hcode[ im ] );\n\t\t\t\tconst l = hufLength( hcode[ im ] );\n\n\t\t\t\tif ( c >> l ) {\n\n\t\t\t\t\tthrow new Error( 'Invalid table entry' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( l > HUF_DECBITS ) {\n\n\t\t\t\t\tconst pl = hdecod[ ( c >> ( l - HUF_DECBITS ) ) ];\n\n\t\t\t\t\tif ( pl.len ) {\n\n\t\t\t\t\t\tthrow new Error( 'Invalid table entry' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpl.lit ++;\n\n\t\t\t\t\tif ( pl.p ) {\n\n\t\t\t\t\t\tconst p = pl.p;\n\t\t\t\t\t\tpl.p = new Array( pl.lit );\n\n\t\t\t\t\t\tfor ( let i = 0; i < pl.lit - 1; ++ i ) {\n\n\t\t\t\t\t\t\tpl.p[ i ] = p[ i ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpl.p = new Array( 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpl.p[ pl.lit - 1 ] = im;\n\n\t\t\t\t} else if ( l ) {\n\n\t\t\t\t\tlet plOffset = 0;\n\n\t\t\t\t\tfor ( let i = 1 << ( HUF_DECBITS - l ); i > 0; i -- ) {\n\n\t\t\t\t\t\tconst pl = hdecod[ ( c << ( HUF_DECBITS - l ) ) + plOffset ];\n\n\t\t\t\t\t\tif ( pl.len || pl.p ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'Invalid table entry' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpl.len = l;\n\t\t\t\t\t\tpl.lit = im;\n\n\t\t\t\t\t\tplOffset ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst getCharReturn = { c: 0, lc: 0 };\n\n\t\tfunction getChar( c, lc, uInt8Array, inOffset ) {\n\n\t\t\tc = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );\n\t\t\tlc += 8;\n\n\t\t\tgetCharReturn.c = c;\n\t\t\tgetCharReturn.lc = lc;\n\n\t\t}\n\n\t\tconst getCodeReturn = { c: 0, lc: 0 };\n\n\t\tfunction getCode( po, rlc, c, lc, uInt8Array, inOffset, outBuffer, outBufferOffset, outBufferEndOffset ) {\n\n\t\t\tif ( po == rlc ) {\n\n\t\t\t\tif ( lc < 8 ) {\n\n\t\t\t\t\tgetChar( c, lc, uInt8Array, inOffset );\n\t\t\t\t\tc = getCharReturn.c;\n\t\t\t\t\tlc = getCharReturn.lc;\n\n\t\t\t\t}\n\n\t\t\t\tlc -= 8;\n\n\t\t\t\tlet cs = ( c >> lc );\n\t\t\t\tcs = new Uint8Array( [ cs ] )[ 0 ];\n\n\t\t\t\tif ( outBufferOffset.value + cs > outBufferEndOffset ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tconst s = outBuffer[ outBufferOffset.value - 1 ];\n\n\t\t\t\twhile ( cs -- > 0 ) {\n\n\t\t\t\t\toutBuffer[ outBufferOffset.value ++ ] = s;\n\n\t\t\t\t}\n\n\t\t\t} else if ( outBufferOffset.value < outBufferEndOffset ) {\n\n\t\t\t\toutBuffer[ outBufferOffset.value ++ ] = po;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tgetCodeReturn.c = c;\n\t\t\tgetCodeReturn.lc = lc;\n\n\t\t}\n\n\t\tfunction UInt16( value ) {\n\n\t\t\treturn ( value & 0xFFFF );\n\n\t\t}\n\n\t\tfunction Int16( value ) {\n\n\t\t\tconst ref = UInt16( value );\n\t\t\treturn ( ref > 0x7FFF ) ? ref - 0x10000 : ref;\n\n\t\t}\n\n\t\tconst wdec14Return = { a: 0, b: 0 };\n\n\t\tfunction wdec14( l, h ) {\n\n\t\t\tconst ls = Int16( l );\n\t\t\tconst hs = Int16( h );\n\n\t\t\tconst hi = hs;\n\t\t\tconst ai = ls + ( hi & 1 ) + ( hi >> 1 );\n\n\t\t\tconst as = ai;\n\t\t\tconst bs = ai - hi;\n\n\t\t\twdec14Return.a = as;\n\t\t\twdec14Return.b = bs;\n\n\t\t}\n\n\t\tfunction wdec16( l, h ) {\n\n\t\t\tconst m = UInt16( l );\n\t\t\tconst d = UInt16( h );\n\n\t\t\tconst bb = ( m - ( d >> 1 ) ) & MOD_MASK;\n\t\t\tconst aa = ( d + bb - A_OFFSET ) & MOD_MASK;\n\n\t\t\twdec14Return.a = aa;\n\t\t\twdec14Return.b = bb;\n\n\t\t}\n\n\t\tfunction wav2Decode( buffer, j, nx, ox, ny, oy, mx ) {\n\n\t\t\tconst w14 = mx < ( 1 << 14 );\n\t\t\tconst n = ( nx > ny ) ? ny : nx;\n\t\t\tlet p = 1;\n\t\t\tlet p2;\n\t\t\tlet py;\n\n\t\t\twhile ( p <= n ) p <<= 1;\n\n\t\t\tp >>= 1;\n\t\t\tp2 = p;\n\t\t\tp >>= 1;\n\n\t\t\twhile ( p >= 1 ) {\n\n\t\t\t\tpy = 0;\n\t\t\t\tconst ey = py + oy * ( ny - p2 );\n\t\t\t\tconst oy1 = oy * p;\n\t\t\t\tconst oy2 = oy * p2;\n\t\t\t\tconst ox1 = ox * p;\n\t\t\t\tconst ox2 = ox * p2;\n\t\t\t\tlet i00, i01, i10, i11;\n\n\t\t\t\tfor ( ; py <= ey; py += oy2 ) {\n\n\t\t\t\t\tlet px = py;\n\t\t\t\t\tconst ex = py + ox * ( nx - p2 );\n\n\t\t\t\t\tfor ( ; px <= ex; px += ox2 ) {\n\n\t\t\t\t\t\tconst p01 = px + ox1;\n\t\t\t\t\t\tconst p10 = px + oy1;\n\t\t\t\t\t\tconst p11 = p10 + ox1;\n\n\t\t\t\t\t\tif ( w14 ) {\n\n\t\t\t\t\t\t\twdec14( buffer[ px + j ], buffer[ p10 + j ] );\n\n\t\t\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\t\t\ti10 = wdec14Return.b;\n\n\t\t\t\t\t\t\twdec14( buffer[ p01 + j ], buffer[ p11 + j ] );\n\n\t\t\t\t\t\t\ti01 = wdec14Return.a;\n\t\t\t\t\t\t\ti11 = wdec14Return.b;\n\n\t\t\t\t\t\t\twdec14( i00, i01 );\n\n\t\t\t\t\t\t\tbuffer[ px + j ] = wdec14Return.a;\n\t\t\t\t\t\t\tbuffer[ p01 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\t\twdec14( i10, i11 );\n\n\t\t\t\t\t\t\tbuffer[ p10 + j ] = wdec14Return.a;\n\t\t\t\t\t\t\tbuffer[ p11 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\twdec16( buffer[ px + j ], buffer[ p10 + j ] );\n\n\t\t\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\t\t\ti10 = wdec14Return.b;\n\n\t\t\t\t\t\t\twdec16( buffer[ p01 + j ], buffer[ p11 + j ] );\n\n\t\t\t\t\t\t\ti01 = wdec14Return.a;\n\t\t\t\t\t\t\ti11 = wdec14Return.b;\n\n\t\t\t\t\t\t\twdec16( i00, i01 );\n\n\t\t\t\t\t\t\tbuffer[ px + j ] = wdec14Return.a;\n\t\t\t\t\t\t\tbuffer[ p01 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\t\twdec16( i10, i11 );\n\n\t\t\t\t\t\t\tbuffer[ p10 + j ] = wdec14Return.a;\n\t\t\t\t\t\t\tbuffer[ p11 + j ] = wdec14Return.b;\n\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( nx & p ) {\n\n\t\t\t\t\t\tconst p10 = px + oy1;\n\n\t\t\t\t\t\tif ( w14 )\n\t\t\t\t\t\t\twdec14( buffer[ px + j ], buffer[ p10 + j ] );\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\twdec16( buffer[ px + j ], buffer[ p10 + j ] );\n\n\t\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\t\tbuffer[ p10 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\tbuffer[ px + j ] = i00;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ny & p ) {\n\n\t\t\t\t\tlet px = py;\n\t\t\t\t\tconst ex = py + ox * ( nx - p2 );\n\n\t\t\t\t\tfor ( ; px <= ex; px += ox2 ) {\n\n\t\t\t\t\t\tconst p01 = px + ox1;\n\n\t\t\t\t\t\tif ( w14 )\n\t\t\t\t\t\t\twdec14( buffer[ px + j ], buffer[ p01 + j ] );\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\twdec16( buffer[ px + j ], buffer[ p01 + j ] );\n\n\t\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\t\tbuffer[ p01 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\tbuffer[ px + j ] = i00;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tp2 = p;\n\t\t\t\tp >>= 1;\n\n\t\t\t}\n\n\t\t\treturn py;\n\n\t\t}\n\n\t\tfunction hufDecode( encodingTable, decodingTable, uInt8Array, inOffset, ni, rlc, no, outBuffer, outOffset ) {\n\n\t\t\tlet c = 0;\n\t\t\tlet lc = 0;\n\t\t\tconst outBufferEndOffset = no;\n\t\t\tconst inOffsetEnd = Math.trunc( inOffset.value + ( ni + 7 ) / 8 );\n\n\t\t\twhile ( inOffset.value < inOffsetEnd ) {\n\n\t\t\t\tgetChar( c, lc, uInt8Array, inOffset );\n\n\t\t\t\tc = getCharReturn.c;\n\t\t\t\tlc = getCharReturn.lc;\n\n\t\t\t\twhile ( lc >= HUF_DECBITS ) {\n\n\t\t\t\t\tconst index = ( c >> ( lc - HUF_DECBITS ) ) & HUF_DECMASK;\n\t\t\t\t\tconst pl = decodingTable[ index ];\n\n\t\t\t\t\tif ( pl.len ) {\n\n\t\t\t\t\t\tlc -= pl.len;\n\n\t\t\t\t\t\tgetCode( pl.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );\n\n\t\t\t\t\t\tc = getCodeReturn.c;\n\t\t\t\t\t\tlc = getCodeReturn.lc;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( ! pl.p ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'hufDecode issues' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet j;\n\n\t\t\t\t\t\tfor ( j = 0; j < pl.lit; j ++ ) {\n\n\t\t\t\t\t\t\tconst l = hufLength( encodingTable[ pl.p[ j ] ] );\n\n\t\t\t\t\t\t\twhile ( lc < l && inOffset.value < inOffsetEnd ) {\n\n\t\t\t\t\t\t\t\tgetChar( c, lc, uInt8Array, inOffset );\n\n\t\t\t\t\t\t\t\tc = getCharReturn.c;\n\t\t\t\t\t\t\t\tlc = getCharReturn.lc;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( lc >= l ) {\n\n\t\t\t\t\t\t\t\tif ( hufCode( encodingTable[ pl.p[ j ] ] ) == ( ( c >> ( lc - l ) ) & ( ( 1 << l ) - 1 ) ) ) {\n\n\t\t\t\t\t\t\t\t\tlc -= l;\n\n\t\t\t\t\t\t\t\t\tgetCode( pl.p[ j ], rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );\n\n\t\t\t\t\t\t\t\t\tc = getCodeReturn.c;\n\t\t\t\t\t\t\t\t\tlc = getCodeReturn.lc;\n\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( j == pl.lit ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'hufDecode issues' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst i = ( 8 - ni ) & 7;\n\n\t\t\tc >>= i;\n\t\t\tlc -= i;\n\n\t\t\twhile ( lc > 0 ) {\n\n\t\t\t\tconst pl = decodingTable[ ( c << ( HUF_DECBITS - lc ) ) & HUF_DECMASK ];\n\n\t\t\t\tif ( pl.len ) {\n\n\t\t\t\t\tlc -= pl.len;\n\n\t\t\t\t\tgetCode( pl.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );\n\n\t\t\t\t\tc = getCodeReturn.c;\n\t\t\t\t\tlc = getCodeReturn.lc;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'hufDecode issues' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction hufUncompress( uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw ) {\n\n\t\t\tconst outOffset = { value: 0 };\n\t\t\tconst initialInOffset = inOffset.value;\n\n\t\t\tconst im = parseUint32( inDataView, inOffset );\n\t\t\tconst iM = parseUint32( inDataView, inOffset );\n\n\t\t\tinOffset.value += 4;\n\n\t\t\tconst nBits = parseUint32( inDataView, inOffset );\n\n\t\t\tinOffset.value += 4;\n\n\t\t\tif ( im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE ) {\n\n\t\t\t\tthrow new Error( 'Something wrong with HUF_ENCSIZE' );\n\n\t\t\t}\n\n\t\t\tconst freq = new Array( HUF_ENCSIZE );\n\t\t\tconst hdec = new Array( HUF_DECSIZE );\n\n\t\t\thufClearDecTable( hdec );\n\n\t\t\tconst ni = nCompressed - ( inOffset.value - initialInOffset );\n\n\t\t\thufUnpackEncTable( uInt8Array, inOffset, ni, im, iM, freq );\n\n\t\t\tif ( nBits > 8 * ( nCompressed - ( inOffset.value - initialInOffset ) ) ) {\n\n\t\t\t\tthrow new Error( 'Something wrong with hufUncompress' );\n\n\t\t\t}\n\n\t\t\thufBuildDecTable( freq, im, iM, hdec );\n\n\t\t\thufDecode( freq, hdec, uInt8Array, inOffset, nBits, iM, nRaw, outBuffer, outOffset );\n\n\t\t}\n\n\t\tfunction applyLut( lut, data, nData ) {\n\n\t\t\tfor ( let i = 0; i < nData; ++ i ) {\n\n\t\t\t\tdata[ i ] = lut[ data[ i ] ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction predictor( source ) {\n\n\t\t\tfor ( let t = 1; t < source.length; t ++ ) {\n\n\t\t\t\tconst d = source[ t - 1 ] + source[ t ] - 128;\n\t\t\t\tsource[ t ] = d;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction interleaveScalar( source, out ) {\n\n\t\t\tlet t1 = 0;\n\t\t\tlet t2 = Math.floor( ( source.length + 1 ) / 2 );\n\t\t\tlet s = 0;\n\t\t\tconst stop = source.length - 1;\n\n\t\t\twhile ( true ) {\n\n\t\t\t\tif ( s > stop ) break;\n\t\t\t\tout[ s ++ ] = source[ t1 ++ ];\n\n\t\t\t\tif ( s > stop ) break;\n\t\t\t\tout[ s ++ ] = source[ t2 ++ ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction decodeRunLength( source ) {\n\n\t\t\tlet size = source.byteLength;\n\t\t\tconst out = new Array();\n\t\t\tlet p = 0;\n\n\t\t\tconst reader = new DataView( source );\n\n\t\t\twhile ( size > 0 ) {\n\n\t\t\t\tconst l = reader.getInt8( p ++ );\n\n\t\t\t\tif ( l < 0 ) {\n\n\t\t\t\t\tconst count = - l;\n\t\t\t\t\tsize -= count + 1;\n\n\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\tout.push( reader.getUint8( p ++ ) );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst count = l;\n\t\t\t\t\tsize -= 2;\n\n\t\t\t\t\tconst value = reader.getUint8( p ++ );\n\n\t\t\t\t\tfor ( let i = 0; i < count + 1; i ++ ) {\n\n\t\t\t\t\t\tout.push( value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn out;\n\n\t\t}\n\n\t\tfunction lossyDctDecode( cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer ) {\n\n\t\t\tlet dataView = new DataView( outBuffer.buffer );\n\n\t\t\tconst width = channelData[ cscSet.idx[ 0 ] ].width;\n\t\t\tconst height = channelData[ cscSet.idx[ 0 ] ].height;\n\n\t\t\tconst numComp = 3;\n\n\t\t\tconst numFullBlocksX = Math.floor( width / 8.0 );\n\t\t\tconst numBlocksX = Math.ceil( width / 8.0 );\n\t\t\tconst numBlocksY = Math.ceil( height / 8.0 );\n\t\t\tconst leftoverX = width - ( numBlocksX - 1 ) * 8;\n\t\t\tconst leftoverY = height - ( numBlocksY - 1 ) * 8;\n\n\t\t\tconst currAcComp = { value: 0 };\n\t\t\tconst currDcComp = new Array( numComp );\n\t\t\tconst dctData = new Array( numComp );\n\t\t\tconst halfZigBlock = new Array( numComp );\n\t\t\tconst rowBlock = new Array( numComp );\n\t\t\tconst rowOffsets = new Array( numComp );\n\n\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\trowOffsets[ comp ] = rowPtrs[ cscSet.idx[ comp ] ];\n\t\t\t\tcurrDcComp[ comp ] = ( comp < 1 ) ? 0 : currDcComp[ comp - 1 ] + numBlocksX * numBlocksY;\n\t\t\t\tdctData[ comp ] = new Float32Array( 64 );\n\t\t\t\thalfZigBlock[ comp ] = new Uint16Array( 64 );\n\t\t\t\trowBlock[ comp ] = new Uint16Array( numBlocksX * 64 );\n\n\t\t\t}\n\n\t\t\tfor ( let blocky = 0; blocky < numBlocksY; ++ blocky ) {\n\n\t\t\t\tlet maxY = 8;\n\n\t\t\t\tif ( blocky == numBlocksY - 1 )\n\t\t\t\t\tmaxY = leftoverY;\n\n\t\t\t\tlet maxX = 8;\n\n\t\t\t\tfor ( let blockx = 0; blockx < numBlocksX; ++ blockx ) {\n\n\t\t\t\t\tif ( blockx == numBlocksX - 1 )\n\t\t\t\t\t\tmaxX = leftoverX;\n\n\t\t\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\t\t\thalfZigBlock[ comp ].fill( 0 );\n\n\t\t\t\t\t\t// set block DC component\n\t\t\t\t\t\thalfZigBlock[ comp ][ 0 ] = dcBuffer[ currDcComp[ comp ] ++ ];\n\t\t\t\t\t\t// set block AC components\n\t\t\t\t\t\tunRleAC( currAcComp, acBuffer, halfZigBlock[ comp ] );\n\n\t\t\t\t\t\t// UnZigZag block to float\n\t\t\t\t\t\tunZigZag( halfZigBlock[ comp ], dctData[ comp ] );\n\t\t\t\t\t\t// decode float dct\n\t\t\t\t\t\tdctInverse( dctData[ comp ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( numComp == 3 ) {\n\n\t\t\t\t\t\tcsc709Inverse( dctData );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\t\t\tconvertToHalf( dctData[ comp ], rowBlock[ comp ], blockx * 64 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} // blockx\n\n\t\t\t\tlet offset = 0;\n\n\t\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\t\tconst type = channelData[ cscSet.idx[ comp ] ].type;\n\n\t\t\t\t\tfor ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) {\n\n\t\t\t\t\t\toffset = rowOffsets[ comp ][ y ];\n\n\t\t\t\t\t\tfor ( let blockx = 0; blockx < numFullBlocksX; ++ blockx ) {\n\n\t\t\t\t\t\t\tconst src = blockx * 64 + ( ( y & 0x7 ) * 8 );\n\n\t\t\t\t\t\t\tdataView.setUint16( offset + 0 * INT16_SIZE * type, rowBlock[ comp ][ src + 0 ], true );\n\t\t\t\t\t\t\tdataView.setUint16( offset + 1 * INT16_SIZE * type, rowBlock[ comp ][ src + 1 ], true );\n\t\t\t\t\t\t\tdataView.setUint16( offset + 2 * INT16_SIZE * type, rowBlock[ comp ][ src + 2 ], true );\n\t\t\t\t\t\t\tdataView.setUint16( offset + 3 * INT16_SIZE * type, rowBlock[ comp ][ src + 3 ], true );\n\n\t\t\t\t\t\t\tdataView.setUint16( offset + 4 * INT16_SIZE * type, rowBlock[ comp ][ src + 4 ], true );\n\t\t\t\t\t\t\tdataView.setUint16( offset + 5 * INT16_SIZE * type, rowBlock[ comp ][ src + 5 ], true );\n\t\t\t\t\t\t\tdataView.setUint16( offset + 6 * INT16_SIZE * type, rowBlock[ comp ][ src + 6 ], true );\n\t\t\t\t\t\t\tdataView.setUint16( offset + 7 * INT16_SIZE * type, rowBlock[ comp ][ src + 7 ], true );\n\n\t\t\t\t\t\t\toffset += 8 * INT16_SIZE * type;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// handle partial X blocks\n\t\t\t\t\tif ( numFullBlocksX != numBlocksX ) {\n\n\t\t\t\t\t\tfor ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) {\n\n\t\t\t\t\t\t\tconst offset = rowOffsets[ comp ][ y ] + 8 * numFullBlocksX * INT16_SIZE * type;\n\t\t\t\t\t\t\tconst src = numFullBlocksX * 64 + ( ( y & 0x7 ) * 8 );\n\n\t\t\t\t\t\t\tfor ( let x = 0; x < maxX; ++ x ) {\n\n\t\t\t\t\t\t\t\tdataView.setUint16( offset + x * INT16_SIZE * type, rowBlock[ comp ][ src + x ], true );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} // comp\n\n\t\t\t} // blocky\n\n\t\t\tconst halfRow = new Uint16Array( width );\n\t\t\tdataView = new DataView( outBuffer.buffer );\n\n\t\t\t// convert channels back to float, if needed\n\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\tchannelData[ cscSet.idx[ comp ] ].decoded = true;\n\t\t\t\tconst type = channelData[ cscSet.idx[ comp ] ].type;\n\n\t\t\t\tif ( channelData[ comp ].type != 2 ) continue;\n\n\t\t\t\tfor ( let y = 0; y < height; ++ y ) {\n\n\t\t\t\t\tconst offset = rowOffsets[ comp ][ y ];\n\n\t\t\t\t\tfor ( let x = 0; x < width; ++ x ) {\n\n\t\t\t\t\t\thalfRow[ x ] = dataView.getUint16( offset + x * INT16_SIZE * type, true );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let x = 0; x < width; ++ x ) {\n\n\t\t\t\t\t\tdataView.setFloat32( offset + x * INT16_SIZE * type, decodeFloat16( halfRow[ x ] ), true );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction unRleAC( currAcComp, acBuffer, halfZigBlock ) {\n\n\t\t\tlet acValue;\n\t\t\tlet dctComp = 1;\n\n\t\t\twhile ( dctComp < 64 ) {\n\n\t\t\t\tacValue = acBuffer[ currAcComp.value ];\n\n\t\t\t\tif ( acValue == 0xff00 ) {\n\n\t\t\t\t\tdctComp = 64;\n\n\t\t\t\t} else if ( acValue >> 8 == 0xff ) {\n\n\t\t\t\t\tdctComp += acValue & 0xff;\n\n\t\t\t\t} else {\n\n\t\t\t\t\thalfZigBlock[ dctComp ] = acValue;\n\t\t\t\t\tdctComp ++;\n\n\t\t\t\t}\n\n\t\t\t\tcurrAcComp.value ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction unZigZag( src, dst ) {\n\n\t\t\tdst[ 0 ] = decodeFloat16( src[ 0 ] );\n\t\t\tdst[ 1 ] = decodeFloat16( src[ 1 ] );\n\t\t\tdst[ 2 ] = decodeFloat16( src[ 5 ] );\n\t\t\tdst[ 3 ] = decodeFloat16( src[ 6 ] );\n\t\t\tdst[ 4 ] = decodeFloat16( src[ 14 ] );\n\t\t\tdst[ 5 ] = decodeFloat16( src[ 15 ] );\n\t\t\tdst[ 6 ] = decodeFloat16( src[ 27 ] );\n\t\t\tdst[ 7 ] = decodeFloat16( src[ 28 ] );\n\t\t\tdst[ 8 ] = decodeFloat16( src[ 2 ] );\n\t\t\tdst[ 9 ] = decodeFloat16( src[ 4 ] );\n\n\t\t\tdst[ 10 ] = decodeFloat16( src[ 7 ] );\n\t\t\tdst[ 11 ] = decodeFloat16( src[ 13 ] );\n\t\t\tdst[ 12 ] = decodeFloat16( src[ 16 ] );\n\t\t\tdst[ 13 ] = decodeFloat16( src[ 26 ] );\n\t\t\tdst[ 14 ] = decodeFloat16( src[ 29 ] );\n\t\t\tdst[ 15 ] = decodeFloat16( src[ 42 ] );\n\t\t\tdst[ 16 ] = decodeFloat16( src[ 3 ] );\n\t\t\tdst[ 17 ] = decodeFloat16( src[ 8 ] );\n\t\t\tdst[ 18 ] = decodeFloat16( src[ 12 ] );\n\t\t\tdst[ 19 ] = decodeFloat16( src[ 17 ] );\n\n\t\t\tdst[ 20 ] = decodeFloat16( src[ 25 ] );\n\t\t\tdst[ 21 ] = decodeFloat16( src[ 30 ] );\n\t\t\tdst[ 22 ] = decodeFloat16( src[ 41 ] );\n\t\t\tdst[ 23 ] = decodeFloat16( src[ 43 ] );\n\t\t\tdst[ 24 ] = decodeFloat16( src[ 9 ] );\n\t\t\tdst[ 25 ] = decodeFloat16( src[ 11 ] );\n\t\t\tdst[ 26 ] = decodeFloat16( src[ 18 ] );\n\t\t\tdst[ 27 ] = decodeFloat16( src[ 24 ] );\n\t\t\tdst[ 28 ] = decodeFloat16( src[ 31 ] );\n\t\t\tdst[ 29 ] = decodeFloat16( src[ 40 ] );\n\n\t\t\tdst[ 30 ] = decodeFloat16( src[ 44 ] );\n\t\t\tdst[ 31 ] = decodeFloat16( src[ 53 ] );\n\t\t\tdst[ 32 ] = decodeFloat16( src[ 10 ] );\n\t\t\tdst[ 33 ] = decodeFloat16( src[ 19 ] );\n\t\t\tdst[ 34 ] = decodeFloat16( src[ 23 ] );\n\t\t\tdst[ 35 ] = decodeFloat16( src[ 32 ] );\n\t\t\tdst[ 36 ] = decodeFloat16( src[ 39 ] );\n\t\t\tdst[ 37 ] = decodeFloat16( src[ 45 ] );\n\t\t\tdst[ 38 ] = decodeFloat16( src[ 52 ] );\n\t\t\tdst[ 39 ] = decodeFloat16( src[ 54 ] );\n\n\t\t\tdst[ 40 ] = decodeFloat16( src[ 20 ] );\n\t\t\tdst[ 41 ] = decodeFloat16( src[ 22 ] );\n\t\t\tdst[ 42 ] = decodeFloat16( src[ 33 ] );\n\t\t\tdst[ 43 ] = decodeFloat16( src[ 38 ] );\n\t\t\tdst[ 44 ] = decodeFloat16( src[ 46 ] );\n\t\t\tdst[ 45 ] = decodeFloat16( src[ 51 ] );\n\t\t\tdst[ 46 ] = decodeFloat16( src[ 55 ] );\n\t\t\tdst[ 47 ] = decodeFloat16( src[ 60 ] );\n\t\t\tdst[ 48 ] = decodeFloat16( src[ 21 ] );\n\t\t\tdst[ 49 ] = decodeFloat16( src[ 34 ] );\n\n\t\t\tdst[ 50 ] = decodeFloat16( src[ 37 ] );\n\t\t\tdst[ 51 ] = decodeFloat16( src[ 47 ] );\n\t\t\tdst[ 52 ] = decodeFloat16( src[ 50 ] );\n\t\t\tdst[ 53 ] = decodeFloat16( src[ 56 ] );\n\t\t\tdst[ 54 ] = decodeFloat16( src[ 59 ] );\n\t\t\tdst[ 55 ] = decodeFloat16( src[ 61 ] );\n\t\t\tdst[ 56 ] = decodeFloat16( src[ 35 ] );\n\t\t\tdst[ 57 ] = decodeFloat16( src[ 36 ] );\n\t\t\tdst[ 58 ] = decodeFloat16( src[ 48 ] );\n\t\t\tdst[ 59 ] = decodeFloat16( src[ 49 ] );\n\n\t\t\tdst[ 60 ] = decodeFloat16( src[ 57 ] );\n\t\t\tdst[ 61 ] = decodeFloat16( src[ 58 ] );\n\t\t\tdst[ 62 ] = decodeFloat16( src[ 62 ] );\n\t\t\tdst[ 63 ] = decodeFloat16( src[ 63 ] );\n\n\t\t}\n\n\t\tfunction dctInverse( data ) {\n\n\t\t\tconst a = 0.5 * Math.cos( 3.14159 / 4.0 );\n\t\t\tconst b = 0.5 * Math.cos( 3.14159 / 16.0 );\n\t\t\tconst c = 0.5 * Math.cos( 3.14159 / 8.0 );\n\t\t\tconst d = 0.5 * Math.cos( 3.0 * 3.14159 / 16.0 );\n\t\t\tconst e = 0.5 * Math.cos( 5.0 * 3.14159 / 16.0 );\n\t\t\tconst f = 0.5 * Math.cos( 3.0 * 3.14159 / 8.0 );\n\t\t\tconst g = 0.5 * Math.cos( 7.0 * 3.14159 / 16.0 );\n\n\t\t\tconst alpha = new Array( 4 );\n\t\t\tconst beta = new Array( 4 );\n\t\t\tconst theta = new Array( 4 );\n\t\t\tconst gamma = new Array( 4 );\n\n\t\t\tfor ( let row = 0; row < 8; ++ row ) {\n\n\t\t\t\tconst rowPtr = row * 8;\n\n\t\t\t\talpha[ 0 ] = c * data[ rowPtr + 2 ];\n\t\t\t\talpha[ 1 ] = f * data[ rowPtr + 2 ];\n\t\t\t\talpha[ 2 ] = c * data[ rowPtr + 6 ];\n\t\t\t\talpha[ 3 ] = f * data[ rowPtr + 6 ];\n\n\t\t\t\tbeta[ 0 ] = b * data[ rowPtr + 1 ] + d * data[ rowPtr + 3 ] + e * data[ rowPtr + 5 ] + g * data[ rowPtr + 7 ];\n\t\t\t\tbeta[ 1 ] = d * data[ rowPtr + 1 ] - g * data[ rowPtr + 3 ] - b * data[ rowPtr + 5 ] - e * data[ rowPtr + 7 ];\n\t\t\t\tbeta[ 2 ] = e * data[ rowPtr + 1 ] - b * data[ rowPtr + 3 ] + g * data[ rowPtr + 5 ] + d * data[ rowPtr + 7 ];\n\t\t\t\tbeta[ 3 ] = g * data[ rowPtr + 1 ] - e * data[ rowPtr + 3 ] + d * data[ rowPtr + 5 ] - b * data[ rowPtr + 7 ];\n\n\t\t\t\ttheta[ 0 ] = a * ( data[ rowPtr + 0 ] + data[ rowPtr + 4 ] );\n\t\t\t\ttheta[ 3 ] = a * ( data[ rowPtr + 0 ] - data[ rowPtr + 4 ] );\n\t\t\t\ttheta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];\n\t\t\t\ttheta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];\n\n\t\t\t\tgamma[ 0 ] = theta[ 0 ] + theta[ 1 ];\n\t\t\t\tgamma[ 1 ] = theta[ 3 ] + theta[ 2 ];\n\t\t\t\tgamma[ 2 ] = theta[ 3 ] - theta[ 2 ];\n\t\t\t\tgamma[ 3 ] = theta[ 0 ] - theta[ 1 ];\n\n\t\t\t\tdata[ rowPtr + 0 ] = gamma[ 0 ] + beta[ 0 ];\n\t\t\t\tdata[ rowPtr + 1 ] = gamma[ 1 ] + beta[ 1 ];\n\t\t\t\tdata[ rowPtr + 2 ] = gamma[ 2 ] + beta[ 2 ];\n\t\t\t\tdata[ rowPtr + 3 ] = gamma[ 3 ] + beta[ 3 ];\n\n\t\t\t\tdata[ rowPtr + 4 ] = gamma[ 3 ] - beta[ 3 ];\n\t\t\t\tdata[ rowPtr + 5 ] = gamma[ 2 ] - beta[ 2 ];\n\t\t\t\tdata[ rowPtr + 6 ] = gamma[ 1 ] - beta[ 1 ];\n\t\t\t\tdata[ rowPtr + 7 ] = gamma[ 0 ] - beta[ 0 ];\n\n\t\t\t}\n\n\t\t\tfor ( let column = 0; column < 8; ++ column ) {\n\n\t\t\t\talpha[ 0 ] = c * data[ 16 + column ];\n\t\t\t\talpha[ 1 ] = f * data[ 16 + column ];\n\t\t\t\talpha[ 2 ] = c * data[ 48 + column ];\n\t\t\t\talpha[ 3 ] = f * data[ 48 + column ];\n\n\t\t\t\tbeta[ 0 ] = b * data[ 8 + column ] + d * data[ 24 + column ] + e * data[ 40 + column ] + g * data[ 56 + column ];\n\t\t\t\tbeta[ 1 ] = d * data[ 8 + column ] - g * data[ 24 + column ] - b * data[ 40 + column ] - e * data[ 56 + column ];\n\t\t\t\tbeta[ 2 ] = e * data[ 8 + column ] - b * data[ 24 + column ] + g * data[ 40 + column ] + d * data[ 56 + column ];\n\t\t\t\tbeta[ 3 ] = g * data[ 8 + column ] - e * data[ 24 + column ] + d * data[ 40 + column ] - b * data[ 56 + column ];\n\n\t\t\t\ttheta[ 0 ] = a * ( data[ column ] + data[ 32 + column ] );\n\t\t\t\ttheta[ 3 ] = a * ( data[ column ] - data[ 32 + column ] );\n\n\t\t\t\ttheta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];\n\t\t\t\ttheta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];\n\n\t\t\t\tgamma[ 0 ] = theta[ 0 ] + theta[ 1 ];\n\t\t\t\tgamma[ 1 ] = theta[ 3 ] + theta[ 2 ];\n\t\t\t\tgamma[ 2 ] = theta[ 3 ] - theta[ 2 ];\n\t\t\t\tgamma[ 3 ] = theta[ 0 ] - theta[ 1 ];\n\n\t\t\t\tdata[ 0 + column ] = gamma[ 0 ] + beta[ 0 ];\n\t\t\t\tdata[ 8 + column ] = gamma[ 1 ] + beta[ 1 ];\n\t\t\t\tdata[ 16 + column ] = gamma[ 2 ] + beta[ 2 ];\n\t\t\t\tdata[ 24 + column ] = gamma[ 3 ] + beta[ 3 ];\n\n\t\t\t\tdata[ 32 + column ] = gamma[ 3 ] - beta[ 3 ];\n\t\t\t\tdata[ 40 + column ] = gamma[ 2 ] - beta[ 2 ];\n\t\t\t\tdata[ 48 + column ] = gamma[ 1 ] - beta[ 1 ];\n\t\t\t\tdata[ 56 + column ] = gamma[ 0 ] - beta[ 0 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction csc709Inverse( data ) {\n\n\t\t\tfor ( let i = 0; i < 64; ++ i ) {\n\n\t\t\t\tconst y = data[ 0 ][ i ];\n\t\t\t\tconst cb = data[ 1 ][ i ];\n\t\t\t\tconst cr = data[ 2 ][ i ];\n\n\t\t\t\tdata[ 0 ][ i ] = y + 1.5747 * cr;\n\t\t\t\tdata[ 1 ][ i ] = y - 0.1873 * cb - 0.4682 * cr;\n\t\t\t\tdata[ 2 ][ i ] = y + 1.8556 * cb;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction convertToHalf( src, dst, idx ) {\n\n\t\t\tfor ( let i = 0; i < 64; ++ i ) {\n\n\t\t\t\tdst[ idx + i ] = DataUtils.toHalfFloat( toLinear( src[ i ] ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction toLinear( float ) {\n\n\t\t\tif ( float <= 1 ) {\n\n\t\t\t\treturn Math.sign( float ) * Math.pow( Math.abs( float ), 2.2 );\n\n\t\t\t} else {\n\n\t\t\t\treturn Math.sign( float ) * Math.pow( logBase, Math.abs( float ) - 1.0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction uncompressRAW( info ) {\n\n\t\t\treturn new DataView( info.array.buffer, info.offset.value, info.size );\n\n\t\t}\n\n\t\tfunction uncompressRLE( info ) {\n\n\t\t\tconst compressed = info.viewer.buffer.slice( info.offset.value, info.offset.value + info.size );\n\n\t\t\tconst rawBuffer = new Uint8Array( decodeRunLength( compressed ) );\n\t\t\tconst tmpBuffer = new Uint8Array( rawBuffer.length );\n\n\t\t\tpredictor( rawBuffer ); // revert predictor\n\n\t\t\tinterleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels\n\n\t\t\treturn new DataView( tmpBuffer.buffer );\n\n\t\t}\n\n\t\tfunction uncompressZIP( info ) {\n\n\t\t\tconst compressed = info.array.slice( info.offset.value, info.offset.value + info.size );\n\n\t\t\tconst rawBuffer = fflate.unzlibSync( compressed );\n\t\t\tconst tmpBuffer = new Uint8Array( rawBuffer.length );\n\n\t\t\tpredictor( rawBuffer ); // revert predictor\n\n\t\t\tinterleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels\n\n\t\t\treturn new DataView( tmpBuffer.buffer );\n\n\t\t}\n\n\t\tfunction uncompressPIZ( info ) {\n\n\t\t\tconst inDataView = info.viewer;\n\t\t\tconst inOffset = { value: info.offset.value };\n\n\t\t\tconst outBuffer = new Uint16Array( info.columns * info.lines * ( info.inputChannels.length * info.type ) );\n\t\t\tconst bitmap = new Uint8Array( BITMAP_SIZE );\n\n\t\t\t// Setup channel info\n\t\t\tlet outBufferEnd = 0;\n\t\t\tconst pizChannelData = new Array( info.inputChannels.length );\n\t\t\tfor ( let i = 0, il = info.inputChannels.length; i < il; i ++ ) {\n\n\t\t\t\tpizChannelData[ i ] = {};\n\t\t\t\tpizChannelData[ i ][ 'start' ] = outBufferEnd;\n\t\t\t\tpizChannelData[ i ][ 'end' ] = pizChannelData[ i ][ 'start' ];\n\t\t\t\tpizChannelData[ i ][ 'nx' ] = info.columns;\n\t\t\t\tpizChannelData[ i ][ 'ny' ] = info.lines;\n\t\t\t\tpizChannelData[ i ][ 'size' ] = info.type;\n\n\t\t\t\toutBufferEnd += pizChannelData[ i ].nx * pizChannelData[ i ].ny * pizChannelData[ i ].size;\n\n\t\t\t}\n\n\t\t\t// Read range compression data\n\n\t\t\tconst minNonZero = parseUint16( inDataView, inOffset );\n\t\t\tconst maxNonZero = parseUint16( inDataView, inOffset );\n\n\t\t\tif ( maxNonZero >= BITMAP_SIZE ) {\n\n\t\t\t\tthrow new Error( 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE' );\n\n\t\t\t}\n\n\t\t\tif ( minNonZero <= maxNonZero ) {\n\n\t\t\t\tfor ( let i = 0; i < maxNonZero - minNonZero + 1; i ++ ) {\n\n\t\t\t\t\tbitmap[ i + minNonZero ] = parseUint8( inDataView, inOffset );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Reverse LUT\n\t\t\tconst lut = new Uint16Array( USHORT_RANGE );\n\t\t\tconst maxValue = reverseLutFromBitmap( bitmap, lut );\n\n\t\t\tconst length = parseUint32( inDataView, inOffset );\n\n\t\t\t// Huffman decoding\n\t\t\thufUncompress( info.array, inDataView, inOffset, length, outBuffer, outBufferEnd );\n\n\t\t\t// Wavelet decoding\n\t\t\tfor ( let i = 0; i < info.inputChannels.length; ++ i ) {\n\n\t\t\t\tconst cd = pizChannelData[ i ];\n\n\t\t\t\tfor ( let j = 0; j < pizChannelData[ i ].size; ++ j ) {\n\n\t\t\t\t\twav2Decode(\n\t\t\t\t\t\toutBuffer,\n\t\t\t\t\t\tcd.start + j,\n\t\t\t\t\t\tcd.nx,\n\t\t\t\t\t\tcd.size,\n\t\t\t\t\t\tcd.ny,\n\t\t\t\t\t\tcd.nx * cd.size,\n\t\t\t\t\t\tmaxValue\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Expand the pixel data to their original range\n\t\t\tapplyLut( lut, outBuffer, outBufferEnd );\n\n\t\t\t// Rearrange the pixel data into the format expected by the caller.\n\t\t\tlet tmpOffset = 0;\n\t\t\tconst tmpBuffer = new Uint8Array( outBuffer.buffer.byteLength );\n\t\t\tfor ( let y = 0; y < info.lines; y ++ ) {\n\n\t\t\t\tfor ( let c = 0; c < info.inputChannels.length; c ++ ) {\n\n\t\t\t\t\tconst cd = pizChannelData[ c ];\n\n\t\t\t\t\tconst n = cd.nx * cd.size;\n\t\t\t\t\tconst cp = new Uint8Array( outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE );\n\n\t\t\t\t\ttmpBuffer.set( cp, tmpOffset );\n\t\t\t\t\ttmpOffset += n * INT16_SIZE;\n\t\t\t\t\tcd.end += n;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new DataView( tmpBuffer.buffer );\n\n\t\t}\n\n\t\tfunction uncompressPXR( info ) {\n\n\t\t\tconst compressed = info.array.slice( info.offset.value, info.offset.value + info.size );\n\n\t\t\tconst rawBuffer = fflate.unzlibSync( compressed );\n\n\t\t\tconst byteSize = info.inputChannels.length * info.lines * info.columns * info.totalBytes;\n\t\t\tconst tmpBuffer = new ArrayBuffer( byteSize );\n\t\t\tconst viewer = new DataView( tmpBuffer );\n\n\t\t\tlet tmpBufferEnd = 0;\n\t\t\tlet writePtr = 0;\n\t\t\tconst ptr = new Array( 4 );\n\n\t\t\tfor ( let y = 0; y < info.lines; y ++ ) {\n\n\t\t\t\tfor ( let c = 0; c < info.inputChannels.length; c ++ ) {\n\n\t\t\t\t\tlet pixel = 0;\n\n\t\t\t\t\tconst type = info.inputChannels[ c ].pixelType;\n\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\tcase 1:\n\n\t\t\t\t\t\t\tptr[ 0 ] = tmpBufferEnd;\n\t\t\t\t\t\t\tptr[ 1 ] = ptr[ 0 ] + info.columns;\n\t\t\t\t\t\t\ttmpBufferEnd = ptr[ 1 ] + info.columns;\n\n\t\t\t\t\t\t\tfor ( let j = 0; j < info.columns; ++ j ) {\n\n\t\t\t\t\t\t\t\tconst diff = ( rawBuffer[ ptr[ 0 ] ++ ] << 8 ) | rawBuffer[ ptr[ 1 ] ++ ];\n\n\t\t\t\t\t\t\t\tpixel += diff;\n\n\t\t\t\t\t\t\t\tviewer.setUint16( writePtr, pixel, true );\n\t\t\t\t\t\t\t\twritePtr += 2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 2:\n\n\t\t\t\t\t\t\tptr[ 0 ] = tmpBufferEnd;\n\t\t\t\t\t\t\tptr[ 1 ] = ptr[ 0 ] + info.columns;\n\t\t\t\t\t\t\tptr[ 2 ] = ptr[ 1 ] + info.columns;\n\t\t\t\t\t\t\ttmpBufferEnd = ptr[ 2 ] + info.columns;\n\n\t\t\t\t\t\t\tfor ( let j = 0; j < info.columns; ++ j ) {\n\n\t\t\t\t\t\t\t\tconst diff = ( rawBuffer[ ptr[ 0 ] ++ ] << 24 ) | ( rawBuffer[ ptr[ 1 ] ++ ] << 16 ) | ( rawBuffer[ ptr[ 2 ] ++ ] << 8 );\n\n\t\t\t\t\t\t\t\tpixel += diff;\n\n\t\t\t\t\t\t\t\tviewer.setUint32( writePtr, pixel, true );\n\t\t\t\t\t\t\t\twritePtr += 4;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn viewer;\n\n\t\t}\n\n\t\tfunction uncompressDWA( info ) {\n\n\t\t\tconst inDataView = info.viewer;\n\t\t\tconst inOffset = { value: info.offset.value };\n\t\t\tconst outBuffer = new Uint8Array( info.columns * info.lines * ( info.inputChannels.length * info.type * INT16_SIZE ) );\n\n\t\t\t// Read compression header information\n\t\t\tconst dwaHeader = {\n\n\t\t\t\tversion: parseInt64( inDataView, inOffset ),\n\t\t\t\tunknownUncompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\tunknownCompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\tacCompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\tdcCompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\trleCompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\trleUncompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\trleRawSize: parseInt64( inDataView, inOffset ),\n\t\t\t\ttotalAcUncompressedCount: parseInt64( inDataView, inOffset ),\n\t\t\t\ttotalDcUncompressedCount: parseInt64( inDataView, inOffset ),\n\t\t\t\tacCompression: parseInt64( inDataView, inOffset )\n\n\t\t\t};\n\n\t\t\tif ( dwaHeader.version < 2 )\n\t\t\t\tthrow new Error( 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported' );\n\n\t\t\t// Read channel ruleset information\n\t\t\tconst channelRules = new Array();\n\t\t\tlet ruleSize = parseUint16( inDataView, inOffset ) - INT16_SIZE;\n\n\t\t\twhile ( ruleSize > 0 ) {\n\n\t\t\t\tconst name = parseNullTerminatedString( inDataView.buffer, inOffset );\n\t\t\t\tconst value = parseUint8( inDataView, inOffset );\n\t\t\t\tconst compression = ( value >> 2 ) & 3;\n\t\t\t\tconst csc = ( value >> 4 ) - 1;\n\t\t\t\tconst index = new Int8Array( [ csc ] )[ 0 ];\n\t\t\t\tconst type = parseUint8( inDataView, inOffset );\n\n\t\t\t\tchannelRules.push( {\n\t\t\t\t\tname: name,\n\t\t\t\t\tindex: index,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tcompression: compression,\n\t\t\t\t} );\n\n\t\t\t\truleSize -= name.length + 3;\n\n\t\t\t}\n\n\t\t\t// Classify channels\n\t\t\tconst channels = EXRHeader.channels;\n\t\t\tconst channelData = new Array( info.inputChannels.length );\n\n\t\t\tfor ( let i = 0; i < info.inputChannels.length; ++ i ) {\n\n\t\t\t\tconst cd = channelData[ i ] = {};\n\t\t\t\tconst channel = channels[ i ];\n\n\t\t\t\tcd.name = channel.name;\n\t\t\t\tcd.compression = UNKNOWN;\n\t\t\t\tcd.decoded = false;\n\t\t\t\tcd.type = channel.pixelType;\n\t\t\t\tcd.pLinear = channel.pLinear;\n\t\t\t\tcd.width = info.columns;\n\t\t\t\tcd.height = info.lines;\n\n\t\t\t}\n\n\t\t\tconst cscSet = {\n\t\t\t\tidx: new Array( 3 )\n\t\t\t};\n\n\t\t\tfor ( let offset = 0; offset < info.inputChannels.length; ++ offset ) {\n\n\t\t\t\tconst cd = channelData[ offset ];\n\n\t\t\t\tfor ( let i = 0; i < channelRules.length; ++ i ) {\n\n\t\t\t\t\tconst rule = channelRules[ i ];\n\n\t\t\t\t\tif ( cd.name == rule.name ) {\n\n\t\t\t\t\t\tcd.compression = rule.compression;\n\n\t\t\t\t\t\tif ( rule.index >= 0 ) {\n\n\t\t\t\t\t\t\tcscSet.idx[ rule.index ] = offset;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcd.offset = offset;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet acBuffer, dcBuffer, rleBuffer;\n\n\t\t\t// Read DCT - AC component data\n\t\t\tif ( dwaHeader.acCompressedSize > 0 ) {\n\n\t\t\t\tswitch ( dwaHeader.acCompression ) {\n\n\t\t\t\t\tcase STATIC_HUFFMAN:\n\n\t\t\t\t\t\tacBuffer = new Uint16Array( dwaHeader.totalAcUncompressedCount );\n\t\t\t\t\t\thufUncompress( info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DEFLATE:\n\n\t\t\t\t\t\tconst compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount );\n\t\t\t\t\t\tconst data = fflate.unzlibSync( compressed );\n\t\t\t\t\t\tacBuffer = new Uint16Array( data.buffer );\n\t\t\t\t\t\tinOffset.value += dwaHeader.totalAcUncompressedCount;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t\t// Read DCT - DC component data\n\t\t\tif ( dwaHeader.dcCompressedSize > 0 ) {\n\n\t\t\t\tconst zlibInfo = {\n\t\t\t\t\tarray: info.array,\n\t\t\t\t\toffset: inOffset,\n\t\t\t\t\tsize: dwaHeader.dcCompressedSize\n\t\t\t\t};\n\t\t\t\tdcBuffer = new Uint16Array( uncompressZIP( zlibInfo ).buffer );\n\t\t\t\tinOffset.value += dwaHeader.dcCompressedSize;\n\n\t\t\t}\n\n\t\t\t// Read RLE compressed data\n\t\t\tif ( dwaHeader.rleRawSize > 0 ) {\n\n\t\t\t\tconst compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.rleCompressedSize );\n\t\t\t\tconst data = fflate.unzlibSync( compressed );\n\t\t\t\trleBuffer = decodeRunLength( data.buffer );\n\n\t\t\t\tinOffset.value += dwaHeader.rleCompressedSize;\n\n\t\t\t}\n\n\t\t\t// Prepare outbuffer data offset\n\t\t\tlet outBufferEnd = 0;\n\t\t\tconst rowOffsets = new Array( channelData.length );\n\t\t\tfor ( let i = 0; i < rowOffsets.length; ++ i ) {\n\n\t\t\t\trowOffsets[ i ] = new Array();\n\n\t\t\t}\n\n\t\t\tfor ( let y = 0; y < info.lines; ++ y ) {\n\n\t\t\t\tfor ( let chan = 0; chan < channelData.length; ++ chan ) {\n\n\t\t\t\t\trowOffsets[ chan ].push( outBufferEnd );\n\t\t\t\t\toutBufferEnd += channelData[ chan ].width * info.type * INT16_SIZE;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Lossy DCT decode RGB channels\n\t\t\tlossyDctDecode( cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer );\n\n\t\t\t// Decode other channels\n\t\t\tfor ( let i = 0; i < channelData.length; ++ i ) {\n\n\t\t\t\tconst cd = channelData[ i ];\n\n\t\t\t\tif ( cd.decoded ) continue;\n\n\t\t\t\tswitch ( cd.compression ) {\n\n\t\t\t\t\tcase RLE:\n\n\t\t\t\t\t\tlet row = 0;\n\t\t\t\t\t\tlet rleOffset = 0;\n\n\t\t\t\t\t\tfor ( let y = 0; y < info.lines; ++ y ) {\n\n\t\t\t\t\t\t\tlet rowOffsetBytes = rowOffsets[ i ][ row ];\n\n\t\t\t\t\t\t\tfor ( let x = 0; x < cd.width; ++ x ) {\n\n\t\t\t\t\t\t\t\tfor ( let byte = 0; byte < INT16_SIZE * cd.type; ++ byte ) {\n\n\t\t\t\t\t\t\t\t\toutBuffer[ rowOffsetBytes ++ ] = rleBuffer[ rleOffset + byte * cd.width * cd.height ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\trleOffset ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\trow ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase LOSSY_DCT: // skip\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error( 'EXRLoader.parse: unsupported channel compression' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new DataView( outBuffer.buffer );\n\n\t\t}\n\n\t\tfunction parseNullTerminatedString( buffer, offset ) {\n\n\t\t\tconst uintBuffer = new Uint8Array( buffer );\n\t\t\tlet endOffset = 0;\n\n\t\t\twhile ( uintBuffer[ offset.value + endOffset ] != 0 ) {\n\n\t\t\t\tendOffset += 1;\n\n\t\t\t}\n\n\t\t\tconst stringValue = new TextDecoder().decode(\n\t\t\t\tuintBuffer.slice( offset.value, offset.value + endOffset )\n\t\t\t);\n\n\t\t\toffset.value = offset.value + endOffset + 1;\n\n\t\t\treturn stringValue;\n\n\t\t}\n\n\t\tfunction parseFixedLengthString( buffer, offset, size ) {\n\n\t\t\tconst stringValue = new TextDecoder().decode(\n\t\t\t\tnew Uint8Array( buffer ).slice( offset.value, offset.value + size )\n\t\t\t);\n\n\t\t\toffset.value = offset.value + size;\n\n\t\t\treturn stringValue;\n\n\t\t}\n\n\t\tfunction parseRational( dataView, offset ) {\n\n\t\t\tconst x = parseInt32( dataView, offset );\n\t\t\tconst y = parseUint32( dataView, offset );\n\n\t\t\treturn [ x, y ];\n\n\t\t}\n\n\t\tfunction parseTimecode( dataView, offset ) {\n\n\t\t\tconst x = parseUint32( dataView, offset );\n\t\t\tconst y = parseUint32( dataView, offset );\n\n\t\t\treturn [ x, y ];\n\n\t\t}\n\n\t\tfunction parseInt32( dataView, offset ) {\n\n\t\t\tconst Int32 = dataView.getInt32( offset.value, true );\n\n\t\t\toffset.value = offset.value + INT32_SIZE;\n\n\t\t\treturn Int32;\n\n\t\t}\n\n\t\tfunction parseUint32( dataView, offset ) {\n\n\t\t\tconst Uint32 = dataView.getUint32( offset.value, true );\n\n\t\t\toffset.value = offset.value + INT32_SIZE;\n\n\t\t\treturn Uint32;\n\n\t\t}\n\n\t\tfunction parseUint8Array( uInt8Array, offset ) {\n\n\t\t\tconst Uint8 = uInt8Array[ offset.value ];\n\n\t\t\toffset.value = offset.value + INT8_SIZE;\n\n\t\t\treturn Uint8;\n\n\t\t}\n\n\t\tfunction parseUint8( dataView, offset ) {\n\n\t\t\tconst Uint8 = dataView.getUint8( offset.value );\n\n\t\t\toffset.value = offset.value + INT8_SIZE;\n\n\t\t\treturn Uint8;\n\n\t\t}\n\n\t\tconst parseInt64 = function ( dataView, offset ) {\n\n\t\t\tlet int;\n\n\t\t\tif ( 'getBigInt64' in DataView.prototype ) {\n\n\t\t\t\tint = Number( dataView.getBigInt64( offset.value, true ) );\n\n\t\t\t} else {\n\n\t\t\t\tint = dataView.getUint32( offset.value + 4, true ) + Number( dataView.getUint32( offset.value, true ) << 32 );\n\n\t\t\t}\n\n\t\t\toffset.value += ULONG_SIZE;\n\n\t\t\treturn int;\n\n\t\t};\n\n\t\tfunction parseFloat32( dataView, offset ) {\n\n\t\t\tconst float = dataView.getFloat32( offset.value, true );\n\n\t\t\toffset.value += FLOAT32_SIZE;\n\n\t\t\treturn float;\n\n\t\t}\n\n\t\tfunction decodeFloat32( dataView, offset ) {\n\n\t\t\treturn DataUtils.toHalfFloat( parseFloat32( dataView, offset ) );\n\n\t\t}\n\n\t\t// https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n\t\tfunction decodeFloat16( binary ) {\n\n\t\t\tconst exponent = ( binary & 0x7C00 ) >> 10,\n\t\t\t\tfraction = binary & 0x03FF;\n\n\t\t\treturn ( binary >> 15 ? - 1 : 1 ) * (\n\t\t\t\texponent ?\n\t\t\t\t\t(\n\t\t\t\t\t\texponent === 0x1F ?\n\t\t\t\t\t\t\tfraction ? NaN : Infinity :\n\t\t\t\t\t\t\tMath.pow( 2, exponent - 15 ) * ( 1 + fraction / 0x400 )\n\t\t\t\t\t) :\n\t\t\t\t\t6.103515625e-5 * ( fraction / 0x400 )\n\t\t\t);\n\n\t\t}\n\n\t\tfunction parseUint16( dataView, offset ) {\n\n\t\t\tconst Uint16 = dataView.getUint16( offset.value, true );\n\n\t\t\toffset.value += INT16_SIZE;\n\n\t\t\treturn Uint16;\n\n\t\t}\n\n\t\tfunction parseFloat16( buffer, offset ) {\n\n\t\t\treturn decodeFloat16( parseUint16( buffer, offset ) );\n\n\t\t}\n\n\t\tfunction parseChlist( dataView, buffer, offset, size ) {\n\n\t\t\tconst startOffset = offset.value;\n\t\t\tconst channels = [];\n\n\t\t\twhile ( offset.value < ( startOffset + size - 1 ) ) {\n\n\t\t\t\tconst name = parseNullTerminatedString( buffer, offset );\n\t\t\t\tconst pixelType = parseInt32( dataView, offset );\n\t\t\t\tconst pLinear = parseUint8( dataView, offset );\n\t\t\t\toffset.value += 3; // reserved, three chars\n\t\t\t\tconst xSampling = parseInt32( dataView, offset );\n\t\t\t\tconst ySampling = parseInt32( dataView, offset );\n\n\t\t\t\tchannels.push( {\n\t\t\t\t\tname: name,\n\t\t\t\t\tpixelType: pixelType,\n\t\t\t\t\tpLinear: pLinear,\n\t\t\t\t\txSampling: xSampling,\n\t\t\t\t\tySampling: ySampling\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\toffset.value += 1;\n\n\t\t\treturn channels;\n\n\t\t}\n\n\t\tfunction parseChromaticities( dataView, offset ) {\n\n\t\t\tconst redX = parseFloat32( dataView, offset );\n\t\t\tconst redY = parseFloat32( dataView, offset );\n\t\t\tconst greenX = parseFloat32( dataView, offset );\n\t\t\tconst greenY = parseFloat32( dataView, offset );\n\t\t\tconst blueX = parseFloat32( dataView, offset );\n\t\t\tconst blueY = parseFloat32( dataView, offset );\n\t\t\tconst whiteX = parseFloat32( dataView, offset );\n\t\t\tconst whiteY = parseFloat32( dataView, offset );\n\n\t\t\treturn { redX: redX, redY: redY, greenX: greenX, greenY: greenY, blueX: blueX, blueY: blueY, whiteX: whiteX, whiteY: whiteY };\n\n\t\t}\n\n\t\tfunction parseCompression( dataView, offset ) {\n\n\t\t\tconst compressionCodes = [\n\t\t\t\t'NO_COMPRESSION',\n\t\t\t\t'RLE_COMPRESSION',\n\t\t\t\t'ZIPS_COMPRESSION',\n\t\t\t\t'ZIP_COMPRESSION',\n\t\t\t\t'PIZ_COMPRESSION',\n\t\t\t\t'PXR24_COMPRESSION',\n\t\t\t\t'B44_COMPRESSION',\n\t\t\t\t'B44A_COMPRESSION',\n\t\t\t\t'DWAA_COMPRESSION',\n\t\t\t\t'DWAB_COMPRESSION'\n\t\t\t];\n\n\t\t\tconst compression = parseUint8( dataView, offset );\n\n\t\t\treturn compressionCodes[ compression ];\n\n\t\t}\n\n\t\tfunction parseBox2i( dataView, offset ) {\n\n\t\t\tconst xMin = parseInt32( dataView, offset );\n\t\t\tconst yMin = parseInt32( dataView, offset );\n\t\t\tconst xMax = parseInt32( dataView, offset );\n\t\t\tconst yMax = parseInt32( dataView, offset );\n\n\t\t\treturn { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax };\n\n\t\t}\n\n\t\tfunction parseLineOrder( dataView, offset ) {\n\n\t\t\tconst lineOrders = [\n\t\t\t\t'INCREASING_Y',\n\t\t\t\t'DECREASING_Y',\n\t\t\t\t'RANDOM_Y',\n\t\t\t];\n\n\t\t\tconst lineOrder = parseUint8( dataView, offset );\n\n\t\t\treturn lineOrders[ lineOrder ];\n\n\t\t}\n\n\t\tfunction parseEnvmap( dataView, offset ) {\n\n\t\t\tconst envmaps = [\n\t\t\t\t'ENVMAP_LATLONG',\n\t\t\t\t'ENVMAP_CUBE'\n\t\t\t];\n\n\t\t\tconst envmap = parseUint8( dataView, offset );\n\n\t\t\treturn envmaps[ envmap ];\n\n\t\t}\n\n\t\tfunction parseTiledesc( dataView, offset ) {\n\n\t\t\tconst levelModes = [\n\t\t\t\t'ONE_LEVEL',\n\t\t\t\t'MIPMAP_LEVELS',\n\t\t\t\t'RIPMAP_LEVELS',\n\t\t\t];\n\n\t\t\tconst roundingModes = [\n\t\t\t\t'ROUND_DOWN',\n\t\t\t\t'ROUND_UP',\n\t\t\t];\n\n\t\t\tconst xSize = parseUint32( dataView, offset );\n\t\t\tconst ySize = parseUint32( dataView, offset );\n\t\t\tconst modes = parseUint8( dataView, offset );\n\n\t\t\treturn {\n\t\t\t\txSize: xSize,\n\t\t\t\tySize: ySize,\n\t\t\t\tlevelMode: levelModes[ modes & 0xf ],\n\t\t\t\troundingMode: roundingModes[ modes >> 4 ]\n\t\t\t};\n\n\t\t}\n\n\t\tfunction parseV2f( dataView, offset ) {\n\n\t\t\tconst x = parseFloat32( dataView, offset );\n\t\t\tconst y = parseFloat32( dataView, offset );\n\n\t\t\treturn [ x, y ];\n\n\t\t}\n\n\t\tfunction parseV3f( dataView, offset ) {\n\n\t\t\tconst x = parseFloat32( dataView, offset );\n\t\t\tconst y = parseFloat32( dataView, offset );\n\t\t\tconst z = parseFloat32( dataView, offset );\n\n\t\t\treturn [ x, y, z ];\n\n\t\t}\n\n\t\tfunction parseValue( dataView, buffer, offset, type, size ) {\n\n\t\t\tif ( type === 'string' || type === 'stringvector' || type === 'iccProfile' ) {\n\n\t\t\t\treturn parseFixedLengthString( buffer, offset, size );\n\n\t\t\t} else if ( type === 'chlist' ) {\n\n\t\t\t\treturn parseChlist( dataView, buffer, offset, size );\n\n\t\t\t} else if ( type === 'chromaticities' ) {\n\n\t\t\t\treturn parseChromaticities( dataView, offset );\n\n\t\t\t} else if ( type === 'compression' ) {\n\n\t\t\t\treturn parseCompression( dataView, offset );\n\n\t\t\t} else if ( type === 'box2i' ) {\n\n\t\t\t\treturn parseBox2i( dataView, offset );\n\n\t\t\t} else if ( type === 'envmap' ) {\n\n\t\t\t\treturn parseEnvmap( dataView, offset );\n\n\t\t\t} else if ( type === 'tiledesc' ) {\n\n\t\t\t\treturn parseTiledesc( dataView, offset );\n\n\t\t\t} else if ( type === 'lineOrder' ) {\n\n\t\t\t\treturn parseLineOrder( dataView, offset );\n\n\t\t\t} else if ( type === 'float' ) {\n\n\t\t\t\treturn parseFloat32( dataView, offset );\n\n\t\t\t} else if ( type === 'v2f' ) {\n\n\t\t\t\treturn parseV2f( dataView, offset );\n\n\t\t\t} else if ( type === 'v3f' ) {\n\n\t\t\t\treturn parseV3f( dataView, offset );\n\n\t\t\t} else if ( type === 'int' ) {\n\n\t\t\t\treturn parseInt32( dataView, offset );\n\n\t\t\t} else if ( type === 'rational' ) {\n\n\t\t\t\treturn parseRational( dataView, offset );\n\n\t\t\t} else if ( type === 'timecode' ) {\n\n\t\t\t\treturn parseTimecode( dataView, offset );\n\n\t\t\t} else if ( type === 'preview' ) {\n\n\t\t\t\toffset.value += size;\n\t\t\t\treturn 'skipped';\n\n\t\t\t} else {\n\n\t\t\t\toffset.value += size;\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction roundLog2( x, mode ) {\n\n\t\t\tconst log2 = Math.log2( x );\n\t\t\treturn mode == 'ROUND_DOWN' ? Math.floor( log2 ) : Math.ceil( log2 );\n\n\t\t}\n\n\t\tfunction calculateTileLevels( tiledesc, w, h ) {\n\n\t\t\tlet num = 0;\n\n\t\t\tswitch ( tiledesc.levelMode ) {\n\n\t\t\t\tcase 'ONE_LEVEL':\n\t\t\t\t\tnum = 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'MIPMAP_LEVELS':\n\t\t\t\t\tnum = roundLog2( Math.max( w, h ), tiledesc.roundingMode ) + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RIPMAP_LEVELS':\n\t\t\t\t\tthrow new Error( 'THREE.EXRLoader: RIPMAP_LEVELS tiles currently unsupported.' );\n\n\t\t\t}\n\n\t\t\treturn num;\n\n\t\t}\n\n\t\tfunction calculateTiles( count, dataSize, size, roundingMode ) {\n\n\t\t\tconst tiles = new Array( count );\n\n\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\tconst b = ( 1 << i );\n\t\t\t\tlet s = ( dataSize / b ) | 0;\n\n\t\t\t\tif ( roundingMode == 'ROUND_UP' && s * b < dataSize ) s += 1;\n\n\t\t\t\tconst l = Math.max( s, 1 );\n\n\t\t\t\ttiles[ i ] = ( ( l + size - 1 ) / size ) | 0;\n\n\t\t\t}\n\n\t\t\treturn tiles;\n\n\t\t}\n\n\t\tfunction parseTiles() {\n\n\t\t\tconst EXRDecoder = this;\n\t\t\tconst offset = EXRDecoder.offset;\n\t\t\tconst tmpOffset = { value: 0 };\n\n\t\t\tfor ( let tile = 0; tile < EXRDecoder.tileCount; tile ++ ) {\n\n\t\t\t\tconst tileX = parseInt32( EXRDecoder.viewer, offset );\n\t\t\t\tconst tileY = parseInt32( EXRDecoder.viewer, offset );\n\t\t\t\toffset.value += 8; // skip levels - only parsing top-level\n\t\t\t\tEXRDecoder.size = parseUint32( EXRDecoder.viewer, offset );\n\n\t\t\t\tconst startX = tileX * EXRDecoder.blockWidth;\n\t\t\t\tconst startY = tileY * EXRDecoder.blockHeight;\n\t\t\t\tEXRDecoder.columns = ( startX + EXRDecoder.blockWidth > EXRDecoder.width ) ? EXRDecoder.width - startX : EXRDecoder.blockWidth;\n\t\t\t\tEXRDecoder.lines = ( startY + EXRDecoder.blockHeight > EXRDecoder.height ) ? EXRDecoder.height - startY : EXRDecoder.blockHeight;\n\n\t\t\t\tconst bytesBlockLine = EXRDecoder.columns * EXRDecoder.totalBytes;\n\t\t\t\tconst isCompressed = EXRDecoder.size < EXRDecoder.lines * bytesBlockLine;\n\t\t\t\tconst viewer = isCompressed ? EXRDecoder.uncompress( EXRDecoder ) : uncompressRAW( EXRDecoder );\n\n\t\t\t\toffset.value += EXRDecoder.size;\n\n\t\t\t\tfor ( let line = 0; line < EXRDecoder.lines; line ++ ) {\n\n\t\t\t\t\tconst lineOffset = line * EXRDecoder.columns * EXRDecoder.totalBytes;\n\n\t\t\t\t\tfor ( let channelID = 0; channelID < EXRDecoder.inputChannels.length; channelID ++ ) {\n\n\t\t\t\t\t\tconst name = EXRHeader.channels[ channelID ].name;\n\t\t\t\t\t\tconst lOff = EXRDecoder.channelByteOffsets[ name ] * EXRDecoder.columns;\n\t\t\t\t\t\tconst cOff = EXRDecoder.decodeChannels[ name ];\n\n\t\t\t\t\t\tif ( cOff === undefined ) continue;\n\n\t\t\t\t\t\ttmpOffset.value = lineOffset + lOff;\n\t\t\t\t\t\tconst outLineOffset = ( EXRDecoder.height - ( 1 + startY + line ) ) * EXRDecoder.outLineWidth;\n\n\t\t\t\t\t\tfor ( let x = 0; x < EXRDecoder.columns; x ++ ) {\n\n\t\t\t\t\t\t\tconst outIndex = outLineOffset + ( x + startX ) * EXRDecoder.outputChannels + cOff;\n\t\t\t\t\t\t\tEXRDecoder.byteArray[ outIndex ] = EXRDecoder.getter( viewer, tmpOffset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseScanline() {\n\n\t\t\tconst EXRDecoder = this;\n\t\t\tconst offset = EXRDecoder.offset;\n\t\t\tconst tmpOffset = { value: 0 };\n\n\t\t\tfor ( let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.blockHeight; scanlineBlockIdx ++ ) {\n\n\t\t\t\tconst line = parseInt32( EXRDecoder.viewer, offset ) - EXRHeader.dataWindow.yMin; // line_no\n\t\t\t\tEXRDecoder.size = parseUint32( EXRDecoder.viewer, offset ); // data_len\n\t\t\t\tEXRDecoder.lines = ( ( line + EXRDecoder.blockHeight > EXRDecoder.height ) ? ( EXRDecoder.height - line ) : EXRDecoder.blockHeight );\n\n\t\t\t\tconst bytesPerLine = EXRDecoder.columns * EXRDecoder.totalBytes;\n\t\t\t\tconst isCompressed = EXRDecoder.size < EXRDecoder.lines * bytesPerLine;\n\t\t\t\tconst viewer = isCompressed ? EXRDecoder.uncompress( EXRDecoder ) : uncompressRAW( EXRDecoder );\n\n\t\t\t\toffset.value += EXRDecoder.size;\n\n\t\t\t\tfor ( let line_y = 0; line_y < EXRDecoder.blockHeight; line_y ++ ) {\n\n\t\t\t\t\tconst scan_y = scanlineBlockIdx * EXRDecoder.blockHeight;\n\t\t\t\t\tconst true_y = line_y + EXRDecoder.scanOrder( scan_y );\n\t\t\t\t\tif ( true_y >= EXRDecoder.height ) continue;\n\n\t\t\t\t\tconst lineOffset = line_y * bytesPerLine;\n\t\t\t\t\tconst outLineOffset = ( EXRDecoder.height - 1 - true_y ) * EXRDecoder.outLineWidth;\n\n\t\t\t\t\tfor ( let channelID = 0; channelID < EXRDecoder.inputChannels.length; channelID ++ ) {\n\n\t\t\t\t\t\tconst name = EXRHeader.channels[ channelID ].name;\n\t\t\t\t\t\tconst lOff = EXRDecoder.channelByteOffsets[ name ] * EXRDecoder.columns;\n\t\t\t\t\t\tconst cOff = EXRDecoder.decodeChannels[ name ];\n\n\t\t\t\t\t\tif ( cOff === undefined ) continue;\n\n\t\t\t\t\t\ttmpOffset.value = lineOffset + lOff;\n\n\t\t\t\t\t\tfor ( let x = 0; x < EXRDecoder.columns; x ++ ) {\n\n\t\t\t\t\t\t\tconst outIndex = outLineOffset + x * EXRDecoder.outputChannels + cOff;\n\t\t\t\t\t\t\tEXRDecoder.byteArray[ outIndex ] = EXRDecoder.getter( viewer, tmpOffset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseHeader( dataView, buffer, offset ) {\n\n\t\t\tconst EXRHeader = {};\n\n\t\t\tif ( dataView.getUint32( 0, true ) != 20000630 ) { // magic\n\n\t\t\t\tthrow new Error( 'THREE.EXRLoader: Provided file doesn\\'t appear to be in OpenEXR format.' );\n\n\t\t\t}\n\n\t\t\tEXRHeader.version = dataView.getUint8( 4 );\n\n\t\t\tconst spec = dataView.getUint8( 5 ); // fullMask\n\n\t\t\tEXRHeader.spec = {\n\t\t\t\tsingleTile: !! ( spec & 2 ),\n\t\t\t\tlongName: !! ( spec & 4 ),\n\t\t\t\tdeepFormat: !! ( spec & 8 ),\n\t\t\t\tmultiPart: !! ( spec & 16 ),\n\t\t\t};\n\n\t\t\t// start of header\n\n\t\t\toffset.value = 8; // start at 8 - after pre-amble\n\n\t\t\tlet keepReading = true;\n\n\t\t\twhile ( keepReading ) {\n\n\t\t\t\tconst attributeName = parseNullTerminatedString( buffer, offset );\n\n\t\t\t\tif ( attributeName === '' ) {\n\n\t\t\t\t\tkeepReading = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst attributeType = parseNullTerminatedString( buffer, offset );\n\t\t\t\t\tconst attributeSize = parseUint32( dataView, offset );\n\t\t\t\t\tconst attributeValue = parseValue( dataView, buffer, offset, attributeType, attributeSize );\n\n\t\t\t\t\tif ( attributeValue === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( `THREE.EXRLoader: Skipped unknown header attribute type \\'${attributeType}\\'.` );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tEXRHeader[ attributeName ] = attributeValue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ( spec & ~ 0x06 ) != 0 ) { // unsupported deep-image, multi-part\n\n\t\t\t\tconsole.error( 'THREE.EXRHeader:', EXRHeader );\n\t\t\t\tthrow new Error( 'THREE.EXRLoader: Provided file is currently unsupported.' );\n\n\t\t\t}\n\n\t\t\treturn EXRHeader;\n\n\t\t}\n\n\t\tfunction setupDecoder( EXRHeader, dataView, uInt8Array, offset, outputType ) {\n\n\t\t\tconst EXRDecoder = {\n\t\t\t\tsize: 0,\n\t\t\t\tviewer: dataView,\n\t\t\t\tarray: uInt8Array,\n\t\t\t\toffset: offset,\n\t\t\t\twidth: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,\n\t\t\t\theight: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,\n\t\t\t\tinputChannels: EXRHeader.channels,\n\t\t\t\tchannelByteOffsets: {},\n\t\t\t\tscanOrder: null,\n\t\t\t\ttotalBytes: null,\n\t\t\t\tcolumns: null,\n\t\t\t\tlines: null,\n\t\t\t\ttype: null,\n\t\t\t\tuncompress: null,\n\t\t\t\tgetter: null,\n\t\t\t\tformat: null,\n\t\t\t\tcolorSpace: LinearSRGBColorSpace,\n\t\t\t};\n\n\t\t\tswitch ( EXRHeader.compression ) {\n\n\t\t\t\tcase 'NO_COMPRESSION':\n\t\t\t\t\tEXRDecoder.blockHeight = 1;\n\t\t\t\t\tEXRDecoder.uncompress = uncompressRAW;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RLE_COMPRESSION':\n\t\t\t\t\tEXRDecoder.blockHeight = 1;\n\t\t\t\t\tEXRDecoder.uncompress = uncompressRLE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZIPS_COMPRESSION':\n\t\t\t\t\tEXRDecoder.blockHeight = 1;\n\t\t\t\t\tEXRDecoder.uncompress = uncompressZIP;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZIP_COMPRESSION':\n\t\t\t\t\tEXRDecoder.blockHeight = 16;\n\t\t\t\t\tEXRDecoder.uncompress = uncompressZIP;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PIZ_COMPRESSION':\n\t\t\t\t\tEXRDecoder.blockHeight = 32;\n\t\t\t\t\tEXRDecoder.uncompress = uncompressPIZ;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PXR24_COMPRESSION':\n\t\t\t\t\tEXRDecoder.blockHeight = 16;\n\t\t\t\t\tEXRDecoder.uncompress = uncompressPXR;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DWAA_COMPRESSION':\n\t\t\t\t\tEXRDecoder.blockHeight = 32;\n\t\t\t\t\tEXRDecoder.uncompress = uncompressDWA;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DWAB_COMPRESSION':\n\t\t\t\t\tEXRDecoder.blockHeight = 256;\n\t\t\t\t\tEXRDecoder.uncompress = uncompressDWA;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported' );\n\n\t\t\t}\n\n\t\t\tconst channels = {};\n\t\t\tfor ( const channel of EXRHeader.channels ) {\n\n\t\t\t\tswitch ( channel.name ) {\n\n\t\t\t\t\tcase 'Y':\n\t\t\t\t\tcase 'R':\n\t\t\t\t\tcase 'G':\n\t\t\t\t\tcase 'B':\n\t\t\t\t\tcase 'A':\n\t\t\t\t\t\tchannels[ channel.name ] = true;\n\t\t\t\t\t\tEXRDecoder.type = channel.pixelType;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// RGB images will be converted to RGBA format, preventing software emulation in select devices.\n\t\t\tlet fillAlpha = false;\n\n\t\t\tif ( channels.R && channels.G && channels.B ) {\n\n\t\t\t\tfillAlpha = ! channels.A;\n\t\t\t\tEXRDecoder.outputChannels = 4;\n\t\t\t\tEXRDecoder.decodeChannels = { R: 0, G: 1, B: 2, A: 3 };\n\n\t\t\t} else if ( channels.Y ) {\n\n\t\t\t\tEXRDecoder.outputChannels = 1;\n\t\t\t\tEXRDecoder.decodeChannels = { Y: 0 };\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'EXRLoader.parse: file contains unsupported data channels.' );\n\n\t\t\t}\n\n\t\t\tif ( EXRDecoder.type == 1 ) {\n\n\t\t\t\t// half\n\t\t\t\tswitch ( outputType ) {\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tEXRDecoder.getter = parseFloat16;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tEXRDecoder.getter = parseUint16;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else if ( EXRDecoder.type == 2 ) {\n\n\t\t\t\t// float\n\t\t\t\tswitch ( outputType ) {\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tEXRDecoder.getter = parseFloat32;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tEXRDecoder.getter = decodeFloat32;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.' );\n\n\t\t\t}\n\n\t\t\tEXRDecoder.columns = EXRDecoder.width;\n\t\t\tconst size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels;\n\n\t\t\tswitch ( outputType ) {\n\n\t\t\t\tcase FloatType:\n\t\t\t\t\tEXRDecoder.byteArray = new Float32Array( size );\n\n\t\t\t\t\t// Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n\t\t\t\t\tif ( fillAlpha )\n\t\t\t\t\t\tEXRDecoder.byteArray.fill( 1, 0, size );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase HalfFloatType:\n\t\t\t\t\tEXRDecoder.byteArray = new Uint16Array( size );\n\n\t\t\t\t\tif ( fillAlpha )\n\t\t\t\t\t\tEXRDecoder.byteArray.fill( 0x3C00, 0, size ); // Uint16Array holds half float data, 0x3C00 is 1\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.error( 'THREE.EXRLoader: unsupported type: ', outputType );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tlet byteOffset = 0;\n\t\t\tfor ( const channel of EXRHeader.channels ) {\n\n\t\t\t\tif ( EXRDecoder.decodeChannels[ channel.name ] !== undefined ) {\n\n\t\t\t\t\tEXRDecoder.channelByteOffsets[ channel.name ] = byteOffset;\n\n\t\t\t\t}\n\n\t\t\t\tbyteOffset += channel.pixelType * 2;\n\n\t\t\t}\n\n\t\t\tEXRDecoder.totalBytes = byteOffset;\n\t\t\tEXRDecoder.outLineWidth = EXRDecoder.width * EXRDecoder.outputChannels;\n\n\t\t\tif ( EXRHeader.lineOrder === 'INCREASING_Y' ) {\n\n\t\t\t\tEXRDecoder.scanOrder = ( y ) => y;\n\n\t\t\t} else {\n\n\t\t\t\tEXRDecoder.scanOrder = ( y ) => EXRDecoder.height - 1 - y;\n\n\t\t\t}\n\n\t\t\tif ( EXRDecoder.outputChannels == 4 ) {\n\n\t\t\t\tEXRDecoder.format = RGBAFormat;\n\t\t\t\tEXRDecoder.colorSpace = LinearSRGBColorSpace;\n\n\t\t\t} else {\n\n\t\t\t\tEXRDecoder.format = RedFormat;\n\t\t\t\tEXRDecoder.colorSpace = NoColorSpace;\n\n\t\t\t}\n\n\t\t\tif ( EXRHeader.spec.singleTile ) {\n\n\t\t\t\tEXRDecoder.blockHeight = EXRHeader.tiles.ySize;\n\t\t\t\tEXRDecoder.blockWidth = EXRHeader.tiles.xSize;\n\n\t\t\t\tconst numXLevels = calculateTileLevels( EXRHeader.tiles, EXRDecoder.width, EXRDecoder.height );\n\t\t\t\t// const numYLevels = calculateTileLevels( EXRHeader.tiles, EXRDecoder.width, EXRDecoder.height );\n\n\t\t\t\tconst numXTiles = calculateTiles( numXLevels, EXRDecoder.width, EXRHeader.tiles.xSize, EXRHeader.tiles.roundingMode );\n\t\t\t\tconst numYTiles = calculateTiles( numXLevels, EXRDecoder.height, EXRHeader.tiles.ySize, EXRHeader.tiles.roundingMode );\n\n\t\t\t\tEXRDecoder.tileCount = numXTiles[ 0 ] * numYTiles[ 0 ];\n\n\t\t\t\tfor ( let l = 0; l < numXLevels; l ++ )\n\t\t\t\t\tfor ( let y = 0; y < numYTiles[ l ]; y ++ )\n\t\t\t\t\t\tfor ( let x = 0; x < numXTiles[ l ]; x ++ )\n\t\t\t\t\t\t\tparseInt64( dataView, offset ); // tileOffset\n\n\t\t\t\tEXRDecoder.decode = parseTiles.bind( EXRDecoder );\n\n\t\t\t} else {\n\n\t\t\t\tEXRDecoder.blockWidth = EXRDecoder.width;\n\t\t\t\tconst blockCount = Math.ceil( EXRDecoder.height / EXRDecoder.blockHeight );\n\n\t\t\t\tfor ( let i = 0; i < blockCount; i ++ )\n\t\t\t\t\tparseInt64( dataView, offset ); // scanlineOffset\n\n\t\t\t\tEXRDecoder.decode = parseScanline.bind( EXRDecoder );\n\n\t\t\t}\n\n\t\t\treturn EXRDecoder;\n\n\t\t}\n\n\t\t// start parsing file [START]\n\t\tconst offset = { value: 0 };\n\t\tconst bufferDataView = new DataView( buffer );\n\t\tconst uInt8Array = new Uint8Array( buffer );\n\n\t\t// get header information and validate format.\n\t\tconst EXRHeader = parseHeader( bufferDataView, buffer, offset );\n\n\t\t// get input compression information and prepare decoding.\n\t\tconst EXRDecoder = setupDecoder( EXRHeader, bufferDataView, uInt8Array, offset, this.type );\n\n\t\t// parse input data\n\t\tEXRDecoder.decode();\n\n\t\treturn {\n\t\t\theader: EXRHeader,\n\t\t\twidth: EXRDecoder.width,\n\t\t\theight: EXRDecoder.height,\n\t\t\tdata: EXRDecoder.byteArray,\n\t\t\tformat: EXRDecoder.format,\n\t\t\tcolorSpace: EXRDecoder.colorSpace,\n\t\t\ttype: this.type,\n\t\t};\n\n\t}\n\n\t/**\n\t * Sets the texture type.\n\t *\n\t * @param {(HalfFloatType|FloatType)} value - The texture type to set.\n\t * @return {RGBMLoader} A reference to this loader.\n\t */\n\tsetDataType( value ) {\n\n\t\tthis.type = value;\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tfunction onLoadCallback( texture, texData ) {\n\n\t\t\ttexture.colorSpace = texData.colorSpace;\n\t\t\ttexture.minFilter = LinearFilter;\n\t\t\ttexture.magFilter = LinearFilter;\n\t\t\ttexture.generateMipmaps = false;\n\t\t\ttexture.flipY = false;\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}\n\n\t\treturn super.load( url, onLoadCallback, onProgress, onError );\n\n\t}\n\n}\n\nexport { EXRLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}