{"ast":null,"code":"import { Group, Raycaster, Vector2 } from 'three';\nconst _pointer = new Vector2();\nconst _event = {\n  type: '',\n  data: _pointer\n};\n\n// The XR events that are mapped to \"standard\" pointer events.\nconst _events = {\n  'move': 'mousemove',\n  'select': 'click',\n  'selectstart': 'mousedown',\n  'selectend': 'mouseup'\n};\nconst _raycaster = new Raycaster();\n\n/**\n * This class can be used to group 3D objects in an interactive group.\n * The group itself can listen to Pointer, Mouse or XR controller events to\n * detect selections of descendant 3D objects. If a 3D object is selected,\n * the respective event is going to dispatched to it.\n *\n * ```js\n * const group = new InteractiveGroup();\n * group.listenToPointerEvents( renderer, camera );\n * group.listenToXRControllerEvents( controller1 );\n * group.listenToXRControllerEvents( controller2 );\n * scene.add( group );\n *\n * // now add objects that should be interactive\n * group.add( mesh1, mesh2, mesh3 );\n * ```\n * @augments Group\n * @three_import import { InteractiveGroup } from 'three/addons/interactive/InteractiveGroup.js';\n */\nclass InteractiveGroup extends Group {\n  constructor() {\n    super();\n\n    /**\n     * The internal raycaster.\n     *\n     * @type {Raycaster}\n     */\n    this.raycaster = new Raycaster();\n\n    /**\n     * The internal raycaster.\n     *\n     * @type {?HTMLDOMElement}\n     * @default null\n     */\n    this.element = null;\n\n    /**\n     * The camera used for raycasting.\n     *\n     * @type {?Camera}\n     * @default null\n     */\n    this.camera = null;\n\n    /**\n     * An array of XR controllers.\n     *\n     * @type {Array<Group>}\n     */\n    this.controllers = [];\n    this._onPointerEvent = this.onPointerEvent.bind(this);\n    this._onXRControllerEvent = this.onXRControllerEvent.bind(this);\n  }\n  onPointerEvent(event) {\n    event.stopPropagation();\n    const rect = this.element.getBoundingClientRect();\n    _pointer.x = (event.clientX - rect.left) / rect.width * 2 - 1;\n    _pointer.y = -(event.clientY - rect.top) / rect.height * 2 + 1;\n    this.raycaster.setFromCamera(_pointer, this.camera);\n    const intersects = this.raycaster.intersectObjects(this.children, false);\n    if (intersects.length > 0) {\n      const intersection = intersects[0];\n      const object = intersection.object;\n      const uv = intersection.uv;\n      _event.type = event.type;\n      _event.data.set(uv.x, 1 - uv.y);\n      object.dispatchEvent(_event);\n    }\n  }\n  onXRControllerEvent(event) {\n    const controller = event.target;\n    _raycaster.setFromXRController(controller);\n    const intersections = _raycaster.intersectObjects(this.children, false);\n    if (intersections.length > 0) {\n      const intersection = intersections[0];\n      const object = intersection.object;\n      const uv = intersection.uv;\n      _event.type = _events[event.type];\n      _event.data.set(uv.x, 1 - uv.y);\n      object.dispatchEvent(_event);\n    }\n  }\n\n  /**\n   * Calling this method makes sure the interactive group listens to Pointer and Mouse events.\n   * The target is the `domElement` of the given renderer. The camera is required for the internal\n   * raycasting so 3D objects can be detected based on the events.\n   *\n   * @param {(WebGPURenderer|WebGLRenderer)} renderer - The renderer.\n   * @param {Camera} camera - The camera.\n   */\n  listenToPointerEvents(renderer, camera) {\n    this.camera = camera;\n    this.element = renderer.domElement;\n    this.element.addEventListener('pointerdown', this._onPointerEvent);\n    this.element.addEventListener('pointerup', this._onPointerEvent);\n    this.element.addEventListener('pointermove', this._onPointerEvent);\n    this.element.addEventListener('mousedown', this._onPointerEvent);\n    this.element.addEventListener('mouseup', this._onPointerEvent);\n    this.element.addEventListener('mousemove', this._onPointerEvent);\n    this.element.addEventListener('click', this._onPointerEvent);\n  }\n\n  /**\n   * Disconnects this interactive group from all Pointer and Mouse Events.\n   */\n  disconnectionPointerEvents() {\n    if (this.element !== null) {\n      this.element.removeEventListener('pointerdown', this._onPointerEvent);\n      this.element.removeEventListener('pointerup', this._onPointerEvent);\n      this.element.removeEventListener('pointermove', this._onPointerEvent);\n      this.element.removeEventListener('mousedown', this._onPointerEvent);\n      this.element.removeEventListener('mouseup', this._onPointerEvent);\n      this.element.removeEventListener('mousemove', this._onPointerEvent);\n      this.element.removeEventListener('click', this._onPointerEvent);\n    }\n  }\n\n  /**\n   * Calling this method makes sure the interactive group listens to events of\n   * the given XR controller.\n   *\n   * @param {Group} controller - The XR controller.\n   */\n  listenToXRControllerEvents(controller) {\n    this.controllers.push(controller);\n    controller.addEventListener('move', this._onXRControllerEvent);\n    controller.addEventListener('select', this._onXRControllerEvent);\n    controller.addEventListener('selectstart', this._onXRControllerEvent);\n    controller.addEventListener('selectend', this._onXRControllerEvent);\n  }\n\n  /**\n   * Disconnects this interactive group from all XR controllers.\n   */\n  disconnectXrControllerEvents() {\n    for (const controller of this.controllers) {\n      controller.removeEventListener('move', this._onXRControllerEvent);\n      controller.removeEventListener('select', this._onXRControllerEvent);\n      controller.removeEventListener('selectstart', this._onXRControllerEvent);\n      controller.removeEventListener('selectend', this._onXRControllerEvent);\n    }\n  }\n\n  /**\n   * Disconnects this interactive group from the DOM and all XR controllers.\n   */\n  disconnect() {\n    this.disconnectionPointerEvents();\n    this.disconnectXrControllerEvents();\n    this.camera = null;\n    this.element = null;\n    this.controllers = [];\n  }\n}\nexport { InteractiveGroup };","map":{"version":3,"names":["Group","Raycaster","Vector2","_pointer","_event","type","data","_events","_raycaster","InteractiveGroup","constructor","raycaster","element","camera","controllers","_onPointerEvent","onPointerEvent","bind","_onXRControllerEvent","onXRControllerEvent","event","stopPropagation","rect","getBoundingClientRect","x","clientX","left","width","y","clientY","top","height","setFromCamera","intersects","intersectObjects","children","length","intersection","object","uv","set","dispatchEvent","controller","target","setFromXRController","intersections","listenToPointerEvents","renderer","domElement","addEventListener","disconnectionPointerEvents","removeEventListener","listenToXRControllerEvents","push","disconnectXrControllerEvents","disconnect"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/interactive/InteractiveGroup.js"],"sourcesContent":["import {\n\tGroup,\n\tRaycaster,\n\tVector2\n} from 'three';\n\nconst _pointer = new Vector2();\nconst _event = { type: '', data: _pointer };\n\n// The XR events that are mapped to \"standard\" pointer events.\nconst _events = {\n\t'move': 'mousemove',\n\t'select': 'click',\n\t'selectstart': 'mousedown',\n\t'selectend': 'mouseup'\n};\n\nconst _raycaster = new Raycaster();\n\n/**\n * This class can be used to group 3D objects in an interactive group.\n * The group itself can listen to Pointer, Mouse or XR controller events to\n * detect selections of descendant 3D objects. If a 3D object is selected,\n * the respective event is going to dispatched to it.\n *\n * ```js\n * const group = new InteractiveGroup();\n * group.listenToPointerEvents( renderer, camera );\n * group.listenToXRControllerEvents( controller1 );\n * group.listenToXRControllerEvents( controller2 );\n * scene.add( group );\n *\n * // now add objects that should be interactive\n * group.add( mesh1, mesh2, mesh3 );\n * ```\n * @augments Group\n * @three_import import { InteractiveGroup } from 'three/addons/interactive/InteractiveGroup.js';\n */\nclass InteractiveGroup extends Group {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The internal raycaster.\n\t\t *\n\t\t * @type {Raycaster}\n\t\t */\n\t\tthis.raycaster = new Raycaster();\n\n\t\t/**\n\t\t * The internal raycaster.\n\t\t *\n\t\t * @type {?HTMLDOMElement}\n\t\t * @default null\n\t\t */\n\t\tthis.element = null;\n\n\t\t/**\n\t\t * The camera used for raycasting.\n\t\t *\n\t\t * @type {?Camera}\n\t\t * @default null\n\t\t */\n\t\tthis.camera = null;\n\n\t\t/**\n\t\t * An array of XR controllers.\n\t\t *\n\t\t * @type {Array<Group>}\n\t\t */\n\t\tthis.controllers = [];\n\n\t\tthis._onPointerEvent = this.onPointerEvent.bind( this );\n\t\tthis._onXRControllerEvent = this.onXRControllerEvent.bind( this );\n\n\t}\n\n\tonPointerEvent( event ) {\n\n\t\tevent.stopPropagation();\n\n\t\tconst rect = this.element.getBoundingClientRect();\n\n\t\t_pointer.x = ( event.clientX - rect.left ) / rect.width * 2 - 1;\n\t\t_pointer.y = - ( event.clientY - rect.top ) / rect.height * 2 + 1;\n\n\t\tthis.raycaster.setFromCamera( _pointer, this.camera );\n\n\t\tconst intersects = this.raycaster.intersectObjects( this.children, false );\n\n\t\tif ( intersects.length > 0 ) {\n\n\t\t\tconst intersection = intersects[ 0 ];\n\n\t\t\tconst object = intersection.object;\n\t\t\tconst uv = intersection.uv;\n\n\t\t\t_event.type = event.type;\n\t\t\t_event.data.set( uv.x, 1 - uv.y );\n\n\t\t\tobject.dispatchEvent( _event );\n\n\t\t}\n\n\t}\n\n\tonXRControllerEvent( event ) {\n\n\t\tconst controller = event.target;\n\n\t\t_raycaster.setFromXRController( controller );\n\n\t\tconst intersections = _raycaster.intersectObjects( this.children, false );\n\n\t\tif ( intersections.length > 0 ) {\n\n\t\t\tconst intersection = intersections[ 0 ];\n\n\t\t\tconst object = intersection.object;\n\t\t\tconst uv = intersection.uv;\n\n\t\t\t_event.type = _events[ event.type ];\n\t\t\t_event.data.set( uv.x, 1 - uv.y );\n\n\t\t\tobject.dispatchEvent( _event );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Calling this method makes sure the interactive group listens to Pointer and Mouse events.\n\t * The target is the `domElement` of the given renderer. The camera is required for the internal\n\t * raycasting so 3D objects can be detected based on the events.\n\t *\n\t * @param {(WebGPURenderer|WebGLRenderer)} renderer - The renderer.\n\t * @param {Camera} camera - The camera.\n\t */\n\tlistenToPointerEvents( renderer, camera ) {\n\n\t\tthis.camera = camera;\n\t\tthis.element = renderer.domElement;\n\n\t\tthis.element.addEventListener( 'pointerdown', this._onPointerEvent );\n\t\tthis.element.addEventListener( 'pointerup', this._onPointerEvent );\n\t\tthis.element.addEventListener( 'pointermove', this._onPointerEvent );\n\t\tthis.element.addEventListener( 'mousedown', this._onPointerEvent );\n\t\tthis.element.addEventListener( 'mouseup', this._onPointerEvent );\n\t\tthis.element.addEventListener( 'mousemove', this._onPointerEvent );\n\t\tthis.element.addEventListener( 'click', this._onPointerEvent );\n\n\t}\n\n\t/**\n\t * Disconnects this interactive group from all Pointer and Mouse Events.\n\t */\n\tdisconnectionPointerEvents() {\n\n\t\tif ( this.element !== null ) {\n\n\t\t\tthis.element.removeEventListener( 'pointerdown', this._onPointerEvent );\n\t\t\tthis.element.removeEventListener( 'pointerup', this._onPointerEvent );\n\t\t\tthis.element.removeEventListener( 'pointermove', this._onPointerEvent );\n\t\t\tthis.element.removeEventListener( 'mousedown', this._onPointerEvent );\n\t\t\tthis.element.removeEventListener( 'mouseup', this._onPointerEvent );\n\t\t\tthis.element.removeEventListener( 'mousemove', this._onPointerEvent );\n\t\t\tthis.element.removeEventListener( 'click', this._onPointerEvent );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Calling this method makes sure the interactive group listens to events of\n\t * the given XR controller.\n\t *\n\t * @param {Group} controller - The XR controller.\n\t */\n\tlistenToXRControllerEvents( controller ) {\n\n\t\tthis.controllers.push( controller );\n\t\tcontroller.addEventListener( 'move', this._onXRControllerEvent );\n\t\tcontroller.addEventListener( 'select', this._onXRControllerEvent );\n\t\tcontroller.addEventListener( 'selectstart', this._onXRControllerEvent );\n\t\tcontroller.addEventListener( 'selectend', this._onXRControllerEvent );\n\n\t}\n\n\t/**\n\t * Disconnects this interactive group from all XR controllers.\n\t */\n\tdisconnectXrControllerEvents() {\n\n\t\tfor ( const controller of this.controllers ) {\n\n\t\t\tcontroller.removeEventListener( 'move', this._onXRControllerEvent );\n\t\t\tcontroller.removeEventListener( 'select', this._onXRControllerEvent );\n\t\t\tcontroller.removeEventListener( 'selectstart', this._onXRControllerEvent );\n\t\t\tcontroller.removeEventListener( 'selectend', this._onXRControllerEvent );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Disconnects this interactive group from the DOM and all XR controllers.\n\t */\n\tdisconnect() {\n\n\t\tthis.disconnectionPointerEvents();\n\t\tthis.disconnectXrControllerEvents();\n\n\t\tthis.camera = null;\n\t\tthis.element = null;\n\n\t\tthis.controllers = [];\n\n\t}\n\n}\n\nexport { InteractiveGroup };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}