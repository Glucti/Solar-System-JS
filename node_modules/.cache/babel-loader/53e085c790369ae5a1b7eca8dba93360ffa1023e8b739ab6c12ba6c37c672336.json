{"ast":null,"code":"import { BufferAttribute, BufferGeometry, Color, FileLoader, Float32BufferAttribute, Loader, SRGBColorSpace } from 'three';\nimport * as fflate from '../libs/fflate.module.js';\n\n/**\n * A loader for the VTK format.\n *\n * This loader only supports the `POLYDATA` dataset format so far. Other formats\n * (structured points, structured grid, rectilinear grid, unstructured grid, appended)\n * are not supported.\n *\n * ```js\n * const loader = new VTKLoader();\n * const geometry = await loader.loadAsync( 'models/vtk/liver.vtk' );\n * geometry.computeVertexNormals();\n *\n * const mesh = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial() );\n * scene.add( mesh );\n * ```\n *\n * @augments Loader\n * @three_import import { VTKLoader } from 'three/addons/loaders/VTKLoader.js';\n */\nclass VTKLoader extends Loader {\n  /**\n   * Constructs a new VTK loader.\n   *\n   * @param {LoadingManager} [manager] - The loading manager.\n   */\n  constructor(manager) {\n    super(manager);\n  }\n\n  /**\n   * Starts loading from the given URL and passes the loaded VRML asset\n   * to the `onLoad()` callback.\n   *\n   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n   * @param {function(BufferGeometry)} onLoad - Executed when the loading process has been finished.\n   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n   * @param {onErrorCallback} onError - Executed when errors occur.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  /**\n   * Parses the given VTK data and returns the resulting geometry.\n   *\n   * @param {ArrayBuffer} data - The raw VTK data as an array buffer\n   * @return {BufferGeometry} The parsed geometry.\n   */\n  parse(data) {\n    function parseASCII(data) {\n      // connectivity of the triangles\n      const indices = [];\n\n      // triangles vertices\n      const positions = [];\n\n      // red, green, blue colors in the range 0 to 1\n      const colors = [];\n\n      // normal vector, one per vertex\n      const normals = [];\n      let result;\n\n      // pattern for detecting the end of a number sequence\n      const patWord = /^[^\\d.\\s-]+/;\n\n      // pattern for reading vertices, 3 floats or integers\n      const pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g;\n\n      // pattern for connectivity, an integer followed by any number of ints\n      // the first integer is the number of polygon nodes\n      const patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/;\n\n      // indicates start of vertex data section\n      const patPOINTS = /^POINTS /;\n\n      // indicates start of polygon connectivity section\n      const patPOLYGONS = /^POLYGONS /;\n\n      // indicates start of triangle strips section\n      const patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /;\n\n      // POINT_DATA number_of_values\n      const patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/;\n\n      // CELL_DATA number_of_polys\n      const patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/;\n\n      // Start of color section\n      const patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/;\n\n      // NORMALS Normals float\n      const patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\n      let inPointsSection = false;\n      let inPolygonsSection = false;\n      let inTriangleStripSection = false;\n      let inPointDataSection = false;\n      let inCellDataSection = false;\n      let inColorSection = false;\n      let inNormalsSection = false;\n      const color = new Color();\n      const lines = data.split('\\n');\n      for (const i in lines) {\n        const line = lines[i].trim();\n        if (line.indexOf('DATASET') === 0) {\n          const dataset = line.split(' ')[1];\n          if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset);\n        } else if (inPointsSection) {\n          // get the vertices\n          while ((result = pat3Floats.exec(line)) !== null) {\n            if (patWord.exec(line) !== null) break;\n            const x = parseFloat(result[1]);\n            const y = parseFloat(result[2]);\n            const z = parseFloat(result[3]);\n            positions.push(x, y, z);\n          }\n        } else if (inPolygonsSection) {\n          if ((result = patConnectivity.exec(line)) !== null) {\n            // numVertices i0 i1 i2 ...\n            const numVertices = parseInt(result[1]);\n            const inds = result[2].split(/\\s+/);\n            if (numVertices >= 3) {\n              const i0 = parseInt(inds[0]);\n              let k = 1;\n              // split the polygon in numVertices - 2 triangles\n              for (let j = 0; j < numVertices - 2; ++j) {\n                const i1 = parseInt(inds[k]);\n                const i2 = parseInt(inds[k + 1]);\n                indices.push(i0, i1, i2);\n                k++;\n              }\n            }\n          }\n        } else if (inTriangleStripSection) {\n          if ((result = patConnectivity.exec(line)) !== null) {\n            // numVertices i0 i1 i2 ...\n            const numVertices = parseInt(result[1]);\n            const inds = result[2].split(/\\s+/);\n            if (numVertices >= 3) {\n              // split the polygon in numVertices - 2 triangles\n              for (let j = 0; j < numVertices - 2; j++) {\n                if (j % 2 === 1) {\n                  const i0 = parseInt(inds[j]);\n                  const i1 = parseInt(inds[j + 2]);\n                  const i2 = parseInt(inds[j + 1]);\n                  indices.push(i0, i1, i2);\n                } else {\n                  const i0 = parseInt(inds[j]);\n                  const i1 = parseInt(inds[j + 1]);\n                  const i2 = parseInt(inds[j + 2]);\n                  indices.push(i0, i1, i2);\n                }\n              }\n            }\n          }\n        } else if (inPointDataSection || inCellDataSection) {\n          if (inColorSection) {\n            // Get the colors\n\n            while ((result = pat3Floats.exec(line)) !== null) {\n              if (patWord.exec(line) !== null) break;\n              const r = parseFloat(result[1]);\n              const g = parseFloat(result[2]);\n              const b = parseFloat(result[3]);\n              color.setRGB(r, g, b, SRGBColorSpace);\n              colors.push(color.r, color.g, color.b);\n            }\n          } else if (inNormalsSection) {\n            // Get the normal vectors\n\n            while ((result = pat3Floats.exec(line)) !== null) {\n              if (patWord.exec(line) !== null) break;\n              const nx = parseFloat(result[1]);\n              const ny = parseFloat(result[2]);\n              const nz = parseFloat(result[3]);\n              normals.push(nx, ny, nz);\n            }\n          }\n        }\n        if (patPOLYGONS.exec(line) !== null) {\n          inPolygonsSection = true;\n          inPointsSection = false;\n          inTriangleStripSection = false;\n        } else if (patPOINTS.exec(line) !== null) {\n          inPolygonsSection = false;\n          inPointsSection = true;\n          inTriangleStripSection = false;\n        } else if (patTRIANGLE_STRIPS.exec(line) !== null) {\n          inPolygonsSection = false;\n          inPointsSection = false;\n          inTriangleStripSection = true;\n        } else if (patPOINT_DATA.exec(line) !== null) {\n          inPointDataSection = true;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patCELL_DATA.exec(line) !== null) {\n          inCellDataSection = true;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patCOLOR_SCALARS.exec(line) !== null) {\n          inColorSection = true;\n          inNormalsSection = false;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        } else if (patNORMALS.exec(line) !== null) {\n          inNormalsSection = true;\n          inColorSection = false;\n          inPointsSection = false;\n          inPolygonsSection = false;\n          inTriangleStripSection = false;\n        }\n      }\n      let geometry = new BufferGeometry();\n      geometry.setIndex(indices);\n      geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n      if (normals.length === positions.length) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n      }\n      if (colors.length !== indices.length) {\n        // stagger\n\n        if (colors.length === positions.length) {\n          geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n        }\n      } else {\n        // cell\n\n        geometry = geometry.toNonIndexed();\n        const numTriangles = geometry.attributes.position.count / 3;\n        if (colors.length === numTriangles * 3) {\n          const newColors = [];\n          for (let i = 0; i < numTriangles; i++) {\n            const r = colors[3 * i + 0];\n            const g = colors[3 * i + 1];\n            const b = colors[3 * i + 2];\n            color.setRGB(r, g, b, SRGBColorSpace);\n            newColors.push(color.r, color.g, color.b);\n            newColors.push(color.r, color.g, color.b);\n            newColors.push(color.r, color.g, color.b);\n          }\n          geometry.setAttribute('color', new Float32BufferAttribute(newColors, 3));\n        }\n      }\n      return geometry;\n    }\n    function parseBinary(data) {\n      const buffer = new Uint8Array(data);\n      const dataView = new DataView(data);\n\n      // Points and normals, by default, are empty\n      let points = [];\n      let normals = [];\n      let indices = [];\n      let index = 0;\n      function findString(buffer, start) {\n        let index = start;\n        let c = buffer[index];\n        const s = [];\n        while (c !== 10) {\n          s.push(String.fromCharCode(c));\n          index++;\n          c = buffer[index];\n        }\n        return {\n          start: start,\n          end: index,\n          next: index + 1,\n          parsedString: s.join('')\n        };\n      }\n      let state, line;\n      while (true) {\n        // Get a string\n        state = findString(buffer, index);\n        line = state.parsedString;\n        if (line.indexOf('DATASET') === 0) {\n          const dataset = line.split(' ')[1];\n          if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset);\n        } else if (line.indexOf('POINTS') === 0) {\n          // Add the points\n          const numberOfPoints = parseInt(line.split(' ')[1], 10);\n\n          // Each point is 3 4-byte floats\n          const count = numberOfPoints * 4 * 3;\n          points = new Float32Array(numberOfPoints * 3);\n          let pointIndex = state.next;\n          for (let i = 0; i < numberOfPoints; i++) {\n            points[3 * i] = dataView.getFloat32(pointIndex, false);\n            points[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n            points[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n            pointIndex = pointIndex + 12;\n          }\n\n          // increment our next pointer\n          state.next = state.next + count + 1;\n        } else if (line.indexOf('TRIANGLE_STRIPS') === 0) {\n          const numberOfStrips = parseInt(line.split(' ')[1], 10);\n          const size = parseInt(line.split(' ')[2], 10);\n          // 4 byte integers\n          const count = size * 4;\n          indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n          let indicesIndex = 0;\n          let pointIndex = state.next;\n          for (let i = 0; i < numberOfStrips; i++) {\n            // For each strip, read the first value, then record that many more points\n            const indexCount = dataView.getInt32(pointIndex, false);\n            const strip = [];\n            pointIndex += 4;\n            for (let s = 0; s < indexCount; s++) {\n              strip.push(dataView.getInt32(pointIndex, false));\n              pointIndex += 4;\n            }\n\n            // retrieves the n-2 triangles from the triangle strip\n            for (let j = 0; j < indexCount - 2; j++) {\n              if (j % 2) {\n                indices[indicesIndex++] = strip[j];\n                indices[indicesIndex++] = strip[j + 2];\n                indices[indicesIndex++] = strip[j + 1];\n              } else {\n                indices[indicesIndex++] = strip[j];\n                indices[indicesIndex++] = strip[j + 1];\n                indices[indicesIndex++] = strip[j + 2];\n              }\n            }\n          }\n\n          // increment our next pointer\n          state.next = state.next + count + 1;\n        } else if (line.indexOf('POLYGONS') === 0) {\n          const numberOfStrips = parseInt(line.split(' ')[1], 10);\n          const size = parseInt(line.split(' ')[2], 10);\n          // 4 byte integers\n          const count = size * 4;\n          indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n          let indicesIndex = 0;\n          let pointIndex = state.next;\n          for (let i = 0; i < numberOfStrips; i++) {\n            // For each strip, read the first value, then record that many more points\n            const indexCount = dataView.getInt32(pointIndex, false);\n            const strip = [];\n            pointIndex += 4;\n            for (let s = 0; s < indexCount; s++) {\n              strip.push(dataView.getInt32(pointIndex, false));\n              pointIndex += 4;\n            }\n\n            // divide the polygon in n-2 triangle\n            for (let j = 1; j < indexCount - 1; j++) {\n              indices[indicesIndex++] = strip[0];\n              indices[indicesIndex++] = strip[j];\n              indices[indicesIndex++] = strip[j + 1];\n            }\n          }\n\n          // increment our next pointer\n          state.next = state.next + count + 1;\n        } else if (line.indexOf('POINT_DATA') === 0) {\n          const numberOfPoints = parseInt(line.split(' ')[1], 10);\n\n          // Grab the next line\n          state = findString(buffer, state.next);\n\n          // Now grab the binary data\n          const count = numberOfPoints * 4 * 3;\n          normals = new Float32Array(numberOfPoints * 3);\n          let pointIndex = state.next;\n          for (let i = 0; i < numberOfPoints; i++) {\n            normals[3 * i] = dataView.getFloat32(pointIndex, false);\n            normals[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n            normals[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n            pointIndex += 12;\n          }\n\n          // Increment past our data\n          state.next = state.next + count;\n        }\n\n        // Increment index\n        index = state.next;\n        if (index >= buffer.byteLength) {\n          break;\n        }\n      }\n      const geometry = new BufferGeometry();\n      geometry.setIndex(new BufferAttribute(indices, 1));\n      geometry.setAttribute('position', new BufferAttribute(points, 3));\n      if (normals.length === points.length) {\n        geometry.setAttribute('normal', new BufferAttribute(normals, 3));\n      }\n      return geometry;\n    }\n    function Float32Concat(first, second) {\n      const firstLength = first.length,\n        result = new Float32Array(firstLength + second.length);\n      result.set(first);\n      result.set(second, firstLength);\n      return result;\n    }\n    function Int32Concat(first, second) {\n      const firstLength = first.length,\n        result = new Int32Array(firstLength + second.length);\n      result.set(first);\n      result.set(second, firstLength);\n      return result;\n    }\n    function parseXML(stringFile) {\n      // Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json\n\n      function xmlToJson(xml) {\n        // Create the return object\n        let obj = {};\n        if (xml.nodeType === 1) {\n          // element\n\n          // do attributes\n\n          if (xml.attributes) {\n            if (xml.attributes.length > 0) {\n              obj['attributes'] = {};\n              for (let j = 0; j < xml.attributes.length; j++) {\n                const attribute = xml.attributes.item(j);\n                obj['attributes'][attribute.nodeName] = attribute.nodeValue.trim();\n              }\n            }\n          }\n        } else if (xml.nodeType === 3) {\n          // text\n\n          obj = xml.nodeValue.trim();\n        }\n\n        // do children\n        if (xml.hasChildNodes()) {\n          for (let i = 0; i < xml.childNodes.length; i++) {\n            const item = xml.childNodes.item(i);\n            const nodeName = item.nodeName;\n            if (typeof obj[nodeName] === 'undefined') {\n              const tmp = xmlToJson(item);\n              if (tmp !== '') {\n                if (Array.isArray(tmp['#text'])) {\n                  tmp['#text'] = tmp['#text'][0];\n                }\n                obj[nodeName] = tmp;\n              }\n            } else {\n              if (typeof obj[nodeName].push === 'undefined') {\n                const old = obj[nodeName];\n                obj[nodeName] = [old];\n              }\n              const tmp = xmlToJson(item);\n              if (tmp !== '') {\n                if (Array.isArray(tmp['#text'])) {\n                  tmp['#text'] = tmp['#text'][0];\n                }\n                obj[nodeName].push(tmp);\n              }\n            }\n          }\n        }\n        return obj;\n      }\n\n      // Taken from Base64-js\n      function Base64toByteArray(b64) {\n        const Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n        const revLookup = [];\n        const code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n        for (let i = 0, l = code.length; i < l; ++i) {\n          revLookup[code.charCodeAt(i)] = i;\n        }\n        revLookup['-'.charCodeAt(0)] = 62;\n        revLookup['_'.charCodeAt(0)] = 63;\n        const len = b64.length;\n        if (len % 4 > 0) {\n          throw new Error('Invalid string. Length must be a multiple of 4');\n        }\n        const placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n        const arr = new Arr(len * 3 / 4 - placeHolders);\n        const l = placeHolders > 0 ? len - 4 : len;\n        let L = 0;\n        let i, j;\n        for (i = 0, j = 0; i < l; i += 4, j += 3) {\n          const tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n          arr[L++] = (tmp & 0xFF0000) >> 16;\n          arr[L++] = (tmp & 0xFF00) >> 8;\n          arr[L++] = tmp & 0xFF;\n        }\n        if (placeHolders === 2) {\n          const tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n          arr[L++] = tmp & 0xFF;\n        } else if (placeHolders === 1) {\n          const tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n          arr[L++] = tmp >> 8 & 0xFF;\n          arr[L++] = tmp & 0xFF;\n        }\n        return arr;\n      }\n      function parseDataArray(ele, compressed) {\n        let numBytes = 0;\n        if (json.attributes.header_type === 'UInt64') {\n          numBytes = 8;\n        } else if (json.attributes.header_type === 'UInt32') {\n          numBytes = 4;\n        }\n        let txt, content;\n\n        // Check the format\n        if (ele.attributes.format === 'binary' && compressed) {\n          if (ele.attributes.type === 'Float32') {\n            txt = new Float32Array();\n          } else if (ele.attributes.type === 'Int32' || ele.attributes.type === 'Int64') {\n            txt = new Int32Array();\n          }\n\n          // VTP data with the header has the following structure:\n          // [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]\n          //\n          // Each token is an integer value whose type is specified by \"header_type\" at the top of the file (UInt32 if no type specified). The token meanings are:\n          // [#blocks] = Number of blocks\n          // [#u-size] = Block size before compression\n          // [#p-size] = Size of last partial block (zero if it not needed)\n          // [#c-size-i] = Size in bytes of block i after compression\n          //\n          // The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is\n          // computed by summing the compressed block sizes from preceding blocks according to the header.\n\n          const textNode = ele['#text'];\n          const rawData = Array.isArray(textNode) ? textNode[0] : textNode;\n          const byteData = Base64toByteArray(rawData);\n\n          // Each data point consists of 8 bits regardless of the header type\n          const dataPointSize = 8;\n          let blocks = byteData[0];\n          for (let i = 1; i < numBytes - 1; i++) {\n            blocks = blocks | byteData[i] << i * dataPointSize;\n          }\n          let headerSize = (blocks + 3) * numBytes;\n          const padding = headerSize % 3 > 0 ? 3 - headerSize % 3 : 0;\n          headerSize = headerSize + padding;\n          const dataOffsets = [];\n          let currentOffset = headerSize;\n          dataOffsets.push(currentOffset);\n\n          // Get the blocks sizes after the compression.\n          // There are three blocks before c-size-i, so we skip 3*numBytes\n          const cSizeStart = 3 * numBytes;\n          for (let i = 0; i < blocks; i++) {\n            let currentBlockSize = byteData[i * numBytes + cSizeStart];\n            for (let j = 1; j < numBytes - 1; j++) {\n              currentBlockSize = currentBlockSize | byteData[i * numBytes + cSizeStart + j] << j * dataPointSize;\n            }\n            currentOffset = currentOffset + currentBlockSize;\n            dataOffsets.push(currentOffset);\n          }\n          for (let i = 0; i < dataOffsets.length - 1; i++) {\n            const data = fflate.unzlibSync(byteData.slice(dataOffsets[i], dataOffsets[i + 1]));\n            content = data.buffer;\n            if (ele.attributes.type === 'Float32') {\n              content = new Float32Array(content);\n              txt = Float32Concat(txt, content);\n            } else if (ele.attributes.type === 'Int32' || ele.attributes.type === 'Int64') {\n              content = new Int32Array(content);\n              txt = Int32Concat(txt, content);\n            }\n          }\n          delete ele['#text'];\n          if (ele.attributes.type === 'Int64') {\n            if (ele.attributes.format === 'binary') {\n              txt = txt.filter(function (el, idx) {\n                if (idx % 2 !== 1) return true;\n              });\n            }\n          }\n        } else {\n          if (ele.attributes.format === 'binary' && !compressed) {\n            content = Base64toByteArray(ele['#text']);\n\n            //  VTP data for the uncompressed case has the following structure:\n            // [#bytes][DATA]\n            // where \"[#bytes]\" is an integer value specifying the number of bytes in the block of data following it.\n            content = content.slice(numBytes).buffer;\n          } else {\n            if (ele['#text']) {\n              content = ele['#text'].split(/\\s+/).filter(function (el) {\n                if (el !== '') return el;\n              });\n            } else {\n              content = new Int32Array(0).buffer;\n            }\n          }\n          delete ele['#text'];\n\n          // Get the content and optimize it\n          if (ele.attributes.type === 'Float32') {\n            txt = new Float32Array(content);\n          } else if (ele.attributes.type === 'Int32') {\n            txt = new Int32Array(content);\n          } else if (ele.attributes.type === 'Int64') {\n            txt = new Int32Array(content);\n            if (ele.attributes.format === 'binary') {\n              txt = txt.filter(function (el, idx) {\n                if (idx % 2 !== 1) return true;\n              });\n            }\n          }\n        } // endif ( ele.attributes.format === 'binary' && compressed )\n\n        return txt;\n      }\n\n      // Main part\n      // Get Dom\n      const dom = new DOMParser().parseFromString(stringFile, 'application/xml');\n\n      // Get the doc\n      const doc = dom.documentElement;\n      // Convert to json\n      const json = xmlToJson(doc);\n      let points = [];\n      let normals = [];\n      let indices = [];\n      if (json.AppendedData) {\n        const appendedData = json.AppendedData['#text'].slice(1);\n        const piece = json.PolyData.Piece;\n        const sections = ['PointData', 'CellData', 'Points', 'Verts', 'Lines', 'Strips', 'Polys'];\n        let sectionIndex = 0;\n        const offsets = sections.map(s => {\n          const sect = piece[s];\n          if (sect && sect.DataArray) {\n            const arr = Array.isArray(sect.DataArray) ? sect.DataArray : [sect.DataArray];\n            return arr.map(a => a.attributes.offset);\n          }\n          return [];\n        }).flat();\n        for (const sect of sections) {\n          const section = piece[sect];\n          if (section && section.DataArray) {\n            if (Array.isArray(section.DataArray)) {\n              for (const sectionEle of section.DataArray) {\n                sectionEle['#text'] = appendedData.slice(offsets[sectionIndex], offsets[sectionIndex + 1]);\n                sectionEle.attributes.format = 'binary';\n                sectionIndex++;\n              }\n            } else {\n              section.DataArray['#text'] = appendedData.slice(offsets[sectionIndex], offsets[sectionIndex + 1]);\n              section.DataArray.attributes.format = 'binary';\n              sectionIndex++;\n            }\n          }\n        }\n      }\n      if (json.PolyData) {\n        const piece = json.PolyData.Piece;\n        const compressed = json.attributes.hasOwnProperty('compressor');\n\n        // Can be optimized\n        // Loop through the sections\n        const sections = ['PointData', 'Points', 'Strips', 'Polys']; // +['CellData', 'Verts', 'Lines'];\n        let sectionIndex = 0;\n        const numberOfSections = sections.length;\n        while (sectionIndex < numberOfSections) {\n          const section = piece[sections[sectionIndex]];\n\n          // If it has a DataArray in it\n\n          if (section && section.DataArray) {\n            // Depending on the number of DataArrays\n\n            let arr;\n            if (Array.isArray(section.DataArray)) {\n              arr = section.DataArray;\n            } else {\n              arr = [section.DataArray];\n            }\n            let dataArrayIndex = 0;\n            const numberOfDataArrays = arr.length;\n            while (dataArrayIndex < numberOfDataArrays) {\n              // Parse the DataArray\n              if ('#text' in arr[dataArrayIndex] && arr[dataArrayIndex]['#text'].length > 0) {\n                arr[dataArrayIndex].text = parseDataArray(arr[dataArrayIndex], compressed);\n              }\n              dataArrayIndex++;\n            }\n            switch (sections[sectionIndex]) {\n              // if iti is point data\n              case 'PointData':\n                {\n                  const numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n                  const normalsName = section.attributes.Normals;\n                  if (numberOfPoints > 0) {\n                    for (let i = 0, len = arr.length; i < len; i++) {\n                      if (normalsName === arr[i].attributes.Name) {\n                        const components = arr[i].attributes.NumberOfComponents;\n                        normals = new Float32Array(numberOfPoints * components);\n                        normals.set(arr[i].text, 0);\n                      }\n                    }\n                  }\n                }\n                break;\n\n              // if it is points\n              case 'Points':\n                {\n                  const numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n                  if (numberOfPoints > 0) {\n                    const components = section.DataArray.attributes.NumberOfComponents;\n                    points = new Float32Array(numberOfPoints * components);\n                    points.set(section.DataArray.text, 0);\n                  }\n                }\n                break;\n\n              // if it is strips\n              case 'Strips':\n                {\n                  const numberOfStrips = parseInt(piece.attributes.NumberOfStrips);\n                  if (numberOfStrips > 0) {\n                    const connectivity = new Int32Array(section.DataArray[0].text.length);\n                    const offset = new Int32Array(section.DataArray[1].text.length);\n                    connectivity.set(section.DataArray[0].text, 0);\n                    offset.set(section.DataArray[1].text, 0);\n                    const size = numberOfStrips + connectivity.length;\n                    indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n                    let indicesIndex = 0;\n                    for (let i = 0, len = numberOfStrips; i < len; i++) {\n                      const strip = [];\n                      for (let s = 0, len1 = offset[i], len0 = 0; s < len1 - len0; s++) {\n                        strip.push(connectivity[s]);\n                        if (i > 0) len0 = offset[i - 1];\n                      }\n                      for (let j = 0, len1 = offset[i], len0 = 0; j < len1 - len0 - 2; j++) {\n                        if (j % 2) {\n                          indices[indicesIndex++] = strip[j];\n                          indices[indicesIndex++] = strip[j + 2];\n                          indices[indicesIndex++] = strip[j + 1];\n                        } else {\n                          indices[indicesIndex++] = strip[j];\n                          indices[indicesIndex++] = strip[j + 1];\n                          indices[indicesIndex++] = strip[j + 2];\n                        }\n                        if (i > 0) len0 = offset[i - 1];\n                      }\n                    }\n                  }\n                }\n                break;\n\n              // if it is polys\n              case 'Polys':\n                {\n                  const numberOfPolys = parseInt(piece.attributes.NumberOfPolys);\n                  if (numberOfPolys > 0) {\n                    const connectivity = new Int32Array(section.DataArray[0].text.length);\n                    const offset = new Int32Array(section.DataArray[1].text.length);\n                    connectivity.set(section.DataArray[0].text, 0);\n                    offset.set(section.DataArray[1].text, 0);\n                    const size = numberOfPolys + connectivity.length;\n                    indices = new Uint32Array(3 * size - 9 * numberOfPolys);\n                    let indicesIndex = 0,\n                      connectivityIndex = 0;\n                    let i = 0,\n                      len0 = 0;\n                    const len = numberOfPolys;\n                    while (i < len) {\n                      const poly = [];\n                      let s = 0;\n                      const len1 = offset[i];\n                      while (s < len1 - len0) {\n                        poly.push(connectivity[connectivityIndex++]);\n                        s++;\n                      }\n                      let j = 1;\n                      while (j < len1 - len0 - 1) {\n                        indices[indicesIndex++] = poly[0];\n                        indices[indicesIndex++] = poly[j];\n                        indices[indicesIndex++] = poly[j + 1];\n                        j++;\n                      }\n                      i++;\n                      len0 = offset[i - 1];\n                    }\n                  }\n                }\n                break;\n              default:\n                break;\n            }\n          }\n          sectionIndex++;\n        }\n        const geometry = new BufferGeometry();\n        geometry.setIndex(new BufferAttribute(indices, 1));\n        geometry.setAttribute('position', new BufferAttribute(points, 3));\n        if (normals.length === points.length) {\n          geometry.setAttribute('normal', new BufferAttribute(normals, 3));\n        }\n        return geometry;\n      } else {\n        throw new Error('Unsupported DATASET type');\n      }\n    }\n    const textDecoder = new TextDecoder();\n\n    // get the 5 first lines of the files to check if there is the key word binary\n    const meta = textDecoder.decode(new Uint8Array(data, 0, 250)).split('\\n');\n    if (meta[0].indexOf('xml') !== -1) {\n      return parseXML(textDecoder.decode(data));\n    } else if (meta[2].includes('ASCII')) {\n      return parseASCII(textDecoder.decode(data));\n    } else {\n      return parseBinary(data);\n    }\n  }\n}\nexport { VTKLoader };","map":{"version":3,"names":["BufferAttribute","BufferGeometry","Color","FileLoader","Float32BufferAttribute","Loader","SRGBColorSpace","fflate","VTKLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","data","parseASCII","indices","positions","colors","normals","result","patWord","pat3Floats","patConnectivity","patPOINTS","patPOLYGONS","patTRIANGLE_STRIPS","patPOINT_DATA","patCELL_DATA","patCOLOR_SCALARS","patNORMALS","inPointsSection","inPolygonsSection","inTriangleStripSection","inPointDataSection","inCellDataSection","inColorSection","inNormalsSection","color","lines","split","i","line","trim","indexOf","dataset","Error","exec","x","parseFloat","y","z","push","numVertices","parseInt","inds","i0","k","j","i1","i2","r","g","b","setRGB","nx","ny","nz","geometry","setIndex","setAttribute","length","toNonIndexed","numTriangles","attributes","position","count","newColors","parseBinary","buffer","Uint8Array","dataView","DataView","points","index","findString","start","c","s","String","fromCharCode","end","next","parsedString","join","state","numberOfPoints","Float32Array","pointIndex","getFloat32","numberOfStrips","size","Uint32Array","indicesIndex","indexCount","getInt32","strip","byteLength","Float32Concat","first","second","firstLength","set","Int32Concat","Int32Array","parseXML","stringFile","xmlToJson","xml","obj","nodeType","attribute","item","nodeName","nodeValue","hasChildNodes","childNodes","tmp","Array","isArray","old","Base64toByteArray","b64","Arr","revLookup","code","l","charCodeAt","len","placeHolders","arr","L","parseDataArray","ele","compressed","numBytes","json","header_type","txt","content","format","type","textNode","rawData","byteData","dataPointSize","blocks","headerSize","padding","dataOffsets","currentOffset","cSizeStart","currentBlockSize","unzlibSync","slice","filter","el","idx","dom","DOMParser","parseFromString","doc","documentElement","AppendedData","appendedData","piece","PolyData","Piece","sections","sectionIndex","offsets","map","sect","DataArray","a","offset","flat","section","sectionEle","hasOwnProperty","numberOfSections","dataArrayIndex","numberOfDataArrays","NumberOfPoints","normalsName","Normals","Name","components","NumberOfComponents","NumberOfStrips","connectivity","len1","len0","numberOfPolys","NumberOfPolys","connectivityIndex","poly","textDecoder","TextDecoder","meta","decode","includes"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/loaders/VTKLoader.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tColor,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tLoader,\n\tSRGBColorSpace\n} from 'three';\nimport * as fflate from '../libs/fflate.module.js';\n\n/**\n * A loader for the VTK format.\n *\n * This loader only supports the `POLYDATA` dataset format so far. Other formats\n * (structured points, structured grid, rectilinear grid, unstructured grid, appended)\n * are not supported.\n *\n * ```js\n * const loader = new VTKLoader();\n * const geometry = await loader.loadAsync( 'models/vtk/liver.vtk' );\n * geometry.computeVertexNormals();\n *\n * const mesh = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial() );\n * scene.add( mesh );\n * ```\n *\n * @augments Loader\n * @three_import import { VTKLoader } from 'three/addons/loaders/VTKLoader.js';\n */\nclass VTKLoader extends Loader {\n\n\t/**\n\t * Constructs a new VTK loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded VRML asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(BufferGeometry)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given VTK data and returns the resulting geometry.\n\t *\n\t * @param {ArrayBuffer} data - The raw VTK data as an array buffer\n\t * @return {BufferGeometry} The parsed geometry.\n\t */\n\tparse( data ) {\n\n\t\tfunction parseASCII( data ) {\n\n\t\t\t// connectivity of the triangles\n\t\t\tconst indices = [];\n\n\t\t\t// triangles vertices\n\t\t\tconst positions = [];\n\n\t\t\t// red, green, blue colors in the range 0 to 1\n\t\t\tconst colors = [];\n\n\t\t\t// normal vector, one per vertex\n\t\t\tconst normals = [];\n\n\t\t\tlet result;\n\n\t\t\t// pattern for detecting the end of a number sequence\n\t\t\tconst patWord = /^[^\\d.\\s-]+/;\n\n\t\t\t// pattern for reading vertices, 3 floats or integers\n\t\t\tconst pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g;\n\n\t\t\t// pattern for connectivity, an integer followed by any number of ints\n\t\t\t// the first integer is the number of polygon nodes\n\t\t\tconst patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/;\n\n\t\t\t// indicates start of vertex data section\n\t\t\tconst patPOINTS = /^POINTS /;\n\n\t\t\t// indicates start of polygon connectivity section\n\t\t\tconst patPOLYGONS = /^POLYGONS /;\n\n\t\t\t// indicates start of triangle strips section\n\t\t\tconst patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /;\n\n\t\t\t// POINT_DATA number_of_values\n\t\t\tconst patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/;\n\n\t\t\t// CELL_DATA number_of_polys\n\t\t\tconst patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/;\n\n\t\t\t// Start of color section\n\t\t\tconst patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/;\n\n\t\t\t// NORMALS Normals float\n\t\t\tconst patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\n\n\t\t\tlet inPointsSection = false;\n\t\t\tlet inPolygonsSection = false;\n\t\t\tlet inTriangleStripSection = false;\n\t\t\tlet inPointDataSection = false;\n\t\t\tlet inCellDataSection = false;\n\t\t\tlet inColorSection = false;\n\t\t\tlet inNormalsSection = false;\n\n\t\t\tconst color = new Color();\n\n\t\t\tconst lines = data.split( '\\n' );\n\n\t\t\tfor ( const i in lines ) {\n\n\t\t\t\tconst line = lines[ i ].trim();\n\n\t\t\t\tif ( line.indexOf( 'DATASET' ) === 0 ) {\n\n\t\t\t\t\tconst dataset = line.split( ' ' )[ 1 ];\n\n\t\t\t\t\tif ( dataset !== 'POLYDATA' ) throw new Error( 'Unsupported DATASET type: ' + dataset );\n\n\t\t\t\t} else if ( inPointsSection ) {\n\n\t\t\t\t\t// get the vertices\n\t\t\t\t\twhile ( ( result = pat3Floats.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\tif ( patWord.exec( line ) !== null ) break;\n\n\t\t\t\t\t\tconst x = parseFloat( result[ 1 ] );\n\t\t\t\t\t\tconst y = parseFloat( result[ 2 ] );\n\t\t\t\t\t\tconst z = parseFloat( result[ 3 ] );\n\t\t\t\t\t\tpositions.push( x, y, z );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( inPolygonsSection ) {\n\n\t\t\t\t\tif ( ( result = patConnectivity.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t// numVertices i0 i1 i2 ...\n\t\t\t\t\t\tconst numVertices = parseInt( result[ 1 ] );\n\t\t\t\t\t\tconst inds = result[ 2 ].split( /\\s+/ );\n\n\t\t\t\t\t\tif ( numVertices >= 3 ) {\n\n\t\t\t\t\t\t\tconst i0 = parseInt( inds[ 0 ] );\n\t\t\t\t\t\t\tlet k = 1;\n\t\t\t\t\t\t\t// split the polygon in numVertices - 2 triangles\n\t\t\t\t\t\t\tfor ( let j = 0; j < numVertices - 2; ++ j ) {\n\n\t\t\t\t\t\t\t\tconst i1 = parseInt( inds[ k ] );\n\t\t\t\t\t\t\t\tconst i2 = parseInt( inds[ k + 1 ] );\n\t\t\t\t\t\t\t\tindices.push( i0, i1, i2 );\n\t\t\t\t\t\t\t\tk ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( inTriangleStripSection ) {\n\n\t\t\t\t\tif ( ( result = patConnectivity.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t// numVertices i0 i1 i2 ...\n\t\t\t\t\t\tconst numVertices = parseInt( result[ 1 ] );\n\t\t\t\t\t\tconst inds = result[ 2 ].split( /\\s+/ );\n\n\t\t\t\t\t\tif ( numVertices >= 3 ) {\n\n\t\t\t\t\t\t\t// split the polygon in numVertices - 2 triangles\n\t\t\t\t\t\t\tfor ( let j = 0; j < numVertices - 2; j ++ ) {\n\n\t\t\t\t\t\t\t\tif ( j % 2 === 1 ) {\n\n\t\t\t\t\t\t\t\t\tconst i0 = parseInt( inds[ j ] );\n\t\t\t\t\t\t\t\t\tconst i1 = parseInt( inds[ j + 2 ] );\n\t\t\t\t\t\t\t\t\tconst i2 = parseInt( inds[ j + 1 ] );\n\t\t\t\t\t\t\t\t\tindices.push( i0, i1, i2 );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tconst i0 = parseInt( inds[ j ] );\n\t\t\t\t\t\t\t\t\tconst i1 = parseInt( inds[ j + 1 ] );\n\t\t\t\t\t\t\t\t\tconst i2 = parseInt( inds[ j + 2 ] );\n\t\t\t\t\t\t\t\t\tindices.push( i0, i1, i2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( inPointDataSection || inCellDataSection ) {\n\n\t\t\t\t\tif ( inColorSection ) {\n\n\t\t\t\t\t\t// Get the colors\n\n\t\t\t\t\t\twhile ( ( result = pat3Floats.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t\tif ( patWord.exec( line ) !== null ) break;\n\n\t\t\t\t\t\t\tconst r = parseFloat( result[ 1 ] );\n\t\t\t\t\t\t\tconst g = parseFloat( result[ 2 ] );\n\t\t\t\t\t\t\tconst b = parseFloat( result[ 3 ] );\n\n\t\t\t\t\t\t\tcolor.setRGB( r, g, b, SRGBColorSpace );\n\n\t\t\t\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( inNormalsSection ) {\n\n\t\t\t\t\t\t// Get the normal vectors\n\n\t\t\t\t\t\twhile ( ( result = pat3Floats.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t\tif ( patWord.exec( line ) !== null ) break;\n\n\t\t\t\t\t\t\tconst nx = parseFloat( result[ 1 ] );\n\t\t\t\t\t\t\tconst ny = parseFloat( result[ 2 ] );\n\t\t\t\t\t\t\tconst nz = parseFloat( result[ 3 ] );\n\t\t\t\t\t\t\tnormals.push( nx, ny, nz );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( patPOLYGONS.exec( line ) !== null ) {\n\n\t\t\t\t\tinPolygonsSection = true;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t} else if ( patPOINTS.exec( line ) !== null ) {\n\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinPointsSection = true;\n\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t} else if ( patTRIANGLE_STRIPS.exec( line ) !== null ) {\n\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinTriangleStripSection = true;\n\n\t\t\t\t} else if ( patPOINT_DATA.exec( line ) !== null ) {\n\n\t\t\t\t\tinPointDataSection = true;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t} else if ( patCELL_DATA.exec( line ) !== null ) {\n\n\t\t\t\t\tinCellDataSection = true;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t} else if ( patCOLOR_SCALARS.exec( line ) !== null ) {\n\n\t\t\t\t\tinColorSection = true;\n\t\t\t\t\tinNormalsSection = false;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t} else if ( patNORMALS.exec( line ) !== null ) {\n\n\t\t\t\t\tinNormalsSection = true;\n\t\t\t\t\tinColorSection = false;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet geometry = new BufferGeometry();\n\t\t\tgeometry.setIndex( indices );\n\t\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\t\t\tif ( normals.length === positions.length ) {\n\n\t\t\t\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\n\t\t\t}\n\n\t\t\tif ( colors.length !== indices.length ) {\n\n\t\t\t\t// stagger\n\n\t\t\t\tif ( colors.length === positions.length ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// cell\n\n\t\t\t\tgeometry = geometry.toNonIndexed();\n\t\t\t\tconst numTriangles = geometry.attributes.position.count / 3;\n\n\t\t\t\tif ( colors.length === ( numTriangles * 3 ) ) {\n\n\t\t\t\t\tconst newColors = [];\n\n\t\t\t\t\tfor ( let i = 0; i < numTriangles; i ++ ) {\n\n\t\t\t\t\t\tconst r = colors[ 3 * i + 0 ];\n\t\t\t\t\t\tconst g = colors[ 3 * i + 1 ];\n\t\t\t\t\t\tconst b = colors[ 3 * i + 2 ];\n\n\t\t\t\t\t\tcolor.setRGB( r, g, b, SRGBColorSpace );\n\n\t\t\t\t\t\tnewColors.push( color.r, color.g, color.b );\n\t\t\t\t\t\tnewColors.push( color.r, color.g, color.b );\n\t\t\t\t\t\tnewColors.push( color.r, color.g, color.b );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( newColors, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction parseBinary( data ) {\n\n\t\t\tconst buffer = new Uint8Array( data );\n\t\t\tconst dataView = new DataView( data );\n\n\t\t\t// Points and normals, by default, are empty\n\t\t\tlet points = [];\n\t\t\tlet normals = [];\n\t\t\tlet indices = [];\n\n\t\t\tlet index = 0;\n\n\t\t\tfunction findString( buffer, start ) {\n\n\t\t\t\tlet index = start;\n\t\t\t\tlet c = buffer[ index ];\n\t\t\t\tconst s = [];\n\t\t\t\twhile ( c !== 10 ) {\n\n\t\t\t\t\ts.push( String.fromCharCode( c ) );\n\t\t\t\t\tindex ++;\n\t\t\t\t\tc = buffer[ index ];\n\n\t\t\t\t}\n\n\t\t\t\treturn { start: start,\n\t\t\t\t\tend: index,\n\t\t\t\t\tnext: index + 1,\n\t\t\t\t\tparsedString: s.join( '' ) };\n\n\t\t\t}\n\n\t\t\tlet state, line;\n\n\t\t\twhile ( true ) {\n\n\t\t\t\t// Get a string\n\t\t\t\tstate = findString( buffer, index );\n\t\t\t\tline = state.parsedString;\n\n\t\t\t\tif ( line.indexOf( 'DATASET' ) === 0 ) {\n\n\t\t\t\t\tconst dataset = line.split( ' ' )[ 1 ];\n\n\t\t\t\t\tif ( dataset !== 'POLYDATA' ) throw new Error( 'Unsupported DATASET type: ' + dataset );\n\n\t\t\t\t} else if ( line.indexOf( 'POINTS' ) === 0 ) {\n\n\t\t\t\t\t// Add the points\n\t\t\t\t\tconst numberOfPoints = parseInt( line.split( ' ' )[ 1 ], 10 );\n\n\t\t\t\t\t// Each point is 3 4-byte floats\n\t\t\t\t\tconst count = numberOfPoints * 4 * 3;\n\n\t\t\t\t\tpoints = new Float32Array( numberOfPoints * 3 );\n\n\t\t\t\t\tlet pointIndex = state.next;\n\t\t\t\t\tfor ( let i = 0; i < numberOfPoints; i ++ ) {\n\n\t\t\t\t\t\tpoints[ 3 * i ] = dataView.getFloat32( pointIndex, false );\n\t\t\t\t\t\tpoints[ 3 * i + 1 ] = dataView.getFloat32( pointIndex + 4, false );\n\t\t\t\t\t\tpoints[ 3 * i + 2 ] = dataView.getFloat32( pointIndex + 8, false );\n\t\t\t\t\t\tpointIndex = pointIndex + 12;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// increment our next pointer\n\t\t\t\t\tstate.next = state.next + count + 1;\n\n\t\t\t\t} else if ( line.indexOf( 'TRIANGLE_STRIPS' ) === 0 ) {\n\n\t\t\t\t\tconst numberOfStrips = parseInt( line.split( ' ' )[ 1 ], 10 );\n\t\t\t\t\tconst size = parseInt( line.split( ' ' )[ 2 ], 10 );\n\t\t\t\t\t// 4 byte integers\n\t\t\t\t\tconst count = size * 4;\n\n\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfStrips );\n\t\t\t\t\tlet indicesIndex = 0;\n\n\t\t\t\t\tlet pointIndex = state.next;\n\t\t\t\t\tfor ( let i = 0; i < numberOfStrips; i ++ ) {\n\n\t\t\t\t\t\t// For each strip, read the first value, then record that many more points\n\t\t\t\t\t\tconst indexCount = dataView.getInt32( pointIndex, false );\n\t\t\t\t\t\tconst strip = [];\n\t\t\t\t\t\tpointIndex += 4;\n\t\t\t\t\t\tfor ( let s = 0; s < indexCount; s ++ ) {\n\n\t\t\t\t\t\t\tstrip.push( dataView.getInt32( pointIndex, false ) );\n\t\t\t\t\t\t\tpointIndex += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// retrieves the n-2 triangles from the triangle strip\n\t\t\t\t\t\tfor ( let j = 0; j < indexCount - 2; j ++ ) {\n\n\t\t\t\t\t\t\tif ( j % 2 ) {\n\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// increment our next pointer\n\t\t\t\t\tstate.next = state.next + count + 1;\n\n\t\t\t\t} else if ( line.indexOf( 'POLYGONS' ) === 0 ) {\n\n\t\t\t\t\tconst numberOfStrips = parseInt( line.split( ' ' )[ 1 ], 10 );\n\t\t\t\t\tconst size = parseInt( line.split( ' ' )[ 2 ], 10 );\n\t\t\t\t\t// 4 byte integers\n\t\t\t\t\tconst count = size * 4;\n\n\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfStrips );\n\t\t\t\t\tlet indicesIndex = 0;\n\n\t\t\t\t\tlet pointIndex = state.next;\n\t\t\t\t\tfor ( let i = 0; i < numberOfStrips; i ++ ) {\n\n\t\t\t\t\t\t// For each strip, read the first value, then record that many more points\n\t\t\t\t\t\tconst indexCount = dataView.getInt32( pointIndex, false );\n\t\t\t\t\t\tconst strip = [];\n\t\t\t\t\t\tpointIndex += 4;\n\t\t\t\t\t\tfor ( let s = 0; s < indexCount; s ++ ) {\n\n\t\t\t\t\t\t\tstrip.push( dataView.getInt32( pointIndex, false ) );\n\t\t\t\t\t\t\tpointIndex += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// divide the polygon in n-2 triangle\n\t\t\t\t\t\tfor ( let j = 1; j < indexCount - 1; j ++ ) {\n\n\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ 0 ];\n\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// increment our next pointer\n\t\t\t\t\tstate.next = state.next + count + 1;\n\n\t\t\t\t} else if ( line.indexOf( 'POINT_DATA' ) === 0 ) {\n\n\t\t\t\t\tconst numberOfPoints = parseInt( line.split( ' ' )[ 1 ], 10 );\n\n\t\t\t\t\t// Grab the next line\n\t\t\t\t\tstate = findString( buffer, state.next );\n\n\t\t\t\t\t// Now grab the binary data\n\t\t\t\t\tconst count = numberOfPoints * 4 * 3;\n\n\t\t\t\t\tnormals = new Float32Array( numberOfPoints * 3 );\n\t\t\t\t\tlet pointIndex = state.next;\n\t\t\t\t\tfor ( let i = 0; i < numberOfPoints; i ++ ) {\n\n\t\t\t\t\t\tnormals[ 3 * i ] = dataView.getFloat32( pointIndex, false );\n\t\t\t\t\t\tnormals[ 3 * i + 1 ] = dataView.getFloat32( pointIndex + 4, false );\n\t\t\t\t\t\tnormals[ 3 * i + 2 ] = dataView.getFloat32( pointIndex + 8, false );\n\t\t\t\t\t\tpointIndex += 12;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Increment past our data\n\t\t\t\t\tstate.next = state.next + count;\n\n\t\t\t\t}\n\n\t\t\t\t// Increment index\n\t\t\t\tindex = state.next;\n\n\t\t\t\tif ( index >= buffer.byteLength ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\t\t\tgeometry.setAttribute( 'position', new BufferAttribute( points, 3 ) );\n\n\t\t\tif ( normals.length === points.length ) {\n\n\t\t\t\tgeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction Float32Concat( first, second ) {\n\n\t\t\tconst firstLength = first.length, result = new Float32Array( firstLength + second.length );\n\n\t\t\tresult.set( first );\n\t\t\tresult.set( second, firstLength );\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tfunction Int32Concat( first, second ) {\n\n\t\t\tconst firstLength = first.length, result = new Int32Array( firstLength + second.length );\n\n\t\t\tresult.set( first );\n\t\t\tresult.set( second, firstLength );\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tfunction parseXML( stringFile ) {\n\n\t\t\t// Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json\n\n\t\t\tfunction xmlToJson( xml ) {\n\n\t\t\t\t// Create the return object\n\t\t\t\tlet obj = {};\n\n\t\t\t\tif ( xml.nodeType === 1 ) { // element\n\n\t\t\t\t\t// do attributes\n\n\t\t\t\t\tif ( xml.attributes ) {\n\n\t\t\t\t\t\tif ( xml.attributes.length > 0 ) {\n\n\t\t\t\t\t\t\tobj[ 'attributes' ] = {};\n\n\t\t\t\t\t\t\tfor ( let j = 0; j < xml.attributes.length; j ++ ) {\n\n\t\t\t\t\t\t\t\tconst attribute = xml.attributes.item( j );\n\t\t\t\t\t\t\t\tobj[ 'attributes' ][ attribute.nodeName ] = attribute.nodeValue.trim();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( xml.nodeType === 3 ) { // text\n\n\t\t\t\t\tobj = xml.nodeValue.trim();\n\n\t\t\t\t}\n\n\t\t\t\t// do children\n\t\t\t\tif ( xml.hasChildNodes() ) {\n\n\t\t\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\t\tconst item = xml.childNodes.item( i );\n\t\t\t\t\t\tconst nodeName = item.nodeName;\n\n\t\t\t\t\t\tif ( typeof obj[ nodeName ] === 'undefined' ) {\n\n\t\t\t\t\t\t\tconst tmp = xmlToJson( item );\n\n\t\t\t\t\t\t\tif ( tmp !== '' ) {\n\n\t\t\t\t\t\t\t\tif ( Array.isArray( tmp[ '#text' ] ) ) {\n\n\t\t\t\t\t\t\t\t\ttmp[ '#text' ] = tmp[ '#text' ][ 0 ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tobj[ nodeName ] = tmp;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( typeof obj[ nodeName ].push === 'undefined' ) {\n\n\t\t\t\t\t\t\t\tconst old = obj[ nodeName ];\n\t\t\t\t\t\t\t\tobj[ nodeName ] = [ old ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst tmp = xmlToJson( item );\n\n\t\t\t\t\t\t\tif ( tmp !== '' ) {\n\n\t\t\t\t\t\t\t\tif ( Array.isArray( tmp[ '#text' ] ) ) {\n\n\t\t\t\t\t\t\t\t\ttmp[ '#text' ] = tmp[ '#text' ][ 0 ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tobj[ nodeName ].push( tmp );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn obj;\n\n\t\t\t}\n\n\t\t\t// Taken from Base64-js\n\t\t\tfunction Base64toByteArray( b64 ) {\n\n\t\t\t\tconst Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\t\t\t\tconst revLookup = [];\n\t\t\t\tconst code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n\t\t\t\tfor ( let i = 0, l = code.length; i < l; ++ i ) {\n\n\t\t\t\t\trevLookup[ code.charCodeAt( i ) ] = i;\n\n\t\t\t\t}\n\n\t\t\t\trevLookup[ '-'.charCodeAt( 0 ) ] = 62;\n\t\t\t\trevLookup[ '_'.charCodeAt( 0 ) ] = 63;\n\n\t\t\t\tconst len = b64.length;\n\n\t\t\t\tif ( len % 4 > 0 ) {\n\n\t\t\t\t\tthrow new Error( 'Invalid string. Length must be a multiple of 4' );\n\n\t\t\t\t}\n\n\t\t\t\tconst placeHolders = b64[ len - 2 ] === '=' ? 2 : b64[ len - 1 ] === '=' ? 1 : 0;\n\t\t\t\tconst arr = new Arr( len * 3 / 4 - placeHolders );\n\t\t\t\tconst l = placeHolders > 0 ? len - 4 : len;\n\n\t\t\t\tlet L = 0;\n\t\t\t\tlet i, j;\n\n\t\t\t\tfor ( i = 0, j = 0; i < l; i += 4, j += 3 ) {\n\n\t\t\t\t\tconst tmp = ( revLookup[ b64.charCodeAt( i ) ] << 18 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] << 12 ) | ( revLookup[ b64.charCodeAt( i + 2 ) ] << 6 ) | revLookup[ b64.charCodeAt( i + 3 ) ];\n\t\t\t\t\tarr[ L ++ ] = ( tmp & 0xFF0000 ) >> 16;\n\t\t\t\t\tarr[ L ++ ] = ( tmp & 0xFF00 ) >> 8;\n\t\t\t\t\tarr[ L ++ ] = tmp & 0xFF;\n\n\t\t\t\t}\n\n\t\t\t\tif ( placeHolders === 2 ) {\n\n\t\t\t\t\tconst tmp = ( revLookup[ b64.charCodeAt( i ) ] << 2 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] >> 4 );\n\t\t\t\t\tarr[ L ++ ] = tmp & 0xFF;\n\n\t\t\t\t} else if ( placeHolders === 1 ) {\n\n\t\t\t\t\tconst tmp = ( revLookup[ b64.charCodeAt( i ) ] << 10 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] << 4 ) | ( revLookup[ b64.charCodeAt( i + 2 ) ] >> 2 );\n\t\t\t\t\tarr[ L ++ ] = ( tmp >> 8 ) & 0xFF;\n\t\t\t\t\tarr[ L ++ ] = tmp & 0xFF;\n\n\t\t\t\t}\n\n\t\t\t\treturn arr;\n\n\t\t\t}\n\n\t\t\tfunction parseDataArray( ele, compressed ) {\n\n\t\t\t\tlet numBytes = 0;\n\n\t\t\t\tif ( json.attributes.header_type === 'UInt64' ) {\n\n\t\t\t\t\tnumBytes = 8;\n\n\t\t\t\t}\telse if ( json.attributes.header_type === 'UInt32' ) {\n\n\t\t\t\t\tnumBytes = 4;\n\n\t\t\t\t}\n\n\t\t\t\tlet txt, content;\n\n\t\t\t\t// Check the format\n\t\t\t\tif ( ele.attributes.format === 'binary' && compressed ) {\n\n\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\n\n\t\t\t\t\t\ttxt = new Float32Array( );\n\n\t\t\t\t\t} else if ( ele.attributes.type === 'Int32' || ele.attributes.type === 'Int64' ) {\n\n\t\t\t\t\t\ttxt = new Int32Array( );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// VTP data with the header has the following structure:\n\t\t\t\t\t// [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]\n\t\t\t\t\t//\n\t\t\t\t\t// Each token is an integer value whose type is specified by \"header_type\" at the top of the file (UInt32 if no type specified). The token meanings are:\n\t\t\t\t\t// [#blocks] = Number of blocks\n\t\t\t\t\t// [#u-size] = Block size before compression\n\t\t\t\t\t// [#p-size] = Size of last partial block (zero if it not needed)\n\t\t\t\t\t// [#c-size-i] = Size in bytes of block i after compression\n\t\t\t\t\t//\n\t\t\t\t\t// The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is\n\t\t\t\t\t// computed by summing the compressed block sizes from preceding blocks according to the header.\n\n\t\t\t\t\tconst textNode = ele[ '#text' ];\n\t\t\t\t\tconst rawData = Array.isArray( textNode ) ? textNode[ 0 ] : textNode;\n\n\t\t\t\t\tconst byteData = Base64toByteArray( rawData );\n\n\t\t\t\t\t// Each data point consists of 8 bits regardless of the header type\n\t\t\t\t\tconst dataPointSize = 8;\n\n\t\t\t\t\tlet blocks = byteData[ 0 ];\n\t\t\t\t\tfor ( let i = 1; i < numBytes - 1; i ++ ) {\n\n\t\t\t\t\t\tblocks = blocks | ( byteData[ i ] << ( i * dataPointSize ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet headerSize = ( blocks + 3 ) * numBytes;\n\t\t\t\t\tconst padding = ( ( headerSize % 3 ) > 0 ) ? 3 - ( headerSize % 3 ) : 0;\n\t\t\t\t\theaderSize = headerSize + padding;\n\n\t\t\t\t\tconst dataOffsets = [];\n\t\t\t\t\tlet currentOffset = headerSize;\n\t\t\t\t\tdataOffsets.push( currentOffset );\n\n\t\t\t\t\t// Get the blocks sizes after the compression.\n\t\t\t\t\t// There are three blocks before c-size-i, so we skip 3*numBytes\n\t\t\t\t\tconst cSizeStart = 3 * numBytes;\n\n\t\t\t\t\tfor ( let i = 0; i < blocks; i ++ ) {\n\n\t\t\t\t\t\tlet currentBlockSize = byteData[ i * numBytes + cSizeStart ];\n\n\t\t\t\t\t\tfor ( let j = 1; j < numBytes - 1; j ++ ) {\n\n\t\t\t\t\t\t\tcurrentBlockSize = currentBlockSize | ( byteData[ i * numBytes + cSizeStart + j ] << ( j * dataPointSize ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentOffset = currentOffset + currentBlockSize;\n\t\t\t\t\t\tdataOffsets.push( currentOffset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0; i < dataOffsets.length - 1; i ++ ) {\n\n\t\t\t\t\t\tconst data = fflate.unzlibSync( byteData.slice( dataOffsets[ i ], dataOffsets[ i + 1 ] ) );\n\t\t\t\t\t\tcontent = data.buffer;\n\n\t\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\n\n\t\t\t\t\t\t\tcontent = new Float32Array( content );\n\t\t\t\t\t\t\ttxt = Float32Concat( txt, content );\n\n\t\t\t\t\t\t} else if ( ele.attributes.type === 'Int32' || ele.attributes.type === 'Int64' ) {\n\n\t\t\t\t\t\t\tcontent = new Int32Array( content );\n\t\t\t\t\t\t\ttxt = Int32Concat( txt, content );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete ele[ '#text' ];\n\n\t\t\t\t\tif ( ele.attributes.type === 'Int64' ) {\n\n\t\t\t\t\t\tif ( ele.attributes.format === 'binary' ) {\n\n\t\t\t\t\t\t\ttxt = txt.filter( function ( el, idx ) {\n\n\t\t\t\t\t\t\t\tif ( idx % 2 !== 1 ) return true;\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( ele.attributes.format === 'binary' && ! compressed ) {\n\n\t\t\t\t\t\tcontent = Base64toByteArray( ele[ '#text' ] );\n\n\t\t\t\t\t\t//  VTP data for the uncompressed case has the following structure:\n\t\t\t\t\t\t// [#bytes][DATA]\n\t\t\t\t\t\t// where \"[#bytes]\" is an integer value specifying the number of bytes in the block of data following it.\n\t\t\t\t\t\tcontent = content.slice( numBytes ).buffer;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( ele[ '#text' ] ) {\n\n\t\t\t\t\t\t\tcontent = ele[ '#text' ].split( /\\s+/ ).filter( function ( el ) {\n\n\t\t\t\t\t\t\t\tif ( el !== '' ) return el;\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tcontent = new Int32Array( 0 ).buffer;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete ele[ '#text' ];\n\n\t\t\t\t\t// Get the content and optimize it\n\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\n\n\t\t\t\t\t\ttxt = new Float32Array( content );\n\n\t\t\t\t\t} else if ( ele.attributes.type === 'Int32' ) {\n\n\t\t\t\t\t\ttxt = new Int32Array( content );\n\n\t\t\t\t\t} else if ( ele.attributes.type === 'Int64' ) {\n\n\t\t\t\t\t\ttxt = new Int32Array( content );\n\n\t\t\t\t\t\tif ( ele.attributes.format === 'binary' ) {\n\n\t\t\t\t\t\t\ttxt = txt.filter( function ( el, idx ) {\n\n\t\t\t\t\t\t\t\tif ( idx % 2 !== 1 ) return true;\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} // endif ( ele.attributes.format === 'binary' && compressed )\n\n\t\t\t\treturn txt;\n\n\t\t\t}\n\n\t\t\t// Main part\n\t\t\t// Get Dom\n\t\t\tconst dom = new DOMParser().parseFromString( stringFile, 'application/xml' );\n\n\t\t\t// Get the doc\n\t\t\tconst doc = dom.documentElement;\n\t\t\t// Convert to json\n\t\t\tconst json = xmlToJson( doc );\n\t\t\tlet points = [];\n\t\t\tlet normals = [];\n\t\t\tlet indices = [];\n\n\t\t\tif ( json.AppendedData ) {\n\n\t\t\t\tconst appendedData = json.AppendedData[ '#text' ].slice( 1 );\n\t\t\t\tconst piece = json.PolyData.Piece;\n\n\t\t\t\tconst sections = [ 'PointData', 'CellData', 'Points', 'Verts', 'Lines', 'Strips', 'Polys' ];\n\t\t\t\tlet sectionIndex = 0;\n\n\t\t\t\tconst offsets = sections.map( s => {\n\n\t\t\t\t\tconst sect = piece[ s ];\n\n\t\t\t\t\tif ( sect && sect.DataArray ) {\n\n\t\t\t\t\t\tconst arr = Array.isArray( sect.DataArray ) ? sect.DataArray : [ sect.DataArray ];\n\n\t\t\t\t\t\treturn arr.map( a => a.attributes.offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn [];\n\n\t\t\t\t} ).flat();\n\n\t\t\t\tfor ( const sect of sections ) {\n\n\t\t\t\t\tconst section = piece[ sect ];\n\n\t\t\t\t\tif ( section && section.DataArray ) {\n\n\t\t\t\t\t\tif ( Array.isArray( section.DataArray ) ) {\n\n\t\t\t\t\t\t\tfor ( const sectionEle of section.DataArray ) {\n\n\t\t\t\t\t\t\t\tsectionEle[ '#text' ] = appendedData.slice( offsets[ sectionIndex ], offsets[ sectionIndex + 1 ] );\n\t\t\t\t\t\t\t\tsectionEle.attributes.format = 'binary';\n\t\t\t\t\t\t\t\tsectionIndex ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tsection.DataArray[ '#text' ] = appendedData.slice( offsets[ sectionIndex ], offsets[ sectionIndex + 1 ] );\n\t\t\t\t\t\t\tsection.DataArray.attributes.format = 'binary';\n\t\t\t\t\t\t\tsectionIndex ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( json.PolyData ) {\n\n\t\t\t\tconst piece = json.PolyData.Piece;\n\t\t\t\tconst compressed = json.attributes.hasOwnProperty( 'compressor' );\n\n\t\t\t\t// Can be optimized\n\t\t\t\t// Loop through the sections\n\t\t\t\tconst sections = [ 'PointData', 'Points', 'Strips', 'Polys' ];// +['CellData', 'Verts', 'Lines'];\n\t\t\t\tlet sectionIndex = 0;\n\t\t\t\tconst numberOfSections = sections.length;\n\n\t\t\t\twhile ( sectionIndex < numberOfSections ) {\n\n\t\t\t\t\tconst section = piece[ sections[ sectionIndex ] ];\n\n\t\t\t\t\t// If it has a DataArray in it\n\n\t\t\t\t\tif ( section && section.DataArray ) {\n\n\t\t\t\t\t\t// Depending on the number of DataArrays\n\n\t\t\t\t\t\tlet arr;\n\n\t\t\t\t\t\tif ( Array.isArray( section.DataArray ) ) {\n\n\t\t\t\t\t\t\tarr = section.DataArray;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tarr = [ section.DataArray ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet dataArrayIndex = 0;\n\t\t\t\t\t\tconst numberOfDataArrays = arr.length;\n\n\t\t\t\t\t\twhile ( dataArrayIndex < numberOfDataArrays ) {\n\n\t\t\t\t\t\t\t// Parse the DataArray\n\t\t\t\t\t\t\tif ( ( '#text' in arr[ dataArrayIndex ] ) && ( arr[ dataArrayIndex ][ '#text' ].length > 0 ) ) {\n\n\t\t\t\t\t\t\t\tarr[ dataArrayIndex ].text = parseDataArray( arr[ dataArrayIndex ], compressed );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tdataArrayIndex ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tswitch ( sections[ sectionIndex ] ) {\n\n\t\t\t\t\t\t\t// if iti is point data\n\t\t\t\t\t\t\tcase 'PointData':\n\n\t\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t\tconst numberOfPoints = parseInt( piece.attributes.NumberOfPoints );\n\t\t\t\t\t\t\t\t\tconst normalsName = section.attributes.Normals;\n\n\t\t\t\t\t\t\t\t\tif ( numberOfPoints > 0 ) {\n\n\t\t\t\t\t\t\t\t\t\tfor ( let i = 0, len = arr.length; i < len; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( normalsName === arr[ i ].attributes.Name ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconst components = arr[ i ].attributes.NumberOfComponents;\n\t\t\t\t\t\t\t\t\t\t\t\tnormals = new Float32Array( numberOfPoints * components );\n\t\t\t\t\t\t\t\t\t\t\t\tnormals.set( arr[ i ].text, 0 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t// if it is points\n\t\t\t\t\t\t\tcase 'Points':\n\n\t\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t\tconst numberOfPoints = parseInt( piece.attributes.NumberOfPoints );\n\n\t\t\t\t\t\t\t\t\tif ( numberOfPoints > 0 ) {\n\n\t\t\t\t\t\t\t\t\t\tconst components = section.DataArray.attributes.NumberOfComponents;\n\t\t\t\t\t\t\t\t\t\tpoints = new Float32Array( numberOfPoints * components );\n\t\t\t\t\t\t\t\t\t\tpoints.set( section.DataArray.text, 0 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t// if it is strips\n\t\t\t\t\t\t\tcase 'Strips':\n\n\t\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t\tconst numberOfStrips = parseInt( piece.attributes.NumberOfStrips );\n\n\t\t\t\t\t\t\t\t\tif ( numberOfStrips > 0 ) {\n\n\t\t\t\t\t\t\t\t\t\tconst connectivity = new Int32Array( section.DataArray[ 0 ].text.length );\n\t\t\t\t\t\t\t\t\t\tconst offset = new Int32Array( section.DataArray[ 1 ].text.length );\n\t\t\t\t\t\t\t\t\t\tconnectivity.set( section.DataArray[ 0 ].text, 0 );\n\t\t\t\t\t\t\t\t\t\toffset.set( section.DataArray[ 1 ].text, 0 );\n\n\t\t\t\t\t\t\t\t\t\tconst size = numberOfStrips + connectivity.length;\n\t\t\t\t\t\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfStrips );\n\n\t\t\t\t\t\t\t\t\t\tlet indicesIndex = 0;\n\n\t\t\t\t\t\t\t\t\t\tfor ( let i = 0, len = numberOfStrips; i < len; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\tconst strip = [];\n\n\t\t\t\t\t\t\t\t\t\t\tfor ( let s = 0, len1 = offset[ i ], len0 = 0; s < len1 - len0; s ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tstrip.push( connectivity[ s ] );\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ( i > 0 ) len0 = offset[ i - 1 ];\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tfor ( let j = 0, len1 = offset[ i ], len0 = 0; j < len1 - len0 - 2; j ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ( j % 2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\n\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ( i > 0 ) len0 = offset[ i - 1 ];\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t// if it is polys\n\t\t\t\t\t\t\tcase 'Polys':\n\n\t\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t\tconst numberOfPolys = parseInt( piece.attributes.NumberOfPolys );\n\n\t\t\t\t\t\t\t\t\tif ( numberOfPolys > 0 ) {\n\n\t\t\t\t\t\t\t\t\t\tconst connectivity = new Int32Array( section.DataArray[ 0 ].text.length );\n\t\t\t\t\t\t\t\t\t\tconst offset = new Int32Array( section.DataArray[ 1 ].text.length );\n\t\t\t\t\t\t\t\t\t\tconnectivity.set( section.DataArray[ 0 ].text, 0 );\n\t\t\t\t\t\t\t\t\t\toffset.set( section.DataArray[ 1 ].text, 0 );\n\n\t\t\t\t\t\t\t\t\t\tconst size = numberOfPolys + connectivity.length;\n\t\t\t\t\t\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfPolys );\n\t\t\t\t\t\t\t\t\t\tlet indicesIndex = 0, connectivityIndex = 0;\n\t\t\t\t\t\t\t\t\t\tlet i = 0, len0 = 0;\n\t\t\t\t\t\t\t\t\t\tconst len = numberOfPolys;\n\n\t\t\t\t\t\t\t\t\t\twhile ( i < len ) {\n\n\t\t\t\t\t\t\t\t\t\t\tconst poly = [];\n\t\t\t\t\t\t\t\t\t\t\tlet s = 0;\n\t\t\t\t\t\t\t\t\t\t\tconst len1 = offset[ i ];\n\n\t\t\t\t\t\t\t\t\t\t\twhile ( s < len1 - len0 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tpoly.push( connectivity[ connectivityIndex ++ ] );\n\t\t\t\t\t\t\t\t\t\t\t\ts ++;\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tlet j = 1;\n\n\t\t\t\t\t\t\t\t\t\t\twhile ( j < len1 - len0 - 1 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = poly[ 0 ];\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = poly[ j ];\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = poly[ j + 1 ];\n\t\t\t\t\t\t\t\t\t\t\t\tj ++;\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\ti ++;\n\t\t\t\t\t\t\t\t\t\t\tlen0 = offset[ i - 1 ];\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsectionIndex ++;\n\n\t\t\t\t}\n\n\t\t\t\tconst geometry = new BufferGeometry();\n\t\t\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\t\t\t\tgeometry.setAttribute( 'position', new BufferAttribute( points, 3 ) );\n\n\t\t\t\tif ( normals.length === points.length ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn geometry;\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'Unsupported DATASET type' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst textDecoder = new TextDecoder();\n\n\t\t// get the 5 first lines of the files to check if there is the key word binary\n\t\tconst meta = textDecoder.decode( new Uint8Array( data, 0, 250 ) ).split( '\\n' );\n\n\t\tif ( meta[ 0 ].indexOf( 'xml' ) !== - 1 ) {\n\n\t\t\treturn parseXML( textDecoder.decode( data ) );\n\n\t\t} else if ( meta[ 2 ].includes( 'ASCII' ) ) {\n\n\t\t\treturn parseASCII( textDecoder.decode( data ) );\n\n\t\t} else {\n\n\t\t\treturn parseBinary( data );\n\n\t\t}\n\n\t}\n\n}\n\nexport { VTKLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}