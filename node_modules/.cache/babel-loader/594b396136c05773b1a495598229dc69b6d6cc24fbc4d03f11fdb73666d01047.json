{"ast":null,"code":"import { Color, Matrix4, Mesh, PerspectiveCamera, Plane, Quaternion, ShaderMaterial, UniformsUtils, Vector3, Vector4, WebGLRenderTarget, HalfFloatType } from 'three';\n\n/**\n * Can be used to create a flat, refractive surface like for special\n * windows or water effects.\n *\n * Note that this class can only be used with {@link WebGLRenderer}.\n * When using {@link WebGPURenderer}, use {@link viewportSharedTexture}.\n *\n * ```js\n * const geometry = new THREE.PlaneGeometry( 100, 100 );\n *\n * const refractor = new Refractor( refractorGeometry, {\n * \tcolor: 0xcbcbcb,\n * \ttextureWidth: 1024,\n * \ttextureHeight: 1024\n * } );\n *\n * scene.add( refractor );\n * ```\n *\n * @augments Mesh\n * @three_import import { Refractor } from 'three/addons/objects/Refractor.js';\n */\nclass Refractor extends Mesh {\n  /**\n   * Constructs a new refractor.\n   *\n   * @param {BufferGeometry} geometry - The refractor's geometry.\n   * @param {Refractor~Options} [options] - The configuration options.\n   */\n  constructor(geometry, options = {}) {\n    super(geometry);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {boolean}\n     * @readonly\n     * @default true\n     */\n    this.isRefractor = true;\n    this.type = 'Refractor';\n\n    /**\n     * The reflector's virtual camera.\n     *\n     * @type {PerspectiveCamera}\n     */\n    this.camera = new PerspectiveCamera();\n    const scope = this;\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7F7F7F);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || Refractor.RefractorShader;\n    const multisample = options.multisample !== undefined ? options.multisample : 4;\n\n    //\n\n    const virtualCamera = this.camera;\n    virtualCamera.matrixAutoUpdate = false;\n    virtualCamera.userData.refractor = true;\n\n    //\n\n    const refractorPlane = new Plane();\n    const textureMatrix = new Matrix4();\n\n    // render target\n\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample,\n      type: HalfFloatType\n    });\n\n    // material\n\n    this.material = new ShaderMaterial({\n      name: shader.name !== undefined ? shader.name : 'unspecified',\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true // ensures, refractors are drawn from farthest to closest\n    });\n    this.material.uniforms['color'].value = color;\n    this.material.uniforms['tDiffuse'].value = renderTarget.texture;\n    this.material.uniforms['textureMatrix'].value = textureMatrix;\n\n    // functions\n\n    const visible = function () {\n      const refractorWorldPosition = new Vector3();\n      const cameraWorldPosition = new Vector3();\n      const rotationMatrix = new Matrix4();\n      const view = new Vector3();\n      const normal = new Vector3();\n      return function visible(camera) {\n        refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n        view.subVectors(refractorWorldPosition, cameraWorldPosition);\n        rotationMatrix.extractRotation(scope.matrixWorld);\n        normal.set(0, 0, 1);\n        normal.applyMatrix4(rotationMatrix);\n        return view.dot(normal) < 0;\n      };\n    }();\n    const updateRefractorPlane = function () {\n      const normal = new Vector3();\n      const position = new Vector3();\n      const quaternion = new Quaternion();\n      const scale = new Vector3();\n      return function updateRefractorPlane() {\n        scope.matrixWorld.decompose(position, quaternion, scale);\n        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize();\n\n        // flip the normal because we want to cull everything above the plane\n\n        normal.negate();\n        refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\n      };\n    }();\n    const updateVirtualCamera = function () {\n      const clipPlane = new Plane();\n      const clipVector = new Vector4();\n      const q = new Vector4();\n      return function updateVirtualCamera(camera) {\n        virtualCamera.matrixWorld.copy(camera.matrixWorld);\n        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n        virtualCamera.far = camera.far; // used in WebGLBackground\n\n        // The following code creates an oblique view frustum for clipping.\n        // see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.\n        // Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5–16\n\n        clipPlane.copy(refractorPlane);\n        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant);\n\n        // calculate the clip-space corner point opposite the clipping plane and\n        // transform it into camera space by multiplying it by the inverse of the projection matrix\n\n        const projectionMatrix = virtualCamera.projectionMatrix;\n        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n        q.z = -1.0;\n        q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n\n        // calculate the scaled plane vector\n\n        clipVector.multiplyScalar(2.0 / clipVector.dot(q));\n\n        // replacing the third row of the projection matrix\n\n        projectionMatrix.elements[2] = clipVector.x;\n        projectionMatrix.elements[6] = clipVector.y;\n        projectionMatrix.elements[10] = clipVector.z + 1.0 - clipBias;\n        projectionMatrix.elements[14] = clipVector.w;\n      };\n    }();\n\n    // This will update the texture matrix that is used for projective texture mapping in the shader.\n    // see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\n\n    function updateTextureMatrix(camera) {\n      // this matrix does range mapping to [ 0, 1 ]\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n\n      // we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\n      // (matrix above) with the projection and view matrix of the virtual camera\n      // and the model matrix of the refractor\n\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    }\n\n    //\n\n    function render(renderer, scene, camera) {\n      scope.visible = false;\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      renderer.xr.enabled = false; // avoid camera modification\n      renderer.shadowMap.autoUpdate = false; // avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget);\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget);\n\n      // restore viewport\n\n      const viewport = camera.viewport;\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n      scope.visible = true;\n    }\n\n    //\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      // ensure refractors are rendered only once per frame\n\n      if (camera.userData.refractor === true) return;\n\n      // avoid rendering when the refractor is viewed from behind\n\n      if (!visible(camera) === true) return;\n\n      // update\n\n      updateRefractorPlane();\n      updateTextureMatrix(camera);\n      updateVirtualCamera(camera);\n      render(renderer, scene, camera);\n    };\n\n    /**\n     * Returns the reflector's internal render target.\n     *\n     * @return {WebGLRenderTarget} The internal render target\n     */\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n\n    /**\n     * Frees the GPU-related resources allocated by this instance. Call this\n     * method whenever this instance is no longer used in your app.\n     */\n    this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n  }\n}\nRefractor.RefractorShader = {\n  name: 'RefractorShader',\n  uniforms: {\n    'color': {\n      value: null\n    },\n    'tDiffuse': {\n      value: null\n    },\n    'textureMatrix': {\n      value: null\n    }\n  },\n  vertexShader: /* glsl */`\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n  fragmentShader: /* glsl */`\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\n\t\t}`\n};\n\n/**\n * Constructor options of `Refractor`.\n *\n * @typedef {Object} Refractor~Options\n * @property {number|Color|string} [color=0x7F7F7F] - The refractor's color.\n * @property {number} [textureWidth=512] - The texture width. A higher value results in more clear refractions but is also more expensive.\n * @property {number} [textureHeight=512] - The texture height. A higher value results in more clear refractions but is also more expensive.\n * @property {number} [clipBias=0] - The clip bias.\n * @property {Object} [shader] - Can be used to pass in a custom shader that defines how the refractive view is projected onto the reflector's geometry.\n * @property {number} [multisample=4] - How many samples to use for MSAA. `0` disables MSAA.\n **/\n\nexport { Refractor };","map":{"version":3,"names":["Color","Matrix4","Mesh","PerspectiveCamera","Plane","Quaternion","ShaderMaterial","UniformsUtils","Vector3","Vector4","WebGLRenderTarget","HalfFloatType","Refractor","constructor","geometry","options","isRefractor","type","camera","scope","color","undefined","textureWidth","textureHeight","clipBias","shader","RefractorShader","multisample","virtualCamera","matrixAutoUpdate","userData","refractor","refractorPlane","textureMatrix","renderTarget","samples","material","name","uniforms","clone","vertexShader","fragmentShader","transparent","value","texture","visible","refractorWorldPosition","cameraWorldPosition","rotationMatrix","view","normal","setFromMatrixPosition","matrixWorld","subVectors","extractRotation","set","applyMatrix4","dot","updateRefractorPlane","position","quaternion","scale","decompose","applyQuaternion","normalize","negate","setFromNormalAndCoplanarPoint","updateVirtualCamera","clipPlane","clipVector","q","copy","matrixWorldInverse","invert","projectionMatrix","far","x","y","z","constant","Math","sign","elements","w","multiplyScalar","updateTextureMatrix","multiply","render","renderer","scene","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","autoClear","clear","viewport","state","onBeforeRender","dispose"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/objects/Refractor.js"],"sourcesContent":["import {\n\tColor,\n\tMatrix4,\n\tMesh,\n\tPerspectiveCamera,\n\tPlane,\n\tQuaternion,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector3,\n\tVector4,\n\tWebGLRenderTarget,\n\tHalfFloatType\n} from 'three';\n\n/**\n * Can be used to create a flat, refractive surface like for special\n * windows or water effects.\n *\n * Note that this class can only be used with {@link WebGLRenderer}.\n * When using {@link WebGPURenderer}, use {@link viewportSharedTexture}.\n *\n * ```js\n * const geometry = new THREE.PlaneGeometry( 100, 100 );\n *\n * const refractor = new Refractor( refractorGeometry, {\n * \tcolor: 0xcbcbcb,\n * \ttextureWidth: 1024,\n * \ttextureHeight: 1024\n * } );\n *\n * scene.add( refractor );\n * ```\n *\n * @augments Mesh\n * @three_import import { Refractor } from 'three/addons/objects/Refractor.js';\n */\nclass Refractor extends Mesh {\n\n\t/**\n\t * Constructs a new refractor.\n\t *\n\t * @param {BufferGeometry} geometry - The refractor's geometry.\n\t * @param {Refractor~Options} [options] - The configuration options.\n\t */\n\tconstructor( geometry, options = {} ) {\n\n\t\tsuper( geometry );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isRefractor = true;\n\n\t\tthis.type = 'Refractor';\n\n\t\t/**\n\t\t * The reflector's virtual camera.\n\t\t *\n\t\t * @type {PerspectiveCamera}\n\t\t */\n\t\tthis.camera = new PerspectiveCamera();\n\n\t\tconst scope = this;\n\n\t\tconst color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );\n\t\tconst textureWidth = options.textureWidth || 512;\n\t\tconst textureHeight = options.textureHeight || 512;\n\t\tconst clipBias = options.clipBias || 0;\n\t\tconst shader = options.shader || Refractor.RefractorShader;\n\t\tconst multisample = ( options.multisample !== undefined ) ? options.multisample : 4;\n\n\t\t//\n\n\t\tconst virtualCamera = this.camera;\n\t\tvirtualCamera.matrixAutoUpdate = false;\n\t\tvirtualCamera.userData.refractor = true;\n\n\t\t//\n\n\t\tconst refractorPlane = new Plane();\n\t\tconst textureMatrix = new Matrix4();\n\n\t\t// render target\n\n\t\tconst renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, { samples: multisample, type: HalfFloatType } );\n\n\t\t// material\n\n\t\tthis.material = new ShaderMaterial( {\n\t\t\tname: ( shader.name !== undefined ) ? shader.name : 'unspecified',\n\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\ttransparent: true // ensures, refractors are drawn from farthest to closest\n\t\t} );\n\n\t\tthis.material.uniforms[ 'color' ].value = color;\n\t\tthis.material.uniforms[ 'tDiffuse' ].value = renderTarget.texture;\n\t\tthis.material.uniforms[ 'textureMatrix' ].value = textureMatrix;\n\n\t\t// functions\n\n\t\tconst visible = ( function () {\n\n\t\t\tconst refractorWorldPosition = new Vector3();\n\t\t\tconst cameraWorldPosition = new Vector3();\n\t\t\tconst rotationMatrix = new Matrix4();\n\n\t\t\tconst view = new Vector3();\n\t\t\tconst normal = new Vector3();\n\n\t\t\treturn function visible( camera ) {\n\n\t\t\t\trefractorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\t\tview.subVectors( refractorWorldPosition, cameraWorldPosition );\n\n\t\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\t\tnormal.set( 0, 0, 1 );\n\t\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\t\treturn view.dot( normal ) < 0;\n\n\t\t\t};\n\n\t\t} )();\n\n\t\tconst updateRefractorPlane = ( function () {\n\n\t\t\tconst normal = new Vector3();\n\t\t\tconst position = new Vector3();\n\t\t\tconst quaternion = new Quaternion();\n\t\t\tconst scale = new Vector3();\n\n\t\t\treturn function updateRefractorPlane() {\n\n\t\t\t\tscope.matrixWorld.decompose( position, quaternion, scale );\n\t\t\t\tnormal.set( 0, 0, 1 ).applyQuaternion( quaternion ).normalize();\n\n\t\t\t\t// flip the normal because we want to cull everything above the plane\n\n\t\t\t\tnormal.negate();\n\n\t\t\t\trefractorPlane.setFromNormalAndCoplanarPoint( normal, position );\n\n\t\t\t};\n\n\t\t} )();\n\n\t\tconst updateVirtualCamera = ( function () {\n\n\t\t\tconst clipPlane = new Plane();\n\t\t\tconst clipVector = new Vector4();\n\t\t\tconst q = new Vector4();\n\n\t\t\treturn function updateVirtualCamera( camera ) {\n\n\t\t\t\tvirtualCamera.matrixWorld.copy( camera.matrixWorld );\n\t\t\t\tvirtualCamera.matrixWorldInverse.copy( virtualCamera.matrixWorld ).invert();\n\t\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\t\t\t\tvirtualCamera.far = camera.far; // used in WebGLBackground\n\n\t\t\t\t// The following code creates an oblique view frustum for clipping.\n\t\t\t\t// see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.\n\t\t\t\t// Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5–16\n\n\t\t\t\tclipPlane.copy( refractorPlane );\n\t\t\t\tclipPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\t\t\tclipVector.set( clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant );\n\n\t\t\t\t// calculate the clip-space corner point opposite the clipping plane and\n\t\t\t\t// transform it into camera space by multiplying it by the inverse of the projection matrix\n\n\t\t\t\tconst projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t\t\tq.x = ( Math.sign( clipVector.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t\t\tq.y = ( Math.sign( clipVector.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t\t\tq.z = - 1.0;\n\t\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t\t\t// calculate the scaled plane vector\n\n\t\t\t\tclipVector.multiplyScalar( 2.0 / clipVector.dot( q ) );\n\n\t\t\t\t// replacing the third row of the projection matrix\n\n\t\t\t\tprojectionMatrix.elements[ 2 ] = clipVector.x;\n\t\t\t\tprojectionMatrix.elements[ 6 ] = clipVector.y;\n\t\t\t\tprojectionMatrix.elements[ 10 ] = clipVector.z + 1.0 - clipBias;\n\t\t\t\tprojectionMatrix.elements[ 14 ] = clipVector.w;\n\n\t\t\t};\n\n\t\t} )();\n\n\t\t// This will update the texture matrix that is used for projective texture mapping in the shader.\n\t\t// see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\n\n\t\tfunction updateTextureMatrix( camera ) {\n\n\t\t\t// this matrix does range mapping to [ 0, 1 ]\n\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\n\t\t\t// we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\n\t\t\t// (matrix above) with the projection and view matrix of the virtual camera\n\t\t\t// and the model matrix of the refractor\n\n\t\t\ttextureMatrix.multiply( camera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( camera.matrixWorldInverse );\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t}\n\n\t\t//\n\n\t\tfunction render( renderer, scene, camera ) {\n\n\t\t\tscope.visible = false;\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\trenderer.xr.enabled = false; // avoid camera modification\n\t\t\trenderer.shadowMap.autoUpdate = false; // avoid re-computing shadows\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\trenderer.render( scene, virtualCamera );\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t// restore viewport\n\n\t\t\tconst viewport = camera.viewport;\n\n\t\t\tif ( viewport !== undefined ) {\n\n\t\t\t\trenderer.state.viewport( viewport );\n\n\t\t\t}\n\n\t\t\tscope.visible = true;\n\n\t\t}\n\n\t\t//\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\t// ensure refractors are rendered only once per frame\n\n\t\t\tif ( camera.userData.refractor === true ) return;\n\n\t\t\t// avoid rendering when the refractor is viewed from behind\n\n\t\t\tif ( ! visible( camera ) === true ) return;\n\n\t\t\t// update\n\n\t\t\tupdateRefractorPlane();\n\n\t\t\tupdateTextureMatrix( camera );\n\n\t\t\tupdateVirtualCamera( camera );\n\n\t\t\trender( renderer, scene, camera );\n\n\t\t};\n\n\t\t/**\n\t\t * Returns the reflector's internal render target.\n\t\t *\n\t\t * @return {WebGLRenderTarget} The internal render target\n\t\t */\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t\t/**\n\t\t * Frees the GPU-related resources allocated by this instance. Call this\n\t\t * method whenever this instance is no longer used in your app.\n\t\t */\n\t\tthis.dispose = function () {\n\n\t\t\trenderTarget.dispose();\n\t\t\tscope.material.dispose();\n\n\t\t};\n\n\t}\n\n}\n\nRefractor.RefractorShader = {\n\n\tname: 'RefractorShader',\n\n\tuniforms: {\n\n\t\t'color': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tDiffuse': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'textureMatrix': {\n\t\t\tvalue: null\n\t\t}\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\n\t\t}`\n\n};\n\n/**\n * Constructor options of `Refractor`.\n *\n * @typedef {Object} Refractor~Options\n * @property {number|Color|string} [color=0x7F7F7F] - The refractor's color.\n * @property {number} [textureWidth=512] - The texture width. A higher value results in more clear refractions but is also more expensive.\n * @property {number} [textureHeight=512] - The texture height. A higher value results in more clear refractions but is also more expensive.\n * @property {number} [clipBias=0] - The clip bias.\n * @property {Object} [shader] - Can be used to pass in a custom shader that defines how the refractive view is projected onto the reflector's geometry.\n * @property {number} [multisample=4] - How many samples to use for MSAA. `0` disables MSAA.\n **/\n\nexport { Refractor };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}