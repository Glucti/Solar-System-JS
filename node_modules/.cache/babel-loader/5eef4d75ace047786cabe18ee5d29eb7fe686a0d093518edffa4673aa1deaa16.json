{"ast":null,"code":"import { Clock, Color, Matrix4, Mesh, RepeatWrapping, ShaderMaterial, TextureLoader, UniformsLib, UniformsUtils, Vector2, Vector4 } from 'three';\nimport { Reflector } from '../objects/Reflector.js';\nimport { Refractor } from '../objects/Refractor.js';\n\n/** @module Water2 */\n\n/**\n * An advanced water effect that supports reflections, refractions and flow maps.\n *\n * Note that this class can only be used with {@link WebGLRenderer}.\n * When using {@link WebGPURenderer}, use {@link module:Water2Mesh}.\n *\n * References:\n *\n * - {@link https://alex.vlachos.com/graphics/Vlachos-SIGGRAPH10-WaterFlow.pdf}\n * - {@link http://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html}\n *\n * @augments Mesh\n * @three_import import { Water } from 'three/addons/objects/Water2.js';\n */\nclass Water extends Mesh {\n  /**\n   * Constructs a new water instance.\n   *\n   * @param {BufferGeometry} geometry - The water's geometry.\n   * @param {module:Water2~Options} [options] - The configuration options.\n   */\n  constructor(geometry, options = {}) {\n    super(geometry);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {boolean}\n     * @readonly\n     * @default true\n     */\n    this.isWater = true;\n    this.type = 'Water';\n    const scope = this;\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0xFFFFFF);\n    const textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\n    const textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\n    const clipBias = options.clipBias !== undefined ? options.clipBias : 0;\n    const flowDirection = options.flowDirection !== undefined ? options.flowDirection : new Vector2(1, 0);\n    const flowSpeed = options.flowSpeed !== undefined ? options.flowSpeed : 0.03;\n    const reflectivity = options.reflectivity !== undefined ? options.reflectivity : 0.02;\n    const scale = options.scale !== undefined ? options.scale : 1;\n    const shader = options.shader !== undefined ? options.shader : Water.WaterShader;\n    const textureLoader = new TextureLoader();\n    const flowMap = options.flowMap || undefined;\n    const normalMap0 = options.normalMap0 || textureLoader.load('textures/water/Water_1_M_Normal.jpg');\n    const normalMap1 = options.normalMap1 || textureLoader.load('textures/water/Water_2_M_Normal.jpg');\n    const cycle = 0.15; // a cycle of a flow map phase\n    const halfCycle = cycle * 0.5;\n    const textureMatrix = new Matrix4();\n    const clock = new Clock();\n\n    // internal components\n\n    if (Reflector === undefined) {\n      console.error('THREE.Water: Required component Reflector not found.');\n      return;\n    }\n    if (Refractor === undefined) {\n      console.error('THREE.Water: Required component Refractor not found.');\n      return;\n    }\n    const reflector = new Reflector(geometry, {\n      textureWidth: textureWidth,\n      textureHeight: textureHeight,\n      clipBias: clipBias\n    });\n    const refractor = new Refractor(geometry, {\n      textureWidth: textureWidth,\n      textureHeight: textureHeight,\n      clipBias: clipBias\n    });\n    reflector.matrixAutoUpdate = false;\n    refractor.matrixAutoUpdate = false;\n\n    // material\n\n    this.material = new ShaderMaterial({\n      name: shader.name,\n      uniforms: UniformsUtils.merge([UniformsLib['fog'], shader.uniforms]),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true,\n      fog: true\n    });\n    if (flowMap !== undefined) {\n      this.material.defines.USE_FLOWMAP = '';\n      this.material.uniforms['tFlowMap'] = {\n        type: 't',\n        value: flowMap\n      };\n    } else {\n      this.material.uniforms['flowDirection'] = {\n        type: 'v2',\n        value: flowDirection\n      };\n    }\n\n    // maps\n\n    normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;\n    normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;\n    this.material.uniforms['tReflectionMap'].value = reflector.getRenderTarget().texture;\n    this.material.uniforms['tRefractionMap'].value = refractor.getRenderTarget().texture;\n    this.material.uniforms['tNormalMap0'].value = normalMap0;\n    this.material.uniforms['tNormalMap1'].value = normalMap1;\n\n    // water\n\n    this.material.uniforms['color'].value = color;\n    this.material.uniforms['reflectivity'].value = reflectivity;\n    this.material.uniforms['textureMatrix'].value = textureMatrix;\n\n    // initial values\n\n    this.material.uniforms['config'].value.x = 0; // flowMapOffset0\n    this.material.uniforms['config'].value.y = halfCycle; // flowMapOffset1\n    this.material.uniforms['config'].value.z = halfCycle; // halfCycle\n    this.material.uniforms['config'].value.w = scale; // scale\n\n    // functions\n\n    function updateTextureMatrix(camera) {\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    }\n    function updateFlow() {\n      const delta = clock.getDelta();\n      const config = scope.material.uniforms['config'];\n      config.value.x += flowSpeed * delta; // flowMapOffset0\n      config.value.y = config.value.x + halfCycle; // flowMapOffset1\n\n      // Important: The distance between offsets should be always the value of \"halfCycle\".\n      // Moreover, both offsets should be in the range of [ 0, cycle ].\n      // This approach ensures a smooth water flow and avoids \"reset\" effects.\n\n      if (config.value.x >= cycle) {\n        config.value.x = 0;\n        config.value.y = halfCycle;\n      } else if (config.value.y >= cycle) {\n        config.value.y = config.value.y - cycle;\n      }\n    }\n\n    //\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      updateTextureMatrix(camera);\n      updateFlow();\n      scope.visible = false;\n      reflector.matrixWorld.copy(scope.matrixWorld);\n      refractor.matrixWorld.copy(scope.matrixWorld);\n      reflector.onBeforeRender(renderer, scene, camera);\n      refractor.onBeforeRender(renderer, scene, camera);\n      scope.visible = true;\n    };\n  }\n}\nWater.WaterShader = {\n  name: 'WaterShader',\n  uniforms: {\n    'color': {\n      type: 'c',\n      value: null\n    },\n    'reflectivity': {\n      type: 'f',\n      value: 0\n    },\n    'tReflectionMap': {\n      type: 't',\n      value: null\n    },\n    'tRefractionMap': {\n      type: 't',\n      value: null\n    },\n    'tNormalMap0': {\n      type: 't',\n      value: null\n    },\n    'tNormalMap1': {\n      type: 't',\n      value: null\n    },\n    'textureMatrix': {\n      type: 'm4',\n      value: null\n    },\n    'config': {\n      type: 'v4',\n      value: new Vector4()\n    }\n  },\n  vertexShader: /* glsl */`\n\n\t\t#include <common>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tvCoord = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvToEye = cameraPosition - worldPosition.xyz;\n\n\t\t\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\n\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}`,\n  fragmentShader: /* glsl */`\n\n\t\t#include <common>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tuniform sampler2D tReflectionMap;\n\t\tuniform sampler2D tRefractionMap;\n\t\tuniform sampler2D tNormalMap0;\n\t\tuniform sampler2D tNormalMap1;\n\n\t\t#ifdef USE_FLOWMAP\n\t\t\tuniform sampler2D tFlowMap;\n\t\t#else\n\t\t\tuniform vec2 flowDirection;\n\t\t#endif\n\n\t\tuniform vec3 color;\n\t\tuniform float reflectivity;\n\t\tuniform vec4 config;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tfloat flowMapOffset0 = config.x;\n\t\t\tfloat flowMapOffset1 = config.y;\n\t\t\tfloat halfCycle = config.z;\n\t\t\tfloat scale = config.w;\n\n\t\t\tvec3 toEye = normalize( vToEye );\n\n\t\t\t// determine flow direction\n\t\t\tvec2 flow;\n\t\t\t#ifdef USE_FLOWMAP\n\t\t\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n\t\t\t#else\n\t\t\t\tflow = flowDirection;\n\t\t\t#endif\n\t\t\tflow.x *= - 1.0;\n\n\t\t\t// sample normal maps (distort uvs with flowdata)\n\t\t\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\n\t\t\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\n\n\t\t\t// linear interpolate to get the final normal color\n\t\t\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\n\t\t\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\n\t\t\t// calculate normal vector\n\t\t\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\n\t\t\tfloat theta = max( dot( toEye, normal ), 0.0 );\n\t\t\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\n\n\t\t\t// calculate final uv coords\n\t\t\tvec3 coord = vCoord.xyz / vCoord.w;\n\t\t\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n\n\t\t\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n\t\t\tvec4 refractColor = texture2D( tRefractionMap, uv );\n\n\t\t\t// multiply water color with the mix of both textures\n\t\t\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}`\n};\n\n/**\n * Constructor options of `Water`.\n *\n * @typedef {Object} module:Water2~Options\n * @property {number|Color|string} [color=0xFFFFFF] - The water color.\n * @property {number} [textureWidth=512] - The texture width. A higher value results in better quality but is also more expensive.\n * @property {number} [textureHeight=512] - The texture height. A higher value results in better quality but is also more expensive.\n * @property {number} [clipBias=0] - The clip bias.\n * @property {Vector2} [flowDirection=(1,0)] - The water's flow direction.\n * @property {number} [flowSpeed=0.03] - The water's flow speed.\n * @property {number} [reflectivity=0.02] - The water's reflectivity.\n * @property {number} [scale=1] - The water's scale.\n * @property {Object} [shader] - A custom water shader.\n * @property {?Texture} [flowMap=null] - The flow map. If no flow map is assigned, the water flow is defined by `flowDirection`.\n * @property {?Texture} [normalMap0] - The first water normal map.\n * @property {?Texture} [normalMap1] -  The second water normal map.\n **/\n\nexport { Water };","map":{"version":3,"names":["Clock","Color","Matrix4","Mesh","RepeatWrapping","ShaderMaterial","TextureLoader","UniformsLib","UniformsUtils","Vector2","Vector4","Reflector","Refractor","Water","constructor","geometry","options","isWater","type","scope","color","undefined","textureWidth","textureHeight","clipBias","flowDirection","flowSpeed","reflectivity","scale","shader","WaterShader","textureLoader","flowMap","normalMap0","load","normalMap1","cycle","halfCycle","textureMatrix","clock","console","error","reflector","refractor","matrixAutoUpdate","material","name","uniforms","merge","vertexShader","fragmentShader","transparent","fog","defines","USE_FLOWMAP","value","wrapS","wrapT","getRenderTarget","texture","x","y","z","w","updateTextureMatrix","camera","set","multiply","projectionMatrix","matrixWorldInverse","matrixWorld","updateFlow","delta","getDelta","config","onBeforeRender","renderer","scene","visible","copy"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/objects/Water2.js"],"sourcesContent":["import {\n\tClock,\n\tColor,\n\tMatrix4,\n\tMesh,\n\tRepeatWrapping,\n\tShaderMaterial,\n\tTextureLoader,\n\tUniformsLib,\n\tUniformsUtils,\n\tVector2,\n\tVector4\n} from 'three';\nimport { Reflector } from '../objects/Reflector.js';\nimport { Refractor } from '../objects/Refractor.js';\n\n/** @module Water2 */\n\n/**\n * An advanced water effect that supports reflections, refractions and flow maps.\n *\n * Note that this class can only be used with {@link WebGLRenderer}.\n * When using {@link WebGPURenderer}, use {@link module:Water2Mesh}.\n *\n * References:\n *\n * - {@link https://alex.vlachos.com/graphics/Vlachos-SIGGRAPH10-WaterFlow.pdf}\n * - {@link http://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html}\n *\n * @augments Mesh\n * @three_import import { Water } from 'three/addons/objects/Water2.js';\n */\nclass Water extends Mesh {\n\n\t/**\n\t * Constructs a new water instance.\n\t *\n\t * @param {BufferGeometry} geometry - The water's geometry.\n\t * @param {module:Water2~Options} [options] - The configuration options.\n\t */\n\tconstructor( geometry, options = {} ) {\n\n\t\tsuper( geometry );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isWater = true;\n\n\t\tthis.type = 'Water';\n\n\t\tconst scope = this;\n\n\t\tconst color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0xFFFFFF );\n\t\tconst textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\n\t\tconst textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\n\t\tconst clipBias = options.clipBias !== undefined ? options.clipBias : 0;\n\t\tconst flowDirection = options.flowDirection !== undefined ? options.flowDirection : new Vector2( 1, 0 );\n\t\tconst flowSpeed = options.flowSpeed !== undefined ? options.flowSpeed : 0.03;\n\t\tconst reflectivity = options.reflectivity !== undefined ? options.reflectivity : 0.02;\n\t\tconst scale = options.scale !== undefined ? options.scale : 1;\n\t\tconst shader = options.shader !== undefined ? options.shader : Water.WaterShader;\n\n\t\tconst textureLoader = new TextureLoader();\n\n\t\tconst flowMap = options.flowMap || undefined;\n\t\tconst normalMap0 = options.normalMap0 || textureLoader.load( 'textures/water/Water_1_M_Normal.jpg' );\n\t\tconst normalMap1 = options.normalMap1 || textureLoader.load( 'textures/water/Water_2_M_Normal.jpg' );\n\n\t\tconst cycle = 0.15; // a cycle of a flow map phase\n\t\tconst halfCycle = cycle * 0.5;\n\t\tconst textureMatrix = new Matrix4();\n\t\tconst clock = new Clock();\n\n\t\t// internal components\n\n\t\tif ( Reflector === undefined ) {\n\n\t\t\tconsole.error( 'THREE.Water: Required component Reflector not found.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( Refractor === undefined ) {\n\n\t\t\tconsole.error( 'THREE.Water: Required component Refractor not found.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst reflector = new Reflector( geometry, {\n\t\t\ttextureWidth: textureWidth,\n\t\t\ttextureHeight: textureHeight,\n\t\t\tclipBias: clipBias\n\t\t} );\n\n\t\tconst refractor = new Refractor( geometry, {\n\t\t\ttextureWidth: textureWidth,\n\t\t\ttextureHeight: textureHeight,\n\t\t\tclipBias: clipBias\n\t\t} );\n\n\t\treflector.matrixAutoUpdate = false;\n\t\trefractor.matrixAutoUpdate = false;\n\n\t\t// material\n\n\t\tthis.material = new ShaderMaterial( {\n\t\t\tname: shader.name,\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib[ 'fog' ],\n\t\t\t\tshader.uniforms\n\t\t\t] ),\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\ttransparent: true,\n\t\t\tfog: true\n\t\t} );\n\n\t\tif ( flowMap !== undefined ) {\n\n\t\t\tthis.material.defines.USE_FLOWMAP = '';\n\t\t\tthis.material.uniforms[ 'tFlowMap' ] = {\n\t\t\t\ttype: 't',\n\t\t\t\tvalue: flowMap\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tthis.material.uniforms[ 'flowDirection' ] = {\n\t\t\t\ttype: 'v2',\n\t\t\t\tvalue: flowDirection\n\t\t\t};\n\n\t\t}\n\n\t\t// maps\n\n\t\tnormalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;\n\t\tnormalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;\n\n\t\tthis.material.uniforms[ 'tReflectionMap' ].value = reflector.getRenderTarget().texture;\n\t\tthis.material.uniforms[ 'tRefractionMap' ].value = refractor.getRenderTarget().texture;\n\t\tthis.material.uniforms[ 'tNormalMap0' ].value = normalMap0;\n\t\tthis.material.uniforms[ 'tNormalMap1' ].value = normalMap1;\n\n\t\t// water\n\n\t\tthis.material.uniforms[ 'color' ].value = color;\n\t\tthis.material.uniforms[ 'reflectivity' ].value = reflectivity;\n\t\tthis.material.uniforms[ 'textureMatrix' ].value = textureMatrix;\n\n\t\t// initial values\n\n\t\tthis.material.uniforms[ 'config' ].value.x = 0; // flowMapOffset0\n\t\tthis.material.uniforms[ 'config' ].value.y = halfCycle; // flowMapOffset1\n\t\tthis.material.uniforms[ 'config' ].value.z = halfCycle; // halfCycle\n\t\tthis.material.uniforms[ 'config' ].value.w = scale; // scale\n\n\t\t// functions\n\n\t\tfunction updateTextureMatrix( camera ) {\n\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\n\t\t\ttextureMatrix.multiply( camera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( camera.matrixWorldInverse );\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t}\n\n\t\tfunction updateFlow() {\n\n\t\t\tconst delta = clock.getDelta();\n\t\t\tconst config = scope.material.uniforms[ 'config' ];\n\n\t\t\tconfig.value.x += flowSpeed * delta; // flowMapOffset0\n\t\t\tconfig.value.y = config.value.x + halfCycle; // flowMapOffset1\n\n\t\t\t// Important: The distance between offsets should be always the value of \"halfCycle\".\n\t\t\t// Moreover, both offsets should be in the range of [ 0, cycle ].\n\t\t\t// This approach ensures a smooth water flow and avoids \"reset\" effects.\n\n\t\t\tif ( config.value.x >= cycle ) {\n\n\t\t\t\tconfig.value.x = 0;\n\t\t\t\tconfig.value.y = halfCycle;\n\n\t\t\t} else if ( config.value.y >= cycle ) {\n\n\t\t\t\tconfig.value.y = config.value.y - cycle;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\tupdateTextureMatrix( camera );\n\t\t\tupdateFlow();\n\n\t\t\tscope.visible = false;\n\n\t\t\treflector.matrixWorld.copy( scope.matrixWorld );\n\t\t\trefractor.matrixWorld.copy( scope.matrixWorld );\n\n\t\t\treflector.onBeforeRender( renderer, scene, camera );\n\t\t\trefractor.onBeforeRender( renderer, scene, camera );\n\n\t\t\tscope.visible = true;\n\n\t\t};\n\n\t}\n\n}\n\nWater.WaterShader = {\n\n\tname: 'WaterShader',\n\n\tuniforms: {\n\n\t\t'color': {\n\t\t\ttype: 'c',\n\t\t\tvalue: null\n\t\t},\n\n\t\t'reflectivity': {\n\t\t\ttype: 'f',\n\t\t\tvalue: 0\n\t\t},\n\n\t\t'tReflectionMap': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tRefractionMap': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tNormalMap0': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tNormalMap1': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t},\n\n\t\t'textureMatrix': {\n\t\t\ttype: 'm4',\n\t\t\tvalue: null\n\t\t},\n\n\t\t'config': {\n\t\t\ttype: 'v4',\n\t\t\tvalue: new Vector4()\n\t\t}\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\t#include <common>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tvCoord = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvToEye = cameraPosition - worldPosition.xyz;\n\n\t\t\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\n\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\t#include <common>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tuniform sampler2D tReflectionMap;\n\t\tuniform sampler2D tRefractionMap;\n\t\tuniform sampler2D tNormalMap0;\n\t\tuniform sampler2D tNormalMap1;\n\n\t\t#ifdef USE_FLOWMAP\n\t\t\tuniform sampler2D tFlowMap;\n\t\t#else\n\t\t\tuniform vec2 flowDirection;\n\t\t#endif\n\n\t\tuniform vec3 color;\n\t\tuniform float reflectivity;\n\t\tuniform vec4 config;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tfloat flowMapOffset0 = config.x;\n\t\t\tfloat flowMapOffset1 = config.y;\n\t\t\tfloat halfCycle = config.z;\n\t\t\tfloat scale = config.w;\n\n\t\t\tvec3 toEye = normalize( vToEye );\n\n\t\t\t// determine flow direction\n\t\t\tvec2 flow;\n\t\t\t#ifdef USE_FLOWMAP\n\t\t\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n\t\t\t#else\n\t\t\t\tflow = flowDirection;\n\t\t\t#endif\n\t\t\tflow.x *= - 1.0;\n\n\t\t\t// sample normal maps (distort uvs with flowdata)\n\t\t\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\n\t\t\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\n\n\t\t\t// linear interpolate to get the final normal color\n\t\t\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\n\t\t\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\n\t\t\t// calculate normal vector\n\t\t\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\n\t\t\tfloat theta = max( dot( toEye, normal ), 0.0 );\n\t\t\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\n\n\t\t\t// calculate final uv coords\n\t\t\tvec3 coord = vCoord.xyz / vCoord.w;\n\t\t\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n\n\t\t\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n\t\t\tvec4 refractColor = texture2D( tRefractionMap, uv );\n\n\t\t\t// multiply water color with the mix of both textures\n\t\t\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}`\n\n};\n\n/**\n * Constructor options of `Water`.\n *\n * @typedef {Object} module:Water2~Options\n * @property {number|Color|string} [color=0xFFFFFF] - The water color.\n * @property {number} [textureWidth=512] - The texture width. A higher value results in better quality but is also more expensive.\n * @property {number} [textureHeight=512] - The texture height. A higher value results in better quality but is also more expensive.\n * @property {number} [clipBias=0] - The clip bias.\n * @property {Vector2} [flowDirection=(1,0)] - The water's flow direction.\n * @property {number} [flowSpeed=0.03] - The water's flow speed.\n * @property {number} [reflectivity=0.02] - The water's reflectivity.\n * @property {number} [scale=1] - The water's scale.\n * @property {Object} [shader] - A custom water shader.\n * @property {?Texture} [flowMap=null] - The flow map. If no flow map is assigned, the water flow is defined by `flowDirection`.\n * @property {?Texture} [normalMap0] - The first water normal map.\n * @property {?Texture} [normalMap1] -  The second water normal map.\n **/\n\nexport { Water };\n"],"mappings":"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AI,EAAE,IAAI;MACVqC,KAAK,EAAE;IACR,CAAC;IAED,QAAQ,EAAE;MACTrC,IAAI,EAAE,IAAI;MACVqC,KAAK,EAAE,IAAI7C,OAAO,CAAC;IACpB;EAED,CAAC;EAEDuC,YAAY,EAAE,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;EAEHC,cAAc,EAAE,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASrC,KAAK","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}