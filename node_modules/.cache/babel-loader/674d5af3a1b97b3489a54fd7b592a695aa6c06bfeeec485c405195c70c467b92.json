{"ast":null,"code":"import { Color, ColorManagement, DefaultLoadingManager, FileLoader, FrontSide, Loader, LoaderUtils, MeshPhongMaterial, RepeatWrapping, TextureLoader, Vector2, SRGBColorSpace } from 'three';\n\n/**\n * A loader for the MTL format.\n *\n * The Material Template Library format (MTL) or .MTL File Format is a companion file format\n * to OBJ that describes surface shading (material) properties of objects within one or more\n * OBJ files.\n *\n * ```js\n * const loader = new MTLLoader();\n * const materials = await loader.loadAsync( 'models/obj/male02/male02.mtl' );\n *\n * const objLoader = new OBJLoader();\n * objLoader.setMaterials( materials );\n * ```\n *\n * @augments Loader\n * @three_import import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';\n */\nclass MTLLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  /**\n   * Starts loading from the given URL and passes the loaded MTL asset\n   * to the `onLoad()` callback.\n   *\n   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n   * @param {function(MaterialCreator)} onLoad - Executed when the loading process has been finished.\n   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n   * @param {onErrorCallback} onError - Executed when errors occur.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  /**\n   * Sets the material options.\n   *\n   * @param {MTLLoader~MaterialOptions} value - The material options.\n   * @return {MTLLoader} A reference to this loader.\n   */\n  setMaterialOptions(value) {\n    this.materialOptions = value;\n    return this;\n  }\n\n  /**\n   * Parses the given MTL data and returns the resulting material creator.\n   *\n   * @param {string} text - The raw MTL data as a string.\n   * @param {string} path - The URL base path.\n   * @return {MaterialCreator} The material creator.\n   */\n  parse(text, path) {\n    const lines = text.split('\\n');\n    let info = {};\n    const delimiter_pattern = /\\s+/;\n    const materialsInfo = {};\n    for (let i = 0; i < lines.length; i++) {\n      let line = lines[i];\n      line = line.trim();\n      if (line.length === 0 || line.charAt(0) === '#') {\n        // Blank line or comment ignore\n        continue;\n      }\n      const pos = line.indexOf(' ');\n      let key = pos >= 0 ? line.substring(0, pos) : line;\n      key = key.toLowerCase();\n      let value = pos >= 0 ? line.substring(pos + 1) : '';\n      value = value.trim();\n      if (key === 'newmtl') {\n        // New material\n\n        info = {\n          name: value\n        };\n        materialsInfo[value] = info;\n      } else {\n        if (key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke') {\n          const ss = value.split(delimiter_pattern, 3);\n          info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];\n        } else {\n          info[key] = value;\n        }\n      }\n    }\n    const materialCreator = new MaterialCreator(this.resourcePath || path, this.materialOptions);\n    materialCreator.setCrossOrigin(this.crossOrigin);\n    materialCreator.setManager(this.manager);\n    materialCreator.setMaterials(materialsInfo);\n    return materialCreator;\n  }\n}\n\n/**\n * Material options of `MTLLoader`.\n *\n * @typedef {Object} MTLLoader~MaterialOptions\n * @property {(FrontSide|BackSide|DoubleSide)} [side=FrontSide] - Which side to apply the material.\n * @property {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)} [wrap=RepeatWrapping] - What type of wrapping to apply for textures.\n * @property {boolean} [normalizeRGB=false] - Whether RGB colors should be normalized to `0-1` from `0-255`.\n * @property {boolean} [ignoreZeroRGBs=false] - Ignore values of RGBs (Ka,Kd,Ks) that are all 0's.\n */\n\nclass MaterialCreator {\n  constructor(baseUrl = '', options = {}) {\n    this.baseUrl = baseUrl;\n    this.options = options;\n    this.materialsInfo = {};\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n    this.crossOrigin = 'anonymous';\n    this.side = this.options.side !== undefined ? this.options.side : FrontSide;\n    this.wrap = this.options.wrap !== undefined ? this.options.wrap : RepeatWrapping;\n  }\n  setCrossOrigin(value) {\n    this.crossOrigin = value;\n    return this;\n  }\n  setManager(value) {\n    this.manager = value;\n  }\n  setMaterials(materialsInfo) {\n    this.materialsInfo = this.convert(materialsInfo);\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n  }\n  convert(materialsInfo) {\n    if (!this.options) return materialsInfo;\n    const converted = {};\n    for (const mn in materialsInfo) {\n      // Convert materials info into normalized form based on options\n\n      const mat = materialsInfo[mn];\n      const covmat = {};\n      converted[mn] = covmat;\n      for (const prop in mat) {\n        let save = true;\n        let value = mat[prop];\n        const lprop = prop.toLowerCase();\n        switch (lprop) {\n          case 'kd':\n          case 'ka':\n          case 'ks':\n            // Diffuse color (color under white light) using RGB values\n\n            if (this.options && this.options.normalizeRGB) {\n              value = [value[0] / 255, value[1] / 255, value[2] / 255];\n            }\n            if (this.options && this.options.ignoreZeroRGBs) {\n              if (value[0] === 0 && value[1] === 0 && value[2] === 0) {\n                // ignore\n\n                save = false;\n              }\n            }\n            break;\n          default:\n            break;\n        }\n        if (save) {\n          covmat[lprop] = value;\n        }\n      }\n    }\n    return converted;\n  }\n  preload() {\n    for (const mn in this.materialsInfo) {\n      this.create(mn);\n    }\n  }\n  getIndex(materialName) {\n    return this.nameLookup[materialName];\n  }\n  getAsArray() {\n    let index = 0;\n    for (const mn in this.materialsInfo) {\n      this.materialsArray[index] = this.create(mn);\n      this.nameLookup[mn] = index;\n      index++;\n    }\n    return this.materialsArray;\n  }\n  create(materialName) {\n    if (this.materials[materialName] === undefined) {\n      this.createMaterial_(materialName);\n    }\n    return this.materials[materialName];\n  }\n  createMaterial_(materialName) {\n    // Create material\n\n    const scope = this;\n    const mat = this.materialsInfo[materialName];\n    const params = {\n      name: materialName,\n      side: this.side\n    };\n    function resolveURL(baseUrl, url) {\n      if (typeof url !== 'string' || url === '') return '';\n\n      // Absolute URL\n      if (/^https?:\\/\\//i.test(url)) return url;\n      return baseUrl + url;\n    }\n    function setMapForType(mapType, value) {\n      if (params[mapType]) return; // Keep the first encountered texture\n\n      const texParams = scope.getTextureParams(value, params);\n      const map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));\n      map.repeat.copy(texParams.scale);\n      map.offset.copy(texParams.offset);\n      map.wrapS = scope.wrap;\n      map.wrapT = scope.wrap;\n      if (mapType === 'map' || mapType === 'emissiveMap') {\n        map.colorSpace = SRGBColorSpace;\n      }\n      params[mapType] = map;\n    }\n    for (const prop in mat) {\n      const value = mat[prop];\n      let n;\n      if (value === '') continue;\n      switch (prop.toLowerCase()) {\n        // Ns is material specular exponent\n\n        case 'kd':\n          // Diffuse color (color under white light) using RGB values\n\n          params.color = ColorManagement.colorSpaceToWorking(new Color().fromArray(value), SRGBColorSpace);\n          break;\n        case 'ks':\n          // Specular color (color when light is reflected from shiny surface) using RGB values\n          params.specular = ColorManagement.colorSpaceToWorking(new Color().fromArray(value), SRGBColorSpace);\n          break;\n        case 'ke':\n          // Emissive using RGB values\n          params.emissive = ColorManagement.colorSpaceToWorking(new Color().fromArray(value), SRGBColorSpace);\n          break;\n        case 'map_kd':\n          // Diffuse texture map\n\n          setMapForType('map', value);\n          break;\n        case 'map_ks':\n          // Specular map\n\n          setMapForType('specularMap', value);\n          break;\n        case 'map_ke':\n          // Emissive map\n\n          setMapForType('emissiveMap', value);\n          break;\n        case 'norm':\n          setMapForType('normalMap', value);\n          break;\n        case 'map_bump':\n        case 'bump':\n          // Bump texture map\n\n          setMapForType('bumpMap', value);\n          break;\n        case 'disp':\n          // Displacement texture map\n\n          setMapForType('displacementMap', value);\n          break;\n        case 'map_d':\n          // Alpha map\n\n          setMapForType('alphaMap', value);\n          params.transparent = true;\n          break;\n        case 'ns':\n          // The specular exponent (defines the focus of the specular highlight)\n          // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n\n          params.shininess = parseFloat(value);\n          break;\n        case 'd':\n          n = parseFloat(value);\n          if (n < 1) {\n            params.opacity = n;\n            params.transparent = true;\n          }\n          break;\n        case 'tr':\n          n = parseFloat(value);\n          if (this.options && this.options.invertTrProperty) n = 1 - n;\n          if (n > 0) {\n            params.opacity = 1 - n;\n            params.transparent = true;\n          }\n          break;\n        default:\n          break;\n      }\n    }\n    this.materials[materialName] = new MeshPhongMaterial(params);\n    return this.materials[materialName];\n  }\n  getTextureParams(value, matParams) {\n    const texParams = {\n      scale: new Vector2(1, 1),\n      offset: new Vector2(0, 0)\n    };\n    const items = value.split(/\\s+/);\n    let pos;\n    pos = items.indexOf('-bm');\n    if (pos >= 0) {\n      matParams.bumpScale = parseFloat(items[pos + 1]);\n      items.splice(pos, 2);\n    }\n    pos = items.indexOf('-mm');\n    if (pos >= 0) {\n      matParams.displacementBias = parseFloat(items[pos + 1]);\n      matParams.displacementScale = parseFloat(items[pos + 2]);\n      items.splice(pos, 3);\n    }\n    pos = items.indexOf('-s');\n    if (pos >= 0) {\n      texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n      items.splice(pos, 4); // we expect 3 parameters here!\n    }\n    pos = items.indexOf('-o');\n    if (pos >= 0) {\n      texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n      items.splice(pos, 4); // we expect 3 parameters here!\n    }\n    texParams.url = items.join(' ').trim();\n    return texParams;\n  }\n  loadTexture(url, mapping, onLoad, onProgress, onError) {\n    const manager = this.manager !== undefined ? this.manager : DefaultLoadingManager;\n    let loader = manager.getHandler(url);\n    if (loader === null) {\n      loader = new TextureLoader(manager);\n    }\n    if (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin);\n    const texture = loader.load(url, onLoad, onProgress, onError);\n    if (mapping !== undefined) texture.mapping = mapping;\n    return texture;\n  }\n}\nexport { MTLLoader };","map":{"version":3,"names":["Color","ColorManagement","DefaultLoadingManager","FileLoader","FrontSide","Loader","LoaderUtils","MeshPhongMaterial","RepeatWrapping","TextureLoader","Vector2","SRGBColorSpace","MTLLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","setMaterialOptions","value","materialOptions","lines","split","info","delimiter_pattern","materialsInfo","i","length","line","trim","charAt","pos","indexOf","key","substring","toLowerCase","name","ss","parseFloat","materialCreator","MaterialCreator","resourcePath","setCrossOrigin","crossOrigin","setManager","setMaterials","baseUrl","options","materials","materialsArray","nameLookup","side","undefined","wrap","convert","converted","mn","mat","covmat","prop","save","lprop","normalizeRGB","ignoreZeroRGBs","preload","create","getIndex","materialName","getAsArray","index","createMaterial_","params","resolveURL","test","setMapForType","mapType","texParams","getTextureParams","map","loadTexture","repeat","copy","scale","offset","wrapS","wrapT","colorSpace","n","color","colorSpaceToWorking","fromArray","specular","emissive","transparent","shininess","opacity","invertTrProperty","matParams","items","bumpScale","splice","displacementBias","displacementScale","set","join","mapping","getHandler","texture"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/loaders/MTLLoader.js"],"sourcesContent":["import {\n\tColor,\n\tColorManagement,\n\tDefaultLoadingManager,\n\tFileLoader,\n\tFrontSide,\n\tLoader,\n\tLoaderUtils,\n\tMeshPhongMaterial,\n\tRepeatWrapping,\n\tTextureLoader,\n\tVector2,\n\tSRGBColorSpace\n} from 'three';\n\n/**\n * A loader for the MTL format.\n *\n * The Material Template Library format (MTL) or .MTL File Format is a companion file format\n * to OBJ that describes surface shading (material) properties of objects within one or more\n * OBJ files.\n *\n * ```js\n * const loader = new MTLLoader();\n * const materials = await loader.loadAsync( 'models/obj/male02/male02.mtl' );\n *\n * const objLoader = new OBJLoader();\n * objLoader.setMaterials( materials );\n * ```\n *\n * @augments Loader\n * @three_import import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';\n */\nclass MTLLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded MTL asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(MaterialCreator)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Sets the material options.\n\t *\n\t * @param {MTLLoader~MaterialOptions} value - The material options.\n\t * @return {MTLLoader} A reference to this loader.\n\t */\n\tsetMaterialOptions( value ) {\n\n\t\tthis.materialOptions = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Parses the given MTL data and returns the resulting material creator.\n\t *\n\t * @param {string} text - The raw MTL data as a string.\n\t * @param {string} path - The URL base path.\n\t * @return {MaterialCreator} The material creator.\n\t */\n\tparse( text, path ) {\n\n\t\tconst lines = text.split( '\\n' );\n\t\tlet info = {};\n\t\tconst delimiter_pattern = /\\s+/;\n\t\tconst materialsInfo = {};\n\n\t\tfor ( let i = 0; i < lines.length; i ++ ) {\n\n\t\t\tlet line = lines[ i ];\n\t\t\tline = line.trim();\n\n\t\t\tif ( line.length === 0 || line.charAt( 0 ) === '#' ) {\n\n\t\t\t\t// Blank line or comment ignore\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst pos = line.indexOf( ' ' );\n\n\t\t\tlet key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;\n\t\t\tkey = key.toLowerCase();\n\n\t\t\tlet value = ( pos >= 0 ) ? line.substring( pos + 1 ) : '';\n\t\t\tvalue = value.trim();\n\n\t\t\tif ( key === 'newmtl' ) {\n\n\t\t\t\t// New material\n\n\t\t\t\tinfo = { name: value };\n\t\t\t\tmaterialsInfo[ value ] = info;\n\n\t\t\t} else {\n\n\t\t\t\tif ( key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke' ) {\n\n\t\t\t\t\tconst ss = value.split( delimiter_pattern, 3 );\n\t\t\t\t\tinfo[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tinfo[ key ] = value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst materialCreator = new MaterialCreator( this.resourcePath || path, this.materialOptions );\n\t\tmaterialCreator.setCrossOrigin( this.crossOrigin );\n\t\tmaterialCreator.setManager( this.manager );\n\t\tmaterialCreator.setMaterials( materialsInfo );\n\t\treturn materialCreator;\n\n\t}\n\n}\n\n/**\n * Material options of `MTLLoader`.\n *\n * @typedef {Object} MTLLoader~MaterialOptions\n * @property {(FrontSide|BackSide|DoubleSide)} [side=FrontSide] - Which side to apply the material.\n * @property {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)} [wrap=RepeatWrapping] - What type of wrapping to apply for textures.\n * @property {boolean} [normalizeRGB=false] - Whether RGB colors should be normalized to `0-1` from `0-255`.\n * @property {boolean} [ignoreZeroRGBs=false] - Ignore values of RGBs (Ka,Kd,Ks) that are all 0's.\n */\n\nclass MaterialCreator {\n\n\tconstructor( baseUrl = '', options = {} ) {\n\n\t\tthis.baseUrl = baseUrl;\n\t\tthis.options = options;\n\t\tthis.materialsInfo = {};\n\t\tthis.materials = {};\n\t\tthis.materialsArray = [];\n\t\tthis.nameLookup = {};\n\n\t\tthis.crossOrigin = 'anonymous';\n\n\t\tthis.side = ( this.options.side !== undefined ) ? this.options.side : FrontSide;\n\t\tthis.wrap = ( this.options.wrap !== undefined ) ? this.options.wrap : RepeatWrapping;\n\n\t}\n\n\tsetCrossOrigin( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t}\n\n\tsetManager( value ) {\n\n\t\tthis.manager = value;\n\n\t}\n\n\tsetMaterials( materialsInfo ) {\n\n\t\tthis.materialsInfo = this.convert( materialsInfo );\n\t\tthis.materials = {};\n\t\tthis.materialsArray = [];\n\t\tthis.nameLookup = {};\n\n\t}\n\n\tconvert( materialsInfo ) {\n\n\t\tif ( ! this.options ) return materialsInfo;\n\n\t\tconst converted = {};\n\n\t\tfor ( const mn in materialsInfo ) {\n\n\t\t\t// Convert materials info into normalized form based on options\n\n\t\t\tconst mat = materialsInfo[ mn ];\n\n\t\t\tconst covmat = {};\n\n\t\t\tconverted[ mn ] = covmat;\n\n\t\t\tfor ( const prop in mat ) {\n\n\t\t\t\tlet save = true;\n\t\t\t\tlet value = mat[ prop ];\n\t\t\t\tconst lprop = prop.toLowerCase();\n\n\t\t\t\tswitch ( lprop ) {\n\n\t\t\t\t\tcase 'kd':\n\t\t\t\t\tcase 'ka':\n\t\t\t\t\tcase 'ks':\n\n\t\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\t\tif ( this.options && this.options.normalizeRGB ) {\n\n\t\t\t\t\t\t\tvalue = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( this.options && this.options.ignoreZeroRGBs ) {\n\n\t\t\t\t\t\t\tif ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0 ) {\n\n\t\t\t\t\t\t\t\t// ignore\n\n\t\t\t\t\t\t\t\tsave = false;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( save ) {\n\n\t\t\t\t\tcovmat[ lprop ] = value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn converted;\n\n\t}\n\n\tpreload() {\n\n\t\tfor ( const mn in this.materialsInfo ) {\n\n\t\t\tthis.create( mn );\n\n\t\t}\n\n\t}\n\n\tgetIndex( materialName ) {\n\n\t\treturn this.nameLookup[ materialName ];\n\n\t}\n\n\tgetAsArray() {\n\n\t\tlet index = 0;\n\n\t\tfor ( const mn in this.materialsInfo ) {\n\n\t\t\tthis.materialsArray[ index ] = this.create( mn );\n\t\t\tthis.nameLookup[ mn ] = index;\n\t\t\tindex ++;\n\n\t\t}\n\n\t\treturn this.materialsArray;\n\n\t}\n\n\tcreate( materialName ) {\n\n\t\tif ( this.materials[ materialName ] === undefined ) {\n\n\t\t\tthis.createMaterial_( materialName );\n\n\t\t}\n\n\t\treturn this.materials[ materialName ];\n\n\t}\n\n\tcreateMaterial_( materialName ) {\n\n\t\t// Create material\n\n\t\tconst scope = this;\n\t\tconst mat = this.materialsInfo[ materialName ];\n\t\tconst params = {\n\n\t\t\tname: materialName,\n\t\t\tside: this.side\n\n\t\t};\n\n\t\tfunction resolveURL( baseUrl, url ) {\n\n\t\t\tif ( typeof url !== 'string' || url === '' )\n\t\t\t\treturn '';\n\n\t\t\t// Absolute URL\n\t\t\tif ( /^https?:\\/\\//i.test( url ) ) return url;\n\n\t\t\treturn baseUrl + url;\n\n\t\t}\n\n\t\tfunction setMapForType( mapType, value ) {\n\n\t\t\tif ( params[ mapType ] ) return; // Keep the first encountered texture\n\n\t\t\tconst texParams = scope.getTextureParams( value, params );\n\t\t\tconst map = scope.loadTexture( resolveURL( scope.baseUrl, texParams.url ) );\n\n\t\t\tmap.repeat.copy( texParams.scale );\n\t\t\tmap.offset.copy( texParams.offset );\n\n\t\t\tmap.wrapS = scope.wrap;\n\t\t\tmap.wrapT = scope.wrap;\n\n\t\t\tif ( mapType === 'map' || mapType === 'emissiveMap' ) {\n\n\t\t\t\tmap.colorSpace = SRGBColorSpace;\n\n\t\t\t}\n\n\t\t\tparams[ mapType ] = map;\n\n\t\t}\n\n\t\tfor ( const prop in mat ) {\n\n\t\t\tconst value = mat[ prop ];\n\t\t\tlet n;\n\n\t\t\tif ( value === '' ) continue;\n\n\t\t\tswitch ( prop.toLowerCase() ) {\n\n\t\t\t\t// Ns is material specular exponent\n\n\t\t\t\tcase 'kd':\n\n\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\tparams.color = ColorManagement.colorSpaceToWorking( new Color().fromArray( value ), SRGBColorSpace );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ks':\n\n\t\t\t\t\t// Specular color (color when light is reflected from shiny surface) using RGB values\n\t\t\t\t\tparams.specular = ColorManagement.colorSpaceToWorking( new Color().fromArray( value ), SRGBColorSpace );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ke':\n\n\t\t\t\t\t// Emissive using RGB values\n\t\t\t\t\tparams.emissive = ColorManagement.colorSpaceToWorking( new Color().fromArray( value ), SRGBColorSpace );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_kd':\n\n\t\t\t\t\t// Diffuse texture map\n\n\t\t\t\t\tsetMapForType( 'map', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_ks':\n\n\t\t\t\t\t// Specular map\n\n\t\t\t\t\tsetMapForType( 'specularMap', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_ke':\n\n\t\t\t\t\t// Emissive map\n\n\t\t\t\t\tsetMapForType( 'emissiveMap', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'norm':\n\n\t\t\t\t\tsetMapForType( 'normalMap', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_bump':\n\t\t\t\tcase 'bump':\n\n\t\t\t\t\t// Bump texture map\n\n\t\t\t\t\tsetMapForType( 'bumpMap', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'disp':\n\n\t\t\t\t\t// Displacement texture map\n\n\t\t\t\t\tsetMapForType( 'displacementMap', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_d':\n\n\t\t\t\t\t// Alpha map\n\n\t\t\t\t\tsetMapForType( 'alphaMap', value );\n\t\t\t\t\tparams.transparent = true;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ns':\n\n\t\t\t\t\t// The specular exponent (defines the focus of the specular highlight)\n\t\t\t\t\t// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n\n\t\t\t\t\tparams.shininess = parseFloat( value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'd':\n\t\t\t\t\tn = parseFloat( value );\n\n\t\t\t\t\tif ( n < 1 ) {\n\n\t\t\t\t\t\tparams.opacity = n;\n\t\t\t\t\t\tparams.transparent = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'tr':\n\t\t\t\t\tn = parseFloat( value );\n\n\t\t\t\t\tif ( this.options && this.options.invertTrProperty ) n = 1 - n;\n\n\t\t\t\t\tif ( n > 0 ) {\n\n\t\t\t\t\t\tparams.opacity = 1 - n;\n\t\t\t\t\t\tparams.transparent = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.materials[ materialName ] = new MeshPhongMaterial( params );\n\t\treturn this.materials[ materialName ];\n\n\t}\n\n\tgetTextureParams( value, matParams ) {\n\n\t\tconst texParams = {\n\n\t\t\tscale: new Vector2( 1, 1 ),\n\t\t\toffset: new Vector2( 0, 0 )\n\n\t\t };\n\n\t\tconst items = value.split( /\\s+/ );\n\t\tlet pos;\n\n\t\tpos = items.indexOf( '-bm' );\n\n\t\tif ( pos >= 0 ) {\n\n\t\t\tmatParams.bumpScale = parseFloat( items[ pos + 1 ] );\n\t\t\titems.splice( pos, 2 );\n\n\t\t}\n\n\t\tpos = items.indexOf( '-mm' );\n\n\t\tif ( pos >= 0 ) {\n\n\t\t\tmatParams.displacementBias = parseFloat( items[ pos + 1 ] );\n\t\t\tmatParams.displacementScale = parseFloat( items[ pos + 2 ] );\n\t\t\titems.splice( pos, 3 );\n\n\t\t}\n\n\t\tpos = items.indexOf( '-s' );\n\n\t\tif ( pos >= 0 ) {\n\n\t\t\ttexParams.scale.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );\n\t\t\titems.splice( pos, 4 ); // we expect 3 parameters here!\n\n\t\t}\n\n\t\tpos = items.indexOf( '-o' );\n\n\t\tif ( pos >= 0 ) {\n\n\t\t\ttexParams.offset.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );\n\t\t\titems.splice( pos, 4 ); // we expect 3 parameters here!\n\n\t\t}\n\n\t\ttexParams.url = items.join( ' ' ).trim();\n\t\treturn texParams;\n\n\t}\n\n\tloadTexture( url, mapping, onLoad, onProgress, onError ) {\n\n\t\tconst manager = ( this.manager !== undefined ) ? this.manager : DefaultLoadingManager;\n\t\tlet loader = manager.getHandler( url );\n\n\t\tif ( loader === null ) {\n\n\t\t\tloader = new TextureLoader( manager );\n\n\t\t}\n\n\t\tif ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin );\n\n\t\tconst texture = loader.load( url, onLoad, onProgress, onError );\n\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\n\n\t\treturn texture;\n\n\t}\n\n}\n\nexport { MTLLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}