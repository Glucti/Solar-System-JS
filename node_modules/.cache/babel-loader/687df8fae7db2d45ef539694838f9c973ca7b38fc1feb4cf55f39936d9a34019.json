{"ast":null,"code":"import { Clock, Vector3, Quaternion, Matrix4 } from 'three';\nconst JOLT_PATH = 'https://cdn.jsdelivr.net/npm/jolt-physics@0.23.0/dist/jolt-physics.wasm-compat.js';\nconst frameRate = 60;\nlet Jolt = null;\nfunction getShape(geometry) {\n  const parameters = geometry.parameters;\n\n  // TODO change type to is*\n\n  if (geometry.type === 'BoxGeometry') {\n    const sx = parameters.width !== undefined ? parameters.width / 2 : 0.5;\n    const sy = parameters.height !== undefined ? parameters.height / 2 : 0.5;\n    const sz = parameters.depth !== undefined ? parameters.depth / 2 : 0.5;\n    return new Jolt.BoxShape(new Jolt.Vec3(sx, sy, sz), 0.05 * Math.min(sx, sy, sz), null);\n  } else if (geometry.type === 'SphereGeometry' || geometry.type === 'IcosahedronGeometry') {\n    const radius = parameters.radius !== undefined ? parameters.radius : 1;\n    return new Jolt.SphereShape(radius, null);\n  }\n  return null;\n}\n\n// Object layers\nconst LAYER_NON_MOVING = 0;\nconst LAYER_MOVING = 1;\nconst NUM_OBJECT_LAYERS = 2;\nfunction setupCollisionFiltering(settings) {\n  const objectFilter = new Jolt.ObjectLayerPairFilterTable(NUM_OBJECT_LAYERS);\n  objectFilter.EnableCollision(LAYER_NON_MOVING, LAYER_MOVING);\n  objectFilter.EnableCollision(LAYER_MOVING, LAYER_MOVING);\n  const BP_LAYER_NON_MOVING = new Jolt.BroadPhaseLayer(0);\n  const BP_LAYER_MOVING = new Jolt.BroadPhaseLayer(1);\n  const NUM_BROAD_PHASE_LAYERS = 2;\n  const bpInterface = new Jolt.BroadPhaseLayerInterfaceTable(NUM_OBJECT_LAYERS, NUM_BROAD_PHASE_LAYERS);\n  bpInterface.MapObjectToBroadPhaseLayer(LAYER_NON_MOVING, BP_LAYER_NON_MOVING);\n  bpInterface.MapObjectToBroadPhaseLayer(LAYER_MOVING, BP_LAYER_MOVING);\n  settings.mObjectLayerPairFilter = objectFilter;\n  settings.mBroadPhaseLayerInterface = bpInterface;\n  settings.mObjectVsBroadPhaseLayerFilter = new Jolt.ObjectVsBroadPhaseLayerFilterTable(settings.mBroadPhaseLayerInterface, NUM_BROAD_PHASE_LAYERS, settings.mObjectLayerPairFilter, NUM_OBJECT_LAYERS);\n}\n\n/**\n * @classdesc Can be used to include Jolt as a Physics engine into\n * `three.js` apps. The API can be initialized via:\n * ```js\n * const physics = await JoltPhysics();\n * ```\n * The component automatically imports Jolt from a CDN so make sure\n * to use the component with an active Internet connection.\n *\n * @name JoltPhysics\n * @class\n * @hideconstructor\n * @three_import import { JoltPhysics } from 'three/addons/physics/JoltPhysics.js';\n */\nasync function JoltPhysics() {\n  if (Jolt === null) {\n    const {\n      default: initJolt\n    } = await import(`${JOLT_PATH}`);\n    Jolt = await initJolt();\n  }\n  const settings = new Jolt.JoltSettings();\n  setupCollisionFiltering(settings);\n  const jolt = new Jolt.JoltInterface(settings);\n  Jolt.destroy(settings);\n  const physicsSystem = jolt.GetPhysicsSystem();\n  const bodyInterface = physicsSystem.GetBodyInterface();\n  const meshes = [];\n  const meshMap = new WeakMap();\n  const _position = new Vector3();\n  const _quaternion = new Quaternion();\n  const _scale = new Vector3(1, 1, 1);\n  const _matrix = new Matrix4();\n  function addScene(scene) {\n    scene.traverse(function (child) {\n      if (child.isMesh) {\n        const physics = child.userData.physics;\n        if (physics) {\n          addMesh(child, physics.mass, physics.restitution);\n        }\n      }\n    });\n  }\n  function addMesh(mesh, mass = 0, restitution = 0) {\n    const shape = getShape(mesh.geometry);\n    if (shape === null) return;\n    const body = mesh.isInstancedMesh ? createInstancedBody(mesh, mass, restitution, shape) : createBody(mesh.position, mesh.quaternion, mass, restitution, shape);\n    if (mass > 0) {\n      meshes.push(mesh);\n      meshMap.set(mesh, body);\n    }\n  }\n  function createInstancedBody(mesh, mass, restitution, shape) {\n    const array = mesh.instanceMatrix.array;\n    const bodies = [];\n    for (let i = 0; i < mesh.count; i++) {\n      const position = _position.fromArray(array, i * 16 + 12);\n      const quaternion = _quaternion.setFromRotationMatrix(_matrix.fromArray(array, i * 16)); // TODO Copilot did this\n      bodies.push(createBody(position, quaternion, mass, restitution, shape));\n    }\n    return bodies;\n  }\n  function createBody(position, rotation, mass, restitution, shape) {\n    const pos = new Jolt.Vec3(position.x, position.y, position.z);\n    const rot = new Jolt.Quat(rotation.x, rotation.y, rotation.z, rotation.w);\n    const motion = mass > 0 ? Jolt.EMotionType_Dynamic : Jolt.EMotionType_Static;\n    const layer = mass > 0 ? LAYER_MOVING : LAYER_NON_MOVING;\n    const creationSettings = new Jolt.BodyCreationSettings(shape, pos, rot, motion, layer);\n    creationSettings.mRestitution = restitution;\n    const body = bodyInterface.CreateBody(creationSettings);\n    bodyInterface.AddBody(body.GetID(), Jolt.EActivation_Activate);\n    Jolt.destroy(creationSettings);\n    return body;\n  }\n  function setMeshPosition(mesh, position, index = 0) {\n    if (mesh.isInstancedMesh) {\n      const bodies = meshMap.get(mesh);\n      const body = bodies[index];\n      bodyInterface.RemoveBody(body.GetID());\n      bodyInterface.DestroyBody(body.GetID());\n      const physics = mesh.userData.physics;\n      const shape = body.GetShape();\n      const body2 = createBody(position, {\n        x: 0,\n        y: 0,\n        z: 0,\n        w: 1\n      }, physics.mass, physics.restitution, shape);\n      bodies[index] = body2;\n    } else {\n\n      // TODO: Implement this\n    }\n  }\n  function setMeshVelocity(mesh, velocity, index = 0) {\n\n    /*\n    let body = meshMap.get( mesh );\n    \tif ( mesh.isInstancedMesh ) {\n    \t\tbody = body[ index ];\n    \t}\n    \tbody.setLinvel( velocity );\n    */\n  }\n\n  //\n\n  const clock = new Clock();\n  function step() {\n    let deltaTime = clock.getDelta();\n\n    // Don't go below 30 Hz to prevent spiral of death\n    deltaTime = Math.min(deltaTime, 1.0 / 30.0);\n\n    // When running below 55 Hz, do 2 steps instead of 1\n    const numSteps = deltaTime > 1.0 / 55.0 ? 2 : 1;\n\n    // Step the physics world\n    jolt.Step(deltaTime, numSteps);\n\n    //\n\n    for (let i = 0, l = meshes.length; i < l; i++) {\n      const mesh = meshes[i];\n      if (mesh.isInstancedMesh) {\n        const array = mesh.instanceMatrix.array;\n        const bodies = meshMap.get(mesh);\n        for (let j = 0; j < bodies.length; j++) {\n          const body = bodies[j];\n          const position = body.GetPosition();\n          const quaternion = body.GetRotation();\n          _position.set(position.GetX(), position.GetY(), position.GetZ());\n          _quaternion.set(quaternion.GetX(), quaternion.GetY(), quaternion.GetZ(), quaternion.GetW());\n          _matrix.compose(_position, _quaternion, _scale).toArray(array, j * 16);\n        }\n        mesh.instanceMatrix.needsUpdate = true;\n        mesh.computeBoundingSphere();\n      } else {\n        const body = meshMap.get(mesh);\n        const position = body.GetPosition();\n        const rotation = body.GetRotation();\n        mesh.position.set(position.GetX(), position.GetY(), position.GetZ());\n        mesh.quaternion.set(rotation.GetX(), rotation.GetY(), rotation.GetZ(), rotation.GetW());\n      }\n    }\n  }\n\n  // animate\n\n  setInterval(step, 1000 / frameRate);\n  return {\n    /**\n     * Adds the given scene to this physics simulation. Only meshes with a\n     * `physics` object in their {@link Object3D#userData} field will be honored.\n     * The object can be used to store the mass and restitution of the mesh. E.g.:\n     * ```js\n     * box.userData.physics = { mass: 1, restitution: 0 };\n     * ```\n     *\n     * @method\n     * @name JoltPhysics#addScene\n     * @param {Object3D} scene The scene or any type of 3D object to add.\n     */\n    addScene: addScene,\n    /**\n     * Adds the given mesh to this physics simulation.\n     *\n     * @method\n     * @name JoltPhysics#addMesh\n     * @param {Mesh} mesh The mesh to add.\n     * @param {number} [mass=0] The mass in kg of the mesh.\n     * @param {number} [restitution=0] The restitution/friction of the mesh.\n     */\n    addMesh: addMesh,\n    /**\n     * Set the position of the given mesh which is part of the physics simulation. Calling this\n     * method will reset the current simulated velocity of the mesh.\n     *\n     * @method\n     * @name JoltPhysics#setMeshPosition\n     * @param {Mesh} mesh The mesh to update the position for.\n     * @param {Vector3} position - The new position.\n     * @param {number} [index=0] - If the mesh is instanced, the index represents the instanced ID.\n     */\n    setMeshPosition: setMeshPosition,\n    // NOOP\n    setMeshVelocity: setMeshVelocity\n  };\n}\nexport { JoltPhysics };","map":{"version":3,"names":["Clock","Vector3","Quaternion","Matrix4","JOLT_PATH","frameRate","Jolt","getShape","geometry","parameters","type","sx","width","undefined","sy","height","sz","depth","BoxShape","Vec3","Math","min","radius","SphereShape","LAYER_NON_MOVING","LAYER_MOVING","NUM_OBJECT_LAYERS","setupCollisionFiltering","settings","objectFilter","ObjectLayerPairFilterTable","EnableCollision","BP_LAYER_NON_MOVING","BroadPhaseLayer","BP_LAYER_MOVING","NUM_BROAD_PHASE_LAYERS","bpInterface","BroadPhaseLayerInterfaceTable","MapObjectToBroadPhaseLayer","mObjectLayerPairFilter","mBroadPhaseLayerInterface","mObjectVsBroadPhaseLayerFilter","ObjectVsBroadPhaseLayerFilterTable","JoltPhysics","default","initJolt","JoltSettings","jolt","JoltInterface","destroy","physicsSystem","GetPhysicsSystem","bodyInterface","GetBodyInterface","meshes","meshMap","WeakMap","_position","_quaternion","_scale","_matrix","addScene","scene","traverse","child","isMesh","physics","userData","addMesh","mass","restitution","mesh","shape","body","isInstancedMesh","createInstancedBody","createBody","position","quaternion","push","set","array","instanceMatrix","bodies","i","count","fromArray","setFromRotationMatrix","rotation","pos","x","y","z","rot","Quat","w","motion","EMotionType_Dynamic","EMotionType_Static","layer","creationSettings","BodyCreationSettings","mRestitution","CreateBody","AddBody","GetID","EActivation_Activate","setMeshPosition","index","get","RemoveBody","DestroyBody","GetShape","body2","setMeshVelocity","velocity","clock","step","deltaTime","getDelta","numSteps","Step","l","length","j","GetPosition","GetRotation","GetX","GetY","GetZ","GetW","compose","toArray","needsUpdate","computeBoundingSphere","setInterval"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/physics/JoltPhysics.js"],"sourcesContent":["import { Clock, Vector3, Quaternion, Matrix4 } from 'three';\n\nconst JOLT_PATH = 'https://cdn.jsdelivr.net/npm/jolt-physics@0.23.0/dist/jolt-physics.wasm-compat.js';\n\nconst frameRate = 60;\n\nlet Jolt = null;\n\nfunction getShape( geometry ) {\n\n\tconst parameters = geometry.parameters;\n\n\t// TODO change type to is*\n\n\tif ( geometry.type === 'BoxGeometry' ) {\n\n\t\tconst sx = parameters.width !== undefined ? parameters.width / 2 : 0.5;\n\t\tconst sy = parameters.height !== undefined ? parameters.height / 2 : 0.5;\n\t\tconst sz = parameters.depth !== undefined ? parameters.depth / 2 : 0.5;\n\n\t\treturn new Jolt.BoxShape( new Jolt.Vec3( sx, sy, sz ), 0.05 * Math.min( sx, sy, sz ), null );\n\n\t} else if ( geometry.type === 'SphereGeometry' || geometry.type === 'IcosahedronGeometry' ) {\n\n\t\tconst radius = parameters.radius !== undefined ? parameters.radius : 1;\n\n\t\treturn new Jolt.SphereShape( radius, null );\n\n\t}\n\n\treturn null;\n\n}\n\n// Object layers\nconst LAYER_NON_MOVING = 0;\nconst LAYER_MOVING = 1;\nconst NUM_OBJECT_LAYERS = 2;\n\nfunction setupCollisionFiltering( settings ) {\n\n\tconst objectFilter = new Jolt.ObjectLayerPairFilterTable( NUM_OBJECT_LAYERS );\n\tobjectFilter.EnableCollision( LAYER_NON_MOVING, LAYER_MOVING );\n\tobjectFilter.EnableCollision( LAYER_MOVING, LAYER_MOVING );\n\n\tconst BP_LAYER_NON_MOVING = new Jolt.BroadPhaseLayer( 0 );\n\tconst BP_LAYER_MOVING = new Jolt.BroadPhaseLayer( 1 );\n\tconst NUM_BROAD_PHASE_LAYERS = 2;\n\n\tconst bpInterface = new Jolt.BroadPhaseLayerInterfaceTable( NUM_OBJECT_LAYERS, NUM_BROAD_PHASE_LAYERS );\n\tbpInterface.MapObjectToBroadPhaseLayer( LAYER_NON_MOVING, BP_LAYER_NON_MOVING );\n\tbpInterface.MapObjectToBroadPhaseLayer( LAYER_MOVING, BP_LAYER_MOVING );\n\n\tsettings.mObjectLayerPairFilter = objectFilter;\n\tsettings.mBroadPhaseLayerInterface = bpInterface;\n\tsettings.mObjectVsBroadPhaseLayerFilter = new Jolt.ObjectVsBroadPhaseLayerFilterTable( settings.mBroadPhaseLayerInterface, NUM_BROAD_PHASE_LAYERS, settings.mObjectLayerPairFilter, NUM_OBJECT_LAYERS );\n\n}\n\n/**\n * @classdesc Can be used to include Jolt as a Physics engine into\n * `three.js` apps. The API can be initialized via:\n * ```js\n * const physics = await JoltPhysics();\n * ```\n * The component automatically imports Jolt from a CDN so make sure\n * to use the component with an active Internet connection.\n *\n * @name JoltPhysics\n * @class\n * @hideconstructor\n * @three_import import { JoltPhysics } from 'three/addons/physics/JoltPhysics.js';\n */\nasync function JoltPhysics() {\n\n\tif ( Jolt === null ) {\n\n\t\tconst { default: initJolt } = await import( `${JOLT_PATH}` );\n\t\tJolt = await initJolt();\n\n\t}\n\n\tconst settings = new Jolt.JoltSettings();\n\tsetupCollisionFiltering( settings );\n\n\tconst jolt = new Jolt.JoltInterface( settings );\n\tJolt.destroy( settings );\n\n\tconst physicsSystem = jolt.GetPhysicsSystem();\n\tconst bodyInterface = physicsSystem.GetBodyInterface();\n\n\tconst meshes = [];\n\tconst meshMap = new WeakMap();\n\n\tconst _position = new Vector3();\n\tconst _quaternion = new Quaternion();\n\tconst _scale = new Vector3( 1, 1, 1 );\n\n\tconst _matrix = new Matrix4();\n\n\tfunction addScene( scene ) {\n\n\t\tscene.traverse( function ( child ) {\n\n\t\t\tif ( child.isMesh ) {\n\n\t\t\t\tconst physics = child.userData.physics;\n\n\t\t\t\tif ( physics ) {\n\n\t\t\t\t\taddMesh( child, physics.mass, physics.restitution );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tfunction addMesh( mesh, mass = 0, restitution = 0 ) {\n\n\t\tconst shape = getShape( mesh.geometry );\n\n\t\tif ( shape === null ) return;\n\n\t\tconst body = mesh.isInstancedMesh\n\t\t\t? createInstancedBody( mesh, mass, restitution, shape )\n\t\t\t: createBody( mesh.position, mesh.quaternion, mass, restitution, shape );\n\n\t\tif ( mass > 0 ) {\n\n\t\t\tmeshes.push( mesh );\n\t\t\tmeshMap.set( mesh, body );\n\n\t\t}\n\n\t}\n\n\tfunction createInstancedBody( mesh, mass, restitution, shape ) {\n\n\t\tconst array = mesh.instanceMatrix.array;\n\n\t\tconst bodies = [];\n\n\t\tfor ( let i = 0; i < mesh.count; i ++ ) {\n\n\t\t\tconst position = _position.fromArray( array, i * 16 + 12 );\n\t\t\tconst quaternion = _quaternion.setFromRotationMatrix( _matrix.fromArray( array, i * 16 ) ); // TODO Copilot did this\n\t\t\tbodies.push( createBody( position, quaternion, mass, restitution, shape ) );\n\n\t\t}\n\n\t\treturn bodies;\n\n\t}\n\n\tfunction createBody( position, rotation, mass, restitution, shape ) {\n\n\t\tconst pos = new Jolt.Vec3( position.x, position.y, position.z );\n\t\tconst rot = new Jolt.Quat( rotation.x, rotation.y, rotation.z, rotation.w );\n\n\t\tconst motion = mass > 0 ? Jolt.EMotionType_Dynamic : Jolt.EMotionType_Static;\n\t\tconst layer = mass > 0 ? LAYER_MOVING : LAYER_NON_MOVING;\n\n\t\tconst creationSettings = new Jolt.BodyCreationSettings( shape, pos, rot, motion, layer );\n\t\tcreationSettings.mRestitution = restitution;\n\n\t\tconst body = bodyInterface.CreateBody( creationSettings );\n\n\t\tbodyInterface.AddBody( body.GetID(), Jolt.EActivation_Activate );\n\n\t\tJolt.destroy( creationSettings );\n\n\t\treturn body;\n\n\t}\n\n\tfunction setMeshPosition( mesh, position, index = 0 ) {\n\n\t\tif ( mesh.isInstancedMesh ) {\n\n\t\t\tconst bodies = meshMap.get( mesh );\n\n\t\t\tconst body = bodies[ index ];\n\n\t\t\tbodyInterface.RemoveBody( body.GetID() );\n\t\t\tbodyInterface.DestroyBody( body.GetID() );\n\n\t\t\tconst physics = mesh.userData.physics;\n\n\t\t\tconst shape = body.GetShape();\n\t\t\tconst body2 = createBody( position, { x: 0, y: 0, z: 0, w: 1 }, physics.mass, physics.restitution, shape );\n\n\t\t\tbodies[ index ] = body2;\n\n\t\t} else {\n\n\t\t\t// TODO: Implement this\n\n\t\t}\n\n\t}\n\n\tfunction setMeshVelocity( mesh, velocity, index = 0 ) {\n\n\t\t/*\n\t\tlet body = meshMap.get( mesh );\n\n\t\tif ( mesh.isInstancedMesh ) {\n\n\t\t\tbody = body[ index ];\n\n\t\t}\n\n\t\tbody.setLinvel( velocity );\n\t\t*/\n\n\t}\n\n\t//\n\n\tconst clock = new Clock();\n\n\tfunction step() {\n\n\t\tlet deltaTime = clock.getDelta();\n\n\t\t// Don't go below 30 Hz to prevent spiral of death\n\t\tdeltaTime = Math.min( deltaTime, 1.0 / 30.0 );\n\n\t\t// When running below 55 Hz, do 2 steps instead of 1\n\t\tconst numSteps = deltaTime > 1.0 / 55.0 ? 2 : 1;\n\n\t\t// Step the physics world\n\t\tjolt.Step( deltaTime, numSteps );\n\n\t\t//\n\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t\tconst mesh = meshes[ i ];\n\n\t\t\tif ( mesh.isInstancedMesh ) {\n\n\t\t\t\tconst array = mesh.instanceMatrix.array;\n\t\t\t\tconst bodies = meshMap.get( mesh );\n\n\t\t\t\tfor ( let j = 0; j < bodies.length; j ++ ) {\n\n\t\t\t\t\tconst body = bodies[ j ];\n\n\t\t\t\t\tconst position = body.GetPosition();\n\t\t\t\t\tconst quaternion = body.GetRotation();\n\n\t\t\t\t\t_position.set( position.GetX(), position.GetY(), position.GetZ() );\n\t\t\t\t\t_quaternion.set( quaternion.GetX(), quaternion.GetY(), quaternion.GetZ(), quaternion.GetW() );\n\n\t\t\t\t\t_matrix.compose( _position, _quaternion, _scale ).toArray( array, j * 16 );\n\n\t\t\t\t}\n\n\t\t\t\tmesh.instanceMatrix.needsUpdate = true;\n\t\t\t\tmesh.computeBoundingSphere();\n\n\t\t\t} else {\n\n\t\t\t\tconst body = meshMap.get( mesh );\n\n\t\t\t\tconst position = body.GetPosition();\n\t\t\t\tconst rotation = body.GetRotation();\n\n\t\t\t\tmesh.position.set( position.GetX(), position.GetY(), position.GetZ() );\n\t\t\t\tmesh.quaternion.set( rotation.GetX(), rotation.GetY(), rotation.GetZ(), rotation.GetW() );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// animate\n\n\tsetInterval( step, 1000 / frameRate );\n\n\treturn {\n\t\t/**\n\t\t * Adds the given scene to this physics simulation. Only meshes with a\n\t\t * `physics` object in their {@link Object3D#userData} field will be honored.\n\t\t * The object can be used to store the mass and restitution of the mesh. E.g.:\n\t\t * ```js\n\t\t * box.userData.physics = { mass: 1, restitution: 0 };\n\t\t * ```\n\t\t *\n\t\t * @method\n\t\t * @name JoltPhysics#addScene\n\t\t * @param {Object3D} scene The scene or any type of 3D object to add.\n\t\t */\n\t\taddScene: addScene,\n\n\t\t/**\n\t\t * Adds the given mesh to this physics simulation.\n\t\t *\n\t\t * @method\n\t\t * @name JoltPhysics#addMesh\n\t\t * @param {Mesh} mesh The mesh to add.\n\t\t * @param {number} [mass=0] The mass in kg of the mesh.\n\t\t * @param {number} [restitution=0] The restitution/friction of the mesh.\n\t\t */\n\t\taddMesh: addMesh,\n\n\t\t/**\n\t\t * Set the position of the given mesh which is part of the physics simulation. Calling this\n\t\t * method will reset the current simulated velocity of the mesh.\n\t\t *\n\t\t * @method\n\t\t * @name JoltPhysics#setMeshPosition\n\t\t * @param {Mesh} mesh The mesh to update the position for.\n\t\t * @param {Vector3} position - The new position.\n\t\t * @param {number} [index=0] - If the mesh is instanced, the index represents the instanced ID.\n\t\t */\n\t\tsetMeshPosition: setMeshPosition,\n\n\t\t// NOOP\n\t\tsetMeshVelocity: setMeshVelocity\n\t};\n\n}\n\nexport { JoltPhysics };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}