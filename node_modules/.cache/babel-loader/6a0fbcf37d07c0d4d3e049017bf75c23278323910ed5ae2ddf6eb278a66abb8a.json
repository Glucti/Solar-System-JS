{"ast":null,"code":"import { AddOperation, BackSide, BufferGeometry, ClampToEdgeWrapping, Color, DoubleSide, EquirectangularReflectionMapping, EquirectangularRefractionMapping, FileLoader, Float32BufferAttribute, FrontSide, LineBasicMaterial, LineSegments, Loader, Mesh, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MirroredRepeatWrapping, Points, PointsMaterial, RepeatWrapping, SRGBColorSpace, TextureLoader, Vector2 } from 'three';\nimport { IFFParser } from './lwo/IFFParser.js';\nlet _lwoTree;\n\n/**\n * A loader for the LWO format.\n *\n * LWO3 and LWO2 formats are supported.\n *\n * References:\n * - [LWO3 format specification]{@link https://static.lightwave3d.com/sdk/2019/html/filefmts/lwo3.html}\n * - [LWO2 format specification]{@link https://static.lightwave3d.com/sdk/2019/html/filefmts/lwo2.html}\n *\n * ```js\n * const loader = new LWOLoader();\n * const lwoData = await loader.loadAsync( 'models/lwo/Objects/LWO3/Demo.lwo' );\n *\n * const mesh = object.meshes[ 0 ];\n * scene.add( mesh );\n * ```\n *\n * @augments Loader\n * @three_import import { LWOLoader } from 'three/addons/loaders/LWOLoader.js';\n */\nclass LWOLoader extends Loader {\n  /**\n   * Constructs a new LWO loader.\n   *\n   * @param {LoadingManager} [manager] - The loading manager.\n   */\n  constructor(manager) {\n    super(manager);\n  }\n\n  /**\n   * Starts loading from the given URL and passes the loaded LWO asset\n   * to the `onLoad()` callback.\n   *\n   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n   * @param {function({meshes:Array<Mesh>,materials:Array<Material>})} onLoad - Executed when the loading process has been finished.\n   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n   * @param {onErrorCallback} onError - Executed when errors occur.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === '' ? extractParentUrl(url, 'Objects') : scope.path;\n\n    // give the mesh a default name based on the filename\n    const modelName = url.split(path).pop().split('.')[0];\n    const loader = new FileLoader(this.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.load(url, function (buffer) {\n      // console.time( 'Total parsing: ' );\n\n      try {\n        onLoad(scope.parse(buffer, path, modelName));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n\n      // console.timeEnd( 'Total parsing: ' );\n    }, onProgress, onError);\n  }\n\n  /**\n   * Parses the given LWO data and returns the resulting meshes and materials.\n   *\n   * @param {ArrayBuffer} iffBuffer - The raw LWO data as an array buffer.\n   * @param {string} path - The URL base path.\n   * @param {string} modelName - The model name.\n   * @return {{meshes:Array<Mesh>,materials:Array<Material>}} An object holding the parse meshes and materials.\n   */\n  parse(iffBuffer, path, modelName) {\n    _lwoTree = new IFFParser().parse(iffBuffer);\n\n    // console.log( 'lwoTree', lwoTree );\n\n    const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    return new LWOTreeParser(textureLoader).parse(modelName);\n  }\n}\n\n// Parse the lwoTree object\nclass LWOTreeParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader;\n  }\n  parse(modelName) {\n    this.materials = new MaterialParser(this.textureLoader).parse();\n    this.defaultLayerName = modelName;\n    this.meshes = this.parseLayers();\n    return {\n      materials: this.materials,\n      meshes: this.meshes\n    };\n  }\n  parseLayers() {\n    // array of all meshes for building hierarchy\n    const meshes = [];\n\n    // final array containing meshes with scene graph hierarchy set up\n    const finalMeshes = [];\n    const geometryParser = new GeometryParser();\n    const scope = this;\n    _lwoTree.layers.forEach(function (layer) {\n      const geometry = geometryParser.parse(layer.geometry, layer);\n      const mesh = scope.parseMesh(geometry, layer);\n      meshes[layer.number] = mesh;\n      if (layer.parent === -1) finalMeshes.push(mesh);else meshes[layer.parent].add(mesh);\n    });\n    this.applyPivots(finalMeshes);\n    return finalMeshes;\n  }\n  parseMesh(geometry, layer) {\n    let mesh;\n    const materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type);\n    if (layer.geometry.type === 'points') mesh = new Points(geometry, materials);else if (layer.geometry.type === 'lines') mesh = new LineSegments(geometry, materials);else mesh = new Mesh(geometry, materials);\n    if (layer.name) mesh.name = layer.name;else mesh.name = this.defaultLayerName + '_layer_' + layer.number;\n    mesh.userData.pivot = layer.pivot;\n    return mesh;\n  }\n\n  // TODO: may need to be reversed in z to convert LWO to three.js coordinates\n  applyPivots(meshes) {\n    meshes.forEach(function (mesh) {\n      mesh.traverse(function (child) {\n        const pivot = child.userData.pivot;\n        child.position.x += pivot[0];\n        child.position.y += pivot[1];\n        child.position.z += pivot[2];\n        if (child.parent) {\n          const parentPivot = child.parent.userData.pivot;\n          child.position.x -= parentPivot[0];\n          child.position.y -= parentPivot[1];\n          child.position.z -= parentPivot[2];\n        }\n      });\n    });\n  }\n  getMaterials(namesArray, type) {\n    const materials = [];\n    const scope = this;\n    namesArray.forEach(function (name, i) {\n      materials[i] = scope.getMaterialByName(name);\n    });\n\n    // convert materials to line or point mats if required\n    if (type === 'points' || type === 'lines') {\n      materials.forEach(function (mat, i) {\n        const spec = {\n          color: mat.color\n        };\n        if (type === 'points') {\n          spec.size = 0.1;\n          spec.map = mat.map;\n          materials[i] = new PointsMaterial(spec);\n        } else if (type === 'lines') {\n          materials[i] = new LineBasicMaterial(spec);\n        }\n      });\n    }\n\n    // if there is only one material, return that directly instead of array\n    const filtered = materials.filter(Boolean);\n    if (filtered.length === 1) return filtered[0];\n    return materials;\n  }\n  getMaterialByName(name) {\n    return this.materials.filter(function (m) {\n      return m.name === name;\n    })[0];\n  }\n}\nclass MaterialParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader;\n  }\n  parse() {\n    const materials = [];\n    this.textures = {};\n    for (const name in _lwoTree.materials) {\n      if (_lwoTree.format === 'LWO3') {\n        materials.push(this.parseMaterial(_lwoTree.materials[name], name, _lwoTree.textures));\n      } else if (_lwoTree.format === 'LWO2') {\n        materials.push(this.parseMaterialLwo2(_lwoTree.materials[name], name, _lwoTree.textures));\n      }\n    }\n    return materials;\n  }\n  parseMaterial(materialData, name, textures) {\n    let params = {\n      name: name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    const connections = this.parseConnections(materialData.connections, materialData.nodes);\n    const maps = this.parseTextureNodes(connections.maps);\n    this.parseAttributeImageMaps(connections.attributes, textures, maps);\n    const attributes = this.parseAttributes(connections.attributes, maps);\n    this.parseEnvMap(connections, maps, attributes);\n    params = Object.assign(maps, params);\n    params = Object.assign(params, attributes);\n    const materialType = this.getMaterialType(connections.attributes);\n    if (materialType !== MeshPhongMaterial) delete params.refractionRatio; // PBR materials do not support \"refractionRatio\"\n\n    return new materialType(params);\n  }\n  parseMaterialLwo2(materialData, name /*, textures*/) {\n    let params = {\n      name: name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    const attributes = this.parseAttributes(materialData.attributes, {});\n    params = Object.assign(params, attributes);\n    return new MeshPhongMaterial(params);\n  }\n\n  // Note: converting from left to right handed coords by switching x -> -x in vertices, and\n  // then switching mat FrontSide -> BackSide\n  // NB: this means that FrontSide and BackSide have been switched!\n  getSide(attributes) {\n    if (!attributes.side) return BackSide;\n    switch (attributes.side) {\n      case 0:\n      case 1:\n        return BackSide;\n      case 2:\n        return FrontSide;\n      case 3:\n        return DoubleSide;\n    }\n  }\n  getSmooth(attributes) {\n    if (!attributes.smooth) return true;\n    return !attributes.smooth;\n  }\n  parseConnections(connections, nodes) {\n    const materialConnections = {\n      maps: {}\n    };\n    const inputName = connections.inputName;\n    const inputNodeName = connections.inputNodeName;\n    const nodeName = connections.nodeName;\n    const scope = this;\n    inputName.forEach(function (name, index) {\n      if (name === 'Material') {\n        const matNode = scope.getNodeByRefName(inputNodeName[index], nodes);\n        materialConnections.attributes = matNode.attributes;\n        materialConnections.envMap = matNode.fileName;\n        materialConnections.name = inputNodeName[index];\n      }\n    });\n    nodeName.forEach(function (name, index) {\n      if (name === materialConnections.name) {\n        materialConnections.maps[inputName[index]] = scope.getNodeByRefName(inputNodeName[index], nodes);\n      }\n    });\n    return materialConnections;\n  }\n  getNodeByRefName(refName, nodes) {\n    for (const name in nodes) {\n      if (nodes[name].refName === refName) return nodes[name];\n    }\n  }\n  parseTextureNodes(textureNodes) {\n    const maps = {};\n    for (const name in textureNodes) {\n      const node = textureNodes[name];\n      const path = node.fileName;\n      if (!path) return;\n      const texture = this.loadTexture(path);\n      if (node.widthWrappingMode !== undefined) texture.wrapS = this.getWrappingType(node.widthWrappingMode);\n      if (node.heightWrappingMode !== undefined) texture.wrapT = this.getWrappingType(node.heightWrappingMode);\n      switch (name) {\n        case 'Color':\n          maps.map = texture;\n          maps.map.colorSpace = SRGBColorSpace;\n          break;\n        case 'Roughness':\n          maps.roughnessMap = texture;\n          maps.roughness = 1;\n          break;\n        case 'Specular':\n          maps.specularMap = texture;\n          maps.specularMap.colorSpace = SRGBColorSpace;\n          maps.specular = 0xffffff;\n          break;\n        case 'Luminous':\n          maps.emissiveMap = texture;\n          maps.emissiveMap.colorSpace = SRGBColorSpace;\n          maps.emissive = 0x808080;\n          break;\n        case 'Luminous Color':\n          maps.emissive = 0x808080;\n          break;\n        case 'Metallic':\n          maps.metalnessMap = texture;\n          maps.metalness = 1;\n          break;\n        case 'Transparency':\n        case 'Alpha':\n          maps.alphaMap = texture;\n          maps.transparent = true;\n          break;\n        case 'Normal':\n          maps.normalMap = texture;\n          if (node.amplitude !== undefined) maps.normalScale = new Vector2(node.amplitude, node.amplitude);\n          break;\n        case 'Bump':\n          maps.bumpMap = texture;\n          break;\n      }\n    }\n\n    // LWO BSDF materials can have both spec and rough, but this is not valid in three\n    if (maps.roughnessMap && maps.specularMap) delete maps.specularMap;\n    return maps;\n  }\n\n  // maps can also be defined on individual material attributes, parse those here\n  // This occurs on Standard (Phong) surfaces\n  parseAttributeImageMaps(attributes, textures, maps) {\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      if (attribute.maps) {\n        const mapData = attribute.maps[0];\n        const path = this.getTexturePathByIndex(mapData.imageIndex);\n        if (!path) return;\n        const texture = this.loadTexture(path);\n        if (mapData.wrap !== undefined) texture.wrapS = this.getWrappingType(mapData.wrap.w);\n        if (mapData.wrap !== undefined) texture.wrapT = this.getWrappingType(mapData.wrap.h);\n        switch (name) {\n          case 'Color':\n            maps.map = texture;\n            maps.map.colorSpace = SRGBColorSpace;\n            break;\n          case 'Diffuse':\n            maps.aoMap = texture;\n            break;\n          case 'Roughness':\n            maps.roughnessMap = texture;\n            maps.roughness = 1;\n            break;\n          case 'Specular':\n            maps.specularMap = texture;\n            maps.specularMap.colorSpace = SRGBColorSpace;\n            maps.specular = 0xffffff;\n            break;\n          case 'Luminosity':\n            maps.emissiveMap = texture;\n            maps.emissiveMap.colorSpace = SRGBColorSpace;\n            maps.emissive = 0x808080;\n            break;\n          case 'Metallic':\n            maps.metalnessMap = texture;\n            maps.metalness = 1;\n            break;\n          case 'Transparency':\n          case 'Alpha':\n            maps.alphaMap = texture;\n            maps.transparent = true;\n            break;\n          case 'Normal':\n            maps.normalMap = texture;\n            break;\n          case 'Bump':\n            maps.bumpMap = texture;\n            break;\n        }\n      }\n    }\n  }\n  parseAttributes(attributes, maps) {\n    const params = {};\n\n    // don't use color data if color map is present\n    if (attributes.Color && !maps.map) {\n      params.color = new Color().fromArray(attributes.Color.value);\n    } else {\n      params.color = new Color();\n    }\n    if (attributes.Transparency && attributes.Transparency.value !== 0) {\n      params.opacity = 1 - attributes.Transparency.value;\n      params.transparent = true;\n    }\n    if (attributes['Bump Height']) params.bumpScale = attributes['Bump Height'].value * 0.1;\n    this.parsePhysicalAttributes(params, attributes, maps);\n    this.parseStandardAttributes(params, attributes, maps);\n    this.parsePhongAttributes(params, attributes, maps);\n    return params;\n  }\n  parsePhysicalAttributes(params, attributes /*, maps*/) {\n    if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {\n      params.clearcoat = attributes.Clearcoat.value;\n      if (attributes['Clearcoat Gloss']) {\n        params.clearcoatRoughness = 0.5 * (1 - attributes['Clearcoat Gloss'].value);\n      }\n    }\n  }\n  parseStandardAttributes(params, attributes, maps) {\n    if (attributes.Luminous) {\n      params.emissiveIntensity = attributes.Luminous.value;\n      if (attributes['Luminous Color'] && !maps.emissive) {\n        params.emissive = new Color().fromArray(attributes['Luminous Color'].value);\n      } else {\n        params.emissive = new Color(0x808080);\n      }\n    }\n    if (attributes.Roughness && !maps.roughnessMap) params.roughness = attributes.Roughness.value;\n    if (attributes.Metallic && !maps.metalnessMap) params.metalness = attributes.Metallic.value;\n  }\n  parsePhongAttributes(params, attributes, maps) {\n    if (attributes['Refraction Index']) params.refractionRatio = 0.98 / attributes['Refraction Index'].value;\n    if (attributes.Diffuse) params.color.multiplyScalar(attributes.Diffuse.value);\n    if (attributes.Reflection) {\n      params.reflectivity = attributes.Reflection.value;\n      params.combine = AddOperation;\n    }\n    if (attributes.Luminosity) {\n      params.emissiveIntensity = attributes.Luminosity.value;\n      if (!maps.emissiveMap && !maps.map) {\n        params.emissive = params.color;\n      } else {\n        params.emissive = new Color(0x808080);\n      }\n    }\n\n    // parse specular if there is no roughness - we will interpret the material as 'Phong' in this case\n    if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {\n      if (attributes['Color Highlight']) {\n        params.specular = new Color().setScalar(attributes.Specular.value).lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes['Color Highlight'].value);\n      } else {\n        params.specular = new Color().setScalar(attributes.Specular.value);\n      }\n    }\n    if (params.specular && attributes.Glossiness) params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2);\n  }\n  parseEnvMap(connections, maps, attributes) {\n    if (connections.envMap) {\n      const envMap = this.loadTexture(connections.envMap);\n      if (attributes.transparent && attributes.opacity < 0.999) {\n        envMap.mapping = EquirectangularRefractionMapping;\n\n        // Reflectivity and refraction mapping don't work well together in Phong materials\n        if (attributes.reflectivity !== undefined) {\n          delete attributes.reflectivity;\n          delete attributes.combine;\n        }\n        if (attributes.metalness !== undefined) {\n          attributes.metalness = 1; // For most transparent materials metalness should be set to 1 if not otherwise defined. If set to 0 no refraction will be visible\n        }\n        attributes.opacity = 1; // transparency fades out refraction, forcing opacity to 1 ensures a closer visual match to the material in Lightwave.\n      } else envMap.mapping = EquirectangularReflectionMapping;\n      maps.envMap = envMap;\n    }\n  }\n\n  // get texture defined at top level by its index\n  getTexturePathByIndex(index) {\n    let fileName = '';\n    if (!_lwoTree.textures) return fileName;\n    _lwoTree.textures.forEach(function (texture) {\n      if (texture.index === index) fileName = texture.fileName;\n    });\n    return fileName;\n  }\n  loadTexture(path) {\n    if (!path) return null;\n    const texture = this.textureLoader.load(path, undefined, undefined, function () {\n      console.warn('LWOLoader: non-standard resource hierarchy. Use \\`resourcePath\\` parameter to specify root content directory.');\n    });\n    return texture;\n  }\n\n  // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n  getWrappingType(num) {\n    switch (num) {\n      case 0:\n        console.warn('LWOLoader: \"Reset\" texture wrapping type is not supported in three.js');\n        return ClampToEdgeWrapping;\n      case 1:\n        return RepeatWrapping;\n      case 2:\n        return MirroredRepeatWrapping;\n      case 3:\n        return ClampToEdgeWrapping;\n    }\n  }\n  getMaterialType(nodeData) {\n    if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0) return MeshPhysicalMaterial;\n    if (nodeData.Roughness) return MeshStandardMaterial;\n    return MeshPhongMaterial;\n  }\n}\nclass GeometryParser {\n  parse(geoData, layer) {\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', new Float32BufferAttribute(geoData.points, 3));\n    const indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions);\n    geometry.setIndex(indices);\n    this.parseGroups(geometry, geoData);\n    geometry.computeVertexNormals();\n    this.parseUVs(geometry, layer);\n    this.parseMorphTargets(geometry, layer);\n\n    // TODO: z may need to be reversed to account for coordinate system change\n    geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2]);\n\n    // let userData = geometry.userData;\n    // geometry = geometry.toNonIndexed()\n    // geometry.userData = userData;\n\n    return geometry;\n  }\n\n  // split quads into tris\n  splitIndices(indices, polygonDimensions) {\n    const remappedIndices = [];\n    let i = 0;\n    polygonDimensions.forEach(function (dim) {\n      if (dim < 4) {\n        for (let k = 0; k < dim; k++) remappedIndices.push(indices[i + k]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i], indices[i + 1], indices[i + 2], indices[i], indices[i + 2], indices[i + 3]);\n      } else if (dim > 4) {\n        for (let k = 1; k < dim - 1; k++) {\n          remappedIndices.push(indices[i], indices[i + k], indices[i + k + 1]);\n        }\n        console.warn('LWOLoader: polygons with greater than 4 sides are not supported');\n      }\n      i += dim;\n    });\n    return remappedIndices;\n  }\n\n  // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n  parseGroups(geometry, geoData) {\n    const tags = _lwoTree.tags;\n    const matNames = [];\n    let elemSize = 3;\n    if (geoData.type === 'lines') elemSize = 2;\n    if (geoData.type === 'points') elemSize = 1;\n    const remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices);\n    let indexNum = 0; // create new indices in numerical order\n    const indexPairs = {}; // original indices mapped to numerical indices\n\n    let prevMaterialIndex;\n    let materialIndex;\n    let prevStart = 0;\n    let currentCount = 0;\n    for (let i = 0; i < remappedIndices.length; i += 2) {\n      materialIndex = remappedIndices[i + 1];\n      if (i === 0) matNames[indexNum] = tags[materialIndex];\n      if (prevMaterialIndex === undefined) prevMaterialIndex = materialIndex;\n      if (materialIndex !== prevMaterialIndex) {\n        let currentIndex;\n        if (indexPairs[tags[prevMaterialIndex]]) {\n          currentIndex = indexPairs[tags[prevMaterialIndex]];\n        } else {\n          currentIndex = indexNum;\n          indexPairs[tags[prevMaterialIndex]] = indexNum;\n          matNames[indexNum] = tags[prevMaterialIndex];\n          indexNum++;\n        }\n        geometry.addGroup(prevStart, currentCount, currentIndex);\n        prevStart += currentCount;\n        prevMaterialIndex = materialIndex;\n        currentCount = 0;\n      }\n      currentCount += elemSize;\n    }\n\n    // the loop above doesn't add the last group, do that here.\n    if (geometry.groups.length > 0) {\n      let currentIndex;\n      if (indexPairs[tags[materialIndex]]) {\n        currentIndex = indexPairs[tags[materialIndex]];\n      } else {\n        currentIndex = indexNum;\n        indexPairs[tags[materialIndex]] = indexNum;\n        matNames[indexNum] = tags[materialIndex];\n      }\n      geometry.addGroup(prevStart, currentCount, currentIndex);\n    }\n\n    // Mat names from TAGS chunk, used to build up an array of materials for this geometry\n    geometry.userData.matNames = matNames;\n  }\n  splitMaterialIndices(polygonDimensions, indices) {\n    const remappedIndices = [];\n    polygonDimensions.forEach(function (dim, i) {\n      if (dim <= 3) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1], indices[i * 2], indices[i * 2 + 1]);\n      } else {\n        // ignore > 4 for now\n        for (let k = 0; k < dim - 2; k++) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n        }\n      }\n    });\n    return remappedIndices;\n  }\n\n  // UV maps:\n  // 1: are defined via index into an array of points, not into a geometry\n  // - the geometry is also defined by an index into this array, but the indexes may not match\n  // 2: there can be any number of UV maps for a single geometry. Here these are combined,\n  // \twith preference given to the first map encountered\n  // 3: UV maps can be partial - that is, defined for only a part of the geometry\n  // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n  // UV maps are defined as partially VMAP and partially VMAD\n  // VMADs are currently not supported\n  parseUVs(geometry, layer) {\n    // start by creating a UV map set to zero for the whole geometry\n    const remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function () {\n      return 0;\n    });\n    for (const name in layer.uvs) {\n      const uvs = layer.uvs[name].uvs;\n      const uvIndices = layer.uvs[name].uvIndices;\n      uvIndices.forEach(function (i, j) {\n        remappedUVs[i * 2] = uvs[j * 2];\n        remappedUVs[i * 2 + 1] = uvs[j * 2 + 1];\n      });\n    }\n    geometry.setAttribute('uv', new Float32BufferAttribute(remappedUVs, 2));\n  }\n  parseMorphTargets(geometry, layer) {\n    let num = 0;\n    for (const name in layer.morphTargets) {\n      const remappedPoints = geometry.attributes.position.array.slice();\n      if (!geometry.morphAttributes.position) geometry.morphAttributes.position = [];\n      const morphPoints = layer.morphTargets[name].points;\n      const morphIndices = layer.morphTargets[name].indices;\n      const type = layer.morphTargets[name].type;\n      morphIndices.forEach(function (i, j) {\n        if (type === 'relative') {\n          remappedPoints[i * 3] += morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] += morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] += morphPoints[j * 3 + 2];\n        } else {\n          remappedPoints[i * 3] = morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] = morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] = morphPoints[j * 3 + 2];\n        }\n      });\n      geometry.morphAttributes.position[num] = new Float32BufferAttribute(remappedPoints, 3);\n      geometry.morphAttributes.position[num].name = name;\n      num++;\n    }\n    geometry.morphTargetsRelative = false;\n  }\n}\n\n// ************** UTILITY FUNCTIONS **************\n\nfunction extractParentUrl(url, dir) {\n  const index = url.indexOf(dir);\n  if (index === -1) return './';\n  return url.slice(0, index);\n}\nexport { LWOLoader };","map":{"version":3,"names":["AddOperation","BackSide","BufferGeometry","ClampToEdgeWrapping","Color","DoubleSide","EquirectangularReflectionMapping","EquirectangularRefractionMapping","FileLoader","Float32BufferAttribute","FrontSide","LineBasicMaterial","LineSegments","Loader","Mesh","MeshPhongMaterial","MeshPhysicalMaterial","MeshStandardMaterial","MirroredRepeatWrapping","Points","PointsMaterial","RepeatWrapping","SRGBColorSpace","TextureLoader","Vector2","IFFParser","_lwoTree","LWOLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","path","extractParentUrl","modelName","split","pop","loader","setPath","setResponseType","buffer","parse","e","console","error","itemError","iffBuffer","textureLoader","resourcePath","setCrossOrigin","crossOrigin","LWOTreeParser","materials","MaterialParser","defaultLayerName","meshes","parseLayers","finalMeshes","geometryParser","GeometryParser","layers","forEach","layer","geometry","mesh","parseMesh","number","parent","push","add","applyPivots","getMaterials","userData","matNames","type","name","pivot","traverse","child","position","x","y","z","parentPivot","namesArray","i","getMaterialByName","mat","spec","color","size","map","filtered","filter","Boolean","length","m","textures","format","parseMaterial","parseMaterialLwo2","materialData","params","side","getSide","attributes","flatShading","getSmooth","connections","parseConnections","nodes","maps","parseTextureNodes","parseAttributeImageMaps","parseAttributes","parseEnvMap","Object","assign","materialType","getMaterialType","refractionRatio","smooth","materialConnections","inputName","inputNodeName","nodeName","index","matNode","getNodeByRefName","envMap","fileName","refName","textureNodes","node","texture","loadTexture","widthWrappingMode","undefined","wrapS","getWrappingType","heightWrappingMode","wrapT","colorSpace","roughnessMap","roughness","specularMap","specular","emissiveMap","emissive","metalnessMap","metalness","alphaMap","transparent","normalMap","amplitude","normalScale","bumpMap","attribute","mapData","getTexturePathByIndex","imageIndex","wrap","w","h","aoMap","fromArray","value","Transparency","opacity","bumpScale","parsePhysicalAttributes","parseStandardAttributes","parsePhongAttributes","Clearcoat","clearcoat","clearcoatRoughness","Luminous","emissiveIntensity","Roughness","Metallic","Diffuse","multiplyScalar","Reflection","reflectivity","combine","Luminosity","Specular","setScalar","lerp","clone","Glossiness","shininess","Math","pow","mapping","warn","num","nodeData","geoData","setAttribute","points","indices","splitIndices","vertexIndices","polygonDimensions","setIndex","parseGroups","computeVertexNormals","parseUVs","parseMorphTargets","translate","remappedIndices","dim","k","tags","elemSize","splitMaterialIndices","materialIndices","indexNum","indexPairs","prevMaterialIndex","materialIndex","prevStart","currentCount","currentIndex","addGroup","groups","remappedUVs","Array","from","count","uvs","uvIndices","j","morphTargets","remappedPoints","array","slice","morphAttributes","morphPoints","morphIndices","morphTargetsRelative","dir","indexOf"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/loaders/LWOLoader.js"],"sourcesContent":["import {\n\tAddOperation,\n\tBackSide,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tColor,\n\tDoubleSide,\n\tEquirectangularReflectionMapping,\n\tEquirectangularRefractionMapping,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tFrontSide,\n\tLineBasicMaterial,\n\tLineSegments,\n\tLoader,\n\tMesh,\n\tMeshPhongMaterial,\n\tMeshPhysicalMaterial,\n\tMeshStandardMaterial,\n\tMirroredRepeatWrapping,\n\tPoints,\n\tPointsMaterial,\n\tRepeatWrapping,\n\tSRGBColorSpace,\n\tTextureLoader,\n\tVector2\n} from 'three';\n\nimport { IFFParser } from './lwo/IFFParser.js';\n\nlet _lwoTree;\n\n/**\n * A loader for the LWO format.\n *\n * LWO3 and LWO2 formats are supported.\n *\n * References:\n * - [LWO3 format specification]{@link https://static.lightwave3d.com/sdk/2019/html/filefmts/lwo3.html}\n * - [LWO2 format specification]{@link https://static.lightwave3d.com/sdk/2019/html/filefmts/lwo2.html}\n *\n * ```js\n * const loader = new LWOLoader();\n * const lwoData = await loader.loadAsync( 'models/lwo/Objects/LWO3/Demo.lwo' );\n *\n * const mesh = object.meshes[ 0 ];\n * scene.add( mesh );\n * ```\n *\n * @augments Loader\n * @three_import import { LWOLoader } from 'three/addons/loaders/LWOLoader.js';\n */\nclass LWOLoader extends Loader {\n\n\t/**\n\t * Constructs a new LWO loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded LWO asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function({meshes:Array<Mesh>,materials:Array<Material>})} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( scope.path === '' ) ? extractParentUrl( url, 'Objects' ) : scope.path;\n\n\t\t// give the mesh a default name based on the filename\n\t\tconst modelName = url.split( path ).pop().split( '.' )[ 0 ];\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t// console.time( 'Total parsing: ' );\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( buffer, path, modelName ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t\t// console.timeEnd( 'Total parsing: ' );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given LWO data and returns the resulting meshes and materials.\n\t *\n\t * @param {ArrayBuffer} iffBuffer - The raw LWO data as an array buffer.\n\t * @param {string} path - The URL base path.\n\t * @param {string} modelName - The model name.\n\t * @return {{meshes:Array<Mesh>,materials:Array<Material>}} An object holding the parse meshes and materials.\n\t */\n\tparse( iffBuffer, path, modelName ) {\n\n\t\t_lwoTree = new IFFParser().parse( iffBuffer );\n\n\t\t// console.log( 'lwoTree', lwoTree );\n\n\t\tconst textureLoader = new TextureLoader( this.manager ).setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\treturn new LWOTreeParser( textureLoader ).parse( modelName );\n\n\t}\n\n}\n\n// Parse the lwoTree object\nclass LWOTreeParser {\n\n\tconstructor( textureLoader ) {\n\n\t\tthis.textureLoader = textureLoader;\n\n\t}\n\n\tparse( modelName ) {\n\n\t\tthis.materials = new MaterialParser( this.textureLoader ).parse();\n\t\tthis.defaultLayerName = modelName;\n\n\t\tthis.meshes = this.parseLayers();\n\n\t\treturn {\n\t\t\tmaterials: this.materials,\n\t\t\tmeshes: this.meshes,\n\t\t};\n\n\t}\n\n\tparseLayers() {\n\n\t\t// array of all meshes for building hierarchy\n\t\tconst meshes = [];\n\n\t\t// final array containing meshes with scene graph hierarchy set up\n\t\tconst finalMeshes = [];\n\n\t\tconst geometryParser = new GeometryParser();\n\n\t\tconst scope = this;\n\t\t_lwoTree.layers.forEach( function ( layer ) {\n\n\t\t\tconst geometry = geometryParser.parse( layer.geometry, layer );\n\n\t\t\tconst mesh = scope.parseMesh( geometry, layer );\n\n\t\t\tmeshes[ layer.number ] = mesh;\n\n\t\t\tif ( layer.parent === - 1 ) finalMeshes.push( mesh );\n\t\t\telse meshes[ layer.parent ].add( mesh );\n\n\n\t\t} );\n\n\t\tthis.applyPivots( finalMeshes );\n\n\t\treturn finalMeshes;\n\n\t}\n\n\tparseMesh( geometry, layer ) {\n\n\t\tlet mesh;\n\n\t\tconst materials = this.getMaterials( geometry.userData.matNames, layer.geometry.type );\n\n\t\tif ( layer.geometry.type === 'points' ) mesh = new Points( geometry, materials );\n\t\telse if ( layer.geometry.type === 'lines' ) mesh = new LineSegments( geometry, materials );\n\t\telse mesh = new Mesh( geometry, materials );\n\n\t\tif ( layer.name ) mesh.name = layer.name;\n\t\telse mesh.name = this.defaultLayerName + '_layer_' + layer.number;\n\n\t\tmesh.userData.pivot = layer.pivot;\n\n\t\treturn mesh;\n\n\t}\n\n\t// TODO: may need to be reversed in z to convert LWO to three.js coordinates\n\tapplyPivots( meshes ) {\n\n\t\tmeshes.forEach( function ( mesh ) {\n\n\t\t\tmesh.traverse( function ( child ) {\n\n\t\t\t\tconst pivot = child.userData.pivot;\n\n\t\t\t\tchild.position.x += pivot[ 0 ];\n\t\t\t\tchild.position.y += pivot[ 1 ];\n\t\t\t\tchild.position.z += pivot[ 2 ];\n\n\t\t\t\tif ( child.parent ) {\n\n\t\t\t\t\tconst parentPivot = child.parent.userData.pivot;\n\n\t\t\t\t\tchild.position.x -= parentPivot[ 0 ];\n\t\t\t\t\tchild.position.y -= parentPivot[ 1 ];\n\t\t\t\t\tchild.position.z -= parentPivot[ 2 ];\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\tgetMaterials( namesArray, type ) {\n\n\t\tconst materials = [];\n\n\t\tconst scope = this;\n\n\t\tnamesArray.forEach( function ( name, i ) {\n\n\t\t\tmaterials[ i ] = scope.getMaterialByName( name );\n\n\t\t} );\n\n\t\t// convert materials to line or point mats if required\n\t\tif ( type === 'points' || type === 'lines' ) {\n\n\t\t\tmaterials.forEach( function ( mat, i ) {\n\n\t\t\t\tconst spec = {\n\t\t\t\t\tcolor: mat.color,\n\t\t\t\t};\n\n\t\t\t\tif ( type === 'points' ) {\n\n\t\t\t\t\tspec.size = 0.1;\n\t\t\t\t\tspec.map = mat.map;\n\t\t\t\t\tmaterials[ i ] = new PointsMaterial( spec );\n\n\t\t\t\t} else if ( type === 'lines' ) {\n\n\t\t\t\t\tmaterials[ i ] = new LineBasicMaterial( spec );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// if there is only one material, return that directly instead of array\n\t\tconst filtered = materials.filter( Boolean );\n\t\tif ( filtered.length === 1 ) return filtered[ 0 ];\n\n\t\treturn materials;\n\n\t}\n\n\tgetMaterialByName( name ) {\n\n\t\treturn this.materials.filter( function ( m ) {\n\n\t\t\treturn m.name === name;\n\n\t\t} )[ 0 ];\n\n\t}\n\n}\n\nclass MaterialParser {\n\n\tconstructor( textureLoader ) {\n\n\t\tthis.textureLoader = textureLoader;\n\n\t}\n\n\tparse() {\n\n\t\tconst materials = [];\n\t\tthis.textures = {};\n\n\t\tfor ( const name in _lwoTree.materials ) {\n\n\t\t\tif ( _lwoTree.format === 'LWO3' ) {\n\n\t\t\t\tmaterials.push( this.parseMaterial( _lwoTree.materials[ name ], name, _lwoTree.textures ) );\n\n\t\t\t} else if ( _lwoTree.format === 'LWO2' ) {\n\n\t\t\t\tmaterials.push( this.parseMaterialLwo2( _lwoTree.materials[ name ], name, _lwoTree.textures ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t}\n\n\tparseMaterial( materialData, name, textures ) {\n\n\t\tlet params = {\n\t\t\tname: name,\n\t\t\tside: this.getSide( materialData.attributes ),\n\t\t\tflatShading: this.getSmooth( materialData.attributes ),\n\t\t};\n\n\t\tconst connections = this.parseConnections( materialData.connections, materialData.nodes );\n\n\t\tconst maps = this.parseTextureNodes( connections.maps );\n\n\t\tthis.parseAttributeImageMaps( connections.attributes, textures, maps );\n\n\t\tconst attributes = this.parseAttributes( connections.attributes, maps );\n\n\t\tthis.parseEnvMap( connections, maps, attributes );\n\n\t\tparams = Object.assign( maps, params );\n\t\tparams = Object.assign( params, attributes );\n\n\t\tconst materialType = this.getMaterialType( connections.attributes );\n\n\t\tif ( materialType !== MeshPhongMaterial ) delete params.refractionRatio; // PBR materials do not support \"refractionRatio\"\n\n\t\treturn new materialType( params );\n\n\t}\n\n\tparseMaterialLwo2( materialData, name/*, textures*/ ) {\n\n\t\tlet params = {\n\t\t\tname: name,\n\t\t\tside: this.getSide( materialData.attributes ),\n\t\t\tflatShading: this.getSmooth( materialData.attributes ),\n\t\t};\n\n\t\tconst attributes = this.parseAttributes( materialData.attributes, {} );\n\t\tparams = Object.assign( params, attributes );\n\t\treturn new MeshPhongMaterial( params );\n\n\t}\n\n\t// Note: converting from left to right handed coords by switching x -> -x in vertices, and\n\t// then switching mat FrontSide -> BackSide\n\t// NB: this means that FrontSide and BackSide have been switched!\n\tgetSide( attributes ) {\n\n\t\tif ( ! attributes.side ) return BackSide;\n\n\t\tswitch ( attributes.side ) {\n\n\t\t\tcase 0:\n\t\t\tcase 1:\n\t\t\t\treturn BackSide;\n\t\t\tcase 2: return FrontSide;\n\t\t\tcase 3: return DoubleSide;\n\n\t\t}\n\n\t}\n\n\tgetSmooth( attributes ) {\n\n\t\tif ( ! attributes.smooth ) return true;\n\t\treturn ! attributes.smooth;\n\n\t}\n\n\tparseConnections( connections, nodes ) {\n\n\t\tconst materialConnections = {\n\t\t\tmaps: {}\n\t\t};\n\n\t\tconst inputName = connections.inputName;\n\t\tconst inputNodeName = connections.inputNodeName;\n\t\tconst nodeName = connections.nodeName;\n\n\t\tconst scope = this;\n\t\tinputName.forEach( function ( name, index ) {\n\n\t\t\tif ( name === 'Material' ) {\n\n\t\t\t\tconst matNode = scope.getNodeByRefName( inputNodeName[ index ], nodes );\n\t\t\t\tmaterialConnections.attributes = matNode.attributes;\n\t\t\t\tmaterialConnections.envMap = matNode.fileName;\n\t\t\t\tmaterialConnections.name = inputNodeName[ index ];\n\n\t\t\t}\n\n\t\t} );\n\n\t\tnodeName.forEach( function ( name, index ) {\n\n\t\t\tif ( name === materialConnections.name ) {\n\n\t\t\t\tmaterialConnections.maps[ inputName[ index ] ] = scope.getNodeByRefName( inputNodeName[ index ], nodes );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn materialConnections;\n\n\t}\n\n\tgetNodeByRefName( refName, nodes ) {\n\n\t\tfor ( const name in nodes ) {\n\n\t\t\tif ( nodes[ name ].refName === refName ) return nodes[ name ];\n\n\t\t}\n\n\t}\n\n\tparseTextureNodes( textureNodes ) {\n\n\t\tconst maps = {};\n\n\t\tfor ( const name in textureNodes ) {\n\n\t\t\tconst node = textureNodes[ name ];\n\t\t\tconst path = node.fileName;\n\n\t\t\tif ( ! path ) return;\n\n\t\t\tconst texture = this.loadTexture( path );\n\n\t\t\tif ( node.widthWrappingMode !== undefined ) texture.wrapS = this.getWrappingType( node.widthWrappingMode );\n\t\t\tif ( node.heightWrappingMode !== undefined ) texture.wrapT = this.getWrappingType( node.heightWrappingMode );\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'Color':\n\t\t\t\t\tmaps.map = texture;\n\t\t\t\t\tmaps.map.colorSpace = SRGBColorSpace;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Roughness':\n\t\t\t\t\tmaps.roughnessMap = texture;\n\t\t\t\t\tmaps.roughness = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Specular':\n\t\t\t\t\tmaps.specularMap = texture;\n\t\t\t\t\tmaps.specularMap.colorSpace = SRGBColorSpace;\n\t\t\t\t\tmaps.specular = 0xffffff;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Luminous':\n\t\t\t\t\tmaps.emissiveMap = texture;\n\t\t\t\t\tmaps.emissiveMap.colorSpace = SRGBColorSpace;\n\t\t\t\t\tmaps.emissive = 0x808080;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Luminous Color':\n\t\t\t\t\tmaps.emissive = 0x808080;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Metallic':\n\t\t\t\t\tmaps.metalnessMap = texture;\n\t\t\t\t\tmaps.metalness = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Transparency':\n\t\t\t\tcase 'Alpha':\n\t\t\t\t\tmaps.alphaMap = texture;\n\t\t\t\t\tmaps.transparent = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Normal':\n\t\t\t\t\tmaps.normalMap = texture;\n\t\t\t\t\tif ( node.amplitude !== undefined ) maps.normalScale = new Vector2( node.amplitude, node.amplitude );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Bump':\n\t\t\t\t\tmaps.bumpMap = texture;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// LWO BSDF materials can have both spec and rough, but this is not valid in three\n\t\tif ( maps.roughnessMap && maps.specularMap ) delete maps.specularMap;\n\n\t\treturn maps;\n\n\t}\n\n\t// maps can also be defined on individual material attributes, parse those here\n\t// This occurs on Standard (Phong) surfaces\n\tparseAttributeImageMaps( attributes, textures, maps ) {\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tif ( attribute.maps ) {\n\n\t\t\t\tconst mapData = attribute.maps[ 0 ];\n\n\t\t\t\tconst path = this.getTexturePathByIndex( mapData.imageIndex );\n\t\t\t\tif ( ! path ) return;\n\n\t\t\t\tconst texture = this.loadTexture( path );\n\n\t\t\t\tif ( mapData.wrap !== undefined ) texture.wrapS = this.getWrappingType( mapData.wrap.w );\n\t\t\t\tif ( mapData.wrap !== undefined ) texture.wrapT = this.getWrappingType( mapData.wrap.h );\n\n\t\t\t\tswitch ( name ) {\n\n\t\t\t\t\tcase 'Color':\n\t\t\t\t\t\tmaps.map = texture;\n\t\t\t\t\t\tmaps.map.colorSpace = SRGBColorSpace;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Diffuse':\n\t\t\t\t\t\tmaps.aoMap = texture;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Roughness':\n\t\t\t\t\t\tmaps.roughnessMap = texture;\n\t\t\t\t\t\tmaps.roughness = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Specular':\n\t\t\t\t\t\tmaps.specularMap = texture;\n\t\t\t\t\t\tmaps.specularMap.colorSpace = SRGBColorSpace;\n\t\t\t\t\t\tmaps.specular = 0xffffff;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Luminosity':\n\t\t\t\t\t\tmaps.emissiveMap = texture;\n\t\t\t\t\t\tmaps.emissiveMap.colorSpace = SRGBColorSpace;\n\t\t\t\t\t\tmaps.emissive = 0x808080;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Metallic':\n\t\t\t\t\t\tmaps.metalnessMap = texture;\n\t\t\t\t\t\tmaps.metalness = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Transparency':\n\t\t\t\t\tcase 'Alpha':\n\t\t\t\t\t\tmaps.alphaMap = texture;\n\t\t\t\t\t\tmaps.transparent = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Normal':\n\t\t\t\t\t\tmaps.normalMap = texture;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Bump':\n\t\t\t\t\t\tmaps.bumpMap = texture;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tparseAttributes( attributes, maps ) {\n\n\t\tconst params = {};\n\n\t\t// don't use color data if color map is present\n\t\tif ( attributes.Color && ! maps.map ) {\n\n\t\t\tparams.color = new Color().fromArray( attributes.Color.value );\n\n\t\t} else {\n\n\t\t\tparams.color = new Color();\n\n\t\t}\n\n\n\t\tif ( attributes.Transparency && attributes.Transparency.value !== 0 ) {\n\n\t\t\tparams.opacity = 1 - attributes.Transparency.value;\n\t\t\tparams.transparent = true;\n\n\t\t}\n\n\t\tif ( attributes[ 'Bump Height' ] ) params.bumpScale = attributes[ 'Bump Height' ].value * 0.1;\n\n\t\tthis.parsePhysicalAttributes( params, attributes, maps );\n\t\tthis.parseStandardAttributes( params, attributes, maps );\n\t\tthis.parsePhongAttributes( params, attributes, maps );\n\n\t\treturn params;\n\n\t}\n\n\tparsePhysicalAttributes( params, attributes/*, maps*/ ) {\n\n\t\tif ( attributes.Clearcoat && attributes.Clearcoat.value > 0 ) {\n\n\t\t\tparams.clearcoat = attributes.Clearcoat.value;\n\n\t\t\tif ( attributes[ 'Clearcoat Gloss' ] ) {\n\n\t\t\t\tparams.clearcoatRoughness = 0.5 * ( 1 - attributes[ 'Clearcoat Gloss' ].value );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tparseStandardAttributes( params, attributes, maps ) {\n\n\n\t\tif ( attributes.Luminous ) {\n\n\t\t\tparams.emissiveIntensity = attributes.Luminous.value;\n\n\t\t\tif ( attributes[ 'Luminous Color' ] && ! maps.emissive ) {\n\n\t\t\t\tparams.emissive = new Color().fromArray( attributes[ 'Luminous Color' ].value );\n\n\t\t\t} else {\n\n\t\t\t\tparams.emissive = new Color( 0x808080 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( attributes.Roughness && ! maps.roughnessMap ) params.roughness = attributes.Roughness.value;\n\t\tif ( attributes.Metallic && ! maps.metalnessMap ) params.metalness = attributes.Metallic.value;\n\n\t}\n\n\tparsePhongAttributes( params, attributes, maps ) {\n\n\t\tif ( attributes[ 'Refraction Index' ] ) params.refractionRatio = 0.98 / attributes[ 'Refraction Index' ].value;\n\n\t\tif ( attributes.Diffuse ) params.color.multiplyScalar( attributes.Diffuse.value );\n\n\t\tif ( attributes.Reflection ) {\n\n\t\t\tparams.reflectivity = attributes.Reflection.value;\n\t\t\tparams.combine = AddOperation;\n\n\t\t}\n\n\t\tif ( attributes.Luminosity ) {\n\n\t\t\tparams.emissiveIntensity = attributes.Luminosity.value;\n\n\t\t\tif ( ! maps.emissiveMap && ! maps.map ) {\n\n\t\t\t\tparams.emissive = params.color;\n\n\t\t\t} else {\n\n\t\t\t\tparams.emissive = new Color( 0x808080 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// parse specular if there is no roughness - we will interpret the material as 'Phong' in this case\n\t\tif ( ! attributes.Roughness && attributes.Specular && ! maps.specularMap ) {\n\n\t\t\tif ( attributes[ 'Color Highlight' ] ) {\n\n\t\t\t\tparams.specular = new Color().setScalar( attributes.Specular.value ).lerp( params.color.clone().multiplyScalar( attributes.Specular.value ), attributes[ 'Color Highlight' ].value );\n\n\t\t\t} else {\n\n\t\t\t\tparams.specular = new Color().setScalar( attributes.Specular.value );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( params.specular && attributes.Glossiness ) params.shininess = 7 + Math.pow( 2, attributes.Glossiness.value * 12 + 2 );\n\n\t}\n\n\tparseEnvMap( connections, maps, attributes ) {\n\n\t\tif ( connections.envMap ) {\n\n\t\t\tconst envMap = this.loadTexture( connections.envMap );\n\n\t\t\tif ( attributes.transparent && attributes.opacity < 0.999 ) {\n\n\t\t\t\tenvMap.mapping = EquirectangularRefractionMapping;\n\n\t\t\t\t// Reflectivity and refraction mapping don't work well together in Phong materials\n\t\t\t\tif ( attributes.reflectivity !== undefined ) {\n\n\t\t\t\t\tdelete attributes.reflectivity;\n\t\t\t\t\tdelete attributes.combine;\n\n\t\t\t\t}\n\n\t\t\t\tif ( attributes.metalness !== undefined ) {\n\n\t\t\t\t\tattributes.metalness = 1; // For most transparent materials metalness should be set to 1 if not otherwise defined. If set to 0 no refraction will be visible\n\n\t\t\t\t}\n\n\t\t\t\tattributes.opacity = 1; // transparency fades out refraction, forcing opacity to 1 ensures a closer visual match to the material in Lightwave.\n\n\t\t\t} else envMap.mapping = EquirectangularReflectionMapping;\n\n\t\t\tmaps.envMap = envMap;\n\n\t\t}\n\n\t}\n\n\t// get texture defined at top level by its index\n\tgetTexturePathByIndex( index ) {\n\n\t\tlet fileName = '';\n\n\t\tif ( ! _lwoTree.textures ) return fileName;\n\n\t\t_lwoTree.textures.forEach( function ( texture ) {\n\n\t\t\tif ( texture.index === index ) fileName = texture.fileName;\n\n\t\t} );\n\n\t\treturn fileName;\n\n\t}\n\n\tloadTexture( path ) {\n\n\t\tif ( ! path ) return null;\n\n\t\tconst texture = this.textureLoader.load(\n\t\t\tpath,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tfunction () {\n\n\t\t\t\tconsole.warn( 'LWOLoader: non-standard resource hierarchy. Use \\`resourcePath\\` parameter to specify root content directory.' );\n\n\t\t\t}\n\t\t);\n\n\t\treturn texture;\n\n\t}\n\n\t// 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n\tgetWrappingType( num ) {\n\n\t\tswitch ( num ) {\n\n\t\t\tcase 0:\n\t\t\t\tconsole.warn( 'LWOLoader: \"Reset\" texture wrapping type is not supported in three.js' );\n\t\t\t\treturn ClampToEdgeWrapping;\n\t\t\tcase 1: return RepeatWrapping;\n\t\t\tcase 2: return MirroredRepeatWrapping;\n\t\t\tcase 3: return ClampToEdgeWrapping;\n\n\t\t}\n\n\t}\n\n\tgetMaterialType( nodeData ) {\n\n\t\tif ( nodeData.Clearcoat && nodeData.Clearcoat.value > 0 ) return MeshPhysicalMaterial;\n\t\tif ( nodeData.Roughness ) return MeshStandardMaterial;\n\t\treturn MeshPhongMaterial;\n\n\t}\n\n}\n\nclass GeometryParser {\n\n\tparse( geoData, layer ) {\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( geoData.points, 3 ) );\n\n\t\tconst indices = this.splitIndices( geoData.vertexIndices, geoData.polygonDimensions );\n\t\tgeometry.setIndex( indices );\n\n\t\tthis.parseGroups( geometry, geoData );\n\n\t\tgeometry.computeVertexNormals();\n\n\t\tthis.parseUVs( geometry, layer );\n\t\tthis.parseMorphTargets( geometry, layer );\n\n\t\t// TODO: z may need to be reversed to account for coordinate system change\n\t\tgeometry.translate( - layer.pivot[ 0 ], - layer.pivot[ 1 ], - layer.pivot[ 2 ] );\n\n\t\t// let userData = geometry.userData;\n\t\t// geometry = geometry.toNonIndexed()\n\t\t// geometry.userData = userData;\n\n\t\treturn geometry;\n\n\t}\n\n\t// split quads into tris\n\tsplitIndices( indices, polygonDimensions ) {\n\n\t\tconst remappedIndices = [];\n\n\t\tlet i = 0;\n\t\tpolygonDimensions.forEach( function ( dim ) {\n\n\t\t\tif ( dim < 4 ) {\n\n\t\t\t\tfor ( let k = 0; k < dim; k ++ ) remappedIndices.push( indices[ i + k ] );\n\n\t\t\t} else if ( dim === 4 ) {\n\n\t\t\t\tremappedIndices.push(\n\t\t\t\t\tindices[ i ],\n\t\t\t\t\tindices[ i + 1 ],\n\t\t\t\t\tindices[ i + 2 ],\n\n\t\t\t\t\tindices[ i ],\n\t\t\t\t\tindices[ i + 2 ],\n\t\t\t\t\tindices[ i + 3 ]\n\n\t\t\t\t);\n\n\t\t\t} else if ( dim > 4 ) {\n\n\t\t\t\tfor ( let k = 1; k < dim - 1; k ++ ) {\n\n\t\t\t\t\tremappedIndices.push( indices[ i ], indices[ i + k ], indices[ i + k + 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( 'LWOLoader: polygons with greater than 4 sides are not supported' );\n\n\t\t\t}\n\n\t\t\ti += dim;\n\n\t\t} );\n\n\t\treturn remappedIndices;\n\n\t}\n\n\t// NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n\tparseGroups( geometry, geoData ) {\n\n\t\tconst tags = _lwoTree.tags;\n\t\tconst matNames = [];\n\n\t\tlet elemSize = 3;\n\t\tif ( geoData.type === 'lines' ) elemSize = 2;\n\t\tif ( geoData.type === 'points' ) elemSize = 1;\n\n\t\tconst remappedIndices = this.splitMaterialIndices( geoData.polygonDimensions, geoData.materialIndices );\n\n\t\tlet indexNum = 0; // create new indices in numerical order\n\t\tconst indexPairs = {}; // original indices mapped to numerical indices\n\n\t\tlet prevMaterialIndex;\n\t\tlet materialIndex;\n\n\t\tlet prevStart = 0;\n\t\tlet currentCount = 0;\n\n\t\tfor ( let i = 0; i < remappedIndices.length; i += 2 ) {\n\n\t\t\tmaterialIndex = remappedIndices[ i + 1 ];\n\n\t\t\tif ( i === 0 ) matNames[ indexNum ] = tags[ materialIndex ];\n\n\t\t\tif ( prevMaterialIndex === undefined ) prevMaterialIndex = materialIndex;\n\n\t\t\tif ( materialIndex !== prevMaterialIndex ) {\n\n\t\t\t\tlet currentIndex;\n\t\t\t\tif ( indexPairs[ tags[ prevMaterialIndex ] ] ) {\n\n\t\t\t\t\tcurrentIndex = indexPairs[ tags[ prevMaterialIndex ] ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentIndex = indexNum;\n\t\t\t\t\tindexPairs[ tags[ prevMaterialIndex ] ] = indexNum;\n\t\t\t\t\tmatNames[ indexNum ] = tags[ prevMaterialIndex ];\n\t\t\t\t\tindexNum ++;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.addGroup( prevStart, currentCount, currentIndex );\n\n\t\t\t\tprevStart += currentCount;\n\n\t\t\t\tprevMaterialIndex = materialIndex;\n\t\t\t\tcurrentCount = 0;\n\n\t\t\t}\n\n\t\t\tcurrentCount += elemSize;\n\n\t\t}\n\n\t\t// the loop above doesn't add the last group, do that here.\n\t\tif ( geometry.groups.length > 0 ) {\n\n\t\t\tlet currentIndex;\n\t\t\tif ( indexPairs[ tags[ materialIndex ] ] ) {\n\n\t\t\t\tcurrentIndex = indexPairs[ tags[ materialIndex ] ];\n\n\t\t\t} else {\n\n\t\t\t\tcurrentIndex = indexNum;\n\t\t\t\tindexPairs[ tags[ materialIndex ] ] = indexNum;\n\t\t\t\tmatNames[ indexNum ] = tags[ materialIndex ];\n\n\t\t\t}\n\n\t\t\tgeometry.addGroup( prevStart, currentCount, currentIndex );\n\n\t\t}\n\n\t\t// Mat names from TAGS chunk, used to build up an array of materials for this geometry\n\t\tgeometry.userData.matNames = matNames;\n\n\t}\n\n\tsplitMaterialIndices( polygonDimensions, indices ) {\n\n\t\tconst remappedIndices = [];\n\n\t\tpolygonDimensions.forEach( function ( dim, i ) {\n\n\t\t\tif ( dim <= 3 ) {\n\n\t\t\t\tremappedIndices.push( indices[ i * 2 ], indices[ i * 2 + 1 ] );\n\n\t\t\t} else if ( dim === 4 ) {\n\n\t\t\t\tremappedIndices.push( indices[ i * 2 ], indices[ i * 2 + 1 ], indices[ i * 2 ], indices[ i * 2 + 1 ] );\n\n\t\t\t} else {\n\n\t\t\t\t // ignore > 4 for now\n\t\t\t\tfor ( let k = 0; k < dim - 2; k ++ ) {\n\n\t\t\t\t\tremappedIndices.push( indices[ i * 2 ], indices[ i * 2 + 1 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn remappedIndices;\n\n\t}\n\n\t// UV maps:\n\t// 1: are defined via index into an array of points, not into a geometry\n\t// - the geometry is also defined by an index into this array, but the indexes may not match\n\t// 2: there can be any number of UV maps for a single geometry. Here these are combined,\n\t// \twith preference given to the first map encountered\n\t// 3: UV maps can be partial - that is, defined for only a part of the geometry\n\t// 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n\t// UV maps are defined as partially VMAP and partially VMAD\n\t// VMADs are currently not supported\n\tparseUVs( geometry, layer ) {\n\n\t\t// start by creating a UV map set to zero for the whole geometry\n\t\tconst remappedUVs = Array.from( Array( geometry.attributes.position.count * 2 ), function () {\n\n\t\t\treturn 0;\n\n\t\t} );\n\n\t\tfor ( const name in layer.uvs ) {\n\n\t\t\tconst uvs = layer.uvs[ name ].uvs;\n\t\t\tconst uvIndices = layer.uvs[ name ].uvIndices;\n\n\t\t\tuvIndices.forEach( function ( i, j ) {\n\n\t\t\t\tremappedUVs[ i * 2 ] = uvs[ j * 2 ];\n\t\t\t\tremappedUVs[ i * 2 + 1 ] = uvs[ j * 2 + 1 ];\n\n\t\t\t} );\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( remappedUVs, 2 ) );\n\n\t}\n\n\tparseMorphTargets( geometry, layer ) {\n\n\t\tlet num = 0;\n\t\tfor ( const name in layer.morphTargets ) {\n\n\t\t\tconst remappedPoints = geometry.attributes.position.array.slice();\n\n\t\t\tif ( ! geometry.morphAttributes.position ) geometry.morphAttributes.position = [];\n\n\t\t\tconst morphPoints = layer.morphTargets[ name ].points;\n\t\t\tconst morphIndices = layer.morphTargets[ name ].indices;\n\t\t\tconst type = layer.morphTargets[ name ].type;\n\n\t\t\tmorphIndices.forEach( function ( i, j ) {\n\n\t\t\t\tif ( type === 'relative' ) {\n\n\t\t\t\t\tremappedPoints[ i * 3 ] += morphPoints[ j * 3 ];\n\t\t\t\t\tremappedPoints[ i * 3 + 1 ] += morphPoints[ j * 3 + 1 ];\n\t\t\t\t\tremappedPoints[ i * 3 + 2 ] += morphPoints[ j * 3 + 2 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tremappedPoints[ i * 3 ] = morphPoints[ j * 3 ];\n\t\t\t\t\tremappedPoints[ i * 3 + 1 ] = morphPoints[ j * 3 + 1 ];\n\t\t\t\t\tremappedPoints[ i * 3 + 2 ] = morphPoints[ j * 3 + 2 ];\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tgeometry.morphAttributes.position[ num ] = new Float32BufferAttribute( remappedPoints, 3 );\n\t\t\tgeometry.morphAttributes.position[ num ].name = name;\n\n\t\t\tnum ++;\n\n\t\t}\n\n\t\tgeometry.morphTargetsRelative = false;\n\n\t}\n\n}\n\n\n// ************** UTILITY FUNCTIONS **************\n\nfunction extractParentUrl( url, dir ) {\n\n\tconst index = url.indexOf( dir );\n\n\tif ( index === - 1 ) return './';\n\n\treturn url.slice( 0, index );\n\n}\n\nexport { LWOLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}