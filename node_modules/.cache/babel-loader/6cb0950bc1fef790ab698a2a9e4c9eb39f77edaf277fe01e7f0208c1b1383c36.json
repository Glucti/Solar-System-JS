{"ast":null,"code":"import { CompressedTextureLoader, RGBAFormat, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_ETC1_Format, RGB_S3TC_DXT1_Format, RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format } from 'three';\n\n/**\n * A loader for the S3TC texture compression format.\n *\n * ```js\n * const loader = new DDSLoader();\n *\n * const map = loader.load( 'textures/compressed/disturb_dxt1_nomip.dds' );\n * map.colorSpace = THREE.SRGBColorSpace; // only for color textures\n * ```\n *\n * @augments CompressedTextureLoader\n * @three_import import { DDSLoader } from 'three/addons/loaders/DDSLoader.js';\n */\nclass DDSLoader extends CompressedTextureLoader {\n  /**\n   * Constructs a new DDS loader.\n   *\n   * @param {LoadingManager} [manager] - The loading manager.\n   */\n  constructor(manager) {\n    super(manager);\n  }\n\n  /**\n   * Parses the given S3TC texture data.\n   *\n   * @param {ArrayBuffer} buffer - The raw texture data.\n   * @param {boolean} loadMipmaps - Whether to load mipmaps or not.\n   * @return {CompressedTextureLoader~TexData} An object representing the parsed texture data.\n   */\n  parse(buffer, loadMipmaps) {\n    const dds = {\n      mipmaps: [],\n      width: 0,\n      height: 0,\n      format: null,\n      mipmapCount: 1\n    };\n\n    // Adapted from @toji's DDS utils\n    // https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\n\n    // All values and structures referenced from:\n    // http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\n    const DDS_MAGIC = 0x20534444;\n\n    // const DDSD_CAPS = 0x1;\n    // const DDSD_HEIGHT = 0x2;\n    // const DDSD_WIDTH = 0x4;\n    // const DDSD_PITCH = 0x8;\n    // const DDSD_PIXELFORMAT = 0x1000;\n    const DDSD_MIPMAPCOUNT = 0x20000;\n    // const DDSD_LINEARSIZE = 0x80000;\n    // const DDSD_DEPTH = 0x800000;\n\n    // const DDSCAPS_COMPLEX = 0x8;\n    // const DDSCAPS_MIPMAP = 0x400000;\n    // const DDSCAPS_TEXTURE = 0x1000;\n\n    const DDSCAPS2_CUBEMAP = 0x200;\n    const DDSCAPS2_CUBEMAP_POSITIVEX = 0x400;\n    const DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800;\n    const DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000;\n    const DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000;\n    const DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000;\n    const DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000;\n    // const DDSCAPS2_VOLUME = 0x200000;\n\n    // const DDPF_ALPHAPIXELS = 0x1;\n    // const DDPF_ALPHA = 0x2;\n    // const DDPF_FOURCC = 0x4;\n    // const DDPF_RGB = 0x40;\n    // const DDPF_YUV = 0x200;\n    // const DDPF_LUMINANCE = 0x20000;\n\n    const DXGI_FORMAT_BC6H_UF16 = 95;\n    const DXGI_FORMAT_BC6H_SF16 = 96;\n    function fourCCToInt32(value) {\n      return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\n    }\n    function int32ToFourCC(value) {\n      return String.fromCharCode(value & 0xff, value >> 8 & 0xff, value >> 16 & 0xff, value >> 24 & 0xff);\n    }\n    function loadARGBMip(buffer, dataOffset, width, height) {\n      const dataLength = width * height * 4;\n      const srcBuffer = new Uint8Array(buffer, dataOffset, dataLength);\n      const byteArray = new Uint8Array(dataLength);\n      let dst = 0;\n      let src = 0;\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const b = srcBuffer[src];\n          src++;\n          const g = srcBuffer[src];\n          src++;\n          const r = srcBuffer[src];\n          src++;\n          const a = srcBuffer[src];\n          src++;\n          byteArray[dst] = r;\n          dst++; //r\n          byteArray[dst] = g;\n          dst++; //g\n          byteArray[dst] = b;\n          dst++; //b\n          byteArray[dst] = a;\n          dst++; //a\n        }\n      }\n      return byteArray;\n    }\n    function loadRGBMip(buffer, dataOffset, width, height) {\n      const dataLength = width * height * 3;\n      const srcBuffer = new Uint8Array(buffer, dataOffset, dataLength);\n      const byteArray = new Uint8Array(width * height * 4);\n      let dst = 0;\n      let src = 0;\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const b = srcBuffer[src];\n          src++;\n          const g = srcBuffer[src];\n          src++;\n          const r = srcBuffer[src];\n          src++;\n          byteArray[dst] = r;\n          dst++; //r\n          byteArray[dst] = g;\n          dst++; //g\n          byteArray[dst] = b;\n          dst++; //b\n          byteArray[dst] = 255;\n          dst++; //a\n        }\n      }\n      return byteArray;\n    }\n    const FOURCC_DXT1 = fourCCToInt32('DXT1');\n    const FOURCC_DXT3 = fourCCToInt32('DXT3');\n    const FOURCC_DXT5 = fourCCToInt32('DXT5');\n    const FOURCC_ETC1 = fourCCToInt32('ETC1');\n    const FOURCC_DX10 = fourCCToInt32('DX10');\n    const headerLengthInt = 31; // The header length in 32 bit ints\n    const extendedHeaderLengthInt = 5; // The extended header length in 32 bit ints\n\n    // Offsets into the header array\n\n    const off_magic = 0;\n    const off_size = 1;\n    const off_flags = 2;\n    const off_height = 3;\n    const off_width = 4;\n    const off_mipmapCount = 7;\n\n    // const off_pfFlags = 20;\n    const off_pfFourCC = 21;\n    const off_RGBBitCount = 22;\n    const off_RBitMask = 23;\n    const off_GBitMask = 24;\n    const off_BBitMask = 25;\n    const off_ABitMask = 26;\n\n    // const off_caps = 27;\n    const off_caps2 = 28;\n    // const off_caps3 = 29;\n    // const off_caps4 = 30;\n\n    // If fourCC = DX10, the extended header starts after 32\n    const off_dxgiFormat = 0;\n\n    // Parse header\n\n    const header = new Int32Array(buffer, 0, headerLengthInt);\n    if (header[off_magic] !== DDS_MAGIC) {\n      console.error('THREE.DDSLoader.parse: Invalid magic number in DDS header.');\n      return dds;\n    }\n    let blockBytes;\n    const fourCC = header[off_pfFourCC];\n    let isRGBAUncompressed = false;\n    let isRGBUncompressed = false;\n    let dataOffset = header[off_size] + 4;\n    switch (fourCC) {\n      case FOURCC_DXT1:\n        blockBytes = 8;\n        dds.format = RGB_S3TC_DXT1_Format;\n        break;\n      case FOURCC_DXT3:\n        blockBytes = 16;\n        dds.format = RGBA_S3TC_DXT3_Format;\n        break;\n      case FOURCC_DXT5:\n        blockBytes = 16;\n        dds.format = RGBA_S3TC_DXT5_Format;\n        break;\n      case FOURCC_ETC1:\n        blockBytes = 8;\n        dds.format = RGB_ETC1_Format;\n        break;\n      case FOURCC_DX10:\n        dataOffset += extendedHeaderLengthInt * 4;\n        const extendedHeader = new Int32Array(buffer, (headerLengthInt + 1) * 4, extendedHeaderLengthInt);\n        const dxgiFormat = extendedHeader[off_dxgiFormat];\n        switch (dxgiFormat) {\n          case DXGI_FORMAT_BC6H_SF16:\n            {\n              blockBytes = 16;\n              dds.format = RGB_BPTC_SIGNED_Format;\n              break;\n            }\n          case DXGI_FORMAT_BC6H_UF16:\n            {\n              blockBytes = 16;\n              dds.format = RGB_BPTC_UNSIGNED_Format;\n              break;\n            }\n          default:\n            {\n              console.error('THREE.DDSLoader.parse: Unsupported DXGI_FORMAT code ', dxgiFormat);\n              return dds;\n            }\n        }\n        break;\n      default:\n        if (header[off_RGBBitCount] === 32 && header[off_RBitMask] & 0xff0000 && header[off_GBitMask] & 0xff00 && header[off_BBitMask] & 0xff && header[off_ABitMask] & 0xff000000) {\n          isRGBAUncompressed = true;\n          blockBytes = 64;\n          dds.format = RGBAFormat;\n        } else if (header[off_RGBBitCount] === 24 && header[off_RBitMask] & 0xff0000 && header[off_GBitMask] & 0xff00 && header[off_BBitMask] & 0xff) {\n          isRGBUncompressed = true;\n          blockBytes = 64;\n          dds.format = RGBAFormat;\n        } else {\n          console.error('THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC(fourCC));\n          return dds;\n        }\n    }\n    dds.mipmapCount = 1;\n    if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\n      dds.mipmapCount = Math.max(1, header[off_mipmapCount]);\n    }\n    const caps2 = header[off_caps2];\n    dds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;\n    if (dds.isCubemap && (!(caps2 & DDSCAPS2_CUBEMAP_POSITIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ))) {\n      console.error('THREE.DDSLoader.parse: Incomplete cubemap faces');\n      return dds;\n    }\n    dds.width = header[off_width];\n    dds.height = header[off_height];\n\n    // Extract mipmaps buffers\n\n    const faces = dds.isCubemap ? 6 : 1;\n    for (let face = 0; face < faces; face++) {\n      let width = dds.width;\n      let height = dds.height;\n      for (let i = 0; i < dds.mipmapCount; i++) {\n        let byteArray, dataLength;\n        if (isRGBAUncompressed) {\n          byteArray = loadARGBMip(buffer, dataOffset, width, height);\n          dataLength = byteArray.length;\n        } else if (isRGBUncompressed) {\n          byteArray = loadRGBMip(buffer, dataOffset, width, height);\n          dataLength = width * height * 3;\n        } else {\n          dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;\n          byteArray = new Uint8Array(buffer, dataOffset, dataLength);\n        }\n        const mipmap = {\n          'data': byteArray,\n          'width': width,\n          'height': height\n        };\n        dds.mipmaps.push(mipmap);\n        dataOffset += dataLength;\n        width = Math.max(width >> 1, 1);\n        height = Math.max(height >> 1, 1);\n      }\n    }\n    return dds;\n  }\n}\nexport { DDSLoader };","map":{"version":3,"names":["CompressedTextureLoader","RGBAFormat","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","RGB_ETC1_Format","RGB_S3TC_DXT1_Format","RGB_BPTC_SIGNED_Format","RGB_BPTC_UNSIGNED_Format","DDSLoader","constructor","manager","parse","buffer","loadMipmaps","dds","mipmaps","width","height","format","mipmapCount","DDS_MAGIC","DDSD_MIPMAPCOUNT","DDSCAPS2_CUBEMAP","DDSCAPS2_CUBEMAP_POSITIVEX","DDSCAPS2_CUBEMAP_NEGATIVEX","DDSCAPS2_CUBEMAP_POSITIVEY","DDSCAPS2_CUBEMAP_NEGATIVEY","DDSCAPS2_CUBEMAP_POSITIVEZ","DDSCAPS2_CUBEMAP_NEGATIVEZ","DXGI_FORMAT_BC6H_UF16","DXGI_FORMAT_BC6H_SF16","fourCCToInt32","value","charCodeAt","int32ToFourCC","String","fromCharCode","loadARGBMip","dataOffset","dataLength","srcBuffer","Uint8Array","byteArray","dst","src","y","x","b","g","r","a","loadRGBMip","FOURCC_DXT1","FOURCC_DXT3","FOURCC_DXT5","FOURCC_ETC1","FOURCC_DX10","headerLengthInt","extendedHeaderLengthInt","off_magic","off_size","off_flags","off_height","off_width","off_mipmapCount","off_pfFourCC","off_RGBBitCount","off_RBitMask","off_GBitMask","off_BBitMask","off_ABitMask","off_caps2","off_dxgiFormat","header","Int32Array","console","error","blockBytes","fourCC","isRGBAUncompressed","isRGBUncompressed","extendedHeader","dxgiFormat","Math","max","caps2","isCubemap","faces","face","i","length","mipmap","push"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/loaders/DDSLoader.js"],"sourcesContent":["import {\n\tCompressedTextureLoader,\n\tRGBAFormat,\n\tRGBA_S3TC_DXT3_Format,\n\tRGBA_S3TC_DXT5_Format,\n\tRGB_ETC1_Format,\n\tRGB_S3TC_DXT1_Format,\n\tRGB_BPTC_SIGNED_Format,\n\tRGB_BPTC_UNSIGNED_Format\n} from 'three';\n\n/**\n * A loader for the S3TC texture compression format.\n *\n * ```js\n * const loader = new DDSLoader();\n *\n * const map = loader.load( 'textures/compressed/disturb_dxt1_nomip.dds' );\n * map.colorSpace = THREE.SRGBColorSpace; // only for color textures\n * ```\n *\n * @augments CompressedTextureLoader\n * @three_import import { DDSLoader } from 'three/addons/loaders/DDSLoader.js';\n */\nclass DDSLoader extends CompressedTextureLoader {\n\n\t/**\n\t * Constructs a new DDS loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\t/**\n\t * Parses the given S3TC texture data.\n\t *\n\t * @param {ArrayBuffer} buffer - The raw texture data.\n\t * @param {boolean} loadMipmaps - Whether to load mipmaps or not.\n\t * @return {CompressedTextureLoader~TexData} An object representing the parsed texture data.\n\t */\n\tparse( buffer, loadMipmaps ) {\n\n\t\tconst dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };\n\n\t\t// Adapted from @toji's DDS utils\n\t\t// https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\n\n\t\t// All values and structures referenced from:\n\t\t// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\n\t\tconst DDS_MAGIC = 0x20534444;\n\n\t\t// const DDSD_CAPS = 0x1;\n\t\t// const DDSD_HEIGHT = 0x2;\n\t\t// const DDSD_WIDTH = 0x4;\n\t\t// const DDSD_PITCH = 0x8;\n\t\t// const DDSD_PIXELFORMAT = 0x1000;\n\t\tconst DDSD_MIPMAPCOUNT = 0x20000;\n\t\t// const DDSD_LINEARSIZE = 0x80000;\n\t\t// const DDSD_DEPTH = 0x800000;\n\n\t\t// const DDSCAPS_COMPLEX = 0x8;\n\t\t// const DDSCAPS_MIPMAP = 0x400000;\n\t\t// const DDSCAPS_TEXTURE = 0x1000;\n\n\t\tconst DDSCAPS2_CUBEMAP = 0x200;\n\t\tconst DDSCAPS2_CUBEMAP_POSITIVEX = 0x400;\n\t\tconst DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800;\n\t\tconst DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000;\n\t\tconst DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000;\n\t\tconst DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000;\n\t\tconst DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000;\n\t\t// const DDSCAPS2_VOLUME = 0x200000;\n\n\t\t// const DDPF_ALPHAPIXELS = 0x1;\n\t\t// const DDPF_ALPHA = 0x2;\n\t\t// const DDPF_FOURCC = 0x4;\n\t\t// const DDPF_RGB = 0x40;\n\t\t// const DDPF_YUV = 0x200;\n\t\t// const DDPF_LUMINANCE = 0x20000;\n\n\t\tconst DXGI_FORMAT_BC6H_UF16 = 95;\n\t\tconst DXGI_FORMAT_BC6H_SF16 = 96;\n\n\t\tfunction fourCCToInt32( value ) {\n\n\t\t\treturn value.charCodeAt( 0 ) +\n\t\t\t\t( value.charCodeAt( 1 ) << 8 ) +\n\t\t\t\t( value.charCodeAt( 2 ) << 16 ) +\n\t\t\t\t( value.charCodeAt( 3 ) << 24 );\n\n\t\t}\n\n\t\tfunction int32ToFourCC( value ) {\n\n\t\t\treturn String.fromCharCode(\n\t\t\t\tvalue & 0xff,\n\t\t\t\t( value >> 8 ) & 0xff,\n\t\t\t\t( value >> 16 ) & 0xff,\n\t\t\t\t( value >> 24 ) & 0xff\n\t\t\t);\n\n\t\t}\n\n\t\tfunction loadARGBMip( buffer, dataOffset, width, height ) {\n\n\t\t\tconst dataLength = width * height * 4;\n\t\t\tconst srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );\n\t\t\tconst byteArray = new Uint8Array( dataLength );\n\t\t\tlet dst = 0;\n\t\t\tlet src = 0;\n\t\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\t\tconst b = srcBuffer[ src ]; src ++;\n\t\t\t\t\tconst g = srcBuffer[ src ]; src ++;\n\t\t\t\t\tconst r = srcBuffer[ src ]; src ++;\n\t\t\t\t\tconst a = srcBuffer[ src ]; src ++;\n\t\t\t\t\tbyteArray[ dst ] = r; dst ++;\t//r\n\t\t\t\t\tbyteArray[ dst ] = g; dst ++;\t//g\n\t\t\t\t\tbyteArray[ dst ] = b; dst ++;\t//b\n\t\t\t\t\tbyteArray[ dst ] = a; dst ++;\t//a\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn byteArray;\n\n\t\t}\n\n\t\tfunction loadRGBMip( buffer, dataOffset, width, height ) {\n\n\t\t\tconst dataLength = width * height * 3;\n\t\t\tconst srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );\n\t\t\tconst byteArray = new Uint8Array( width * height * 4 );\n\t\t\tlet dst = 0;\n\t\t\tlet src = 0;\n\t\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\t\tconst b = srcBuffer[ src ]; src ++;\n\t\t\t\t\tconst g = srcBuffer[ src ]; src ++;\n\t\t\t\t\tconst r = srcBuffer[ src ]; src ++;\n\t\t\t\t\tbyteArray[ dst ] = r; dst ++;\t//r\n\t\t\t\t\tbyteArray[ dst ] = g; dst ++;\t//g\n\t\t\t\t\tbyteArray[ dst ] = b; dst ++;\t//b\n\t\t\t\t\tbyteArray[ dst ] = 255; dst ++; //a\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn byteArray;\n\n\t\t}\n\n\t\tconst FOURCC_DXT1 = fourCCToInt32( 'DXT1' );\n\t\tconst FOURCC_DXT3 = fourCCToInt32( 'DXT3' );\n\t\tconst FOURCC_DXT5 = fourCCToInt32( 'DXT5' );\n\t\tconst FOURCC_ETC1 = fourCCToInt32( 'ETC1' );\n\t\tconst FOURCC_DX10 = fourCCToInt32( 'DX10' );\n\n\t\tconst headerLengthInt = 31; // The header length in 32 bit ints\n\t\tconst extendedHeaderLengthInt = 5; // The extended header length in 32 bit ints\n\n\t\t// Offsets into the header array\n\n\t\tconst off_magic = 0;\n\n\t\tconst off_size = 1;\n\t\tconst off_flags = 2;\n\t\tconst off_height = 3;\n\t\tconst off_width = 4;\n\n\t\tconst off_mipmapCount = 7;\n\n\t\t// const off_pfFlags = 20;\n\t\tconst off_pfFourCC = 21;\n\t\tconst off_RGBBitCount = 22;\n\t\tconst off_RBitMask = 23;\n\t\tconst off_GBitMask = 24;\n\t\tconst off_BBitMask = 25;\n\t\tconst off_ABitMask = 26;\n\n\t\t// const off_caps = 27;\n\t\tconst off_caps2 = 28;\n\t\t// const off_caps3 = 29;\n\t\t// const off_caps4 = 30;\n\n\t\t// If fourCC = DX10, the extended header starts after 32\n\t\tconst off_dxgiFormat = 0;\n\n\t\t// Parse header\n\n\t\tconst header = new Int32Array( buffer, 0, headerLengthInt );\n\n\t\tif ( header[ off_magic ] !== DDS_MAGIC ) {\n\n\t\t\tconsole.error( 'THREE.DDSLoader.parse: Invalid magic number in DDS header.' );\n\t\t\treturn dds;\n\n\t\t}\n\n\t\tlet blockBytes;\n\n\t\tconst fourCC = header[ off_pfFourCC ];\n\n\t\tlet isRGBAUncompressed = false;\n\t\tlet isRGBUncompressed = false;\n\n\t\tlet dataOffset = header[ off_size ] + 4;\n\n\t\tswitch ( fourCC ) {\n\n\t\t\tcase FOURCC_DXT1:\n\n\t\t\t\tblockBytes = 8;\n\t\t\t\tdds.format = RGB_S3TC_DXT1_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase FOURCC_DXT3:\n\n\t\t\t\tblockBytes = 16;\n\t\t\t\tdds.format = RGBA_S3TC_DXT3_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase FOURCC_DXT5:\n\n\t\t\t\tblockBytes = 16;\n\t\t\t\tdds.format = RGBA_S3TC_DXT5_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase FOURCC_ETC1:\n\n\t\t\t\tblockBytes = 8;\n\t\t\t\tdds.format = RGB_ETC1_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase FOURCC_DX10:\n\n\t\t\t\tdataOffset += extendedHeaderLengthInt * 4;\n\t\t\t\tconst extendedHeader = new Int32Array( buffer, ( headerLengthInt + 1 ) * 4, extendedHeaderLengthInt );\n\t\t\t\tconst dxgiFormat = extendedHeader[ off_dxgiFormat ];\n\t\t\t\tswitch ( dxgiFormat ) {\n\n\t\t\t\t\tcase DXGI_FORMAT_BC6H_SF16: {\n\n\t\t\t\t\t\tblockBytes = 16;\n\t\t\t\t\t\tdds.format = RGB_BPTC_SIGNED_Format;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcase DXGI_FORMAT_BC6H_UF16: {\n\n\t\t\t\t\t\tblockBytes = 16;\n\t\t\t\t\t\tdds.format = RGB_BPTC_UNSIGNED_Format;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdefault: {\n\n\t\t\t\t\t\tconsole.error( 'THREE.DDSLoader.parse: Unsupported DXGI_FORMAT code ', dxgiFormat );\n\t\t\t\t\t\treturn dds;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tif ( header[ off_RGBBitCount ] === 32\n\t\t\t\t\t&& header[ off_RBitMask ] & 0xff0000\n\t\t\t\t\t&& header[ off_GBitMask ] & 0xff00\n\t\t\t\t\t&& header[ off_BBitMask ] & 0xff\n\t\t\t\t\t&& header[ off_ABitMask ] & 0xff000000 ) {\n\n\t\t\t\t\tisRGBAUncompressed = true;\n\t\t\t\t\tblockBytes = 64;\n\t\t\t\t\tdds.format = RGBAFormat;\n\n\t\t\t\t} else if ( header[ off_RGBBitCount ] === 24\n\t\t\t\t\t&& header[ off_RBitMask ] & 0xff0000\n\t\t\t\t\t&& header[ off_GBitMask ] & 0xff00\n\t\t\t\t\t&& header[ off_BBitMask ] & 0xff ) {\n\n\t\t\t\t    \tisRGBUncompressed = true;\n                    \t\t\tblockBytes = 64;\n                    \t\t\tdds.format = RGBAFormat;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC( fourCC ) );\n\t\t\t\t\treturn dds;\n\n\t\t\t\t}\n\n\t\t}\n\n\t\tdds.mipmapCount = 1;\n\n\t\tif ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {\n\n\t\t\tdds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );\n\n\t\t}\n\n\t\tconst caps2 = header[ off_caps2 ];\n\t\tdds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;\n\t\tif ( dds.isCubemap && (\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ )\n\t\t) ) {\n\n\t\t\tconsole.error( 'THREE.DDSLoader.parse: Incomplete cubemap faces' );\n\t\t\treturn dds;\n\n\t\t}\n\n\t\tdds.width = header[ off_width ];\n\t\tdds.height = header[ off_height ];\n\n\t\t// Extract mipmaps buffers\n\n\t\tconst faces = dds.isCubemap ? 6 : 1;\n\n\t\tfor ( let face = 0; face < faces; face ++ ) {\n\n\t\t\tlet width = dds.width;\n\t\t\tlet height = dds.height;\n\n\t\t\tfor ( let i = 0; i < dds.mipmapCount; i ++ ) {\n\n\t\t\t\tlet byteArray, dataLength;\n\n\t\t\t\tif ( isRGBAUncompressed ) {\n\n\t\t\t\t\tbyteArray = loadARGBMip( buffer, dataOffset, width, height );\n\t\t\t\t\tdataLength = byteArray.length;\n\n\t\t\t\t} else if ( isRGBUncompressed ) {\n\n\t\t\t\t\tbyteArray = loadRGBMip( buffer, dataOffset, width, height );\n\t\t\t\t\tdataLength = width * height * 3;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;\n\t\t\t\t\tbyteArray = new Uint8Array( buffer, dataOffset, dataLength );\n\n\t\t\t\t}\n\n\t\t\t\tconst mipmap = { 'data': byteArray, 'width': width, 'height': height };\n\t\t\t\tdds.mipmaps.push( mipmap );\n\n\t\t\t\tdataOffset += dataLength;\n\n\t\t\t\twidth = Math.max( width >> 1, 1 );\n\t\t\t\theight = Math.max( height >> 1, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn dds;\n\n\t}\n\n}\n\nexport { DDSLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}