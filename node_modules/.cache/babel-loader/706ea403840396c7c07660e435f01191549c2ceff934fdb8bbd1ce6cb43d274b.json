{"ast":null,"code":"import { Color, ShaderMaterial, UniformsLib, UniformsUtils } from 'three';\n\n/**\n * A special line material for meshes loaded via {@link LDrawLoader}.\n *\n * This module can only be used with {@link WebGLRenderer}. When using {@link WebGPURenderer},\n * import the class from `LDrawConditionalLineNodeMaterial.js`.\n *\n * @augments ShaderMaterial\n * @three_import import { LDrawConditionalLineMaterial } from 'three/addons/materials/LDrawConditionalLineMaterial.js';\n */\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\n  static get type() {\n    return 'LDrawConditionalLineMaterial';\n  }\n\n  /**\n   * Constructs a new conditional line material.\n   *\n   * @param {Object} [parameters] - An object with one or more properties\n   * defining the material's appearance. Any property of the material\n   * (including any property from inherited materials) can be passed\n   * in here. Color values can be passed any type of value accepted\n   * by {@link Color#set}.\n   */\n  constructor(parameters) {\n    super({\n      uniforms: UniformsUtils.merge([UniformsLib.fog, {\n        diffuse: {\n          value: new Color()\n        },\n        opacity: {\n          value: 1.0\n        }\n      }]),\n      vertexShader: /* glsl */`\n\t\t\t\tattribute vec3 control0;\n\t\t\t\tattribute vec3 control1;\n\t\t\t\tattribute vec3 direction;\n\t\t\t\tvarying float discardFlag;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <color_pars_vertex>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <color_vertex>\n\n\t\t\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\t// Transform the line segment ends and control points into camera clip space\n\t\t\t\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\t\t\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\t\t\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\t\t\t\tc0.xy /= c0.w;\n\t\t\t\t\tc1.xy /= c1.w;\n\t\t\t\t\tp0.xy /= p0.w;\n\t\t\t\t\tp1.xy /= p1.w;\n\n\t\t\t\t\t// Get the direction of the segment and an orthogonal vector\n\t\t\t\t\tvec2 dir = p1.xy - p0.xy;\n\t\t\t\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t\t\t\t// Get control point directions from the line\n\t\t\t\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\t\t\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t\t\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t\t\t\t// from the line segment then the line should not be drawn.\n\t\t\t\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\t\t\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\t\t\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\t\t\t\t}\n\t\t\t`,\n      fragmentShader: /* glsl */`\n\t\t\tuniform vec3 diffuse;\n\t\t\tuniform float opacity;\n\t\t\tvarying float discardFlag;\n\n\t\t\t#include <common>\n\t\t\t#include <color_pars_fragment>\n\t\t\t#include <fog_pars_fragment>\n\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t#include <clipping_planes_pars_fragment>\n\t\t\tvoid main() {\n\n\t\t\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t\t\t#include <clipping_planes_fragment>\n\t\t\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t#include <color_fragment>\n\t\t\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t#include <colorspace_fragment>\n\t\t\t\t#include <fog_fragment>\n\t\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t}\n\t\t\t`\n    });\n    Object.defineProperties(this, {\n      /**\n       * The material's opacity.\n       *\n       * @name LDrawConditionalLineMaterial#opacity\n       * @type {number}\n       * @default 1\n       */\n      opacity: {\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      /**\n       * The material's color.\n       *\n       * @name LDrawConditionalLineMaterial#color\n       * @type {Color}\n       * @default (1,1,1)\n       */\n      color: {\n        get: function () {\n          return this.uniforms.diffuse.value;\n        }\n      }\n    });\n    this.setValues(parameters);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {boolean}\n     * @readonly\n     * @default true\n     */\n    this.isLDrawConditionalLineMaterial = true;\n  }\n}\nexport { LDrawConditionalLineMaterial };","map":{"version":3,"names":["Color","ShaderMaterial","UniformsLib","UniformsUtils","LDrawConditionalLineMaterial","type","constructor","parameters","uniforms","merge","fog","diffuse","value","opacity","vertexShader","fragmentShader","Object","defineProperties","get","set","color","setValues","isLDrawConditionalLineMaterial"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/materials/LDrawConditionalLineMaterial.js"],"sourcesContent":["import {\n\tColor,\n\tShaderMaterial,\n\tUniformsLib,\n\tUniformsUtils,\n} from 'three';\n\n/**\n * A special line material for meshes loaded via {@link LDrawLoader}.\n *\n * This module can only be used with {@link WebGLRenderer}. When using {@link WebGPURenderer},\n * import the class from `LDrawConditionalLineNodeMaterial.js`.\n *\n * @augments ShaderMaterial\n * @three_import import { LDrawConditionalLineMaterial } from 'three/addons/materials/LDrawConditionalLineMaterial.js';\n */\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'LDrawConditionalLineMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new conditional line material.\n\t *\n\t * @param {Object} [parameters] - An object with one or more properties\n\t * defining the material's appearance. Any property of the material\n\t * (including any property from inherited materials) can be passed\n\t * in here. Color values can be passed any type of value accepted\n\t * by {@link Color#set}.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib.fog,\n\t\t\t\t{\n\t\t\t\t\tdiffuse: {\n\t\t\t\t\t\tvalue: new Color()\n\t\t\t\t\t},\n\t\t\t\t\topacity: {\n\t\t\t\t\t\tvalue: 1.0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t] ),\n\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tattribute vec3 control0;\n\t\t\t\tattribute vec3 control1;\n\t\t\t\tattribute vec3 direction;\n\t\t\t\tvarying float discardFlag;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <color_pars_vertex>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <color_vertex>\n\n\t\t\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\t// Transform the line segment ends and control points into camera clip space\n\t\t\t\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\t\t\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\t\t\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\t\t\t\tc0.xy /= c0.w;\n\t\t\t\t\tc1.xy /= c1.w;\n\t\t\t\t\tp0.xy /= p0.w;\n\t\t\t\t\tp1.xy /= p1.w;\n\n\t\t\t\t\t// Get the direction of the segment and an orthogonal vector\n\t\t\t\t\tvec2 dir = p1.xy - p0.xy;\n\t\t\t\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t\t\t\t// Get control point directions from the line\n\t\t\t\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\t\t\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t\t\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t\t\t\t// from the line segment then the line should not be drawn.\n\t\t\t\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\t\t\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\t\t\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\tuniform vec3 diffuse;\n\t\t\tuniform float opacity;\n\t\t\tvarying float discardFlag;\n\n\t\t\t#include <common>\n\t\t\t#include <color_pars_fragment>\n\t\t\t#include <fog_pars_fragment>\n\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t#include <clipping_planes_pars_fragment>\n\t\t\tvoid main() {\n\n\t\t\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t\t\t#include <clipping_planes_fragment>\n\t\t\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t#include <color_fragment>\n\t\t\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t#include <colorspace_fragment>\n\t\t\t\t#include <fog_fragment>\n\t\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t}\n\t\t\t`,\n\n\t\t} );\n\n\t\tObject.defineProperties( this, {\n\n\t\t\t/**\n\t\t\t * The material's opacity.\n\t\t\t *\n\t\t\t * @name LDrawConditionalLineMaterial#opacity\n\t\t\t * @type {number}\n\t\t\t * @default 1\n\t\t\t */\n\t\t\topacity: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.opacity.value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms.opacity.value = value;\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * The material's color.\n\t\t\t *\n\t\t\t * @name LDrawConditionalLineMaterial#color\n\t\t\t * @type {Color}\n\t\t\t * @default (1,1,1)\n\t\t\t */\n\t\t\tcolor: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.diffuse.value;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLDrawConditionalLineMaterial = true;\n\n\t}\n\n}\n\nexport { LDrawConditionalLineMaterial };\n"],"mappings":"AAAA,SACCA,KAAK,EACLC,cAAc,EACdC,WAAW,EACXC,aAAa,QACP,OAAO;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,4BAA4B,SAASH,cAAc,CAAC;EAEzD,WAAWI,IAAIA,CAAA,EAAG;IAEjB,OAAO,8BAA8B;EAEtC;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCC,WAAWA,CAAEC,UAAU,EAAG;IAEzB,KAAK,CAAE;MAENC,QAAQ,EAAEL,aAAa,CAACM,KAAK,CAAE,CAC9BP,WAAW,CAACQ,GAAG,EACf;QACCC,OAAO,EAAE;UACRC,KAAK,EAAE,IAAIZ,KAAK,CAAC;QAClB,CAAC;QACDa,OAAO,EAAE;UACRD,KAAK,EAAE;QACR;MACD,CAAC,CACA,CAAC;MAEHE,YAAY,EAAE,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;MAEDC,cAAc,EAAE,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAEE,CAAE,CAAC;IAEHC,MAAM,CAACC,gBAAgB,CAAE,IAAI,EAAE;MAE9B;AACH;AACA;AACA;AACA;AACA;AACA;MACGJ,OAAO,EAAE;QACRK,GAAG,EAAE,SAAAA,CAAA,EAAY;UAEhB,OAAO,IAAI,CAACV,QAAQ,CAACK,OAAO,CAACD,KAAK;QAEnC,CAAC;QAEDO,GAAG,EAAE,SAAAA,CAAWP,KAAK,EAAG;UAEvB,IAAI,CAACJ,QAAQ,CAACK,OAAO,CAACD,KAAK,GAAGA,KAAK;QAEpC;MACD,CAAC;MAED;AACH;AACA;AACA;AACA;AACA;AACA;MACGQ,KAAK,EAAE;QACNF,GAAG,EAAE,SAAAA,CAAA,EAAY;UAEhB,OAAO,IAAI,CAACV,QAAQ,CAACG,OAAO,CAACC,KAAK;QAEnC;MACD;IAED,CAAE,CAAC;IAEH,IAAI,CAACS,SAAS,CAAEd,UAAW,CAAC;;IAE5B;AACF;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACe,8BAA8B,GAAG,IAAI;EAE3C;AAED;AAEA,SAASlB,4BAA4B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}