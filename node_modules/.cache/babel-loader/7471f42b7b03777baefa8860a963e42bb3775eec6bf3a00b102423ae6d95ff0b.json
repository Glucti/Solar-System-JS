{"ast":null,"code":"import { Line3, Mesh, Plane, Vector3 } from 'three';\nimport { ConvexGeometry } from '../geometries/ConvexGeometry.js';\nconst _v1 = new Vector3();\n\n/**\n * This class can be used to subdivide a convex Geometry object into pieces.\n *\n * Use the function prepareBreakableObject to prepare a Mesh object to be broken.\n * Then, call the various functions to subdivide the object (subdivideByImpact, cutByPlane).\n * Sub-objects that are product of subdivision don't need prepareBreakableObject to be called on them.\n *\n * Requisites for the object:\n * - Mesh object must have a buffer geometry and a material.\n * - Vertex normals must be planar (not smoothed).\n * - The geometry must be convex (this is not checked in the library). You can create convex\n * geometries with {@link ConvexGeometry}. The {@link BoxGeometry}, {@link SphereGeometry} and other\n * convex primitives can also be used.\n *\n * Note: This lib adds member variables to object's userData member (see prepareBreakableObject function)\n * Use with caution and read the code when using with other libs.\n *\n * @three_import import { ConvexObjectBreaker } from 'three/addons/misc/ConvexObjectBreaker.js';\n */\nclass ConvexObjectBreaker {\n  /**\n   * Constructs a new convex object breaker.\n   *\n   * @param {number} [minSizeForBreak=1.4] - Min size a debris can have to break.\n  \t * @param {number} [smallDelta=0.0001] - Max distance to consider that a point belongs to a plane.\n   */\n  constructor(minSizeForBreak = 1.4, smallDelta = 0.0001) {\n    this.minSizeForBreak = minSizeForBreak;\n    this.smallDelta = smallDelta;\n    this.tempLine1 = new Line3();\n    this.tempPlane1 = new Plane();\n    this.tempPlane2 = new Plane();\n    this.tempPlane_Cut = new Plane();\n    this.tempCM1 = new Vector3();\n    this.tempCM2 = new Vector3();\n    this.tempVector3 = new Vector3();\n    this.tempVector3_2 = new Vector3();\n    this.tempVector3_3 = new Vector3();\n    this.tempVector3_P0 = new Vector3();\n    this.tempVector3_P1 = new Vector3();\n    this.tempVector3_P2 = new Vector3();\n    this.tempVector3_N0 = new Vector3();\n    this.tempVector3_N1 = new Vector3();\n    this.tempVector3_AB = new Vector3();\n    this.tempVector3_CB = new Vector3();\n    this.tempResultObjects = {\n      object1: null,\n      object2: null\n    };\n    this.segments = [];\n    const n = 30 * 30;\n    for (let i = 0; i < n; i++) this.segments[i] = false;\n  }\n\n  /**\n   * Must be called for all 3D objects that should be breakable.\n   *\n   * @param {Object3D} object - The 3D object. It must have a convex geometry.\n   * @param {number} mass - The 3D object's mass in kg. Must be greater than `0`.\n   * @param {Vector3} velocity - The 3D object's velocity.\n   * @param {Vector3} angularVelocity - The 3D object's angular velocity.\n   * @param {boolean} breakable - Whether the 3D object is breakable or not.\n   */\n  prepareBreakableObject(object, mass, velocity, angularVelocity, breakable) {\n    // object is a Object3d (normally a Mesh), must have a buffer geometry, and it must be convex.\n    // Its material property is propagated to its children (sub-pieces)\n    // mass must be > 0\n\n    const userData = object.userData;\n    userData.mass = mass;\n    userData.velocity = velocity.clone();\n    userData.angularVelocity = angularVelocity.clone();\n    userData.breakable = breakable;\n  }\n\n  /**\n   * Subdivides the given 3D object into pieces by an impact (meaning another object hits\n   * the given 3D object at a certain surface point).\n   *\n   * @param {Object3D} object - The 3D object to subdivide.\n   * @param {Vector3} pointOfImpact - The point of impact.\n   * @param {Vector3} normal - The impact normal.\n   * @param {number} maxRadialIterations - Iterations for radial cuts.\n   * @param {number} maxRandomIterations - Max random iterations for not-radial cuts.\n   * @return {Array<Object3D>} The array of pieces.\n   */\n  subdivideByImpact(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {\n    const debris = [];\n    const tempPlane1 = this.tempPlane1;\n    const tempPlane2 = this.tempPlane2;\n    this.tempVector3.addVectors(pointOfImpact, normal);\n    tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3);\n    const maxTotalIterations = maxRandomIterations + maxRadialIterations;\n    const scope = this;\n    function subdivideRadial(subObject, startAngle, endAngle, numIterations) {\n      if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {\n        debris.push(subObject);\n        return;\n      }\n      let angle = Math.PI;\n      if (numIterations === 0) {\n        tempPlane2.normal.copy(tempPlane1.normal);\n        tempPlane2.constant = tempPlane1.constant;\n      } else {\n        if (numIterations <= maxRadialIterations) {\n          angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle;\n\n          // Rotate tempPlane2 at impact point around normal axis and the angle\n          scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact);\n          tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2);\n        } else {\n          angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI;\n\n          // Rotate tempPlane2 at object position around normal axis and the angle\n          scope.tempVector3_2.copy(pointOfImpact).sub(subObject.position).applyAxisAngle(normal, angle).add(subObject.position);\n          scope.tempVector3_3.copy(normal).add(subObject.position);\n          tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2);\n        }\n      }\n\n      // Perform the cut\n      scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects);\n      const obj1 = scope.tempResultObjects.object1;\n      const obj2 = scope.tempResultObjects.object2;\n      if (obj1) {\n        subdivideRadial(obj1, startAngle, angle, numIterations + 1);\n      }\n      if (obj2) {\n        subdivideRadial(obj2, angle, endAngle, numIterations + 1);\n      }\n    }\n    subdivideRadial(object, 0, 2 * Math.PI, 0);\n    return debris;\n  }\n\n  /**\n   * Subdivides the given 3D object into pieces by a plane.\n   *\n   * @param {Object3D} object - The 3D object to subdivide.\n   * @param {Plane} plane - The plane to cut the 3D object.\n   * @param {{object1:?Mesh,object2:?Mesh}} output - An object that stores the pieces.\n   * @return {number} The number of pieces.\n   */\n  cutByPlane(object, plane, output) {\n    // Returns breakable objects in output.object1 and output.object2 members, the resulting 2 pieces of the cut.\n    // object2 can be null if the plane doesn't cut the object.\n    // object1 can be null only in case of internal error\n    // Returned value is number of pieces, 0 for error.\n\n    const geometry = object.geometry;\n    const coords = geometry.attributes.position.array;\n    const normals = geometry.attributes.normal.array;\n    const numPoints = coords.length / 3;\n    let numFaces = numPoints / 3;\n    let indices = geometry.getIndex();\n    if (indices) {\n      indices = indices.array;\n      numFaces = indices.length / 3;\n    }\n    function getVertexIndex(faceIdx, vert) {\n      // vert = 0, 1 or 2.\n\n      const idx = faceIdx * 3 + vert;\n      return indices ? indices[idx] : idx;\n    }\n    const points1 = [];\n    const points2 = [];\n    const delta = this.smallDelta;\n\n    // Reset segments mark\n    const numPointPairs = numPoints * numPoints;\n    for (let i = 0; i < numPointPairs; i++) this.segments[i] = false;\n    const p0 = this.tempVector3_P0;\n    const p1 = this.tempVector3_P1;\n    const n0 = this.tempVector3_N0;\n    const n1 = this.tempVector3_N1;\n\n    // Iterate through the faces to mark edges shared by coplanar faces\n    for (let i = 0; i < numFaces - 1; i++) {\n      const a1 = getVertexIndex(i, 0);\n      const b1 = getVertexIndex(i, 1);\n      const c1 = getVertexIndex(i, 2);\n\n      // Assuming all 3 vertices have the same normal\n      n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2);\n      for (let j = i + 1; j < numFaces; j++) {\n        const a2 = getVertexIndex(j, 0);\n        const b2 = getVertexIndex(j, 1);\n        const c2 = getVertexIndex(j, 2);\n\n        // Assuming all 3 vertices have the same normal\n        n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2);\n        const coplanar = 1 - n0.dot(n1) < delta;\n        if (coplanar) {\n          if (a1 === a2 || a1 === b2 || a1 === c2) {\n            if (b1 === a2 || b1 === b2 || b1 === c2) {\n              this.segments[a1 * numPoints + b1] = true;\n              this.segments[b1 * numPoints + a1] = true;\n            } else {\n              this.segments[c1 * numPoints + a1] = true;\n              this.segments[a1 * numPoints + c1] = true;\n            }\n          } else if (b1 === a2 || b1 === b2 || b1 === c2) {\n            this.segments[c1 * numPoints + b1] = true;\n            this.segments[b1 * numPoints + c1] = true;\n          }\n        }\n      }\n    }\n\n    // Transform the plane to object local space\n    const localPlane = this.tempPlane_Cut;\n    object.updateMatrix();\n    ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane);\n\n    // Iterate through the faces adding points to both pieces\n    for (let i = 0; i < numFaces; i++) {\n      const va = getVertexIndex(i, 0);\n      const vb = getVertexIndex(i, 1);\n      const vc = getVertexIndex(i, 2);\n      for (let segment = 0; segment < 3; segment++) {\n        const i0 = segment === 0 ? va : segment === 1 ? vb : vc;\n        const i1 = segment === 0 ? vb : segment === 1 ? vc : va;\n        const segmentState = this.segments[i0 * numPoints + i1];\n        if (segmentState) continue; // The segment already has been processed in another face\n\n        // Mark segment as processed (also inverted segment)\n        this.segments[i0 * numPoints + i1] = true;\n        this.segments[i1 * numPoints + i0] = true;\n        p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2]);\n        p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2]);\n\n        // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n        let mark0 = 0;\n        let d = localPlane.distanceToPoint(p0);\n        if (d > delta) {\n          mark0 = 2;\n          points2.push(p0.clone());\n        } else if (d < -delta) {\n          mark0 = 1;\n          points1.push(p0.clone());\n        } else {\n          mark0 = 3;\n          points1.push(p0.clone());\n          points2.push(p0.clone());\n        }\n\n        // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n        let mark1 = 0;\n        d = localPlane.distanceToPoint(p1);\n        if (d > delta) {\n          mark1 = 2;\n          points2.push(p1.clone());\n        } else if (d < -delta) {\n          mark1 = 1;\n          points1.push(p1.clone());\n        } else {\n          mark1 = 3;\n          points1.push(p1.clone());\n          points2.push(p1.clone());\n        }\n        if (mark0 === 1 && mark1 === 2 || mark0 === 2 && mark1 === 1) {\n          // Intersection of segment with the plane\n\n          this.tempLine1.start.copy(p0);\n          this.tempLine1.end.copy(p1);\n          let intersection = new Vector3();\n          intersection = localPlane.intersectLine(this.tempLine1, intersection);\n          if (intersection === null) {\n            // Shouldn't happen\n            console.error('Internal error: segment does not intersect plane.');\n            output.segmentedObject1 = null;\n            output.segmentedObject2 = null;\n            return 0;\n          }\n          points1.push(intersection);\n          points2.push(intersection.clone());\n        }\n      }\n    }\n\n    // Calculate debris mass (very fast and imprecise):\n    const newMass = object.userData.mass * 0.5;\n\n    // Calculate debris Center of Mass (again fast and imprecise)\n    this.tempCM1.set(0, 0, 0);\n    let radius1 = 0;\n    const numPoints1 = points1.length;\n    if (numPoints1 > 0) {\n      for (let i = 0; i < numPoints1; i++) this.tempCM1.add(points1[i]);\n      this.tempCM1.divideScalar(numPoints1);\n      for (let i = 0; i < numPoints1; i++) {\n        const p = points1[i];\n        p.sub(this.tempCM1);\n        radius1 = Math.max(radius1, p.x, p.y, p.z);\n      }\n      this.tempCM1.add(object.position);\n    }\n    this.tempCM2.set(0, 0, 0);\n    let radius2 = 0;\n    const numPoints2 = points2.length;\n    if (numPoints2 > 0) {\n      for (let i = 0; i < numPoints2; i++) this.tempCM2.add(points2[i]);\n      this.tempCM2.divideScalar(numPoints2);\n      for (let i = 0; i < numPoints2; i++) {\n        const p = points2[i];\n        p.sub(this.tempCM2);\n        radius2 = Math.max(radius2, p.x, p.y, p.z);\n      }\n      this.tempCM2.add(object.position);\n    }\n    let object1 = null;\n    let object2 = null;\n    let numObjects = 0;\n    if (numPoints1 > 4) {\n      object1 = new Mesh(new ConvexGeometry(points1), object.material);\n      object1.position.copy(this.tempCM1);\n      object1.quaternion.copy(object.quaternion);\n      this.prepareBreakableObject(object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak);\n      numObjects++;\n    }\n    if (numPoints2 > 4) {\n      object2 = new Mesh(new ConvexGeometry(points2), object.material);\n      object2.position.copy(this.tempCM2);\n      object2.quaternion.copy(object.quaternion);\n      this.prepareBreakableObject(object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak);\n      numObjects++;\n    }\n    output.object1 = object1;\n    output.object2 = object2;\n    return numObjects;\n  }\n\n  // internal helpers\n\n  static transformFreeVector(v, m) {\n    // input:\n    // vector interpreted as a free vector\n    // THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n    const x = v.x,\n      y = v.y,\n      z = v.z;\n    const e = m.elements;\n    v.x = e[0] * x + e[4] * y + e[8] * z;\n    v.y = e[1] * x + e[5] * y + e[9] * z;\n    v.z = e[2] * x + e[6] * y + e[10] * z;\n    return v;\n  }\n  static transformFreeVectorInverse(v, m) {\n    // input:\n    // vector interpreted as a free vector\n    // THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n    const x = v.x,\n      y = v.y,\n      z = v.z;\n    const e = m.elements;\n    v.x = e[0] * x + e[1] * y + e[2] * z;\n    v.y = e[4] * x + e[5] * y + e[6] * z;\n    v.z = e[8] * x + e[9] * y + e[10] * z;\n    return v;\n  }\n  static transformTiedVectorInverse(v, m) {\n    // input:\n    // vector interpreted as a tied (ordinary) vector\n    // THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n    const x = v.x,\n      y = v.y,\n      z = v.z;\n    const e = m.elements;\n    v.x = e[0] * x + e[1] * y + e[2] * z - e[12];\n    v.y = e[4] * x + e[5] * y + e[6] * z - e[13];\n    v.z = e[8] * x + e[9] * y + e[10] * z - e[14];\n    return v;\n  }\n  static transformPlaneToLocalSpace(plane, m, resultPlane) {\n    resultPlane.normal.copy(plane.normal);\n    resultPlane.constant = plane.constant;\n    const referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(_v1), m);\n    ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m);\n\n    // recalculate constant (like in setFromNormalAndCoplanarPoint)\n    resultPlane.constant = -referencePoint.dot(resultPlane.normal);\n  }\n}\nexport { ConvexObjectBreaker };","map":{"version":3,"names":["Line3","Mesh","Plane","Vector3","ConvexGeometry","_v1","ConvexObjectBreaker","constructor","minSizeForBreak","smallDelta","tempLine1","tempPlane1","tempPlane2","tempPlane_Cut","tempCM1","tempCM2","tempVector3","tempVector3_2","tempVector3_3","tempVector3_P0","tempVector3_P1","tempVector3_P2","tempVector3_N0","tempVector3_N1","tempVector3_AB","tempVector3_CB","tempResultObjects","object1","object2","segments","n","i","prepareBreakableObject","object","mass","velocity","angularVelocity","breakable","userData","clone","subdivideByImpact","pointOfImpact","normal","maxRadialIterations","maxRandomIterations","debris","addVectors","setFromCoplanarPoints","position","maxTotalIterations","scope","subdivideRadial","subObject","startAngle","endAngle","numIterations","Math","random","push","angle","PI","copy","constant","sub","applyAxisAngle","add","cutByPlane","obj1","obj2","plane","output","geometry","coords","attributes","array","normals","numPoints","length","numFaces","indices","getIndex","getVertexIndex","faceIdx","vert","idx","points1","points2","delta","numPointPairs","p0","p1","n0","n1","a1","b1","c1","set","j","a2","b2","c2","coplanar","dot","localPlane","updateMatrix","transformPlaneToLocalSpace","matrix","va","vb","vc","segment","i0","i1","segmentState","mark0","d","distanceToPoint","mark1","start","end","intersection","intersectLine","console","error","segmentedObject1","segmentedObject2","newMass","radius1","numPoints1","divideScalar","p","max","x","y","z","radius2","numPoints2","numObjects","material","quaternion","transformFreeVector","v","m","e","elements","transformFreeVectorInverse","transformTiedVectorInverse","resultPlane","referencePoint","coplanarPoint"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/misc/ConvexObjectBreaker.js"],"sourcesContent":["import {\n\tLine3,\n\tMesh,\n\tPlane,\n\tVector3\n} from 'three';\nimport { ConvexGeometry } from '../geometries/ConvexGeometry.js';\n\nconst _v1 = new Vector3();\n\n/**\n * This class can be used to subdivide a convex Geometry object into pieces.\n *\n * Use the function prepareBreakableObject to prepare a Mesh object to be broken.\n * Then, call the various functions to subdivide the object (subdivideByImpact, cutByPlane).\n * Sub-objects that are product of subdivision don't need prepareBreakableObject to be called on them.\n *\n * Requisites for the object:\n * - Mesh object must have a buffer geometry and a material.\n * - Vertex normals must be planar (not smoothed).\n * - The geometry must be convex (this is not checked in the library). You can create convex\n * geometries with {@link ConvexGeometry}. The {@link BoxGeometry}, {@link SphereGeometry} and other\n * convex primitives can also be used.\n *\n * Note: This lib adds member variables to object's userData member (see prepareBreakableObject function)\n * Use with caution and read the code when using with other libs.\n *\n * @three_import import { ConvexObjectBreaker } from 'three/addons/misc/ConvexObjectBreaker.js';\n */\nclass ConvexObjectBreaker {\n\n\t/**\n\t * Constructs a new convex object breaker.\n\t *\n\t * @param {number} [minSizeForBreak=1.4] - Min size a debris can have to break.\n \t * @param {number} [smallDelta=0.0001] - Max distance to consider that a point belongs to a plane.\n\t */\n\tconstructor( minSizeForBreak = 1.4, smallDelta = 0.0001 ) {\n\n\t\tthis.minSizeForBreak = minSizeForBreak;\n\t\tthis.smallDelta = smallDelta;\n\n\t\tthis.tempLine1 = new Line3();\n\t\tthis.tempPlane1 = new Plane();\n\t\tthis.tempPlane2 = new Plane();\n\t\tthis.tempPlane_Cut = new Plane();\n\t\tthis.tempCM1 = new Vector3();\n\t\tthis.tempCM2 = new Vector3();\n\t\tthis.tempVector3 = new Vector3();\n\t\tthis.tempVector3_2 = new Vector3();\n\t\tthis.tempVector3_3 = new Vector3();\n\t\tthis.tempVector3_P0 = new Vector3();\n\t\tthis.tempVector3_P1 = new Vector3();\n\t\tthis.tempVector3_P2 = new Vector3();\n\t\tthis.tempVector3_N0 = new Vector3();\n\t\tthis.tempVector3_N1 = new Vector3();\n\t\tthis.tempVector3_AB = new Vector3();\n\t\tthis.tempVector3_CB = new Vector3();\n\t\tthis.tempResultObjects = { object1: null, object2: null };\n\n\t\tthis.segments = [];\n\t\tconst n = 30 * 30;\n\t\tfor ( let i = 0; i < n; i ++ ) this.segments[ i ] = false;\n\n\t}\n\n\t/**\n\t * Must be called for all 3D objects that should be breakable.\n\t *\n\t * @param {Object3D} object - The 3D object. It must have a convex geometry.\n\t * @param {number} mass - The 3D object's mass in kg. Must be greater than `0`.\n\t * @param {Vector3} velocity - The 3D object's velocity.\n\t * @param {Vector3} angularVelocity - The 3D object's angular velocity.\n\t * @param {boolean} breakable - Whether the 3D object is breakable or not.\n\t */\n\tprepareBreakableObject( object, mass, velocity, angularVelocity, breakable ) {\n\n\t\t// object is a Object3d (normally a Mesh), must have a buffer geometry, and it must be convex.\n\t\t// Its material property is propagated to its children (sub-pieces)\n\t\t// mass must be > 0\n\n\t\tconst userData = object.userData;\n\t\tuserData.mass = mass;\n\t\tuserData.velocity = velocity.clone();\n\t\tuserData.angularVelocity = angularVelocity.clone();\n\t\tuserData.breakable = breakable;\n\n\t}\n\n\t/**\n\t * Subdivides the given 3D object into pieces by an impact (meaning another object hits\n\t * the given 3D object at a certain surface point).\n\t *\n\t * @param {Object3D} object - The 3D object to subdivide.\n\t * @param {Vector3} pointOfImpact - The point of impact.\n\t * @param {Vector3} normal - The impact normal.\n\t * @param {number} maxRadialIterations - Iterations for radial cuts.\n\t * @param {number} maxRandomIterations - Max random iterations for not-radial cuts.\n\t * @return {Array<Object3D>} The array of pieces.\n\t */\n\tsubdivideByImpact( object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations ) {\n\n\t\tconst debris = [];\n\n\t\tconst tempPlane1 = this.tempPlane1;\n\t\tconst tempPlane2 = this.tempPlane2;\n\n\t\tthis.tempVector3.addVectors( pointOfImpact, normal );\n\t\ttempPlane1.setFromCoplanarPoints( pointOfImpact, object.position, this.tempVector3 );\n\n\t\tconst maxTotalIterations = maxRandomIterations + maxRadialIterations;\n\n\t\tconst scope = this;\n\n\t\tfunction subdivideRadial( subObject, startAngle, endAngle, numIterations ) {\n\n\t\t\tif ( Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations ) {\n\n\t\t\t\tdebris.push( subObject );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tlet angle = Math.PI;\n\n\t\t\tif ( numIterations === 0 ) {\n\n\t\t\t\ttempPlane2.normal.copy( tempPlane1.normal );\n\t\t\t\ttempPlane2.constant = tempPlane1.constant;\n\n\t\t\t} else {\n\n\t\t\t\tif ( numIterations <= maxRadialIterations ) {\n\n\t\t\t\t\tangle = ( endAngle - startAngle ) * ( 0.2 + 0.6 * Math.random() ) + startAngle;\n\n\t\t\t\t\t// Rotate tempPlane2 at impact point around normal axis and the angle\n\t\t\t\t\tscope.tempVector3_2.copy( object.position ).sub( pointOfImpact ).applyAxisAngle( normal, angle ).add( pointOfImpact );\n\t\t\t\t\ttempPlane2.setFromCoplanarPoints( pointOfImpact, scope.tempVector3, scope.tempVector3_2 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tangle = ( ( 0.5 * ( numIterations & 1 ) ) + 0.2 * ( 2 - Math.random() ) ) * Math.PI;\n\n\t\t\t\t\t// Rotate tempPlane2 at object position around normal axis and the angle\n\t\t\t\t\tscope.tempVector3_2.copy( pointOfImpact ).sub( subObject.position ).applyAxisAngle( normal, angle ).add( subObject.position );\n\t\t\t\t\tscope.tempVector3_3.copy( normal ).add( subObject.position );\n\t\t\t\t\ttempPlane2.setFromCoplanarPoints( subObject.position, scope.tempVector3_3, scope.tempVector3_2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Perform the cut\n\t\t\tscope.cutByPlane( subObject, tempPlane2, scope.tempResultObjects );\n\n\t\t\tconst obj1 = scope.tempResultObjects.object1;\n\t\t\tconst obj2 = scope.tempResultObjects.object2;\n\n\t\t\tif ( obj1 ) {\n\n\t\t\t\tsubdivideRadial( obj1, startAngle, angle, numIterations + 1 );\n\n\t\t\t}\n\n\t\t\tif ( obj2 ) {\n\n\t\t\t\tsubdivideRadial( obj2, angle, endAngle, numIterations + 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tsubdivideRadial( object, 0, 2 * Math.PI, 0 );\n\n\t\treturn debris;\n\n\t}\n\n\t/**\n\t * Subdivides the given 3D object into pieces by a plane.\n\t *\n\t * @param {Object3D} object - The 3D object to subdivide.\n\t * @param {Plane} plane - The plane to cut the 3D object.\n\t * @param {{object1:?Mesh,object2:?Mesh}} output - An object that stores the pieces.\n\t * @return {number} The number of pieces.\n\t */\n\tcutByPlane( object, plane, output ) {\n\n\t\t// Returns breakable objects in output.object1 and output.object2 members, the resulting 2 pieces of the cut.\n\t\t// object2 can be null if the plane doesn't cut the object.\n\t\t// object1 can be null only in case of internal error\n\t\t// Returned value is number of pieces, 0 for error.\n\n\t\tconst geometry = object.geometry;\n\t\tconst coords = geometry.attributes.position.array;\n\t\tconst normals = geometry.attributes.normal.array;\n\n\t\tconst numPoints = coords.length / 3;\n\t\tlet numFaces = numPoints / 3;\n\n\t\tlet indices = geometry.getIndex();\n\n\t\tif ( indices ) {\n\n\t\t\tindices = indices.array;\n\t\t\tnumFaces = indices.length / 3;\n\n\t\t}\n\n\t\tfunction getVertexIndex( faceIdx, vert ) {\n\n\t\t\t// vert = 0, 1 or 2.\n\n\t\t\tconst idx = faceIdx * 3 + vert;\n\n\t\t\treturn indices ? indices[ idx ] : idx;\n\n\t\t}\n\n\t\tconst points1 = [];\n\t\tconst points2 = [];\n\n\t\tconst delta = this.smallDelta;\n\n\t\t// Reset segments mark\n\t\tconst numPointPairs = numPoints * numPoints;\n\t\tfor ( let i = 0; i < numPointPairs; i ++ ) this.segments[ i ] = false;\n\n\t\tconst p0 = this.tempVector3_P0;\n\t\tconst p1 = this.tempVector3_P1;\n\t\tconst n0 = this.tempVector3_N0;\n\t\tconst n1 = this.tempVector3_N1;\n\n\t\t// Iterate through the faces to mark edges shared by coplanar faces\n\t\tfor ( let i = 0; i < numFaces - 1; i ++ ) {\n\n\t\t\tconst a1 = getVertexIndex( i, 0 );\n\t\t\tconst b1 = getVertexIndex( i, 1 );\n\t\t\tconst c1 = getVertexIndex( i, 2 );\n\n\t\t\t// Assuming all 3 vertices have the same normal\n\t\t\tn0.set( normals[ a1 ], normals[ a1 ] + 1, normals[ a1 ] + 2 );\n\n\t\t\tfor ( let j = i + 1; j < numFaces; j ++ ) {\n\n\t\t\t\tconst a2 = getVertexIndex( j, 0 );\n\t\t\t\tconst b2 = getVertexIndex( j, 1 );\n\t\t\t\tconst c2 = getVertexIndex( j, 2 );\n\n\t\t\t\t// Assuming all 3 vertices have the same normal\n\t\t\t\tn1.set( normals[ a2 ], normals[ a2 ] + 1, normals[ a2 ] + 2 );\n\n\t\t\t\tconst coplanar = 1 - n0.dot( n1 ) < delta;\n\n\t\t\t\tif ( coplanar ) {\n\n\t\t\t\t\tif ( a1 === a2 || a1 === b2 || a1 === c2 ) {\n\n\t\t\t\t\t\tif ( b1 === a2 || b1 === b2 || b1 === c2 ) {\n\n\t\t\t\t\t\t\tthis.segments[ a1 * numPoints + b1 ] = true;\n\t\t\t\t\t\t\tthis.segments[ b1 * numPoints + a1 ] = true;\n\n\t\t\t\t\t\t}\telse {\n\n\t\t\t\t\t\t\tthis.segments[ c1 * numPoints + a1 ] = true;\n\t\t\t\t\t\t\tthis.segments[ a1 * numPoints + c1 ] = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\telse if ( b1 === a2 || b1 === b2 || b1 === c2 ) {\n\n\t\t\t\t\t\tthis.segments[ c1 * numPoints + b1 ] = true;\n\t\t\t\t\t\tthis.segments[ b1 * numPoints + c1 ] = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Transform the plane to object local space\n\t\tconst localPlane = this.tempPlane_Cut;\n\t\tobject.updateMatrix();\n\t\tConvexObjectBreaker.transformPlaneToLocalSpace( plane, object.matrix, localPlane );\n\n\t\t// Iterate through the faces adding points to both pieces\n\t\tfor ( let i = 0; i < numFaces; i ++ ) {\n\n\t\t\tconst va = getVertexIndex( i, 0 );\n\t\t\tconst vb = getVertexIndex( i, 1 );\n\t\t\tconst vc = getVertexIndex( i, 2 );\n\n\t\t\tfor ( let segment = 0; segment < 3; segment ++ ) {\n\n\t\t\t\tconst i0 = segment === 0 ? va : ( segment === 1 ? vb : vc );\n\t\t\t\tconst i1 = segment === 0 ? vb : ( segment === 1 ? vc : va );\n\n\t\t\t\tconst segmentState = this.segments[ i0 * numPoints + i1 ];\n\n\t\t\t\tif ( segmentState ) continue; // The segment already has been processed in another face\n\n\t\t\t\t// Mark segment as processed (also inverted segment)\n\t\t\t\tthis.segments[ i0 * numPoints + i1 ] = true;\n\t\t\t\tthis.segments[ i1 * numPoints + i0 ] = true;\n\n\t\t\t\tp0.set( coords[ 3 * i0 ], coords[ 3 * i0 + 1 ], coords[ 3 * i0 + 2 ] );\n\t\t\t\tp1.set( coords[ 3 * i1 ], coords[ 3 * i1 + 1 ], coords[ 3 * i1 + 2 ] );\n\n\t\t\t\t// mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n\t\t\t\tlet mark0 = 0;\n\n\t\t\t\tlet d = localPlane.distanceToPoint( p0 );\n\n\t\t\t\tif ( d > delta ) {\n\n\t\t\t\t\tmark0 = 2;\n\t\t\t\t\tpoints2.push( p0.clone() );\n\n\t\t\t\t} else if ( d < - delta ) {\n\n\t\t\t\t\tmark0 = 1;\n\t\t\t\t\tpoints1.push( p0.clone() );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmark0 = 3;\n\t\t\t\t\tpoints1.push( p0.clone() );\n\t\t\t\t\tpoints2.push( p0.clone() );\n\n\t\t\t\t}\n\n\t\t\t\t// mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n\t\t\t\tlet mark1 = 0;\n\n\t\t\t\td = localPlane.distanceToPoint( p1 );\n\n\t\t\t\tif ( d > delta ) {\n\n\t\t\t\t\tmark1 = 2;\n\t\t\t\t\tpoints2.push( p1.clone() );\n\n\t\t\t\t} else if ( d < - delta ) {\n\n\t\t\t\t\tmark1 = 1;\n\t\t\t\t\tpoints1.push( p1.clone() );\n\n\t\t\t\t}\telse {\n\n\t\t\t\t\tmark1 = 3;\n\t\t\t\t\tpoints1.push( p1.clone() );\n\t\t\t\t\tpoints2.push( p1.clone() );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ( mark0 === 1 && mark1 === 2 ) || ( mark0 === 2 && mark1 === 1 ) ) {\n\n\t\t\t\t\t// Intersection of segment with the plane\n\n\t\t\t\t\tthis.tempLine1.start.copy( p0 );\n\t\t\t\t\tthis.tempLine1.end.copy( p1 );\n\n\t\t\t\t\tlet intersection = new Vector3();\n\t\t\t\t\tintersection = localPlane.intersectLine( this.tempLine1, intersection );\n\n\t\t\t\t\tif ( intersection === null ) {\n\n\t\t\t\t\t\t// Shouldn't happen\n\t\t\t\t\t\tconsole.error( 'Internal error: segment does not intersect plane.' );\n\t\t\t\t\t\toutput.segmentedObject1 = null;\n\t\t\t\t\t\toutput.segmentedObject2 = null;\n\t\t\t\t\t\treturn 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpoints1.push( intersection );\n\t\t\t\t\tpoints2.push( intersection.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Calculate debris mass (very fast and imprecise):\n\t\tconst newMass = object.userData.mass * 0.5;\n\n\t\t// Calculate debris Center of Mass (again fast and imprecise)\n\t\tthis.tempCM1.set( 0, 0, 0 );\n\t\tlet radius1 = 0;\n\t\tconst numPoints1 = points1.length;\n\n\t\tif ( numPoints1 > 0 ) {\n\n\t\t\tfor ( let i = 0; i < numPoints1; i ++ ) this.tempCM1.add( points1[ i ] );\n\n\t\t\tthis.tempCM1.divideScalar( numPoints1 );\n\t\t\tfor ( let i = 0; i < numPoints1; i ++ ) {\n\n\t\t\t\tconst p = points1[ i ];\n\t\t\t\tp.sub( this.tempCM1 );\n\t\t\t\tradius1 = Math.max( radius1, p.x, p.y, p.z );\n\n\t\t\t}\n\n\t\t\tthis.tempCM1.add( object.position );\n\n\t\t}\n\n\t\tthis.tempCM2.set( 0, 0, 0 );\n\t\tlet radius2 = 0;\n\t\tconst numPoints2 = points2.length;\n\t\tif ( numPoints2 > 0 ) {\n\n\t\t\tfor ( let i = 0; i < numPoints2; i ++ ) this.tempCM2.add( points2[ i ] );\n\n\t\t\tthis.tempCM2.divideScalar( numPoints2 );\n\t\t\tfor ( let i = 0; i < numPoints2; i ++ ) {\n\n\t\t\t\tconst p = points2[ i ];\n\t\t\t\tp.sub( this.tempCM2 );\n\t\t\t\tradius2 = Math.max( radius2, p.x, p.y, p.z );\n\n\t\t\t}\n\n\t\t\tthis.tempCM2.add( object.position );\n\n\t\t}\n\n\t\tlet object1 = null;\n\t\tlet object2 = null;\n\n\t\tlet numObjects = 0;\n\n\t\tif ( numPoints1 > 4 ) {\n\n\t\t\tobject1 = new Mesh( new ConvexGeometry( points1 ), object.material );\n\t\t\tobject1.position.copy( this.tempCM1 );\n\t\t\tobject1.quaternion.copy( object.quaternion );\n\n\t\t\tthis.prepareBreakableObject( object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak );\n\n\t\t\tnumObjects ++;\n\n\t\t}\n\n\t\tif ( numPoints2 > 4 ) {\n\n\t\t\tobject2 = new Mesh( new ConvexGeometry( points2 ), object.material );\n\t\t\tobject2.position.copy( this.tempCM2 );\n\t\t\tobject2.quaternion.copy( object.quaternion );\n\n\t\t\tthis.prepareBreakableObject( object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak );\n\n\t\t\tnumObjects ++;\n\n\t\t}\n\n\t\toutput.object1 = object1;\n\t\toutput.object2 = object2;\n\n\t\treturn numObjects;\n\n\t}\n\n\t// internal helpers\n\n\tstatic transformFreeVector( v, m ) {\n\n\t\t// input:\n\t\t// vector interpreted as a free vector\n\t\t// THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n\t\tconst x = v.x, y = v.y, z = v.z;\n\t\tconst e = m.elements;\n\n\t\tv.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\n\t\tv.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\n\t\tv.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\treturn v;\n\n\t}\n\n\tstatic transformFreeVectorInverse( v, m ) {\n\n\t\t// input:\n\t\t// vector interpreted as a free vector\n\t\t// THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n\t\tconst x = v.x, y = v.y, z = v.z;\n\t\tconst e = m.elements;\n\n\t\tv.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z;\n\t\tv.y = e[ 4 ] * x + e[ 5 ] * y + e[ 6 ] * z;\n\t\tv.z = e[ 8 ] * x + e[ 9 ] * y + e[ 10 ] * z;\n\n\t\treturn v;\n\n\t}\n\n\tstatic transformTiedVectorInverse( v, m ) {\n\n\t\t// input:\n\t\t// vector interpreted as a tied (ordinary) vector\n\t\t// THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n\t\tconst x = v.x, y = v.y, z = v.z;\n\t\tconst e = m.elements;\n\n\t\tv.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z - e[ 12 ];\n\t\tv.y = e[ 4 ] * x + e[ 5 ] * y + e[ 6 ] * z - e[ 13 ];\n\t\tv.z = e[ 8 ] * x + e[ 9 ] * y + e[ 10 ] * z - e[ 14 ];\n\n\t\treturn v;\n\n\t}\n\n\tstatic transformPlaneToLocalSpace( plane, m, resultPlane ) {\n\n\t\tresultPlane.normal.copy( plane.normal );\n\t\tresultPlane.constant = plane.constant;\n\n\t\tconst referencePoint = ConvexObjectBreaker.transformTiedVectorInverse( plane.coplanarPoint( _v1 ), m );\n\n\t\tConvexObjectBreaker.transformFreeVectorInverse( resultPlane.normal, m );\n\n\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\n\t\tresultPlane.constant = - referencePoint.dot( resultPlane.normal );\n\n\t}\n\n}\n\nexport { ConvexObjectBreaker };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}