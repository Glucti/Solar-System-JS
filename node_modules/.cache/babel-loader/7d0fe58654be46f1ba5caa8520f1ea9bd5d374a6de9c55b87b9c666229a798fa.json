{"ast":null,"code":"import { Color, LinearSRGBColorSpace, MathUtils } from 'three';\n\n/**\n * Represents a lookup table for colormaps. It is used to determine the color\n * values from a range of data values.\n *\n * ```js\n * const lut = new Lut( 'rainbow', 512 );\n * const color = lut.getColor( 0.5 );\n * ```\n *\n * @three_import import { Lut } from 'three/addons/math/Lut.js';\n */\nclass Lut {\n  /**\n   * Constructs a new Lut.\n   *\n   * @param {('rainbow'|'cooltowarm'|'blackbody'|'grayscale')} [colormap='rainbow'] - Sets a colormap from predefined list of colormaps.\n   * @param {number} [count=32] - Sets the number of colors used to represent the data array.\n   */\n  constructor(colormap, count = 32) {\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {boolean}\n     * @readonly\n     * @default true\n     */\n    this.isLut = true;\n\n    /**\n     * The lookup table for the selected color map\n     *\n     * @type {Array<Color>}\n     */\n    this.lut = [];\n\n    /**\n     * The currently selected color map.\n     *\n     * @type {Array}\n     */\n    this.map = [];\n\n    /**\n     * The number of colors of the current selected color map.\n     *\n     * @type {number}\n     * @default 32\n     */\n    this.n = 0;\n\n    /**\n     * The minimum value to be represented with the lookup table.\n     *\n     * @type {number}\n     * @default 0\n     */\n    this.minV = 0;\n\n    /**\n     * The maximum value to be represented with the lookup table.\n     *\n     * @type {number}\n     * @default 1\n     */\n    this.maxV = 1;\n    this.setColorMap(colormap, count);\n  }\n\n  /**\n   * Sets the given LUT.\n   *\n   * @param {Lut} value - The LUT to set.\n   * @return {Lut} A reference to this LUT.\n   */\n  set(value) {\n    if (value.isLut === true) {\n      this.copy(value);\n    }\n    return this;\n  }\n\n  /**\n   * Sets the minimum value to be represented with this LUT.\n   *\n   * @param {number} min - The minimum value to be represented with the lookup table.\n   * @return {Lut} A reference to this LUT.\n   */\n  setMin(min) {\n    this.minV = min;\n    return this;\n  }\n\n  /**\n   * Sets the maximum value to be represented with this LUT.\n   *\n   * @param {number} max - The maximum value to be represented with the lookup table.\n   * @return {Lut} A reference to this LUT.\n   */\n  setMax(max) {\n    this.maxV = max;\n    return this;\n  }\n\n  /**\n   * Configure the lookup table for the given color map and number of colors.\n   *\n   * @param {string} colormap - The name of the color map.\n   * @param {number} [count=32] - The number of colors.\n   * @return {Lut} A reference to this LUT.\n   */\n  setColorMap(colormap, count = 32) {\n    this.map = ColorMapKeywords[colormap] || ColorMapKeywords.rainbow;\n    this.n = count;\n    const step = 1.0 / this.n;\n    const minColor = new Color();\n    const maxColor = new Color();\n    this.lut.length = 0;\n\n    // sample at 0\n\n    this.lut.push(new Color(this.map[0][1]));\n\n    // sample at 1/n, ..., (n-1)/n\n\n    for (let i = 1; i < count; i++) {\n      const alpha = i * step;\n      for (let j = 0; j < this.map.length - 1; j++) {\n        if (alpha > this.map[j][0] && alpha <= this.map[j + 1][0]) {\n          const min = this.map[j][0];\n          const max = this.map[j + 1][0];\n          minColor.setHex(this.map[j][1], LinearSRGBColorSpace);\n          maxColor.setHex(this.map[j + 1][1], LinearSRGBColorSpace);\n          const color = new Color().lerpColors(minColor, maxColor, (alpha - min) / (max - min));\n          this.lut.push(color);\n        }\n      }\n    }\n\n    // sample at 1\n\n    this.lut.push(new Color(this.map[this.map.length - 1][1]));\n    return this;\n  }\n\n  /**\n   * Copies the given lut.\n   *\n   * @param {Lut} lut - The LUT to copy.\n   * @return {Lut} A reference to this LUT.\n   */\n  copy(lut) {\n    this.lut = lut.lut;\n    this.map = lut.map;\n    this.n = lut.n;\n    this.minV = lut.minV;\n    this.maxV = lut.maxV;\n    return this;\n  }\n\n  /**\n   * Returns an instance of Color for the given data value.\n   *\n   * @param {number} alpha - The value to lookup.\n   * @return {Color} The color from the LUT.\n   */\n  getColor(alpha) {\n    alpha = MathUtils.clamp(alpha, this.minV, this.maxV);\n    alpha = (alpha - this.minV) / (this.maxV - this.minV);\n    const colorPosition = Math.round(alpha * this.n);\n    return this.lut[colorPosition];\n  }\n\n  /**\n   * Adds a color map to this Lut instance.\n   *\n   * @param {string} name - The name of the color map.\n   * @param {Array} arrayOfColors - An array of color values. Each value is an array\n   * holding a threshold and the actual color value as a hexadecimal number.\n   * @return {Lut} A reference to this LUT.\n   */\n  addColorMap(name, arrayOfColors) {\n    ColorMapKeywords[name] = arrayOfColors;\n    return this;\n  }\n\n  /**\n   * Creates a canvas in order to visualize the lookup table as a texture.\n   *\n   * @return {HTMLCanvasElement} The created canvas.\n   */\n  createCanvas() {\n    const canvas = document.createElement('canvas');\n    canvas.width = 1;\n    canvas.height = this.n;\n    this.updateCanvas(canvas);\n    return canvas;\n  }\n\n  /**\n   * Updates the given canvas with the Lut's data.\n   *\n   * @param {HTMLCanvasElement} canvas - The canvas to update.\n   * @return {HTMLCanvasElement} The updated canvas.\n   */\n  updateCanvas(canvas) {\n    const ctx = canvas.getContext('2d', {\n      alpha: false\n    });\n    const imageData = ctx.getImageData(0, 0, 1, this.n);\n    const data = imageData.data;\n    let k = 0;\n    const step = 1.0 / this.n;\n    const minColor = new Color();\n    const maxColor = new Color();\n    const finalColor = new Color();\n    for (let i = 1; i >= 0; i -= step) {\n      for (let j = this.map.length - 1; j >= 0; j--) {\n        if (i < this.map[j][0] && i >= this.map[j - 1][0]) {\n          const min = this.map[j - 1][0];\n          const max = this.map[j][0];\n          minColor.setHex(this.map[j - 1][1], LinearSRGBColorSpace);\n          maxColor.setHex(this.map[j][1], LinearSRGBColorSpace);\n          finalColor.lerpColors(minColor, maxColor, (i - min) / (max - min));\n          data[k * 4] = Math.round(finalColor.r * 255);\n          data[k * 4 + 1] = Math.round(finalColor.g * 255);\n          data[k * 4 + 2] = Math.round(finalColor.b * 255);\n          data[k * 4 + 3] = 255;\n          k += 1;\n        }\n      }\n    }\n    ctx.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n}\nconst ColorMapKeywords = {\n  'rainbow': [[0.0, 0x0000FF], [0.2, 0x00FFFF], [0.5, 0x00FF00], [0.8, 0xFFFF00], [1.0, 0xFF0000]],\n  'cooltowarm': [[0.0, 0x3C4EC2], [0.2, 0x9BBCFF], [0.5, 0xDCDCDC], [0.8, 0xF6A385], [1.0, 0xB40426]],\n  'blackbody': [[0.0, 0x000000], [0.2, 0x780000], [0.5, 0xE63200], [0.8, 0xFFFF00], [1.0, 0xFFFFFF]],\n  'grayscale': [[0.0, 0x000000], [0.2, 0x404040], [0.5, 0x7F7F80], [0.8, 0xBFBFBF], [1.0, 0xFFFFFF]]\n};\nexport { Lut, ColorMapKeywords };","map":{"version":3,"names":["Color","LinearSRGBColorSpace","MathUtils","Lut","constructor","colormap","count","isLut","lut","map","n","minV","maxV","setColorMap","set","value","copy","setMin","min","setMax","max","ColorMapKeywords","rainbow","step","minColor","maxColor","length","push","i","alpha","j","setHex","color","lerpColors","getColor","clamp","colorPosition","Math","round","addColorMap","name","arrayOfColors","createCanvas","canvas","document","createElement","width","height","updateCanvas","ctx","getContext","imageData","getImageData","data","k","finalColor","r","g","b","putImageData"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/math/Lut.js"],"sourcesContent":["import {\n\tColor,\n\tLinearSRGBColorSpace,\n\tMathUtils\n} from 'three';\n\n/**\n * Represents a lookup table for colormaps. It is used to determine the color\n * values from a range of data values.\n *\n * ```js\n * const lut = new Lut( 'rainbow', 512 );\n * const color = lut.getColor( 0.5 );\n * ```\n *\n * @three_import import { Lut } from 'three/addons/math/Lut.js';\n */\nclass Lut {\n\n\t/**\n\t * Constructs a new Lut.\n\t *\n\t * @param {('rainbow'|'cooltowarm'|'blackbody'|'grayscale')} [colormap='rainbow'] - Sets a colormap from predefined list of colormaps.\n\t * @param {number} [count=32] - Sets the number of colors used to represent the data array.\n\t */\n \tconstructor( colormap, count = 32 ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLut = true;\n\n\n\t\t/**\n\t\t * The lookup table for the selected color map\n\t\t *\n\t\t * @type {Array<Color>}\n\t\t */\n\t\tthis.lut = [];\n\n\t\t/**\n\t\t * The currently selected color map.\n\t\t *\n\t\t * @type {Array}\n\t\t */\n\t\tthis.map = [];\n\n\t\t/**\n\t\t * The number of colors of the current selected color map.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 32\n\t\t */\n\t\tthis.n = 0;\n\n\t\t/**\n\t\t * The minimum value to be represented with the lookup table.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.minV = 0;\n\n\t\t/**\n\t\t * The maximum value to be represented with the lookup table.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.maxV = 1;\n\n\t\tthis.setColorMap( colormap, count );\n\n\t}\n\n\t/**\n\t * Sets the given LUT.\n\t *\n\t * @param {Lut} value - The LUT to set.\n\t * @return {Lut} A reference to this LUT.\n\t */\n\tset( value ) {\n\n\t\tif ( value.isLut === true ) {\n\n\t\t\tthis.copy( value );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the minimum value to be represented with this LUT.\n\t *\n\t * @param {number} min - The minimum value to be represented with the lookup table.\n\t * @return {Lut} A reference to this LUT.\n\t */\n\tsetMin( min ) {\n\n\t\tthis.minV = min;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the maximum value to be represented with this LUT.\n\t *\n\t * @param {number} max - The maximum value to be represented with the lookup table.\n\t * @return {Lut} A reference to this LUT.\n\t */\n\tsetMax( max ) {\n\n\t\tthis.maxV = max;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Configure the lookup table for the given color map and number of colors.\n\t *\n\t * @param {string} colormap - The name of the color map.\n\t * @param {number} [count=32] - The number of colors.\n\t * @return {Lut} A reference to this LUT.\n\t */\n\tsetColorMap( colormap, count = 32 ) {\n\n\t\tthis.map = ColorMapKeywords[ colormap ] || ColorMapKeywords.rainbow;\n\t\tthis.n = count;\n\n\t\tconst step = 1.0 / this.n;\n\t\tconst minColor = new Color();\n\t\tconst maxColor = new Color();\n\n\t\tthis.lut.length = 0;\n\n\t\t// sample at 0\n\n\t\tthis.lut.push( new Color( this.map[ 0 ][ 1 ] ) );\n\n\t\t// sample at 1/n, ..., (n-1)/n\n\n\t\tfor ( let i = 1; i < count; i ++ ) {\n\n\t\t\tconst alpha = i * step;\n\n\t\t\tfor ( let j = 0; j < this.map.length - 1; j ++ ) {\n\n\t\t\t\tif ( alpha > this.map[ j ][ 0 ] && alpha <= this.map[ j + 1 ][ 0 ] ) {\n\n\t\t\t\t\tconst min = this.map[ j ][ 0 ];\n\t\t\t\t\tconst max = this.map[ j + 1 ][ 0 ];\n\n\t\t\t\t\tminColor.setHex( this.map[ j ][ 1 ], LinearSRGBColorSpace );\n\t\t\t\t\tmaxColor.setHex( this.map[ j + 1 ][ 1 ], LinearSRGBColorSpace );\n\n\t\t\t\t\tconst color = new Color().lerpColors( minColor, maxColor, ( alpha - min ) / ( max - min ) );\n\n\t\t\t\t\tthis.lut.push( color );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// sample at 1\n\n\t\tthis.lut.push( new Color( this.map[ this.map.length - 1 ][ 1 ] ) );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Copies the given lut.\n\t *\n\t * @param {Lut} lut - The LUT to copy.\n\t * @return {Lut} A reference to this LUT.\n\t */\n\tcopy( lut ) {\n\n\t\tthis.lut = lut.lut;\n\t\tthis.map = lut.map;\n\t\tthis.n = lut.n;\n\t\tthis.minV = lut.minV;\n\t\tthis.maxV = lut.maxV;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns an instance of Color for the given data value.\n\t *\n\t * @param {number} alpha - The value to lookup.\n\t * @return {Color} The color from the LUT.\n\t */\n\tgetColor( alpha ) {\n\n\t\talpha = MathUtils.clamp( alpha, this.minV, this.maxV );\n\n\t\talpha = ( alpha - this.minV ) / ( this.maxV - this.minV );\n\n\t\tconst colorPosition = Math.round( alpha * this.n );\n\n\t\treturn this.lut[ colorPosition ];\n\n\t}\n\n\t/**\n\t * Adds a color map to this Lut instance.\n\t *\n\t * @param {string} name - The name of the color map.\n\t * @param {Array} arrayOfColors - An array of color values. Each value is an array\n\t * holding a threshold and the actual color value as a hexadecimal number.\n\t * @return {Lut} A reference to this LUT.\n\t */\n\taddColorMap( name, arrayOfColors ) {\n\n\t\tColorMapKeywords[ name ] = arrayOfColors;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Creates a canvas in order to visualize the lookup table as a texture.\n\t *\n\t * @return {HTMLCanvasElement} The created canvas.\n\t */\n\tcreateCanvas() {\n\n\t\tconst canvas = document.createElement( 'canvas' );\n\t\tcanvas.width = 1;\n\t\tcanvas.height = this.n;\n\n\t\tthis.updateCanvas( canvas );\n\n\t\treturn canvas;\n\n\t}\n\n\t/**\n\t * Updates the given canvas with the Lut's data.\n\t *\n\t * @param {HTMLCanvasElement} canvas - The canvas to update.\n\t * @return {HTMLCanvasElement} The updated canvas.\n\t */\n\tupdateCanvas( canvas ) {\n\n\t\tconst ctx = canvas.getContext( '2d', { alpha: false } );\n\n\t\tconst imageData = ctx.getImageData( 0, 0, 1, this.n );\n\n\t\tconst data = imageData.data;\n\n\t\tlet k = 0;\n\n\t\tconst step = 1.0 / this.n;\n\n\t\tconst minColor = new Color();\n\t\tconst maxColor = new Color();\n\t\tconst finalColor = new Color();\n\n\t\tfor ( let i = 1; i >= 0; i -= step ) {\n\n\t\t\tfor ( let j = this.map.length - 1; j >= 0; j -- ) {\n\n\t\t\t\tif ( i < this.map[ j ][ 0 ] && i >= this.map[ j - 1 ][ 0 ] ) {\n\n\t\t\t\t\tconst min = this.map[ j - 1 ][ 0 ];\n\t\t\t\t\tconst max = this.map[ j ][ 0 ];\n\n\t\t\t\t\tminColor.setHex( this.map[ j - 1 ][ 1 ], LinearSRGBColorSpace );\n\t\t\t\t\tmaxColor.setHex( this.map[ j ][ 1 ], LinearSRGBColorSpace );\n\n\t\t\t\t\tfinalColor.lerpColors( minColor, maxColor, ( i - min ) / ( max - min ) );\n\n\t\t\t\t\tdata[ k * 4 ] = Math.round( finalColor.r * 255 );\n\t\t\t\t\tdata[ k * 4 + 1 ] = Math.round( finalColor.g * 255 );\n\t\t\t\t\tdata[ k * 4 + 2 ] = Math.round( finalColor.b * 255 );\n\t\t\t\t\tdata[ k * 4 + 3 ] = 255;\n\n\t\t\t\t\tk += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tctx.putImageData( imageData, 0, 0 );\n\n\t\treturn canvas;\n\n\t}\n\n}\n\nconst ColorMapKeywords = {\n\n\t'rainbow': [[ 0.0, 0x0000FF ], [ 0.2, 0x00FFFF ], [ 0.5, 0x00FF00 ], [ 0.8, 0xFFFF00 ], [ 1.0, 0xFF0000 ]],\n\t'cooltowarm': [[ 0.0, 0x3C4EC2 ], [ 0.2, 0x9BBCFF ], [ 0.5, 0xDCDCDC ], [ 0.8, 0xF6A385 ], [ 1.0, 0xB40426 ]],\n\t'blackbody': [[ 0.0, 0x000000 ], [ 0.2, 0x780000 ], [ 0.5, 0xE63200 ], [ 0.8, 0xFFFF00 ], [ 1.0, 0xFFFFFF ]],\n\t'grayscale': [[ 0.0, 0x000000 ], [ 0.2, 0x404040 ], [ 0.5, 0x7F7F80 ], [ 0.8, 0xBFBFBF ], [ 1.0, 0xFFFFFF ]]\n\n};\n\nexport { Lut, ColorMapKeywords };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}