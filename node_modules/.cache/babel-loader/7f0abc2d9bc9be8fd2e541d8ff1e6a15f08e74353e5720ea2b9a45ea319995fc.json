{"ast":null,"code":"import { FloatType, HalfFloatType, RGBAFormat, DataUtils } from 'three';\nimport * as fflate from '../libs/fflate.module.js';\nconst textEncoder = new TextEncoder();\nconst NO_COMPRESSION = 0;\nconst ZIPS_COMPRESSION = 2;\nconst ZIP_COMPRESSION = 3;\n\n/**\n * An exporter for EXR.\n *\n * EXR ( Extended Dynamic Range) is an [open format specification]{@link https://github.com/AcademySoftwareFoundation/openexr}\n * for professional-grade image storage format of the motion picture industry. The purpose of\n * format is to accurately and efficiently represent high-dynamic-range scene-linear image data\n * and associated metadata. The library is widely used in host application software where accuracy\n * is critical, such as photorealistic rendering, texture access, image compositing, deep compositing,\n * and DI.\n *\n * ```js\n * const exporter = new EXRExporter();\n * const result = await exporter.parse( renderer, options );\n * ```\n *\n * @three_import import { EXRExporter } from 'three/addons/exporters/EXRExporter.js';\n */\nclass EXRExporter {\n  /**\n   * This method has two variants.\n   *\n   * - When exporting a data texture, it receives two parameters. The texture and the exporter options.\n   * - When exporting a render target (e.g. a PMREM), it receives three parameters. The renderer, the\n   * render target and the exporter options.\n   *\n   * @async\n   * @param {(DataTexture|WebGPURenderer|WebGLRenderer)} arg1 - The data texture to export or a renderer.\n   * @param {(EXRExporter~Options|RenderTarget)} arg2 - The exporter options or a render target.\n   * @param {EXRExporter~Options} [arg3] - The exporter options.\n   * @return {Promise<Uint8Array>} A Promise that resolves with the exported EXR.\n   */\n  async parse(arg1, arg2, arg3) {\n    if (!arg1 || !(arg1.isWebGLRenderer || arg1.isWebGPURenderer || arg1.isDataTexture)) {\n      throw Error('EXRExporter.parse: Unsupported first parameter, expected instance of WebGLRenderer, WebGPURenderer or DataTexture.');\n    } else if (arg1.isWebGLRenderer || arg1.isWebGPURenderer) {\n      const renderer = arg1,\n        renderTarget = arg2,\n        options = arg3;\n      supportedRTT(renderTarget);\n      const info = buildInfoRTT(renderTarget, options),\n        dataBuffer = await getPixelData(renderer, renderTarget, info),\n        rawContentBuffer = reorganizeDataBuffer(dataBuffer, info),\n        chunks = compressData(rawContentBuffer, info);\n      return fillData(chunks, info);\n    } else if (arg1.isDataTexture) {\n      const texture = arg1,\n        options = arg2;\n      supportedDT(texture);\n      const info = buildInfoDT(texture, options),\n        dataBuffer = texture.image.data,\n        rawContentBuffer = reorganizeDataBuffer(dataBuffer, info),\n        chunks = compressData(rawContentBuffer, info);\n      return fillData(chunks, info);\n    }\n  }\n}\nfunction supportedRTT(renderTarget) {\n  if (!renderTarget || !renderTarget.isRenderTarget) {\n    throw Error('EXRExporter.parse: Unsupported second parameter, expected instance of WebGLRenderTarget.');\n  }\n  if (renderTarget.isWebGLCubeRenderTarget || renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {\n    throw Error('EXRExporter.parse: Unsupported render target type, expected instance of WebGLRenderTarget.');\n  }\n  if (renderTarget.texture.type !== FloatType && renderTarget.texture.type !== HalfFloatType) {\n    throw Error('EXRExporter.parse: Unsupported WebGLRenderTarget texture type.');\n  }\n  if (renderTarget.texture.format !== RGBAFormat) {\n    throw Error('EXRExporter.parse: Unsupported WebGLRenderTarget texture format, expected RGBAFormat.');\n  }\n}\nfunction supportedDT(texture) {\n  if (texture.type !== FloatType && texture.type !== HalfFloatType) {\n    throw Error('EXRExporter.parse: Unsupported DataTexture texture type.');\n  }\n  if (texture.format !== RGBAFormat) {\n    throw Error('EXRExporter.parse: Unsupported DataTexture texture format, expected RGBAFormat.');\n  }\n  if (!texture.image.data) {\n    throw Error('EXRExporter.parse: Invalid DataTexture image data.');\n  }\n  if (texture.type === FloatType && texture.image.data.constructor.name !== 'Float32Array') {\n    throw Error('EXRExporter.parse: DataTexture image data doesn\\'t match type, expected \\'Float32Array\\'.');\n  }\n  if (texture.type === HalfFloatType && texture.image.data.constructor.name !== 'Uint16Array') {\n    throw Error('EXRExporter.parse: DataTexture image data doesn\\'t match type, expected \\'Uint16Array\\'.');\n  }\n}\nfunction buildInfoRTT(renderTarget, options = {}) {\n  const compressionSizes = {\n    0: 1,\n    2: 1,\n    3: 16\n  };\n  const WIDTH = renderTarget.width,\n    HEIGHT = renderTarget.height,\n    TYPE = renderTarget.texture.type,\n    FORMAT = renderTarget.texture.format,\n    COMPRESSION = options.compression !== undefined ? options.compression : ZIP_COMPRESSION,\n    EXPORTER_TYPE = options.type !== undefined ? options.type : HalfFloatType,\n    OUT_TYPE = EXPORTER_TYPE === FloatType ? 2 : 1,\n    COMPRESSION_SIZE = compressionSizes[COMPRESSION],\n    NUM_CHANNELS = 4;\n  return {\n    width: WIDTH,\n    height: HEIGHT,\n    type: TYPE,\n    format: FORMAT,\n    compression: COMPRESSION,\n    blockLines: COMPRESSION_SIZE,\n    dataType: OUT_TYPE,\n    dataSize: 2 * OUT_TYPE,\n    numBlocks: Math.ceil(HEIGHT / COMPRESSION_SIZE),\n    numInputChannels: 4,\n    numOutputChannels: NUM_CHANNELS\n  };\n}\nfunction buildInfoDT(texture, options = {}) {\n  const compressionSizes = {\n    0: 1,\n    2: 1,\n    3: 16\n  };\n  const WIDTH = texture.image.width,\n    HEIGHT = texture.image.height,\n    TYPE = texture.type,\n    FORMAT = texture.format,\n    COMPRESSION = options.compression !== undefined ? options.compression : ZIP_COMPRESSION,\n    EXPORTER_TYPE = options.type !== undefined ? options.type : HalfFloatType,\n    OUT_TYPE = EXPORTER_TYPE === FloatType ? 2 : 1,\n    COMPRESSION_SIZE = compressionSizes[COMPRESSION],\n    NUM_CHANNELS = 4;\n  return {\n    width: WIDTH,\n    height: HEIGHT,\n    type: TYPE,\n    format: FORMAT,\n    compression: COMPRESSION,\n    blockLines: COMPRESSION_SIZE,\n    dataType: OUT_TYPE,\n    dataSize: 2 * OUT_TYPE,\n    numBlocks: Math.ceil(HEIGHT / COMPRESSION_SIZE),\n    numInputChannels: 4,\n    numOutputChannels: NUM_CHANNELS\n  };\n}\nasync function getPixelData(renderer, rtt, info) {\n  let dataBuffer;\n  if (renderer.isWebGLRenderer) {\n    if (info.type === FloatType) {\n      dataBuffer = new Float32Array(info.width * info.height * info.numInputChannels);\n    } else {\n      dataBuffer = new Uint16Array(info.width * info.height * info.numInputChannels);\n    }\n    await renderer.readRenderTargetPixelsAsync(rtt, 0, 0, info.width, info.height, dataBuffer);\n  } else {\n    dataBuffer = await renderer.readRenderTargetPixelsAsync(rtt, 0, 0, info.width, info.height);\n  }\n  return dataBuffer;\n}\nfunction reorganizeDataBuffer(inBuffer, info) {\n  const w = info.width,\n    h = info.height,\n    dec = {\n      r: 0,\n      g: 0,\n      b: 0,\n      a: 0\n    },\n    offset = {\n      value: 0\n    },\n    cOffset = info.numOutputChannels == 4 ? 1 : 0,\n    getValue = info.type == FloatType ? getFloat32 : getFloat16,\n    setValue = info.dataType == 1 ? setFloat16 : setFloat32,\n    outBuffer = new Uint8Array(info.width * info.height * info.numOutputChannels * info.dataSize),\n    dv = new DataView(outBuffer.buffer);\n  for (let y = 0; y < h; ++y) {\n    for (let x = 0; x < w; ++x) {\n      const i = y * w * 4 + x * 4;\n      const r = getValue(inBuffer, i);\n      const g = getValue(inBuffer, i + 1);\n      const b = getValue(inBuffer, i + 2);\n      const a = getValue(inBuffer, i + 3);\n      const line = (h - y - 1) * w * (3 + cOffset) * info.dataSize;\n      decodeLinear(dec, r, g, b, a);\n      offset.value = line + x * info.dataSize;\n      setValue(dv, dec.a, offset);\n      offset.value = line + cOffset * w * info.dataSize + x * info.dataSize;\n      setValue(dv, dec.b, offset);\n      offset.value = line + (1 + cOffset) * w * info.dataSize + x * info.dataSize;\n      setValue(dv, dec.g, offset);\n      offset.value = line + (2 + cOffset) * w * info.dataSize + x * info.dataSize;\n      setValue(dv, dec.r, offset);\n    }\n  }\n  return outBuffer;\n}\nfunction compressData(inBuffer, info) {\n  let compress,\n    tmpBuffer,\n    sum = 0;\n  const chunks = {\n      data: new Array(),\n      totalSize: 0\n    },\n    size = info.width * info.numOutputChannels * info.blockLines * info.dataSize;\n  switch (info.compression) {\n    case 0:\n      compress = compressNONE;\n      break;\n    case 2:\n    case 3:\n      compress = compressZIP;\n      break;\n  }\n  if (info.compression !== 0) {\n    tmpBuffer = new Uint8Array(size);\n  }\n  for (let i = 0; i < info.numBlocks; ++i) {\n    const arr = inBuffer.subarray(size * i, size * (i + 1));\n    const block = compress(arr, tmpBuffer);\n    sum += block.length;\n    chunks.data.push({\n      dataChunk: block,\n      size: block.length\n    });\n  }\n  chunks.totalSize = sum;\n  return chunks;\n}\nfunction compressNONE(data) {\n  return data;\n}\nfunction compressZIP(data, tmpBuffer) {\n  //\n  // Reorder the pixel data.\n  //\n\n  let t1 = 0,\n    t2 = Math.floor((data.length + 1) / 2),\n    s = 0;\n  const stop = data.length - 1;\n  while (true) {\n    if (s > stop) break;\n    tmpBuffer[t1++] = data[s++];\n    if (s > stop) break;\n    tmpBuffer[t2++] = data[s++];\n  }\n\n  //\n  // Predictor.\n  //\n\n  let p = tmpBuffer[0];\n  for (let t = 1; t < tmpBuffer.length; t++) {\n    const d = tmpBuffer[t] - p + (128 + 256);\n    p = tmpBuffer[t];\n    tmpBuffer[t] = d;\n  }\n  const deflate = fflate.zlibSync(tmpBuffer);\n  return deflate;\n}\nfunction fillHeader(outBuffer, chunks, info) {\n  const offset = {\n    value: 0\n  };\n  const dv = new DataView(outBuffer.buffer);\n  setUint32(dv, 20000630, offset); // magic\n  setUint32(dv, 2, offset); // mask\n\n  // = HEADER =\n\n  setString(dv, 'compression', offset);\n  setString(dv, 'compression', offset);\n  setUint32(dv, 1, offset);\n  setUint8(dv, info.compression, offset);\n  setString(dv, 'screenWindowCenter', offset);\n  setString(dv, 'v2f', offset);\n  setUint32(dv, 8, offset);\n  setUint32(dv, 0, offset);\n  setUint32(dv, 0, offset);\n  setString(dv, 'screenWindowWidth', offset);\n  setString(dv, 'float', offset);\n  setUint32(dv, 4, offset);\n  setFloat32(dv, 1.0, offset);\n  setString(dv, 'pixelAspectRatio', offset);\n  setString(dv, 'float', offset);\n  setUint32(dv, 4, offset);\n  setFloat32(dv, 1.0, offset);\n  setString(dv, 'lineOrder', offset);\n  setString(dv, 'lineOrder', offset);\n  setUint32(dv, 1, offset);\n  setUint8(dv, 0, offset);\n  setString(dv, 'dataWindow', offset);\n  setString(dv, 'box2i', offset);\n  setUint32(dv, 16, offset);\n  setUint32(dv, 0, offset);\n  setUint32(dv, 0, offset);\n  setUint32(dv, info.width - 1, offset);\n  setUint32(dv, info.height - 1, offset);\n  setString(dv, 'displayWindow', offset);\n  setString(dv, 'box2i', offset);\n  setUint32(dv, 16, offset);\n  setUint32(dv, 0, offset);\n  setUint32(dv, 0, offset);\n  setUint32(dv, info.width - 1, offset);\n  setUint32(dv, info.height - 1, offset);\n  setString(dv, 'channels', offset);\n  setString(dv, 'chlist', offset);\n  setUint32(dv, info.numOutputChannels * 18 + 1, offset);\n  setString(dv, 'A', offset);\n  setUint32(dv, info.dataType, offset);\n  offset.value += 4;\n  setUint32(dv, 1, offset);\n  setUint32(dv, 1, offset);\n  setString(dv, 'B', offset);\n  setUint32(dv, info.dataType, offset);\n  offset.value += 4;\n  setUint32(dv, 1, offset);\n  setUint32(dv, 1, offset);\n  setString(dv, 'G', offset);\n  setUint32(dv, info.dataType, offset);\n  offset.value += 4;\n  setUint32(dv, 1, offset);\n  setUint32(dv, 1, offset);\n  setString(dv, 'R', offset);\n  setUint32(dv, info.dataType, offset);\n  offset.value += 4;\n  setUint32(dv, 1, offset);\n  setUint32(dv, 1, offset);\n  setUint8(dv, 0, offset);\n\n  // null-byte\n  setUint8(dv, 0, offset);\n\n  // = OFFSET TABLE =\n\n  let sum = offset.value + info.numBlocks * 8;\n  for (let i = 0; i < chunks.data.length; ++i) {\n    setUint64(dv, sum, offset);\n    sum += chunks.data[i].size + 8;\n  }\n}\nfunction fillData(chunks, info) {\n  const TableSize = info.numBlocks * 8,\n    HeaderSize = 259 + 18 * info.numOutputChannels,\n    // 259 + 18 * chlist\n    offset = {\n      value: HeaderSize + TableSize\n    },\n    outBuffer = new Uint8Array(HeaderSize + TableSize + chunks.totalSize + info.numBlocks * 8),\n    dv = new DataView(outBuffer.buffer);\n  fillHeader(outBuffer, chunks, info);\n  for (let i = 0; i < chunks.data.length; ++i) {\n    const data = chunks.data[i].dataChunk;\n    const size = chunks.data[i].size;\n    setUint32(dv, i * info.blockLines, offset);\n    setUint32(dv, size, offset);\n    outBuffer.set(data, offset.value);\n    offset.value += size;\n  }\n  return outBuffer;\n}\nfunction decodeLinear(dec, r, g, b, a) {\n  dec.r = r;\n  dec.g = g;\n  dec.b = b;\n  dec.a = a;\n}\n\n// function decodeSRGB( dec, r, g, b, a ) {\n\n// \tdec.r = r > 0.04045 ? Math.pow( r * 0.9478672986 + 0.0521327014, 2.4 ) : r * 0.0773993808;\n// \tdec.g = g > 0.04045 ? Math.pow( g * 0.9478672986 + 0.0521327014, 2.4 ) : g * 0.0773993808;\n// \tdec.b = b > 0.04045 ? Math.pow( b * 0.9478672986 + 0.0521327014, 2.4 ) : b * 0.0773993808;\n// \tdec.a = a;\n\n// }\n\nfunction setUint8(dv, value, offset) {\n  dv.setUint8(offset.value, value);\n  offset.value += 1;\n}\nfunction setUint32(dv, value, offset) {\n  dv.setUint32(offset.value, value, true);\n  offset.value += 4;\n}\nfunction setFloat16(dv, value, offset) {\n  dv.setUint16(offset.value, DataUtils.toHalfFloat(value), true);\n  offset.value += 2;\n}\nfunction setFloat32(dv, value, offset) {\n  dv.setFloat32(offset.value, value, true);\n  offset.value += 4;\n}\nfunction setUint64(dv, value, offset) {\n  dv.setBigUint64(offset.value, BigInt(value), true);\n  offset.value += 8;\n}\nfunction setString(dv, string, offset) {\n  const tmp = textEncoder.encode(string + '\\0');\n  for (let i = 0; i < tmp.length; ++i) {\n    setUint8(dv, tmp[i], offset);\n  }\n}\nfunction decodeFloat16(binary) {\n  const exponent = (binary & 0x7C00) >> 10,\n    fraction = binary & 0x03FF;\n  return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 0x1F ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 0x400) : 6.103515625e-5 * (fraction / 0x400));\n}\nfunction getFloat16(arr, i) {\n  return decodeFloat16(arr[i]);\n}\nfunction getFloat32(arr, i) {\n  return arr[i];\n}\n\n/**\n * Export options of `EXRExporter`.\n *\n * @typedef {Object} EXRExporter~Options\n * @property {(HalfFloatType|FloatType)} [type=HalfFloatType] - Output data type.\n * @property {(NO_COMPRESSION|ZIP_COMPRESSION|ZIPS_COMPRESSION)} [type=ZIP_COMPRESSION] - The compression algorithm.\n **/\n\nexport { EXRExporter, NO_COMPRESSION, ZIP_COMPRESSION, ZIPS_COMPRESSION };","map":{"version":3,"names":["FloatType","HalfFloatType","RGBAFormat","DataUtils","fflate","textEncoder","TextEncoder","NO_COMPRESSION","ZIPS_COMPRESSION","ZIP_COMPRESSION","EXRExporter","parse","arg1","arg2","arg3","isWebGLRenderer","isWebGPURenderer","isDataTexture","Error","renderer","renderTarget","options","supportedRTT","info","buildInfoRTT","dataBuffer","getPixelData","rawContentBuffer","reorganizeDataBuffer","chunks","compressData","fillData","texture","supportedDT","buildInfoDT","image","data","isRenderTarget","isWebGLCubeRenderTarget","isWebGL3DRenderTarget","isWebGLArrayRenderTarget","type","format","constructor","name","compressionSizes","WIDTH","width","HEIGHT","height","TYPE","FORMAT","COMPRESSION","compression","undefined","EXPORTER_TYPE","OUT_TYPE","COMPRESSION_SIZE","NUM_CHANNELS","blockLines","dataType","dataSize","numBlocks","Math","ceil","numInputChannels","numOutputChannels","rtt","Float32Array","Uint16Array","readRenderTargetPixelsAsync","inBuffer","w","h","dec","r","g","b","a","offset","value","cOffset","getValue","getFloat32","getFloat16","setValue","setFloat16","setFloat32","outBuffer","Uint8Array","dv","DataView","buffer","y","x","i","line","decodeLinear","compress","tmpBuffer","sum","Array","totalSize","size","compressNONE","compressZIP","arr","subarray","block","length","push","dataChunk","t1","t2","floor","s","stop","p","t","d","deflate","zlibSync","fillHeader","setUint32","setString","setUint8","setUint64","TableSize","HeaderSize","set","setUint16","toHalfFloat","setBigUint64","BigInt","string","tmp","encode","decodeFloat16","binary","exponent","fraction","NaN","Infinity","pow"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/exporters/EXRExporter.js"],"sourcesContent":["import {\n\tFloatType,\n\tHalfFloatType,\n\tRGBAFormat,\n\tDataUtils,\n} from 'three';\nimport * as fflate from '../libs/fflate.module.js';\n\nconst textEncoder = new TextEncoder();\n\nconst NO_COMPRESSION = 0;\nconst ZIPS_COMPRESSION = 2;\nconst ZIP_COMPRESSION = 3;\n\n/**\n * An exporter for EXR.\n *\n * EXR ( Extended Dynamic Range) is an [open format specification]{@link https://github.com/AcademySoftwareFoundation/openexr}\n * for professional-grade image storage format of the motion picture industry. The purpose of\n * format is to accurately and efficiently represent high-dynamic-range scene-linear image data\n * and associated metadata. The library is widely used in host application software where accuracy\n * is critical, such as photorealistic rendering, texture access, image compositing, deep compositing,\n * and DI.\n *\n * ```js\n * const exporter = new EXRExporter();\n * const result = await exporter.parse( renderer, options );\n * ```\n *\n * @three_import import { EXRExporter } from 'three/addons/exporters/EXRExporter.js';\n */\nclass EXRExporter {\n\n\t/**\n\t * This method has two variants.\n\t *\n\t * - When exporting a data texture, it receives two parameters. The texture and the exporter options.\n\t * - When exporting a render target (e.g. a PMREM), it receives three parameters. The renderer, the\n\t * render target and the exporter options.\n\t *\n\t * @async\n\t * @param {(DataTexture|WebGPURenderer|WebGLRenderer)} arg1 - The data texture to export or a renderer.\n\t * @param {(EXRExporter~Options|RenderTarget)} arg2 - The exporter options or a render target.\n\t * @param {EXRExporter~Options} [arg3] - The exporter options.\n\t * @return {Promise<Uint8Array>} A Promise that resolves with the exported EXR.\n\t */\n\tasync parse( arg1, arg2, arg3 ) {\n\n\t\tif ( ! arg1 || ! ( arg1.isWebGLRenderer || arg1.isWebGPURenderer || arg1.isDataTexture ) ) {\n\n\t\t\tthrow Error( 'EXRExporter.parse: Unsupported first parameter, expected instance of WebGLRenderer, WebGPURenderer or DataTexture.' );\n\n\t\t} else if ( arg1.isWebGLRenderer || arg1.isWebGPURenderer ) {\n\n\t\t\tconst renderer = arg1, renderTarget = arg2, options = arg3;\n\n\t\t\tsupportedRTT( renderTarget );\n\n\t\t\tconst info = buildInfoRTT( renderTarget, options ),\n\t\t\t\tdataBuffer = await getPixelData( renderer, renderTarget, info ),\n\t\t\t\trawContentBuffer = reorganizeDataBuffer( dataBuffer, info ),\n\t\t\t\tchunks = compressData( rawContentBuffer, info );\n\n\t\t\treturn fillData( chunks, info );\n\n\t\t} else if ( arg1.isDataTexture ) {\n\n\t\t\tconst texture = arg1, options = arg2;\n\n\t\t\tsupportedDT( texture );\n\n\t\t\tconst info = buildInfoDT( texture, options ),\n\t\t\t\tdataBuffer = texture.image.data,\n\t\t\t\trawContentBuffer = reorganizeDataBuffer( dataBuffer, info ),\n\t\t\t\tchunks = compressData( rawContentBuffer, info );\n\n\t\t\treturn fillData( chunks, info );\n\n\t\t}\n\n\t}\n\n}\n\nfunction supportedRTT( renderTarget ) {\n\n\tif ( ! renderTarget || ! renderTarget.isRenderTarget ) {\n\n\t\tthrow Error( 'EXRExporter.parse: Unsupported second parameter, expected instance of WebGLRenderTarget.' );\n\n\t}\n\n\tif ( renderTarget.isWebGLCubeRenderTarget || renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget ) {\n\n\t\tthrow Error( 'EXRExporter.parse: Unsupported render target type, expected instance of WebGLRenderTarget.' );\n\n\t}\n\n\tif ( renderTarget.texture.type !== FloatType && renderTarget.texture.type !== HalfFloatType ) {\n\n\t\tthrow Error( 'EXRExporter.parse: Unsupported WebGLRenderTarget texture type.' );\n\n\t}\n\n\tif ( renderTarget.texture.format !== RGBAFormat ) {\n\n\t\tthrow Error( 'EXRExporter.parse: Unsupported WebGLRenderTarget texture format, expected RGBAFormat.' );\n\n\t}\n\n}\n\nfunction supportedDT( texture ) {\n\n\tif ( texture.type !== FloatType && texture.type !== HalfFloatType ) {\n\n\t\tthrow Error( 'EXRExporter.parse: Unsupported DataTexture texture type.' );\n\n\t}\n\n\tif ( texture.format !== RGBAFormat ) {\n\n\t\tthrow Error( 'EXRExporter.parse: Unsupported DataTexture texture format, expected RGBAFormat.' );\n\n\t}\n\n\tif ( ! texture.image.data ) {\n\n\t\tthrow Error( 'EXRExporter.parse: Invalid DataTexture image data.' );\n\n\t}\n\n\tif ( texture.type === FloatType && texture.image.data.constructor.name !== 'Float32Array' ) {\n\n\t\tthrow Error( 'EXRExporter.parse: DataTexture image data doesn\\'t match type, expected \\'Float32Array\\'.' );\n\n\t}\n\n\tif ( texture.type === HalfFloatType && texture.image.data.constructor.name !== 'Uint16Array' ) {\n\n\t\tthrow Error( 'EXRExporter.parse: DataTexture image data doesn\\'t match type, expected \\'Uint16Array\\'.' );\n\n\t}\n\n}\n\nfunction buildInfoRTT( renderTarget, options = {} ) {\n\n\tconst compressionSizes = {\n\t\t0: 1,\n\t\t2: 1,\n\t\t3: 16\n\t};\n\n\tconst WIDTH = renderTarget.width,\n\t\tHEIGHT = renderTarget.height,\n\t\tTYPE = renderTarget.texture.type,\n\t\tFORMAT = renderTarget.texture.format,\n\t\tCOMPRESSION = ( options.compression !== undefined ) ? options.compression : ZIP_COMPRESSION,\n\t\tEXPORTER_TYPE = ( options.type !== undefined ) ? options.type : HalfFloatType,\n\t\tOUT_TYPE = ( EXPORTER_TYPE === FloatType ) ? 2 : 1,\n\t\tCOMPRESSION_SIZE = compressionSizes[ COMPRESSION ],\n\t\tNUM_CHANNELS = 4;\n\n\treturn {\n\t\twidth: WIDTH,\n\t\theight: HEIGHT,\n\t\ttype: TYPE,\n\t\tformat: FORMAT,\n\t\tcompression: COMPRESSION,\n\t\tblockLines: COMPRESSION_SIZE,\n\t\tdataType: OUT_TYPE,\n\t\tdataSize: 2 * OUT_TYPE,\n\t\tnumBlocks: Math.ceil( HEIGHT / COMPRESSION_SIZE ),\n\t\tnumInputChannels: 4,\n\t\tnumOutputChannels: NUM_CHANNELS,\n\t};\n\n}\n\nfunction buildInfoDT( texture, options = {} ) {\n\n\tconst compressionSizes = {\n\t\t0: 1,\n\t\t2: 1,\n\t\t3: 16\n\t};\n\n\tconst WIDTH = texture.image.width,\n\t\tHEIGHT = texture.image.height,\n\t\tTYPE = texture.type,\n\t\tFORMAT = texture.format,\n\t\tCOMPRESSION = ( options.compression !== undefined ) ? options.compression : ZIP_COMPRESSION,\n\t\tEXPORTER_TYPE = ( options.type !== undefined ) ? options.type : HalfFloatType,\n\t\tOUT_TYPE = ( EXPORTER_TYPE === FloatType ) ? 2 : 1,\n\t\tCOMPRESSION_SIZE = compressionSizes[ COMPRESSION ],\n\t\tNUM_CHANNELS = 4;\n\n\treturn {\n\t\twidth: WIDTH,\n\t\theight: HEIGHT,\n\t\ttype: TYPE,\n\t\tformat: FORMAT,\n\t\tcompression: COMPRESSION,\n\t\tblockLines: COMPRESSION_SIZE,\n\t\tdataType: OUT_TYPE,\n\t\tdataSize: 2 * OUT_TYPE,\n\t\tnumBlocks: Math.ceil( HEIGHT / COMPRESSION_SIZE ),\n\t\tnumInputChannels: 4,\n\t\tnumOutputChannels: NUM_CHANNELS,\n\t};\n\n}\n\nasync function getPixelData( renderer, rtt, info ) {\n\n\tlet dataBuffer;\n\n\tif ( renderer.isWebGLRenderer ) {\n\n\t\tif ( info.type === FloatType ) {\n\n\t\t\tdataBuffer = new Float32Array( info.width * info.height * info.numInputChannels );\n\n\t\t} else {\n\n\t\t\tdataBuffer = new Uint16Array( info.width * info.height * info.numInputChannels );\n\n\t\t}\n\n\t\tawait renderer.readRenderTargetPixelsAsync( rtt, 0, 0, info.width, info.height, dataBuffer );\n\n\t} else {\n\n\t\tdataBuffer = await renderer.readRenderTargetPixelsAsync( rtt, 0, 0, info.width, info.height );\n\n\t}\n\n\treturn dataBuffer;\n\n}\n\nfunction reorganizeDataBuffer( inBuffer, info ) {\n\n\tconst w = info.width,\n\t\th = info.height,\n\t\tdec = { r: 0, g: 0, b: 0, a: 0 },\n\t\toffset = { value: 0 },\n\t\tcOffset = ( info.numOutputChannels == 4 ) ? 1 : 0,\n\t\tgetValue = ( info.type == FloatType ) ? getFloat32 : getFloat16,\n\t\tsetValue = ( info.dataType == 1 ) ? setFloat16 : setFloat32,\n\t\toutBuffer = new Uint8Array( info.width * info.height * info.numOutputChannels * info.dataSize ),\n\t\tdv = new DataView( outBuffer.buffer );\n\n\tfor ( let y = 0; y < h; ++ y ) {\n\n\t\tfor ( let x = 0; x < w; ++ x ) {\n\n\t\t\tconst i = y * w * 4 + x * 4;\n\n\t\t\tconst r = getValue( inBuffer, i );\n\t\t\tconst g = getValue( inBuffer, i + 1 );\n\t\t\tconst b = getValue( inBuffer, i + 2 );\n\t\t\tconst a = getValue( inBuffer, i + 3 );\n\n\t\t\tconst line = ( h - y - 1 ) * w * ( 3 + cOffset ) * info.dataSize;\n\n\t\t\tdecodeLinear( dec, r, g, b, a );\n\n\t\t\toffset.value = line + x * info.dataSize;\n\t\t\tsetValue( dv, dec.a, offset );\n\n\t\t\toffset.value = line + ( cOffset ) * w * info.dataSize + x * info.dataSize;\n\t\t\tsetValue( dv, dec.b, offset );\n\n\t\t\toffset.value = line + ( 1 + cOffset ) * w * info.dataSize + x * info.dataSize;\n\t\t\tsetValue( dv, dec.g, offset );\n\n\t\t\toffset.value = line + ( 2 + cOffset ) * w * info.dataSize + x * info.dataSize;\n\t\t\tsetValue( dv, dec.r, offset );\n\n\t\t}\n\n\t}\n\n\treturn outBuffer;\n\n}\n\nfunction compressData( inBuffer, info ) {\n\n\tlet compress,\n\t\ttmpBuffer,\n\t\tsum = 0;\n\n\tconst chunks = { data: new Array(), totalSize: 0 },\n\t\tsize = info.width * info.numOutputChannels * info.blockLines * info.dataSize;\n\n\tswitch ( info.compression ) {\n\n\t\tcase 0:\n\t\t\tcompress = compressNONE;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\tcase 3:\n\t\t\tcompress = compressZIP;\n\t\t\tbreak;\n\n\t}\n\n\tif ( info.compression !== 0 ) {\n\n\t\ttmpBuffer = new Uint8Array( size );\n\n\t}\n\n\tfor ( let i = 0; i < info.numBlocks; ++ i ) {\n\n\t\tconst arr = inBuffer.subarray( size * i, size * ( i + 1 ) );\n\n\t\tconst block = compress( arr, tmpBuffer );\n\n\t\tsum += block.length;\n\n\t\tchunks.data.push( { dataChunk: block, size: block.length } );\n\n\t}\n\n\tchunks.totalSize = sum;\n\n\treturn chunks;\n\n}\n\nfunction compressNONE( data ) {\n\n\treturn data;\n\n}\n\nfunction compressZIP( data, tmpBuffer ) {\n\n\t//\n\t// Reorder the pixel data.\n\t//\n\n\tlet t1 = 0,\n\t\tt2 = Math.floor( ( data.length + 1 ) / 2 ),\n\t\ts = 0;\n\n\tconst stop = data.length - 1;\n\n\twhile ( true ) {\n\n\t\tif ( s > stop ) break;\n\t\ttmpBuffer[ t1 ++ ] = data[ s ++ ];\n\n\t\tif ( s > stop ) break;\n\t\ttmpBuffer[ t2 ++ ] = data[ s ++ ];\n\n\t}\n\n\t//\n\t// Predictor.\n\t//\n\n\tlet p = tmpBuffer[ 0 ];\n\n\tfor ( let t = 1; t < tmpBuffer.length; t ++ ) {\n\n\t\tconst d = tmpBuffer[ t ] - p + ( 128 + 256 );\n\t\tp = tmpBuffer[ t ];\n\t\ttmpBuffer[ t ] = d;\n\n\t}\n\n\tconst deflate = fflate.zlibSync( tmpBuffer );\n\n\treturn deflate;\n\n}\n\nfunction fillHeader( outBuffer, chunks, info ) {\n\n\tconst offset = { value: 0 };\n\tconst dv = new DataView( outBuffer.buffer );\n\n\tsetUint32( dv, 20000630, offset ); // magic\n\tsetUint32( dv, 2, offset ); // mask\n\n\t// = HEADER =\n\n\tsetString( dv, 'compression', offset );\n\tsetString( dv, 'compression', offset );\n\tsetUint32( dv, 1, offset );\n\tsetUint8( dv, info.compression, offset );\n\n\tsetString( dv, 'screenWindowCenter', offset );\n\tsetString( dv, 'v2f', offset );\n\tsetUint32( dv, 8, offset );\n\tsetUint32( dv, 0, offset );\n\tsetUint32( dv, 0, offset );\n\n\tsetString( dv, 'screenWindowWidth', offset );\n\tsetString( dv, 'float', offset );\n\tsetUint32( dv, 4, offset );\n\tsetFloat32( dv, 1.0, offset );\n\n\tsetString( dv, 'pixelAspectRatio', offset );\n\tsetString( dv, 'float', offset );\n\tsetUint32( dv, 4, offset );\n\tsetFloat32( dv, 1.0, offset );\n\n\tsetString( dv, 'lineOrder', offset );\n\tsetString( dv, 'lineOrder', offset );\n\tsetUint32( dv, 1, offset );\n\tsetUint8( dv, 0, offset );\n\n\tsetString( dv, 'dataWindow', offset );\n\tsetString( dv, 'box2i', offset );\n\tsetUint32( dv, 16, offset );\n\tsetUint32( dv, 0, offset );\n\tsetUint32( dv, 0, offset );\n\tsetUint32( dv, info.width - 1, offset );\n\tsetUint32( dv, info.height - 1, offset );\n\n\tsetString( dv, 'displayWindow', offset );\n\tsetString( dv, 'box2i', offset );\n\tsetUint32( dv, 16, offset );\n\tsetUint32( dv, 0, offset );\n\tsetUint32( dv, 0, offset );\n\tsetUint32( dv, info.width - 1, offset );\n\tsetUint32( dv, info.height - 1, offset );\n\n\tsetString( dv, 'channels', offset );\n\tsetString( dv, 'chlist', offset );\n\tsetUint32( dv, info.numOutputChannels * 18 + 1, offset );\n\n\tsetString( dv, 'A', offset );\n\tsetUint32( dv, info.dataType, offset );\n\toffset.value += 4;\n\tsetUint32( dv, 1, offset );\n\tsetUint32( dv, 1, offset );\n\n\tsetString( dv, 'B', offset );\n\tsetUint32( dv, info.dataType, offset );\n\toffset.value += 4;\n\tsetUint32( dv, 1, offset );\n\tsetUint32( dv, 1, offset );\n\n\tsetString( dv, 'G', offset );\n\tsetUint32( dv, info.dataType, offset );\n\toffset.value += 4;\n\tsetUint32( dv, 1, offset );\n\tsetUint32( dv, 1, offset );\n\n\tsetString( dv, 'R', offset );\n\tsetUint32( dv, info.dataType, offset );\n\toffset.value += 4;\n\tsetUint32( dv, 1, offset );\n\tsetUint32( dv, 1, offset );\n\n\tsetUint8( dv, 0, offset );\n\n\t// null-byte\n\tsetUint8( dv, 0, offset );\n\n\t// = OFFSET TABLE =\n\n\tlet sum = offset.value + info.numBlocks * 8;\n\n\tfor ( let i = 0; i < chunks.data.length; ++ i ) {\n\n\t\tsetUint64( dv, sum, offset );\n\n\t\tsum += chunks.data[ i ].size + 8;\n\n\t}\n\n}\n\nfunction fillData( chunks, info ) {\n\n\tconst TableSize = info.numBlocks * 8,\n\t\tHeaderSize = 259 + ( 18 * info.numOutputChannels ), // 259 + 18 * chlist\n\t\toffset = { value: HeaderSize + TableSize },\n\t\toutBuffer = new Uint8Array( HeaderSize + TableSize + chunks.totalSize + info.numBlocks * 8 ),\n\t\tdv = new DataView( outBuffer.buffer );\n\n\tfillHeader( outBuffer, chunks, info );\n\n\tfor ( let i = 0; i < chunks.data.length; ++ i ) {\n\n\t\tconst data = chunks.data[ i ].dataChunk;\n\t\tconst size = chunks.data[ i ].size;\n\n\t\tsetUint32( dv, i * info.blockLines, offset );\n\t\tsetUint32( dv, size, offset );\n\n\t\toutBuffer.set( data, offset.value );\n\t\toffset.value += size;\n\n\t}\n\n\treturn outBuffer;\n\n}\n\nfunction decodeLinear( dec, r, g, b, a ) {\n\n\tdec.r = r;\n\tdec.g = g;\n\tdec.b = b;\n\tdec.a = a;\n\n}\n\n// function decodeSRGB( dec, r, g, b, a ) {\n\n// \tdec.r = r > 0.04045 ? Math.pow( r * 0.9478672986 + 0.0521327014, 2.4 ) : r * 0.0773993808;\n// \tdec.g = g > 0.04045 ? Math.pow( g * 0.9478672986 + 0.0521327014, 2.4 ) : g * 0.0773993808;\n// \tdec.b = b > 0.04045 ? Math.pow( b * 0.9478672986 + 0.0521327014, 2.4 ) : b * 0.0773993808;\n// \tdec.a = a;\n\n// }\n\n\nfunction setUint8( dv, value, offset ) {\n\n\tdv.setUint8( offset.value, value );\n\n\toffset.value += 1;\n\n}\n\nfunction setUint32( dv, value, offset ) {\n\n\tdv.setUint32( offset.value, value, true );\n\n\toffset.value += 4;\n\n}\n\nfunction setFloat16( dv, value, offset ) {\n\n\tdv.setUint16( offset.value, DataUtils.toHalfFloat( value ), true );\n\n\toffset.value += 2;\n\n}\n\nfunction setFloat32( dv, value, offset ) {\n\n\tdv.setFloat32( offset.value, value, true );\n\n\toffset.value += 4;\n\n}\n\nfunction setUint64( dv, value, offset ) {\n\n\tdv.setBigUint64( offset.value, BigInt( value ), true );\n\n\toffset.value += 8;\n\n}\n\nfunction setString( dv, string, offset ) {\n\n\tconst tmp = textEncoder.encode( string + '\\0' );\n\n\tfor ( let i = 0; i < tmp.length; ++ i ) {\n\n\t\tsetUint8( dv, tmp[ i ], offset );\n\n\t}\n\n}\n\nfunction decodeFloat16( binary ) {\n\n\tconst exponent = ( binary & 0x7C00 ) >> 10,\n\t\tfraction = binary & 0x03FF;\n\n\treturn ( binary >> 15 ? - 1 : 1 ) * (\n\t\texponent ?\n\t\t\t(\n\t\t\t\texponent === 0x1F ?\n\t\t\t\t\tfraction ? NaN : Infinity :\n\t\t\t\t\tMath.pow( 2, exponent - 15 ) * ( 1 + fraction / 0x400 )\n\t\t\t) :\n\t\t\t6.103515625e-5 * ( fraction / 0x400 )\n\t);\n\n}\n\nfunction getFloat16( arr, i ) {\n\n\treturn decodeFloat16( arr[ i ] );\n\n}\n\nfunction getFloat32( arr, i ) {\n\n\treturn arr[ i ];\n\n}\n\n/**\n * Export options of `EXRExporter`.\n *\n * @typedef {Object} EXRExporter~Options\n * @property {(HalfFloatType|FloatType)} [type=HalfFloatType] - Output data type.\n * @property {(NO_COMPRESSION|ZIP_COMPRESSION|ZIPS_COMPRESSION)} [type=ZIP_COMPRESSION] - The compression algorithm.\n **/\n\nexport { EXRExporter, NO_COMPRESSION, ZIP_COMPRESSION, ZIPS_COMPRESSION };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}