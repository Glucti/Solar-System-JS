{"ast":null,"code":"import { Mesh, ShaderMaterial, SphereGeometry } from 'three';\n\n/**\n * Renders a sphere to visualize a light probe in the scene.\n *\n * This helper can only be used with {@link WebGLRenderer}.\n * When using {@link WebGPURenderer}, import from `LightProbeHelperGPU.js`.\n *\n * ```js\n * const helper = new LightProbeHelper( lightProbe );\n * scene.add( helper );\n * ```\n *\n * @augments Mesh\n * @three_import import { LightProbeHelper } from 'three/addons/helpers/LightProbeHelper.js';\n */\nclass LightProbeHelper extends Mesh {\n  /**\n   * Constructs a new light probe helper.\n   *\n   * @param {LightProbe} lightProbe - The light probe to visualize.\n   * @param {number} [size=1] - The size of the helper.\n   */\n  constructor(lightProbe, size = 1) {\n    const material = new ShaderMaterial({\n      type: 'LightProbeHelperMaterial',\n      uniforms: {\n        sh: {\n          value: lightProbe.sh.coefficients\n        },\n        // by reference\n\n        intensity: {\n          value: lightProbe.intensity\n        }\n      },\n      vertexShader: /* glsl */`\n\n\t\t\t\tvarying vec3 vNormal;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvNormal = normalize( normalMatrix * normal );\n\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t`,\n      fragmentShader: /* glsl */`\n\n\t\t\t\t#define RECIPROCAL_PI 0.318309886\n\n\t\t\t\tvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\n\t\t\t\t\t// matrix is assumed to be orthogonal\n\n\t\t\t\t\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\t// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf,\n\t\t\t\tvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\n\t\t\t\t\t// normal is assumed to have unit length,\n\n\t\t\t\t\tfloat x = normal.x, y = normal.y, z = normal.z;\n\n\t\t\t\t\t// band 0,\n\t\t\t\t\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\n\t\t\t\t\t// band 1,\n\t\t\t\t\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\t\t\t\t\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\t\t\t\t\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\n\t\t\t\t\t// band 2,\n\t\t\t\t\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\t\t\t\t\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\t\t\t\t\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\t\t\t\t\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\t\t\t\t\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\t\t\t\t\treturn result;\n\n\t\t\t\t}\n\n\t\t\t\tuniform vec3 sh[ 9 ]; // sh coefficients\n\n\t\t\t\tuniform float intensity; // light probe intensity\n\n\t\t\t\tvarying vec3 vNormal;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 normal = normalize( vNormal );\n\n\t\t\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t\t\t\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );\n\n\t\t\t\t\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;\n\n\t\t\t\t\tgl_FragColor = linearToOutputTexel( vec4( outgoingLight, 1.0 ) );\n\n\t\t\t\t}\n\n\t\t\t`\n    });\n    const geometry = new SphereGeometry(1, 32, 16);\n    super(geometry, material);\n\n    /**\n     * The light probe to visualize.\n     *\n     * @type {LightProbe}\n     */\n    this.lightProbe = lightProbe;\n\n    /**\n     * The size of the helper.\n     *\n     * @type {number}\n     * @default 1\n     */\n    this.size = size;\n    this.type = 'LightProbeHelper';\n    this.onBeforeRender();\n  }\n\n  /**\n   * Frees the GPU-related resources allocated by this instance. Call this\n   * method whenever this instance is no longer used in your app.\n   */\n  dispose() {\n    this.geometry.dispose();\n    this.material.dispose();\n  }\n  onBeforeRender() {\n    this.position.copy(this.lightProbe.position);\n    this.scale.set(1, 1, 1).multiplyScalar(this.size);\n    this.material.uniforms.intensity.value = this.lightProbe.intensity;\n  }\n}\nexport { LightProbeHelper };","map":{"version":3,"names":["Mesh","ShaderMaterial","SphereGeometry","LightProbeHelper","constructor","lightProbe","size","material","type","uniforms","sh","value","coefficients","intensity","vertexShader","fragmentShader","geometry","onBeforeRender","dispose","position","copy","scale","set","multiplyScalar"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/helpers/LightProbeHelper.js"],"sourcesContent":["import {\n\tMesh,\n\tShaderMaterial,\n\tSphereGeometry\n} from 'three';\n\n/**\n * Renders a sphere to visualize a light probe in the scene.\n *\n * This helper can only be used with {@link WebGLRenderer}.\n * When using {@link WebGPURenderer}, import from `LightProbeHelperGPU.js`.\n *\n * ```js\n * const helper = new LightProbeHelper( lightProbe );\n * scene.add( helper );\n * ```\n *\n * @augments Mesh\n * @three_import import { LightProbeHelper } from 'three/addons/helpers/LightProbeHelper.js';\n */\nclass LightProbeHelper extends Mesh {\n\n\t/**\n\t * Constructs a new light probe helper.\n\t *\n\t * @param {LightProbe} lightProbe - The light probe to visualize.\n\t * @param {number} [size=1] - The size of the helper.\n\t */\n\tconstructor( lightProbe, size = 1 ) {\n\n\t\tconst material = new ShaderMaterial( {\n\n\t\t\ttype: 'LightProbeHelperMaterial',\n\n\t\t\tuniforms: {\n\n\t\t\t\tsh: { value: lightProbe.sh.coefficients }, // by reference\n\n\t\t\t\tintensity: { value: lightProbe.intensity }\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec3 vNormal;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvNormal = normalize( normalMatrix * normal );\n\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\t#define RECIPROCAL_PI 0.318309886\n\n\t\t\t\tvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\n\t\t\t\t\t// matrix is assumed to be orthogonal\n\n\t\t\t\t\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\t// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf,\n\t\t\t\tvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\n\t\t\t\t\t// normal is assumed to have unit length,\n\n\t\t\t\t\tfloat x = normal.x, y = normal.y, z = normal.z;\n\n\t\t\t\t\t// band 0,\n\t\t\t\t\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\n\t\t\t\t\t// band 1,\n\t\t\t\t\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\t\t\t\t\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\t\t\t\t\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\n\t\t\t\t\t// band 2,\n\t\t\t\t\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\t\t\t\t\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\t\t\t\t\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\t\t\t\t\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\t\t\t\t\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\t\t\t\t\treturn result;\n\n\t\t\t\t}\n\n\t\t\t\tuniform vec3 sh[ 9 ]; // sh coefficients\n\n\t\t\t\tuniform float intensity; // light probe intensity\n\n\t\t\t\tvarying vec3 vNormal;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 normal = normalize( vNormal );\n\n\t\t\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t\t\t\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );\n\n\t\t\t\t\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;\n\n\t\t\t\t\tgl_FragColor = linearToOutputTexel( vec4( outgoingLight, 1.0 ) );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t} );\n\n\t\tconst geometry = new SphereGeometry( 1, 32, 16 );\n\n\t\tsuper( geometry, material );\n\n\t\t/**\n\t\t * The light probe to visualize.\n\t\t *\n\t\t * @type {LightProbe}\n\t\t */\n\t\tthis.lightProbe = lightProbe;\n\n\t\t/**\n\t\t * The size of the helper.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.size = size;\n\t\tthis.type = 'LightProbeHelper';\n\n\t\tthis.onBeforeRender();\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever this instance is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n\tonBeforeRender() {\n\n\t\tthis.position.copy( this.lightProbe.position );\n\n\t\tthis.scale.set( 1, 1, 1 ).multiplyScalar( this.size );\n\n\t\tthis.material.uniforms.intensity.value = this.lightProbe.intensity;\n\n\t}\n\n}\n\nexport { LightProbeHelper };\n"],"mappings":"AAAA,SACCA,IAAI,EACJC,cAAc,EACdC,cAAc,QACR,OAAO;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,gBAAgB,SAASH,IAAI,CAAC;EAEnC;AACD;AACA;AACA;AACA;AACA;EACCI,WAAWA,CAAEC,UAAU,EAAEC,IAAI,GAAG,CAAC,EAAG;IAEnC,MAAMC,QAAQ,GAAG,IAAIN,cAAc,CAAE;MAEpCO,IAAI,EAAE,0BAA0B;MAEhCC,QAAQ,EAAE;QAETC,EAAE,EAAE;UAAEC,KAAK,EAAEN,UAAU,CAACK,EAAE,CAACE;QAAa,CAAC;QAAE;;QAE3CC,SAAS,EAAE;UAAEF,KAAK,EAAEN,UAAU,CAACQ;QAAU;MAE1C,CAAC;MAEDC,YAAY,EAAE,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;MAEDC,cAAc,EAAE,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAEE,CAAE,CAAC;IAEH,MAAMC,QAAQ,GAAG,IAAId,cAAc,CAAE,CAAC,EAAE,EAAE,EAAE,EAAG,CAAC;IAEhD,KAAK,CAAEc,QAAQ,EAAET,QAAS,CAAC;;IAE3B;AACF;AACA;AACA;AACA;IACE,IAAI,CAACF,UAAU,GAAGA,UAAU;;IAE5B;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACE,IAAI,GAAG,kBAAkB;IAE9B,IAAI,CAACS,cAAc,CAAC,CAAC;EAEtB;;EAEA;AACD;AACA;AACA;EACCC,OAAOA,CAAA,EAAG;IAET,IAAI,CAACF,QAAQ,CAACE,OAAO,CAAC,CAAC;IACvB,IAAI,CAACX,QAAQ,CAACW,OAAO,CAAC,CAAC;EAExB;EAEAD,cAAcA,CAAA,EAAG;IAEhB,IAAI,CAACE,QAAQ,CAACC,IAAI,CAAE,IAAI,CAACf,UAAU,CAACc,QAAS,CAAC;IAE9C,IAAI,CAACE,KAAK,CAACC,GAAG,CAAE,CAAC,EAAE,CAAC,EAAE,CAAE,CAAC,CAACC,cAAc,CAAE,IAAI,CAACjB,IAAK,CAAC;IAErD,IAAI,CAACC,QAAQ,CAACE,QAAQ,CAACI,SAAS,CAACF,KAAK,GAAG,IAAI,CAACN,UAAU,CAACQ,SAAS;EAEnE;AAED;AAEA,SAASV,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}