{"ast":null,"code":"import { BufferGeometry, Float32BufferAttribute, Matrix4, Mesh, MeshBasicMaterial, Object3D, Raycaster, SphereGeometry, Vector3 } from 'three';\nconst PINCH_MAX = 0.05;\nconst PINCH_THRESHOLD = 0.02;\nconst PINCH_MIN = 0.01;\nconst POINTER_ADVANCE_MAX = 0.02;\nconst POINTER_OPACITY_MAX = 1;\nconst POINTER_OPACITY_MIN = 0.4;\nconst POINTER_FRONT_RADIUS = 0.002;\nconst POINTER_REAR_RADIUS = 0.01;\nconst POINTER_REAR_RADIUS_MIN = 0.003;\nconst POINTER_LENGTH = 0.035;\nconst POINTER_SEGMENTS = 16;\nconst POINTER_RINGS = 12;\nconst POINTER_HEMISPHERE_ANGLE = 110;\nconst YAXIS = /* @__PURE__ */new Vector3(0, 1, 0);\nconst ZAXIS = /* @__PURE__ */new Vector3(0, 0, 1);\nconst CURSOR_RADIUS = 0.02;\nconst CURSOR_MAX_DISTANCE = 1.5;\n\n/**\n * Represents an Oculus hand pointer model.\n *\n * @augments Object3D\n * @three_import import { OculusHandPointerModel } from 'three/addons/webxr/OculusHandPointerModel.js';\n */\nclass OculusHandPointerModel extends Object3D {\n  /**\n   * Constructs a new Oculus hand model.\n   *\n   * @param {Group} hand - The hand controller.\n   * @param {Group} controller - The WebXR controller in target ray space.\n   */\n  constructor(hand, controller) {\n    super();\n\n    /**\n     * The hand controller.\n     *\n     * @type {Group}\n     */\n    this.hand = hand;\n\n    /**\n     * The WebXR controller in target ray space.\n     *\n     * @type {Group}\n     */\n    this.controller = controller;\n\n    // Unused\n    this.motionController = null;\n    this.envMap = null;\n    this.mesh = null;\n\n    /**\n     * The pointer geometry.\n     *\n     * @type {?BufferGeometry}\n     * @default null\n     */\n    this.pointerGeometry = null;\n\n    /**\n     * The pointer mesh.\n     *\n     * @type {?Mesh}\n     * @default null\n     */\n    this.pointerMesh = null;\n\n    /**\n     * The pointer object that holds the pointer mesh.\n     *\n     * @type {?Object3D}\n     * @default null\n     */\n    this.pointerObject = null;\n\n    /**\n     * Whether the model is pinched or not.\n     *\n     * @type {?boolean}\n     * @default false\n     */\n    this.pinched = false;\n\n    /**\n     * Whether the model is attached or not.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    this.attached = false;\n\n    /**\n     * The cursor object.\n     *\n     * @type {?Mesh}\n     * @default null\n     */\n    this.cursorObject = null;\n\n    /**\n     * The internal raycaster used for detecting\n     * intersections.\n     *\n     * @type {?Raycaster}\n     * @default null\n     */\n    this.raycaster = null;\n    this._onConnected = this._onConnected.bind(this);\n    this._onDisconnected = this._onDisconnected.bind(this);\n    this.hand.addEventListener('connected', this._onConnected);\n    this.hand.addEventListener('disconnected', this._onDisconnected);\n  }\n  _onConnected(event) {\n    const xrInputSource = event.data;\n    if (xrInputSource.hand) {\n      this.visible = true;\n      this.xrInputSource = xrInputSource;\n      this.createPointer();\n    }\n  }\n  _onDisconnected() {\n    this.visible = false;\n    this.xrInputSource = null;\n    if (this.pointerGeometry) this.pointerGeometry.dispose();\n    if (this.pointerMesh && this.pointerMesh.material) this.pointerMesh.material.dispose();\n    this.clear();\n  }\n  _drawVerticesRing(vertices, baseVector, ringIndex) {\n    const segmentVector = baseVector.clone();\n    for (let i = 0; i < POINTER_SEGMENTS; i++) {\n      segmentVector.applyAxisAngle(ZAXIS, Math.PI * 2 / POINTER_SEGMENTS);\n      const vid = ringIndex * POINTER_SEGMENTS + i;\n      vertices[3 * vid] = segmentVector.x;\n      vertices[3 * vid + 1] = segmentVector.y;\n      vertices[3 * vid + 2] = segmentVector.z;\n    }\n  }\n  _updatePointerVertices(rearRadius) {\n    const vertices = this.pointerGeometry.attributes.position.array;\n    // first ring for front face\n    const frontFaceBase = new Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius));\n    this._drawVerticesRing(vertices, frontFaceBase, 0);\n\n    // rings for rear hemisphere\n    const rearBase = new Vector3(Math.sin(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, Math.cos(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, 0);\n    for (let i = 0; i < POINTER_RINGS; i++) {\n      this._drawVerticesRing(vertices, rearBase, i + 1);\n      rearBase.applyAxisAngle(YAXIS, Math.PI * POINTER_HEMISPHERE_ANGLE / 180 / (POINTER_RINGS * -2));\n    }\n\n    // front and rear face center vertices\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n    const frontCenter = new Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius));\n    vertices[frontCenterIndex * 3] = frontCenter.x;\n    vertices[frontCenterIndex * 3 + 1] = frontCenter.y;\n    vertices[frontCenterIndex * 3 + 2] = frontCenter.z;\n    const rearCenter = new Vector3(0, 0, rearRadius);\n    vertices[rearCenterIndex * 3] = rearCenter.x;\n    vertices[rearCenterIndex * 3 + 1] = rearCenter.y;\n    vertices[rearCenterIndex * 3 + 2] = rearCenter.z;\n    this.pointerGeometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    // verticesNeedUpdate = true;\n  }\n\n  /**\n   * Creates a pointer mesh and adds it to this model.\n   */\n  createPointer() {\n    let i, j;\n    const vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0);\n    // const vertices = [];\n    const indices = [];\n    this.pointerGeometry = new BufferGeometry();\n    this.pointerGeometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this._updatePointerVertices(POINTER_REAR_RADIUS);\n\n    // construct faces to connect rings\n    for (i = 0; i < POINTER_RINGS; i++) {\n      for (j = 0; j < POINTER_SEGMENTS - 1; j++) {\n        indices.push(i * POINTER_SEGMENTS + j, i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n        indices.push(i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n      }\n      indices.push((i + 1) * POINTER_SEGMENTS - 1, i * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n      indices.push(i * POINTER_SEGMENTS, (i + 1) * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n    }\n\n    // construct front and rear face\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n    for (i = 0; i < POINTER_SEGMENTS - 1; i++) {\n      indices.push(frontCenterIndex, i + 1, i);\n      indices.push(rearCenterIndex, i + POINTER_SEGMENTS * POINTER_RINGS, i + POINTER_SEGMENTS * POINTER_RINGS + 1);\n    }\n    indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1);\n    indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS);\n    const material = new MeshBasicMaterial();\n    material.transparent = true;\n    material.opacity = POINTER_OPACITY_MIN;\n    this.pointerGeometry.setIndex(indices);\n    this.pointerMesh = new Mesh(this.pointerGeometry, material);\n    this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n    this.pointerObject = new Object3D();\n    this.pointerObject.add(this.pointerMesh);\n    this.raycaster = new Raycaster();\n\n    // create cursor\n    const cursorGeometry = new SphereGeometry(CURSOR_RADIUS, 10, 10);\n    const cursorMaterial = new MeshBasicMaterial();\n    cursorMaterial.transparent = true;\n    cursorMaterial.opacity = POINTER_OPACITY_MIN;\n    this.cursorObject = new Mesh(cursorGeometry, cursorMaterial);\n    this.pointerObject.add(this.cursorObject);\n    this.add(this.pointerObject);\n  }\n  _updateRaycaster() {\n    if (this.raycaster) {\n      const pointerMatrix = this.pointerObject.matrixWorld;\n      const tempMatrix = new Matrix4();\n      tempMatrix.identity().extractRotation(pointerMatrix);\n      this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix);\n      this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\n    }\n  }\n  _updatePointer() {\n    this.pointerObject.visible = this.controller.visible;\n    const indexTip = this.hand.joints['index-finger-tip'];\n    const thumbTip = this.hand.joints['thumb-tip'];\n    const distance = indexTip.position.distanceTo(thumbTip.position);\n    const position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5);\n    this.pointerObject.position.copy(position);\n    this.pointerObject.quaternion.copy(this.controller.quaternion);\n    this.pinched = distance <= PINCH_THRESHOLD;\n    const pinchScale = (distance - PINCH_MIN) / (PINCH_MAX - PINCH_MIN);\n    const focusScale = (distance - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN);\n    if (pinchScale > 1) {\n      this._updatePointerVertices(POINTER_REAR_RADIUS);\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n    } else if (pinchScale > 0) {\n      const rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN;\n      this._updatePointerVertices(rearRadius);\n      if (focusScale < 1) {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN);\n      } else {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n      }\n    } else {\n      this._updatePointerVertices(POINTER_REAR_RADIUS_MIN);\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MAX;\n    }\n    this.cursorObject.material.opacity = this.pointerMesh.material.opacity;\n  }\n\n  /**\n   * Overwritten with a custom implementation. Makes sure the internal pointer and raycaster are updated.\n   *\n   * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even\n   * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.\n   */\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n    if (this.pointerGeometry) {\n      this._updatePointer();\n      this._updateRaycaster();\n    }\n  }\n\n  /**\n   * Returns `true` is the model is pinched.\n   *\n   * @return {boolean} Whether the model is pinched or not.\n   */\n  isPinched() {\n    return this.pinched;\n  }\n\n  /**\n   * Sets the attached state.\n   *\n   * @param {boolean} attached - Whether the model is attached or not.\n   */\n  setAttached(attached) {\n    this.attached = attached;\n  }\n\n  /**\n   * Returns `true` is the model is attached.\n   *\n   * @return {boolean} Whether the model is attached or not.\n   */\n  isAttached() {\n    return this.attached;\n  }\n\n  /**\n   * Performs an intersection test with the model's raycaster and the given object.\n   *\n   * @param {Object3D} object - The 3D object to check for intersection with the ray.\n   * @param {boolean} [recursive=true] - If set to `true`, it also checks all descendants.\n   * Otherwise it only checks intersection with the object.\n   * @return {Array<Raycaster~Intersection>} An array holding the intersection points.\n   */\n  intersectObject(object, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObject(object, recursive);\n    }\n  }\n\n  /**\n   * Performs an intersection test with the model's raycaster and the given objects.\n   *\n   * @param {Array<Object3D>} objects - The 3D objects to check for intersection with the ray.\n   * @param {boolean} [recursive=true] - If set to `true`, it also checks all descendants.\n   * Otherwise it only checks intersection with the object.\n   * @return {Array<Raycaster~Intersection>} An array holding the intersection points.\n   */\n  intersectObjects(objects, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObjects(objects, recursive);\n    }\n  }\n\n  /**\n   * Checks for intersections between the model's raycaster and the given objects. The method\n   * updates the cursor object to the intersection point.\n   *\n   * @param {Array<Object3D>} objects - The 3D objects to check for intersection with the ray.\n   * @param {boolean} [recursive=false] - If set to `true`, it also checks all descendants.\n   * Otherwise it only checks intersection with the object.\n   */\n  checkIntersections(objects, recursive = false) {\n    if (this.raycaster && !this.attached) {\n      const intersections = this.raycaster.intersectObjects(objects, recursive);\n      const direction = new Vector3(0, 0, -1);\n      if (intersections.length > 0) {\n        const intersection = intersections[0];\n        const distance = intersection.distance;\n        this.cursorObject.position.copy(direction.multiplyScalar(distance));\n      } else {\n        this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE));\n      }\n    }\n  }\n\n  /**\n   * Sets the cursor to the given distance.\n   *\n   * @param {number} distance - The distance to set the cursor to.\n   */\n  setCursor(distance) {\n    const direction = new Vector3(0, 0, -1);\n    if (this.raycaster && !this.attached) {\n      this.cursorObject.position.copy(direction.multiplyScalar(distance));\n    }\n  }\n\n  /**\n   * Frees the GPU-related resources allocated by this instance. Call this\n   * method whenever this instance is no longer used in your app.\n   */\n  dispose() {\n    this._onDisconnected();\n    this.hand.removeEventListener('connected', this._onConnected);\n    this.hand.removeEventListener('disconnected', this._onDisconnected);\n  }\n}\nexport { OculusHandPointerModel };","map":{"version":3,"names":["BufferGeometry","Float32BufferAttribute","Matrix4","Mesh","MeshBasicMaterial","Object3D","Raycaster","SphereGeometry","Vector3","PINCH_MAX","PINCH_THRESHOLD","PINCH_MIN","POINTER_ADVANCE_MAX","POINTER_OPACITY_MAX","POINTER_OPACITY_MIN","POINTER_FRONT_RADIUS","POINTER_REAR_RADIUS","POINTER_REAR_RADIUS_MIN","POINTER_LENGTH","POINTER_SEGMENTS","POINTER_RINGS","POINTER_HEMISPHERE_ANGLE","YAXIS","ZAXIS","CURSOR_RADIUS","CURSOR_MAX_DISTANCE","OculusHandPointerModel","constructor","hand","controller","motionController","envMap","mesh","pointerGeometry","pointerMesh","pointerObject","pinched","attached","cursorObject","raycaster","_onConnected","bind","_onDisconnected","addEventListener","event","xrInputSource","data","visible","createPointer","dispose","material","clear","_drawVerticesRing","vertices","baseVector","ringIndex","segmentVector","clone","i","applyAxisAngle","Math","PI","vid","x","y","z","_updatePointerVertices","rearRadius","attributes","position","array","frontFaceBase","rearBase","sin","cos","frontCenterIndex","rearCenterIndex","frontCenter","rearCenter","setAttribute","j","Array","fill","indices","push","transparent","opacity","setIndex","set","add","cursorGeometry","cursorMaterial","_updateRaycaster","pointerMatrix","matrixWorld","tempMatrix","identity","extractRotation","ray","origin","setFromMatrixPosition","direction","applyMatrix4","_updatePointer","indexTip","joints","thumbTip","distance","distanceTo","multiplyScalar","copy","quaternion","pinchScale","focusScale","updateMatrixWorld","force","isPinched","setAttached","isAttached","intersectObject","object","recursive","intersectObjects","objects","checkIntersections","intersections","length","intersection","setCursor","removeEventListener"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/webxr/OculusHandPointerModel.js"],"sourcesContent":["import { BufferGeometry, Float32BufferAttribute, Matrix4, Mesh, MeshBasicMaterial, Object3D, Raycaster, SphereGeometry, Vector3 } from 'three';\n\nconst PINCH_MAX = 0.05;\nconst PINCH_THRESHOLD = 0.02;\nconst PINCH_MIN = 0.01;\nconst POINTER_ADVANCE_MAX = 0.02;\nconst POINTER_OPACITY_MAX = 1;\nconst POINTER_OPACITY_MIN = 0.4;\nconst POINTER_FRONT_RADIUS = 0.002;\nconst POINTER_REAR_RADIUS = 0.01;\nconst POINTER_REAR_RADIUS_MIN = 0.003;\nconst POINTER_LENGTH = 0.035;\nconst POINTER_SEGMENTS = 16;\nconst POINTER_RINGS = 12;\nconst POINTER_HEMISPHERE_ANGLE = 110;\nconst YAXIS = /* @__PURE__ */ new Vector3( 0, 1, 0 );\nconst ZAXIS = /* @__PURE__ */ new Vector3( 0, 0, 1 );\n\nconst CURSOR_RADIUS = 0.02;\nconst CURSOR_MAX_DISTANCE = 1.5;\n\n/**\n * Represents an Oculus hand pointer model.\n *\n * @augments Object3D\n * @three_import import { OculusHandPointerModel } from 'three/addons/webxr/OculusHandPointerModel.js';\n */\nclass OculusHandPointerModel extends Object3D {\n\n\t/**\n\t * Constructs a new Oculus hand model.\n\t *\n\t * @param {Group} hand - The hand controller.\n\t * @param {Group} controller - The WebXR controller in target ray space.\n\t */\n\tconstructor( hand, controller ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The hand controller.\n\t\t *\n\t\t * @type {Group}\n\t\t */\n\t\tthis.hand = hand;\n\n\t\t/**\n\t\t * The WebXR controller in target ray space.\n\t\t *\n\t\t * @type {Group}\n\t\t */\n\t\tthis.controller = controller;\n\n\t\t// Unused\n\t\tthis.motionController = null;\n\t\tthis.envMap = null;\n\t\tthis.mesh = null;\n\n\t\t/**\n\t\t * The pointer geometry.\n\t\t *\n\t\t * @type {?BufferGeometry}\n\t\t * @default null\n\t\t */\n\t\tthis.pointerGeometry = null;\n\n\t\t/**\n\t\t * The pointer mesh.\n\t\t *\n\t\t * @type {?Mesh}\n\t\t * @default null\n\t\t */\n\t\tthis.pointerMesh = null;\n\n\t\t/**\n\t\t * The pointer object that holds the pointer mesh.\n\t\t *\n\t\t * @type {?Object3D}\n\t\t * @default null\n\t\t */\n\t\tthis.pointerObject = null;\n\n\t\t/**\n\t\t * Whether the model is pinched or not.\n\t\t *\n\t\t * @type {?boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.pinched = false;\n\n\t\t/**\n\t\t * Whether the model is attached or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.attached = false;\n\n\t\t/**\n\t\t * The cursor object.\n\t\t *\n\t\t * @type {?Mesh}\n\t\t * @default null\n\t\t */\n\t\tthis.cursorObject = null;\n\n\t\t/**\n\t\t * The internal raycaster used for detecting\n\t\t * intersections.\n\t\t *\n\t\t * @type {?Raycaster}\n\t\t * @default null\n\t\t */\n\t\tthis.raycaster = null;\n\n\t\tthis._onConnected = this._onConnected.bind( this );\n\t\tthis._onDisconnected = this._onDisconnected.bind( this );\n\t\tthis.hand.addEventListener( 'connected', this._onConnected );\n\t\tthis.hand.addEventListener( 'disconnected', this._onDisconnected );\n\n\t}\n\n\t_onConnected( event ) {\n\n\t\tconst xrInputSource = event.data;\n\t\tif ( xrInputSource.hand ) {\n\n\t\t\tthis.visible = true;\n\t\t\tthis.xrInputSource = xrInputSource;\n\n\t\t\tthis.createPointer();\n\n\t\t}\n\n\t}\n\n\t_onDisconnected() {\n\n\t\tthis.visible = false;\n\t\tthis.xrInputSource = null;\n\n\t\tif ( this.pointerGeometry ) this.pointerGeometry.dispose();\n\t\tif ( this.pointerMesh && this.pointerMesh.material ) this.pointerMesh.material.dispose();\n\n\t\tthis.clear();\n\n\t}\n\n\t_drawVerticesRing( vertices, baseVector, ringIndex ) {\n\n\t\tconst segmentVector = baseVector.clone();\n\t\tfor ( let i = 0; i < POINTER_SEGMENTS; i ++ ) {\n\n\t\t\tsegmentVector.applyAxisAngle( ZAXIS, ( Math.PI * 2 ) / POINTER_SEGMENTS );\n\t\t\tconst vid = ringIndex * POINTER_SEGMENTS + i;\n\t\t\tvertices[ 3 * vid ] = segmentVector.x;\n\t\t\tvertices[ 3 * vid + 1 ] = segmentVector.y;\n\t\t\tvertices[ 3 * vid + 2 ] = segmentVector.z;\n\n\t\t}\n\n\t}\n\n\t_updatePointerVertices( rearRadius ) {\n\n\t\tconst vertices = this.pointerGeometry.attributes.position.array;\n\t\t// first ring for front face\n\t\tconst frontFaceBase = new Vector3(\n\t\t\tPOINTER_FRONT_RADIUS,\n\t\t\t0,\n\t\t\t- 1 * ( POINTER_LENGTH - rearRadius )\n\t\t);\n\t\tthis._drawVerticesRing( vertices, frontFaceBase, 0 );\n\n\t\t// rings for rear hemisphere\n\t\tconst rearBase = new Vector3(\n\t\t\tMath.sin( ( Math.PI * POINTER_HEMISPHERE_ANGLE ) / 180 ) * rearRadius,\n\t\t\tMath.cos( ( Math.PI * POINTER_HEMISPHERE_ANGLE ) / 180 ) * rearRadius,\n\t\t\t0\n\t\t);\n\t\tfor ( let i = 0; i < POINTER_RINGS; i ++ ) {\n\n\t\t\tthis._drawVerticesRing( vertices, rearBase, i + 1 );\n\t\t\trearBase.applyAxisAngle(\n\t\t\t\tYAXIS,\n\t\t\t\t( Math.PI * POINTER_HEMISPHERE_ANGLE ) / 180 / ( POINTER_RINGS * - 2 )\n\t\t\t);\n\n\t\t}\n\n\t\t// front and rear face center vertices\n\t\tconst frontCenterIndex = POINTER_SEGMENTS * ( 1 + POINTER_RINGS );\n\t\tconst rearCenterIndex = POINTER_SEGMENTS * ( 1 + POINTER_RINGS ) + 1;\n\t\tconst frontCenter = new Vector3(\n\t\t\t0,\n\t\t\t0,\n\t\t\t- 1 * ( POINTER_LENGTH - rearRadius )\n\t\t);\n\t\tvertices[ frontCenterIndex * 3 ] = frontCenter.x;\n\t\tvertices[ frontCenterIndex * 3 + 1 ] = frontCenter.y;\n\t\tvertices[ frontCenterIndex * 3 + 2 ] = frontCenter.z;\n\t\tconst rearCenter = new Vector3( 0, 0, rearRadius );\n\t\tvertices[ rearCenterIndex * 3 ] = rearCenter.x;\n\t\tvertices[ rearCenterIndex * 3 + 1 ] = rearCenter.y;\n\t\tvertices[ rearCenterIndex * 3 + 2 ] = rearCenter.z;\n\n\t\tthis.pointerGeometry.setAttribute(\n\t\t\t'position',\n\t\t\tnew Float32BufferAttribute( vertices, 3 )\n\t\t);\n\t\t// verticesNeedUpdate = true;\n\n\t}\n\n\t/**\n\t * Creates a pointer mesh and adds it to this model.\n\t */\n\tcreatePointer() {\n\n\t\tlet i, j;\n\t\tconst vertices = new Array(\n\t\t\t( ( POINTER_RINGS + 1 ) * POINTER_SEGMENTS + 2 ) * 3\n\t\t).fill( 0 );\n\t\t// const vertices = [];\n\t\tconst indices = [];\n\t\tthis.pointerGeometry = new BufferGeometry();\n\n\t\tthis.pointerGeometry.setAttribute(\n\t\t\t'position',\n\t\t\tnew Float32BufferAttribute( vertices, 3 )\n\t\t);\n\n\t\tthis._updatePointerVertices( POINTER_REAR_RADIUS );\n\n\t\t// construct faces to connect rings\n\t\tfor ( i = 0; i < POINTER_RINGS; i ++ ) {\n\n\t\t\tfor ( j = 0; j < POINTER_SEGMENTS - 1; j ++ ) {\n\n\t\t\t\tindices.push(\n\t\t\t\t\ti * POINTER_SEGMENTS + j,\n\t\t\t\t\ti * POINTER_SEGMENTS + j + 1,\n\t\t\t\t\t( i + 1 ) * POINTER_SEGMENTS + j\n\t\t\t\t);\n\t\t\t\tindices.push(\n\t\t\t\t\ti * POINTER_SEGMENTS + j + 1,\n\t\t\t\t\t( i + 1 ) * POINTER_SEGMENTS + j + 1,\n\t\t\t\t\t( i + 1 ) * POINTER_SEGMENTS + j\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tindices.push(\n\t\t\t\t( i + 1 ) * POINTER_SEGMENTS - 1,\n\t\t\t\ti * POINTER_SEGMENTS,\n\t\t\t\t( i + 2 ) * POINTER_SEGMENTS - 1\n\t\t\t);\n\t\t\tindices.push(\n\t\t\t\ti * POINTER_SEGMENTS,\n\t\t\t\t( i + 1 ) * POINTER_SEGMENTS,\n\t\t\t\t( i + 2 ) * POINTER_SEGMENTS - 1\n\t\t\t);\n\n\t\t}\n\n\t\t// construct front and rear face\n\t\tconst frontCenterIndex = POINTER_SEGMENTS * ( 1 + POINTER_RINGS );\n\t\tconst rearCenterIndex = POINTER_SEGMENTS * ( 1 + POINTER_RINGS ) + 1;\n\n\t\tfor ( i = 0; i < POINTER_SEGMENTS - 1; i ++ ) {\n\n\t\t\tindices.push( frontCenterIndex, i + 1, i );\n\t\t\tindices.push(\n\t\t\t\trearCenterIndex,\n\t\t\t\ti + POINTER_SEGMENTS * POINTER_RINGS,\n\t\t\t\ti + POINTER_SEGMENTS * POINTER_RINGS + 1\n\t\t\t);\n\n\t\t}\n\n\t\tindices.push( frontCenterIndex, 0, POINTER_SEGMENTS - 1 );\n\t\tindices.push(\n\t\t\trearCenterIndex,\n\t\t\tPOINTER_SEGMENTS * ( POINTER_RINGS + 1 ) - 1,\n\t\t\tPOINTER_SEGMENTS * POINTER_RINGS\n\t\t);\n\n\t\tconst material = new MeshBasicMaterial();\n\t\tmaterial.transparent = true;\n\t\tmaterial.opacity = POINTER_OPACITY_MIN;\n\n\t\tthis.pointerGeometry.setIndex( indices );\n\n\t\tthis.pointerMesh = new Mesh( this.pointerGeometry, material );\n\n\t\tthis.pointerMesh.position.set( 0, 0, - 1 * POINTER_REAR_RADIUS );\n\t\tthis.pointerObject = new Object3D();\n\t\tthis.pointerObject.add( this.pointerMesh );\n\n\t\tthis.raycaster = new Raycaster();\n\n\t\t// create cursor\n\t\tconst cursorGeometry = new SphereGeometry( CURSOR_RADIUS, 10, 10 );\n\t\tconst cursorMaterial = new MeshBasicMaterial();\n\t\tcursorMaterial.transparent = true;\n\t\tcursorMaterial.opacity = POINTER_OPACITY_MIN;\n\n\t\tthis.cursorObject = new Mesh( cursorGeometry, cursorMaterial );\n\t\tthis.pointerObject.add( this.cursorObject );\n\n\t\tthis.add( this.pointerObject );\n\n\t}\n\n\t_updateRaycaster() {\n\n\t\tif ( this.raycaster ) {\n\n\t\t\tconst pointerMatrix = this.pointerObject.matrixWorld;\n\t\t\tconst tempMatrix = new Matrix4();\n\t\t\ttempMatrix.identity().extractRotation( pointerMatrix );\n\t\t\tthis.raycaster.ray.origin.setFromMatrixPosition( pointerMatrix );\n\t\t\tthis.raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );\n\n\t\t}\n\n\t}\n\n\t_updatePointer() {\n\n\t\tthis.pointerObject.visible = this.controller.visible;\n\t\tconst indexTip = this.hand.joints[ 'index-finger-tip' ];\n\t\tconst thumbTip = this.hand.joints[ 'thumb-tip' ];\n\t\tconst distance = indexTip.position.distanceTo( thumbTip.position );\n\t\tconst position = indexTip.position\n\t\t\t.clone()\n\t\t\t.add( thumbTip.position )\n\t\t\t.multiplyScalar( 0.5 );\n\t\tthis.pointerObject.position.copy( position );\n\t\tthis.pointerObject.quaternion.copy( this.controller.quaternion );\n\n\t\tthis.pinched = distance <= PINCH_THRESHOLD;\n\n\t\tconst pinchScale = ( distance - PINCH_MIN ) / ( PINCH_MAX - PINCH_MIN );\n\t\tconst focusScale = ( distance - PINCH_MIN ) / ( PINCH_THRESHOLD - PINCH_MIN );\n\t\tif ( pinchScale > 1 ) {\n\n\t\t\tthis._updatePointerVertices( POINTER_REAR_RADIUS );\n\t\t\tthis.pointerMesh.position.set( 0, 0, - 1 * POINTER_REAR_RADIUS );\n\t\t\tthis.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n\n\t\t} else if ( pinchScale > 0 ) {\n\n\t\t\tconst rearRadius =\n        ( POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN ) * pinchScale +\n        POINTER_REAR_RADIUS_MIN;\n\t\t\tthis._updatePointerVertices( rearRadius );\n\t\t\tif ( focusScale < 1 ) {\n\n\t\t\t\tthis.pointerMesh.position.set(\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\t- 1 * rearRadius - ( 1 - focusScale ) * POINTER_ADVANCE_MAX\n\t\t\t\t);\n\t\t\t\tthis.pointerMesh.material.opacity =\n          POINTER_OPACITY_MIN +\n          ( 1 - focusScale ) * ( POINTER_OPACITY_MAX - POINTER_OPACITY_MIN );\n\n\t\t\t} else {\n\n\t\t\t\tthis.pointerMesh.position.set( 0, 0, - 1 * rearRadius );\n\t\t\t\tthis.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis._updatePointerVertices( POINTER_REAR_RADIUS_MIN );\n\t\t\tthis.pointerMesh.position.set(\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t- 1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX\n\t\t\t);\n\t\t\tthis.pointerMesh.material.opacity = POINTER_OPACITY_MAX;\n\n\t\t}\n\n\t\tthis.cursorObject.material.opacity = this.pointerMesh.material.opacity;\n\n\t}\n\n\t/**\n\t * Overwritten with a custom implementation. Makes sure the internal pointer and raycaster are updated.\n\t *\n\t * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even\n\t * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.\n\t */\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\t\tif ( this.pointerGeometry ) {\n\n\t\t\tthis._updatePointer();\n\t\t\tthis._updateRaycaster();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` is the model is pinched.\n\t *\n\t * @return {boolean} Whether the model is pinched or not.\n\t */\n\tisPinched() {\n\n\t\treturn this.pinched;\n\n\t}\n\n\t/**\n\t * Sets the attached state.\n\t *\n\t * @param {boolean} attached - Whether the model is attached or not.\n\t */\n\tsetAttached( attached ) {\n\n\t\tthis.attached = attached;\n\n\t}\n\n\t/**\n\t * Returns `true` is the model is attached.\n\t *\n\t * @return {boolean} Whether the model is attached or not.\n\t */\n\tisAttached() {\n\n\t\treturn this.attached;\n\n\t}\n\n\t/**\n\t * Performs an intersection test with the model's raycaster and the given object.\n\t *\n\t * @param {Object3D} object - The 3D object to check for intersection with the ray.\n\t * @param {boolean} [recursive=true] - If set to `true`, it also checks all descendants.\n\t * Otherwise it only checks intersection with the object.\n\t * @return {Array<Raycaster~Intersection>} An array holding the intersection points.\n\t */\n\tintersectObject( object, recursive = true ) {\n\n\t\tif ( this.raycaster ) {\n\n\t\t\treturn this.raycaster.intersectObject( object, recursive );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Performs an intersection test with the model's raycaster and the given objects.\n\t *\n\t * @param {Array<Object3D>} objects - The 3D objects to check for intersection with the ray.\n\t * @param {boolean} [recursive=true] - If set to `true`, it also checks all descendants.\n\t * Otherwise it only checks intersection with the object.\n\t * @return {Array<Raycaster~Intersection>} An array holding the intersection points.\n\t */\n\tintersectObjects( objects, recursive = true ) {\n\n\t\tif ( this.raycaster ) {\n\n\t\t\treturn this.raycaster.intersectObjects( objects, recursive );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Checks for intersections between the model's raycaster and the given objects. The method\n\t * updates the cursor object to the intersection point.\n\t *\n\t * @param {Array<Object3D>} objects - The 3D objects to check for intersection with the ray.\n\t * @param {boolean} [recursive=false] - If set to `true`, it also checks all descendants.\n\t * Otherwise it only checks intersection with the object.\n\t */\n\tcheckIntersections( objects, recursive = false ) {\n\n\t\tif ( this.raycaster && ! this.attached ) {\n\n\t\t\tconst intersections = this.raycaster.intersectObjects( objects, recursive );\n\t\t\tconst direction = new Vector3( 0, 0, - 1 );\n\t\t\tif ( intersections.length > 0 ) {\n\n\t\t\t\tconst intersection = intersections[ 0 ];\n\t\t\t\tconst distance = intersection.distance;\n\t\t\t\tthis.cursorObject.position.copy( direction.multiplyScalar( distance ) );\n\n\t\t\t} else {\n\n\t\t\t\tthis.cursorObject.position.copy( direction.multiplyScalar( CURSOR_MAX_DISTANCE ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets the cursor to the given distance.\n\t *\n\t * @param {number} distance - The distance to set the cursor to.\n\t */\n\tsetCursor( distance ) {\n\n\t\tconst direction = new Vector3( 0, 0, - 1 );\n\t\tif ( this.raycaster && ! this.attached ) {\n\n\t\t\tthis.cursorObject.position.copy( direction.multiplyScalar( distance ) );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever this instance is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis._onDisconnected();\n\t\tthis.hand.removeEventListener( 'connected', this._onConnected );\n\t\tthis.hand.removeEventListener( 'disconnected', this._onDisconnected );\n\n\t}\n\n}\n\nexport { OculusHandPointerModel };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}