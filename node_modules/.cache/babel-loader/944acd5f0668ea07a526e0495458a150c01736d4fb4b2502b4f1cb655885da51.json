{"ast":null,"code":"import { BufferAttribute, BufferGeometry, Group, LineSegments, Matrix3, Mesh } from 'three';\nimport { mergeGeometries } from './BufferGeometryUtils.js';\n\n/**\n * Utility class for LDraw models.\n *\n * @three_import import { LDrawUtils } from 'three/addons/utils/LDrawUtils.js';\n */\nclass LDrawUtils {\n  /**\n   * Merges geometries in the given object by materials and returns a new group object.\n   * Use on not indexed geometries. The object buffers reference the old object ones.\n   * Special treatment is done to the conditional lines generated by LDrawLoader.\n   *\n   * @param {Object3D} object - The object to merge.\n   * @returns {Group} The merged object.\n   */\n  static mergeObject(object) {\n    function extractGroup(geometry, group, elementSize, isConditionalLine) {\n      // Extracts a group from a geometry as a new geometry (with attribute buffers referencing original buffers)\n\n      const newGeometry = new BufferGeometry();\n      const originalPositions = geometry.getAttribute('position').array;\n      const originalNormals = elementSize === 3 ? geometry.getAttribute('normal').array : null;\n      const numVertsGroup = Math.min(group.count, Math.floor(originalPositions.length / 3) - group.start);\n      const vertStart = group.start * 3;\n      const vertEnd = (group.start + numVertsGroup) * 3;\n      const positions = originalPositions.subarray(vertStart, vertEnd);\n      const normals = originalNormals !== null ? originalNormals.subarray(vertStart, vertEnd) : null;\n      newGeometry.setAttribute('position', new BufferAttribute(positions, 3));\n      if (normals !== null) newGeometry.setAttribute('normal', new BufferAttribute(normals, 3));\n      if (isConditionalLine) {\n        const controlArray0 = geometry.getAttribute('control0').array.subarray(vertStart, vertEnd);\n        const controlArray1 = geometry.getAttribute('control1').array.subarray(vertStart, vertEnd);\n        const directionArray = geometry.getAttribute('direction').array.subarray(vertStart, vertEnd);\n        newGeometry.setAttribute('control0', new BufferAttribute(controlArray0, 3, false));\n        newGeometry.setAttribute('control1', new BufferAttribute(controlArray1, 3, false));\n        newGeometry.setAttribute('direction', new BufferAttribute(directionArray, 3, false));\n      }\n      return newGeometry;\n    }\n    function addGeometry(mat, geometry, geometries) {\n      const geoms = geometries[mat.uuid];\n      if (!geoms) {\n        geometries[mat.uuid] = {\n          mat: mat,\n          arr: [geometry]\n        };\n      } else {\n        geoms.arr.push(geometry);\n      }\n    }\n    function permuteAttribute(attribute, elemSize) {\n      // Permutes first two vertices of each attribute element\n\n      if (!attribute) return;\n      const verts = attribute.array;\n      const numVerts = Math.floor(verts.length / 3);\n      let offset = 0;\n      for (let i = 0; i < numVerts; i++) {\n        const x = verts[offset];\n        const y = verts[offset + 1];\n        const z = verts[offset + 2];\n        verts[offset] = verts[offset + 3];\n        verts[offset + 1] = verts[offset + 4];\n        verts[offset + 2] = verts[offset + 5];\n        verts[offset + 3] = x;\n        verts[offset + 4] = y;\n        verts[offset + 5] = z;\n        offset += elemSize * 3;\n      }\n    }\n\n    // Traverse the object hierarchy collecting geometries and transforming them to world space\n\n    const meshGeometries = {};\n    const linesGeometries = {};\n    const condLinesGeometries = {};\n    object.updateMatrixWorld(true);\n    const normalMatrix = new Matrix3();\n    object.traverse(c => {\n      if (c.isMesh | c.isLineSegments) {\n        const elemSize = c.isMesh ? 3 : 2;\n        const geometry = c.geometry.clone();\n        const matrixIsInverted = c.matrixWorld.determinant() < 0;\n        if (matrixIsInverted) {\n          permuteAttribute(geometry.attributes.position, elemSize);\n          permuteAttribute(geometry.attributes.normal, elemSize);\n        }\n        geometry.applyMatrix4(c.matrixWorld);\n        if (c.isConditionalLine) {\n          geometry.attributes.control0.applyMatrix4(c.matrixWorld);\n          geometry.attributes.control1.applyMatrix4(c.matrixWorld);\n          normalMatrix.getNormalMatrix(c.matrixWorld);\n          geometry.attributes.direction.applyNormalMatrix(normalMatrix);\n        }\n        const geometries = c.isMesh ? meshGeometries : c.isConditionalLine ? condLinesGeometries : linesGeometries;\n        if (Array.isArray(c.material)) {\n          for (const groupIndex in geometry.groups) {\n            const group = geometry.groups[groupIndex];\n            const mat = c.material[group.materialIndex];\n            const newGeometry = extractGroup(geometry, group, elemSize, c.isConditionalLine);\n            addGeometry(mat, newGeometry, geometries);\n          }\n        } else {\n          addGeometry(c.material, geometry, geometries);\n        }\n      }\n    });\n\n    // Create object with merged geometries\n\n    const mergedObject = new Group();\n    const meshMaterialsIds = Object.keys(meshGeometries);\n    for (const meshMaterialsId of meshMaterialsIds) {\n      const meshGeometry = meshGeometries[meshMaterialsId];\n      const mergedGeometry = mergeGeometries(meshGeometry.arr);\n      mergedObject.add(new Mesh(mergedGeometry, meshGeometry.mat));\n    }\n    const linesMaterialsIds = Object.keys(linesGeometries);\n    for (const linesMaterialsId of linesMaterialsIds) {\n      const lineGeometry = linesGeometries[linesMaterialsId];\n      const mergedGeometry = mergeGeometries(lineGeometry.arr);\n      mergedObject.add(new LineSegments(mergedGeometry, lineGeometry.mat));\n    }\n    const condLinesMaterialsIds = Object.keys(condLinesGeometries);\n    for (const condLinesMaterialsId of condLinesMaterialsIds) {\n      const condLineGeometry = condLinesGeometries[condLinesMaterialsId];\n      const mergedGeometry = mergeGeometries(condLineGeometry.arr);\n      const condLines = new LineSegments(mergedGeometry, condLineGeometry.mat);\n      condLines.isConditionalLine = true;\n      mergedObject.add(condLines);\n    }\n    mergedObject.userData.constructionStep = 0;\n    mergedObject.userData.numConstructionSteps = 1;\n    return mergedObject;\n  }\n}\nexport { LDrawUtils };","map":{"version":3,"names":["BufferAttribute","BufferGeometry","Group","LineSegments","Matrix3","Mesh","mergeGeometries","LDrawUtils","mergeObject","object","extractGroup","geometry","group","elementSize","isConditionalLine","newGeometry","originalPositions","getAttribute","array","originalNormals","numVertsGroup","Math","min","count","floor","length","start","vertStart","vertEnd","positions","subarray","normals","setAttribute","controlArray0","controlArray1","directionArray","addGeometry","mat","geometries","geoms","uuid","arr","push","permuteAttribute","attribute","elemSize","verts","numVerts","offset","i","x","y","z","meshGeometries","linesGeometries","condLinesGeometries","updateMatrixWorld","normalMatrix","traverse","c","isMesh","isLineSegments","clone","matrixIsInverted","matrixWorld","determinant","attributes","position","normal","applyMatrix4","control0","control1","getNormalMatrix","direction","applyNormalMatrix","Array","isArray","material","groupIndex","groups","materialIndex","mergedObject","meshMaterialsIds","Object","keys","meshMaterialsId","meshGeometry","mergedGeometry","add","linesMaterialsIds","linesMaterialsId","lineGeometry","condLinesMaterialsIds","condLinesMaterialsId","condLineGeometry","condLines","userData","constructionStep","numConstructionSteps"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/utils/LDrawUtils.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tGroup,\n\tLineSegments,\n\tMatrix3,\n\tMesh\n} from 'three';\n\nimport { mergeGeometries } from './BufferGeometryUtils.js';\n\n/**\n * Utility class for LDraw models.\n *\n * @three_import import { LDrawUtils } from 'three/addons/utils/LDrawUtils.js';\n */\nclass LDrawUtils {\n\n\t/**\n\t * Merges geometries in the given object by materials and returns a new group object.\n\t * Use on not indexed geometries. The object buffers reference the old object ones.\n\t * Special treatment is done to the conditional lines generated by LDrawLoader.\n\t *\n\t * @param {Object3D} object - The object to merge.\n\t * @returns {Group} The merged object.\n\t */\n\tstatic mergeObject( object ) {\n\n\t\tfunction extractGroup( geometry, group, elementSize, isConditionalLine ) {\n\n\t\t\t// Extracts a group from a geometry as a new geometry (with attribute buffers referencing original buffers)\n\n\t\t\tconst newGeometry = new BufferGeometry();\n\n\t\t\tconst originalPositions = geometry.getAttribute( 'position' ).array;\n\t\t\tconst originalNormals = elementSize === 3 ? geometry.getAttribute( 'normal' ).array : null;\n\n\t\t\tconst numVertsGroup = Math.min( group.count, Math.floor( originalPositions.length / 3 ) - group.start );\n\t\t\tconst vertStart = group.start * 3;\n\t\t\tconst vertEnd = ( group.start + numVertsGroup ) * 3;\n\n\t\t\tconst positions = originalPositions.subarray( vertStart, vertEnd );\n\t\t\tconst normals = originalNormals !== null ? originalNormals.subarray( vertStart, vertEnd ) : null;\n\n\t\t\tnewGeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\t\t\tif ( normals !== null ) newGeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\n\t\t\tif ( isConditionalLine ) {\n\n\t\t\t\tconst controlArray0 = geometry.getAttribute( 'control0' ).array.subarray( vertStart, vertEnd );\n\t\t\t\tconst controlArray1 = geometry.getAttribute( 'control1' ).array.subarray( vertStart, vertEnd );\n\t\t\t\tconst directionArray = geometry.getAttribute( 'direction' ).array.subarray( vertStart, vertEnd );\n\n\t\t\t\tnewGeometry.setAttribute( 'control0', new BufferAttribute( controlArray0, 3, false ) );\n\t\t\t\tnewGeometry.setAttribute( 'control1', new BufferAttribute( controlArray1, 3, false ) );\n\t\t\t\tnewGeometry.setAttribute( 'direction', new BufferAttribute( directionArray, 3, false ) );\n\n\t\t\t}\n\n\t\t\treturn newGeometry;\n\n\t\t}\n\n\t\tfunction addGeometry( mat, geometry, geometries ) {\n\n\t\t\tconst geoms = geometries[ mat.uuid ];\n\t\t\tif ( ! geoms ) {\n\n\t\t\t\tgeometries[ mat.uuid ] = {\n\t\t\t\t\tmat: mat,\n\t\t\t\t\tarr: [ geometry ]\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tgeoms.arr.push( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction permuteAttribute( attribute, elemSize ) {\n\n\t\t\t// Permutes first two vertices of each attribute element\n\n\t\t\tif ( ! attribute ) return;\n\n\t\t\tconst verts = attribute.array;\n\t\t\tconst numVerts = Math.floor( verts.length / 3 );\n\t\t\tlet offset = 0;\n\t\t\tfor ( let i = 0; i < numVerts; i ++ ) {\n\n\t\t\t\tconst x = verts[ offset ];\n\t\t\t\tconst y = verts[ offset + 1 ];\n\t\t\t\tconst z = verts[ offset + 2 ];\n\n\t\t\t\tverts[ offset ] = verts[ offset + 3 ];\n\t\t\t\tverts[ offset + 1 ] = verts[ offset + 4 ];\n\t\t\t\tverts[ offset + 2 ] = verts[ offset + 5 ];\n\n\t\t\t\tverts[ offset + 3 ] = x;\n\t\t\t\tverts[ offset + 4 ] = y;\n\t\t\t\tverts[ offset + 5 ] = z;\n\n\t\t\t\toffset += elemSize * 3;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Traverse the object hierarchy collecting geometries and transforming them to world space\n\n\t\tconst meshGeometries = {};\n\t\tconst linesGeometries = {};\n\t\tconst condLinesGeometries = {};\n\n\t\tobject.updateMatrixWorld( true );\n\t\tconst normalMatrix = new Matrix3();\n\n\t\tobject.traverse( c => {\n\n\t\t\tif ( c.isMesh | c.isLineSegments ) {\n\n\t\t\t\tconst elemSize = c.isMesh ? 3 : 2;\n\n\t\t\t\tconst geometry = c.geometry.clone();\n\t\t\t\tconst matrixIsInverted = c.matrixWorld.determinant() < 0;\n\t\t\t\tif ( matrixIsInverted ) {\n\n\t\t\t\t\tpermuteAttribute( geometry.attributes.position, elemSize );\n\t\t\t\t\tpermuteAttribute( geometry.attributes.normal, elemSize );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.applyMatrix4( c.matrixWorld );\n\n\t\t\t\tif ( c.isConditionalLine ) {\n\n\t\t\t\t\tgeometry.attributes.control0.applyMatrix4( c.matrixWorld );\n\t\t\t\t\tgeometry.attributes.control1.applyMatrix4( c.matrixWorld );\n\t\t\t\t\tnormalMatrix.getNormalMatrix( c.matrixWorld );\n\t\t\t\t\tgeometry.attributes.direction.applyNormalMatrix( normalMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tconst geometries = c.isMesh ? meshGeometries : ( c.isConditionalLine ? condLinesGeometries : linesGeometries );\n\n\t\t\t\tif ( Array.isArray( c.material ) ) {\n\n\t\t\t\t\tfor ( const groupIndex in geometry.groups ) {\n\n\t\t\t\t\t\tconst group = geometry.groups[ groupIndex ];\n\t\t\t\t\t\tconst mat = c.material[ group.materialIndex ];\n\t\t\t\t\t\tconst newGeometry = extractGroup( geometry, group, elemSize, c.isConditionalLine );\n\t\t\t\t\t\taddGeometry( mat, newGeometry, geometries );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddGeometry( c.material, geometry, geometries );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Create object with merged geometries\n\n\t\tconst mergedObject = new Group();\n\n\t\tconst meshMaterialsIds = Object.keys( meshGeometries );\n\t\tfor ( const meshMaterialsId of meshMaterialsIds ) {\n\n\t\t\tconst meshGeometry = meshGeometries[ meshMaterialsId ];\n\t\t\tconst mergedGeometry = mergeGeometries( meshGeometry.arr );\n\t\t\tmergedObject.add( new Mesh( mergedGeometry, meshGeometry.mat ) );\n\n\t\t}\n\n\t\tconst linesMaterialsIds = Object.keys( linesGeometries );\n\t\tfor ( const linesMaterialsId of linesMaterialsIds ) {\n\n\t\t\tconst lineGeometry = linesGeometries[ linesMaterialsId ];\n\t\t\tconst mergedGeometry = mergeGeometries( lineGeometry.arr );\n\t\t\tmergedObject.add( new LineSegments( mergedGeometry, lineGeometry.mat ) );\n\n\t\t}\n\n\t\tconst condLinesMaterialsIds = Object.keys( condLinesGeometries );\n\t\tfor ( const condLinesMaterialsId of condLinesMaterialsIds ) {\n\n\t\t\tconst condLineGeometry = condLinesGeometries[ condLinesMaterialsId ];\n\t\t\tconst mergedGeometry = mergeGeometries( condLineGeometry.arr );\n\t\t\tconst condLines = new LineSegments( mergedGeometry, condLineGeometry.mat );\n\t\t\tcondLines.isConditionalLine = true;\n\t\t\tmergedObject.add( condLines );\n\n\t\t}\n\n\t\tmergedObject.userData.constructionStep = 0;\n\t\tmergedObject.userData.numConstructionSteps = 1;\n\n\t\treturn mergedObject;\n\n\t}\n\n}\n\nexport { LDrawUtils };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}