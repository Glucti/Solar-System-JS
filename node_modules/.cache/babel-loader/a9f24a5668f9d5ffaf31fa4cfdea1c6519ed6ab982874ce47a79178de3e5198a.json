{"ast":null,"code":"import { AdditiveBlending, HalfFloatType, ShaderMaterial, UniformsUtils, Vector2, WebGLRenderTarget } from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { ConvolutionShader } from '../shaders/ConvolutionShader.js';\n\n/**\n * A pass for a basic Bloom effect.\n *\n * {@link UnrealBloomPass} produces a more advanced Bloom but is also\n * more expensive.\n *\n * ```js\n * const effectBloom = new BloomPass( 0.75 );\n * composer.addPass( effectBloom );\n * ```\n *\n * @augments Pass\n * @three_import import { BloomPass } from 'three/addons/postprocessing/BloomPass.js';\n */\nclass BloomPass extends Pass {\n  /**\n   * Constructs a new Bloom pass.\n   *\n   * @param {number} [strength=1] - The Bloom strength.\n   * @param {number} [kernelSize=25] - The kernel size.\n   * @param {number} [sigma=4] - The sigma.\n   */\n  constructor(strength = 1, kernelSize = 25, sigma = 4) {\n    super();\n\n    // combine material\n\n    /**\n     * The combine pass uniforms.\n     *\n     * @type {Object}\n     */\n    this.combineUniforms = UniformsUtils.clone(CombineShader.uniforms);\n    this.combineUniforms['strength'].value = strength;\n\n    /**\n     * The combine pass material.\n     *\n     * @type {ShaderMaterial}\n     */\n    this.materialCombine = new ShaderMaterial({\n      name: CombineShader.name,\n      uniforms: this.combineUniforms,\n      vertexShader: CombineShader.vertexShader,\n      fragmentShader: CombineShader.fragmentShader,\n      blending: AdditiveBlending,\n      transparent: true\n    });\n\n    // convolution material\n\n    const convolutionShader = ConvolutionShader;\n\n    /**\n     * The convolution pass uniforms.\n     *\n     * @type {Object}\n     */\n    this.convolutionUniforms = UniformsUtils.clone(convolutionShader.uniforms);\n    this.convolutionUniforms['uImageIncrement'].value = BloomPass.blurX;\n    this.convolutionUniforms['cKernel'].value = buildKernel(sigma);\n\n    /**\n     * The convolution pass material.\n     *\n     * @type {ShaderMaterial}\n     */\n    this.materialConvolution = new ShaderMaterial({\n      name: convolutionShader.name,\n      uniforms: this.convolutionUniforms,\n      vertexShader: convolutionShader.vertexShader,\n      fragmentShader: convolutionShader.fragmentShader,\n      defines: {\n        'KERNEL_SIZE_FLOAT': kernelSize.toFixed(1),\n        'KERNEL_SIZE_INT': kernelSize.toFixed(0)\n      }\n    });\n\n    /**\n     * Overwritten to disable the swap.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    this.needsSwap = false;\n\n    // internals\n\n    this._renderTargetX = new WebGLRenderTarget(1, 1, {\n      type: HalfFloatType\n    }); // will be resized later\n    this._renderTargetX.texture.name = 'BloomPass.x';\n    this._renderTargetY = new WebGLRenderTarget(1, 1, {\n      type: HalfFloatType\n    }); // will be resized later\n    this._renderTargetY.texture.name = 'BloomPass.y';\n    this._fsQuad = new FullScreenQuad(null);\n  }\n\n  /**\n   * Performs the Bloom pass.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n   * destination for the pass.\n   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n   * previous pass from this buffer.\n   * @param {number} deltaTime - The delta time in seconds.\n   * @param {boolean} maskActive - Whether masking is active or not.\n   */\n  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    if (maskActive) renderer.state.buffers.stencil.setTest(false);\n\n    // Render quad with blurred scene into texture (convolution pass 1)\n\n    this._fsQuad.material = this.materialConvolution;\n    this.convolutionUniforms['tDiffuse'].value = readBuffer.texture;\n    this.convolutionUniforms['uImageIncrement'].value = BloomPass.blurX;\n    renderer.setRenderTarget(this._renderTargetX);\n    renderer.clear();\n    this._fsQuad.render(renderer);\n\n    // Render quad with blurred scene into texture (convolution pass 2)\n\n    this.convolutionUniforms['tDiffuse'].value = this._renderTargetX.texture;\n    this.convolutionUniforms['uImageIncrement'].value = BloomPass.blurY;\n    renderer.setRenderTarget(this._renderTargetY);\n    renderer.clear();\n    this._fsQuad.render(renderer);\n\n    // Render original scene with superimposed blur to texture\n\n    this._fsQuad.material = this.materialCombine;\n    this.combineUniforms['tDiffuse'].value = this._renderTargetY.texture;\n    if (maskActive) renderer.state.buffers.stencil.setTest(true);\n    renderer.setRenderTarget(readBuffer);\n    if (this.clear) renderer.clear();\n    this._fsQuad.render(renderer);\n  }\n\n  /**\n   * Sets the size of the pass.\n   *\n   * @param {number} width - The width to set.\n   * @param {number} height - The height to set.\n   */\n  setSize(width, height) {\n    this._renderTargetX.setSize(width, height);\n    this._renderTargetY.setSize(width, height);\n  }\n\n  /**\n   * Frees the GPU-related resources allocated by this instance. Call this\n   * method whenever the pass is no longer used in your app.\n   */\n  dispose() {\n    this._renderTargetX.dispose();\n    this._renderTargetY.dispose();\n    this.materialCombine.dispose();\n    this.materialConvolution.dispose();\n    this._fsQuad.dispose();\n  }\n}\nconst CombineShader = {\n  name: 'CombineShader',\n  uniforms: {\n    'tDiffuse': {\n      value: null\n    },\n    'strength': {\n      value: 1.0\n    }\n  },\n  vertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n  fragmentShader: /* glsl */`\n\n\t\tuniform float strength;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = strength * texel;\n\n\t\t}`\n};\nBloomPass.blurX = new Vector2(0.001953125, 0.0);\nBloomPass.blurY = new Vector2(0.0, 0.001953125);\nfunction gauss(x, sigma) {\n  return Math.exp(-(x * x) / (2.0 * sigma * sigma));\n}\nfunction buildKernel(sigma) {\n  // We loop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n\n  const kMaxKernelSize = 25;\n  let kernelSize = 2 * Math.ceil(sigma * 3.0) + 1;\n  if (kernelSize > kMaxKernelSize) kernelSize = kMaxKernelSize;\n  const halfWidth = (kernelSize - 1) * 0.5;\n  const values = new Array(kernelSize);\n  let sum = 0.0;\n  for (let i = 0; i < kernelSize; ++i) {\n    values[i] = gauss(i - halfWidth, sigma);\n    sum += values[i];\n  }\n\n  // normalize the kernel\n\n  for (let i = 0; i < kernelSize; ++i) values[i] /= sum;\n  return values;\n}\nexport { BloomPass };","map":{"version":3,"names":["AdditiveBlending","HalfFloatType","ShaderMaterial","UniformsUtils","Vector2","WebGLRenderTarget","Pass","FullScreenQuad","ConvolutionShader","BloomPass","constructor","strength","kernelSize","sigma","combineUniforms","clone","CombineShader","uniforms","value","materialCombine","name","vertexShader","fragmentShader","blending","transparent","convolutionShader","convolutionUniforms","blurX","buildKernel","materialConvolution","defines","toFixed","needsSwap","_renderTargetX","type","texture","_renderTargetY","_fsQuad","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","state","buffers","stencil","setTest","material","setRenderTarget","clear","blurY","setSize","width","height","dispose","gauss","x","Math","exp","kMaxKernelSize","ceil","halfWidth","values","Array","sum","i"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/postprocessing/BloomPass.js"],"sourcesContent":["import {\n\tAdditiveBlending,\n\tHalfFloatType,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector2,\n\tWebGLRenderTarget\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { ConvolutionShader } from '../shaders/ConvolutionShader.js';\n\n/**\n * A pass for a basic Bloom effect.\n *\n * {@link UnrealBloomPass} produces a more advanced Bloom but is also\n * more expensive.\n *\n * ```js\n * const effectBloom = new BloomPass( 0.75 );\n * composer.addPass( effectBloom );\n * ```\n *\n * @augments Pass\n * @three_import import { BloomPass } from 'three/addons/postprocessing/BloomPass.js';\n */\nclass BloomPass extends Pass {\n\n\t/**\n\t * Constructs a new Bloom pass.\n\t *\n\t * @param {number} [strength=1] - The Bloom strength.\n\t * @param {number} [kernelSize=25] - The kernel size.\n\t * @param {number} [sigma=4] - The sigma.\n\t */\n\tconstructor( strength = 1, kernelSize = 25, sigma = 4 ) {\n\n\t\tsuper();\n\n\t\t// combine material\n\n\t\t/**\n\t\t * The combine pass uniforms.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.combineUniforms = UniformsUtils.clone( CombineShader.uniforms );\n\t\tthis.combineUniforms[ 'strength' ].value = strength;\n\n\t\t/**\n\t\t * The combine pass material.\n\t\t *\n\t\t * @type {ShaderMaterial}\n\t\t */\n\t\tthis.materialCombine = new ShaderMaterial( {\n\n\t\t\tname: CombineShader.name,\n\t\t\tuniforms: this.combineUniforms,\n\t\t\tvertexShader: CombineShader.vertexShader,\n\t\t\tfragmentShader: CombineShader.fragmentShader,\n\t\t\tblending: AdditiveBlending,\n\t\t\ttransparent: true\n\n\t\t} );\n\n\t\t// convolution material\n\n\t\tconst convolutionShader = ConvolutionShader;\n\n\t\t/**\n\t\t * The convolution pass uniforms.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.convolutionUniforms = UniformsUtils.clone( convolutionShader.uniforms );\n\n\t\tthis.convolutionUniforms[ 'uImageIncrement' ].value = BloomPass.blurX;\n\t\tthis.convolutionUniforms[ 'cKernel' ].value = buildKernel( sigma );\n\n\t\t/**\n\t\t * The convolution pass material.\n\t\t *\n\t\t * @type {ShaderMaterial}\n\t\t */\n\t\tthis.materialConvolution = new ShaderMaterial( {\n\n\t\t\tname: convolutionShader.name,\n\t\t\tuniforms: this.convolutionUniforms,\n\t\t\tvertexShader: convolutionShader.vertexShader,\n\t\t\tfragmentShader: convolutionShader.fragmentShader,\n\t\t\tdefines: {\n\t\t\t\t'KERNEL_SIZE_FLOAT': kernelSize.toFixed( 1 ),\n\t\t\t\t'KERNEL_SIZE_INT': kernelSize.toFixed( 0 )\n\t\t\t}\n\n\t\t} );\n\n\t\t/**\n\t\t * Overwritten to disable the swap.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.needsSwap = false;\n\n\t\t// internals\n\n\t\tthis._renderTargetX = new WebGLRenderTarget( 1, 1, { type: HalfFloatType } ); // will be resized later\n\t\tthis._renderTargetX.texture.name = 'BloomPass.x';\n\t\tthis._renderTargetY = new WebGLRenderTarget( 1, 1, { type: HalfFloatType } ); // will be resized later\n\t\tthis._renderTargetY.texture.name = 'BloomPass.y';\n\n\t\tthis._fsQuad = new FullScreenQuad( null );\n\n\t}\n\n\t/**\n\t * Performs the Bloom pass.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\n\n\t\t// Render quad with blurred scene into texture (convolution pass 1)\n\n\t\tthis._fsQuad.material = this.materialConvolution;\n\n\t\tthis.convolutionUniforms[ 'tDiffuse' ].value = readBuffer.texture;\n\t\tthis.convolutionUniforms[ 'uImageIncrement' ].value = BloomPass.blurX;\n\n\t\trenderer.setRenderTarget( this._renderTargetX );\n\t\trenderer.clear();\n\t\tthis._fsQuad.render( renderer );\n\n\n\t\t// Render quad with blurred scene into texture (convolution pass 2)\n\n\t\tthis.convolutionUniforms[ 'tDiffuse' ].value = this._renderTargetX.texture;\n\t\tthis.convolutionUniforms[ 'uImageIncrement' ].value = BloomPass.blurY;\n\n\t\trenderer.setRenderTarget( this._renderTargetY );\n\t\trenderer.clear();\n\t\tthis._fsQuad.render( renderer );\n\n\t\t// Render original scene with superimposed blur to texture\n\n\t\tthis._fsQuad.material = this.materialCombine;\n\n\t\tthis.combineUniforms[ 'tDiffuse' ].value = this._renderTargetY.texture;\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\n\n\t\trenderer.setRenderTarget( readBuffer );\n\t\tif ( this.clear ) renderer.clear();\n\t\tthis._fsQuad.render( renderer );\n\n\t}\n\n\t/**\n\t * Sets the size of the pass.\n\t *\n\t * @param {number} width - The width to set.\n\t * @param {number} height - The height to set.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis._renderTargetX.setSize( width, height );\n\t\tthis._renderTargetY.setSize( width, height );\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the pass is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis._renderTargetX.dispose();\n\t\tthis._renderTargetY.dispose();\n\n\t\tthis.materialCombine.dispose();\n\t\tthis.materialConvolution.dispose();\n\n\t\tthis._fsQuad.dispose();\n\n\t}\n\n}\n\nconst CombineShader = {\n\n\tname: 'CombineShader',\n\n\tuniforms: {\n\n\t\t'tDiffuse': { value: null },\n\t\t'strength': { value: 1.0 }\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\tuniform float strength;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = strength * texel;\n\n\t\t}`\n\n};\n\nBloomPass.blurX = new Vector2( 0.001953125, 0.0 );\nBloomPass.blurY = new Vector2( 0.0, 0.001953125 );\n\n\nfunction gauss( x, sigma ) {\n\n\treturn Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );\n\n}\n\nfunction buildKernel( sigma ) {\n\n\t// We loop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n\n\tconst kMaxKernelSize = 25;\n\tlet kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;\n\n\tif ( kernelSize > kMaxKernelSize ) kernelSize = kMaxKernelSize;\n\n\tconst halfWidth = ( kernelSize - 1 ) * 0.5;\n\n\tconst values = new Array( kernelSize );\n\tlet sum = 0.0;\n\tfor ( let i = 0; i < kernelSize; ++ i ) {\n\n\t\tvalues[ i ] = gauss( i - halfWidth, sigma );\n\t\tsum += values[ i ];\n\n\t}\n\n\t// normalize the kernel\n\n\tfor ( let i = 0; i < kernelSize; ++ i ) values[ i ] /= sum;\n\n\treturn values;\n\n}\n\nexport { BloomPass };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}