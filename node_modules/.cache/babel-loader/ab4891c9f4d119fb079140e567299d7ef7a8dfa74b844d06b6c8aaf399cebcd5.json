{"ast":null,"code":"import { Color, ColorManagement, SRGBColorSpace } from 'three';\n\n/* global DracoEncoderModule */\n\n/**\n * An exporter to compress geometry with the Draco library.\n *\n * [Draco]{@link https://google.github.io/draco/} is an open source library for compressing and\n * decompressing 3D meshes and point clouds. Compressed geometry can be significantly smaller,\n * at the cost of additional decoding time on the client device.\n *\n * Standalone Draco files have a `.drc` extension, and contain vertex positions,\n * normals, colors, and other attributes. Draco files *do not* contain materials,\n * textures, animation, or node hierarchies â€“ to use these features, embed Draco geometry\n * inside of a glTF file. A normal glTF file can be converted to a Draco-compressed glTF file\n * using [glTF-Pipeline]{@link https://github.com/AnalyticalGraphicsInc/gltf-pipeline}.\n *\n * ```js\n * const exporter = new DRACOExporter();\n * const data = exporter.parse( mesh, options );\n * ```\n *\n * @three_import import { DRACOExporter } from 'three/addons/exporters/DRACOExporter.js';\n */\nclass DRACOExporter {\n  /**\n   * Parses the given mesh or point cloud and generates the Draco output.\n   *\n   * @param {(Mesh|Points)} object - The mesh or point cloud to export.\n   * @param {DRACOExporter~Options} options - The export options.\n   * @return {Int8Array} The exported Draco.\n   */\n  parse(object, options = {}) {\n    options = Object.assign({\n      decodeSpeed: 5,\n      encodeSpeed: 5,\n      encoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n      quantization: [16, 8, 8, 8, 8],\n      exportUvs: true,\n      exportNormals: true,\n      exportColor: false\n    }, options);\n    if (DracoEncoderModule === undefined) {\n      throw new Error('THREE.DRACOExporter: required the draco_encoder to work.');\n    }\n    const geometry = object.geometry;\n    const dracoEncoder = DracoEncoderModule();\n    const encoder = new dracoEncoder.Encoder();\n    let builder;\n    let dracoObject;\n    if (object.isMesh === true) {\n      builder = new dracoEncoder.MeshBuilder();\n      dracoObject = new dracoEncoder.Mesh();\n      const vertices = geometry.getAttribute('position');\n      builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n      const faces = geometry.getIndex();\n      if (faces !== null) {\n        builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);\n      } else {\n        const faces = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);\n        for (let i = 0; i < faces.length; i++) {\n          faces[i] = i;\n        }\n        builder.AddFacesToMesh(dracoObject, vertices.count, faces);\n      }\n      if (options.exportNormals === true) {\n        const normals = geometry.getAttribute('normal');\n        if (normals !== undefined) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array);\n        }\n      }\n      if (options.exportUvs === true) {\n        const uvs = geometry.getAttribute('uv');\n        if (uvs !== undefined) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);\n        }\n      }\n      if (options.exportColor === true) {\n        const colors = geometry.getAttribute('color');\n        if (colors !== undefined) {\n          const array = createVertexColorSRGBArray(colors);\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, array);\n        }\n      }\n    } else if (object.isPoints === true) {\n      builder = new dracoEncoder.PointCloudBuilder();\n      dracoObject = new dracoEncoder.PointCloud();\n      const vertices = geometry.getAttribute('position');\n      builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n      if (options.exportColor === true) {\n        const colors = geometry.getAttribute('color');\n        if (colors !== undefined) {\n          const array = createVertexColorSRGBArray(colors);\n          builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, array);\n        }\n      }\n    } else {\n      throw new Error('DRACOExporter: Unsupported object type.');\n    }\n\n    //Compress using draco encoder\n\n    const encodedData = new dracoEncoder.DracoInt8Array();\n\n    //Sets the desired encoding and decoding speed for the given options from 0 (slowest speed, but the best compression) to 10 (fastest, but the worst compression).\n\n    const encodeSpeed = options.encodeSpeed !== undefined ? options.encodeSpeed : 5;\n    const decodeSpeed = options.decodeSpeed !== undefined ? options.decodeSpeed : 5;\n    encoder.SetSpeedOptions(encodeSpeed, decodeSpeed);\n\n    // Sets the desired encoding method for a given geometry.\n\n    if (options.encoderMethod !== undefined) {\n      encoder.SetEncodingMethod(options.encoderMethod);\n    }\n\n    // Sets the quantization (number of bits used to represent) compression options for a named attribute.\n    // The attribute values will be quantized in a box defined by the maximum extent of the attribute values.\n    if (options.quantization !== undefined) {\n      for (let i = 0; i < 5; i++) {\n        if (options.quantization[i] !== undefined) {\n          encoder.SetAttributeQuantization(i, options.quantization[i]);\n        }\n      }\n    }\n    let length;\n    if (object.isMesh === true) {\n      length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);\n    } else {\n      length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);\n    }\n    dracoEncoder.destroy(dracoObject);\n    if (length === 0) {\n      throw new Error('THREE.DRACOExporter: Draco encoding failed.');\n    }\n\n    //Copy encoded data to buffer.\n    const outputData = new Int8Array(new ArrayBuffer(length));\n    for (let i = 0; i < length; i++) {\n      outputData[i] = encodedData.GetValue(i);\n    }\n    dracoEncoder.destroy(encodedData);\n    dracoEncoder.destroy(encoder);\n    dracoEncoder.destroy(builder);\n    return outputData;\n  }\n}\nfunction createVertexColorSRGBArray(attribute) {\n  // While .drc files do not specify colorspace, the only 'official' tooling\n  // is PLY and OBJ converters, which use sRGB. We'll assume sRGB is expected\n  // for .drc files, but note that Draco buffers embedded in glTF files will\n  // be Linear-sRGB instead.\n\n  const _color = new Color();\n  const count = attribute.count;\n  const itemSize = attribute.itemSize;\n  const array = new Float32Array(count * itemSize);\n  for (let i = 0, il = count; i < il; i++) {\n    _color.fromBufferAttribute(attribute, i);\n    ColorManagement.workingToColorSpace(_color, SRGBColorSpace);\n    array[i * itemSize] = _color.r;\n    array[i * itemSize + 1] = _color.g;\n    array[i * itemSize + 2] = _color.b;\n    if (itemSize === 4) {\n      array[i * itemSize + 3] = attribute.getW(i);\n    }\n  }\n  return array;\n}\n\n// Encoder methods\n\n/**\n * Edgebreaker encoding.\n *\n * @static\n * @constant\n * @type {number}\n * @default 1\n */\nDRACOExporter.MESH_EDGEBREAKER_ENCODING = 1;\n\n/**\n * Sequential encoding.\n *\n * @static\n * @constant\n * @type {number}\n * @default 0\n */\nDRACOExporter.MESH_SEQUENTIAL_ENCODING = 0;\n\n// Geometry type\n\nDRACOExporter.POINT_CLOUD = 0;\nDRACOExporter.TRIANGULAR_MESH = 1;\n\n// Attribute type\n\nDRACOExporter.INVALID = -1;\nDRACOExporter.POSITION = 0;\nDRACOExporter.NORMAL = 1;\nDRACOExporter.COLOR = 2;\nDRACOExporter.TEX_COORD = 3;\nDRACOExporter.GENERIC = 4;\n\n/**\n * Export options of `DRACOExporter`.\n *\n * @typedef {Object} DRACOExporter~Options\n * @property {number} [decodeSpeed=5] - Indicates how to tune the encoder regarding decode speed (0 gives better speed but worst quality).\n * @property {number} [encodeSpeed=5] - Indicates how to tune the encoder parameters (0 gives better speed but worst quality).\n * @property {number} [encoderMethod=1] - Either sequential (very little compression) or Edgebreaker. Edgebreaker traverses the triangles of the mesh in a deterministic, spiral-like way which provides most of the benefits of this data format.\n * @property {Array<number>} [quantization=[ 16, 8, 8, 8, 8 ]] - Indicates the precision of each type of data stored in the draco file in the order (POSITION, NORMAL, COLOR, TEX_COORD, GENERIC).\n * @property {boolean} [exportUvs=true] - Whether to export UVs or not.\n * @property {boolean} [exportNormals=true] - Whether to export normals or not.\n * @property {boolean} [exportColor=false] - Whether to export colors or not.\n **/\n\nexport { DRACOExporter };","map":{"version":3,"names":["Color","ColorManagement","SRGBColorSpace","DRACOExporter","parse","object","options","Object","assign","decodeSpeed","encodeSpeed","encoderMethod","MESH_EDGEBREAKER_ENCODING","quantization","exportUvs","exportNormals","exportColor","DracoEncoderModule","undefined","Error","geometry","dracoEncoder","encoder","Encoder","builder","dracoObject","isMesh","MeshBuilder","Mesh","vertices","getAttribute","AddFloatAttributeToMesh","POSITION","count","itemSize","array","faces","getIndex","AddFacesToMesh","Uint32Array","Uint16Array","i","length","normals","NORMAL","uvs","TEX_COORD","colors","createVertexColorSRGBArray","COLOR","isPoints","PointCloudBuilder","PointCloud","AddFloatAttribute","encodedData","DracoInt8Array","SetSpeedOptions","SetEncodingMethod","SetAttributeQuantization","EncodeMeshToDracoBuffer","EncodePointCloudToDracoBuffer","destroy","outputData","Int8Array","ArrayBuffer","GetValue","attribute","_color","Float32Array","il","fromBufferAttribute","workingToColorSpace","r","g","b","getW","MESH_SEQUENTIAL_ENCODING","POINT_CLOUD","TRIANGULAR_MESH","INVALID","GENERIC"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/exporters/DRACOExporter.js"],"sourcesContent":["import { Color, ColorManagement, SRGBColorSpace } from 'three';\n\n/* global DracoEncoderModule */\n\n/**\n * An exporter to compress geometry with the Draco library.\n *\n * [Draco]{@link https://google.github.io/draco/} is an open source library for compressing and\n * decompressing 3D meshes and point clouds. Compressed geometry can be significantly smaller,\n * at the cost of additional decoding time on the client device.\n *\n * Standalone Draco files have a `.drc` extension, and contain vertex positions,\n * normals, colors, and other attributes. Draco files *do not* contain materials,\n * textures, animation, or node hierarchies â€“ to use these features, embed Draco geometry\n * inside of a glTF file. A normal glTF file can be converted to a Draco-compressed glTF file\n * using [glTF-Pipeline]{@link https://github.com/AnalyticalGraphicsInc/gltf-pipeline}.\n *\n * ```js\n * const exporter = new DRACOExporter();\n * const data = exporter.parse( mesh, options );\n * ```\n *\n * @three_import import { DRACOExporter } from 'three/addons/exporters/DRACOExporter.js';\n */\nclass DRACOExporter {\n\n\t/**\n\t * Parses the given mesh or point cloud and generates the Draco output.\n\t *\n\t * @param {(Mesh|Points)} object - The mesh or point cloud to export.\n\t * @param {DRACOExporter~Options} options - The export options.\n\t * @return {Int8Array} The exported Draco.\n\t */\n\tparse( object, options = {} ) {\n\n\t\toptions = Object.assign( {\n\t\t\tdecodeSpeed: 5,\n\t\t\tencodeSpeed: 5,\n\t\t\tencoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n\t\t\tquantization: [ 16, 8, 8, 8, 8 ],\n\t\t\texportUvs: true,\n\t\t\texportNormals: true,\n\t\t\texportColor: false,\n\t\t}, options );\n\n\t\tif ( DracoEncoderModule === undefined ) {\n\n\t\t\tthrow new Error( 'THREE.DRACOExporter: required the draco_encoder to work.' );\n\n\t\t}\n\n\t\tconst geometry = object.geometry;\n\n\t\tconst dracoEncoder = DracoEncoderModule();\n\t\tconst encoder = new dracoEncoder.Encoder();\n\t\tlet builder;\n\t\tlet dracoObject;\n\n\t\tif ( object.isMesh === true ) {\n\n\t\t\tbuilder = new dracoEncoder.MeshBuilder();\n\t\t\tdracoObject = new dracoEncoder.Mesh();\n\n\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\tbuilder.AddFloatAttributeToMesh( dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array );\n\n\t\t\tconst faces = geometry.getIndex();\n\n\t\t\tif ( faces !== null ) {\n\n\t\t\t\tbuilder.AddFacesToMesh( dracoObject, faces.count / 3, faces.array );\n\n\t\t\t} else {\n\n\t\t\t\tconst faces = new ( vertices.count > 65535 ? Uint32Array : Uint16Array )( vertices.count );\n\n\t\t\t\tfor ( let i = 0; i < faces.length; i ++ ) {\n\n\t\t\t\t\tfaces[ i ] = i;\n\n\t\t\t\t}\n\n\t\t\t\tbuilder.AddFacesToMesh( dracoObject, vertices.count, faces );\n\n\t\t\t}\n\n\t\t\tif ( options.exportNormals === true ) {\n\n\t\t\t\tconst normals = geometry.getAttribute( 'normal' );\n\n\t\t\t\tif ( normals !== undefined ) {\n\n\t\t\t\t\tbuilder.AddFloatAttributeToMesh( dracoObject, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( options.exportUvs === true ) {\n\n\t\t\t\tconst uvs = geometry.getAttribute( 'uv' );\n\n\t\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\t\tbuilder.AddFloatAttributeToMesh( dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( options.exportColor === true ) {\n\n\t\t\t\tconst colors = geometry.getAttribute( 'color' );\n\n\t\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\t\tconst array = createVertexColorSRGBArray( colors );\n\n\t\t\t\t\tbuilder.AddFloatAttributeToMesh( dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, array );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( object.isPoints === true ) {\n\n\t\t\tbuilder = new dracoEncoder.PointCloudBuilder();\n\t\t\tdracoObject = new dracoEncoder.PointCloud();\n\n\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\tbuilder.AddFloatAttribute( dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array );\n\n\t\t\tif ( options.exportColor === true ) {\n\n\t\t\t\tconst colors = geometry.getAttribute( 'color' );\n\n\t\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\t\tconst array = createVertexColorSRGBArray( colors );\n\n\t\t\t\t\tbuilder.AddFloatAttribute( dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, array );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'DRACOExporter: Unsupported object type.' );\n\n\t\t}\n\n\t\t//Compress using draco encoder\n\n\t\tconst encodedData = new dracoEncoder.DracoInt8Array();\n\n\t\t//Sets the desired encoding and decoding speed for the given options from 0 (slowest speed, but the best compression) to 10 (fastest, but the worst compression).\n\n\t\tconst encodeSpeed = ( options.encodeSpeed !== undefined ) ? options.encodeSpeed : 5;\n\t\tconst decodeSpeed = ( options.decodeSpeed !== undefined ) ? options.decodeSpeed : 5;\n\n\t\tencoder.SetSpeedOptions( encodeSpeed, decodeSpeed );\n\n\t\t// Sets the desired encoding method for a given geometry.\n\n\t\tif ( options.encoderMethod !== undefined ) {\n\n\t\t\tencoder.SetEncodingMethod( options.encoderMethod );\n\n\t\t}\n\n\t\t// Sets the quantization (number of bits used to represent) compression options for a named attribute.\n\t\t// The attribute values will be quantized in a box defined by the maximum extent of the attribute values.\n\t\tif ( options.quantization !== undefined ) {\n\n\t\t\tfor ( let i = 0; i < 5; i ++ ) {\n\n\t\t\t\tif ( options.quantization[ i ] !== undefined ) {\n\n\t\t\t\t\tencoder.SetAttributeQuantization( i, options.quantization[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet length;\n\n\t\tif ( object.isMesh === true ) {\n\n\t\t\tlength = encoder.EncodeMeshToDracoBuffer( dracoObject, encodedData );\n\n\t\t} else {\n\n\t\t\tlength = encoder.EncodePointCloudToDracoBuffer( dracoObject, true, encodedData );\n\n\t\t}\n\n\t\tdracoEncoder.destroy( dracoObject );\n\n\t\tif ( length === 0 ) {\n\n\t\t\tthrow new Error( 'THREE.DRACOExporter: Draco encoding failed.' );\n\n\t\t}\n\n\t\t//Copy encoded data to buffer.\n\t\tconst outputData = new Int8Array( new ArrayBuffer( length ) );\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\toutputData[ i ] = encodedData.GetValue( i );\n\n\t\t}\n\n\t\tdracoEncoder.destroy( encodedData );\n\t\tdracoEncoder.destroy( encoder );\n\t\tdracoEncoder.destroy( builder );\n\n\t\treturn outputData;\n\n\t}\n\n}\n\nfunction createVertexColorSRGBArray( attribute ) {\n\n\t// While .drc files do not specify colorspace, the only 'official' tooling\n\t// is PLY and OBJ converters, which use sRGB. We'll assume sRGB is expected\n\t// for .drc files, but note that Draco buffers embedded in glTF files will\n\t// be Linear-sRGB instead.\n\n\tconst _color = new Color();\n\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst array = new Float32Array( count * itemSize );\n\n\tfor ( let i = 0, il = count; i < il; i ++ ) {\n\n\t\t_color.fromBufferAttribute( attribute, i );\n\n\t\tColorManagement.workingToColorSpace( _color, SRGBColorSpace );\n\n\t\tarray[ i * itemSize ] = _color.r;\n\t\tarray[ i * itemSize + 1 ] = _color.g;\n\t\tarray[ i * itemSize + 2 ] = _color.b;\n\n\t\tif ( itemSize === 4 ) {\n\n\t\t\tarray[ i * itemSize + 3 ] = attribute.getW( i );\n\n\t\t}\n\n\t}\n\n\treturn array;\n\n}\n\n// Encoder methods\n\n/**\n * Edgebreaker encoding.\n *\n * @static\n * @constant\n * @type {number}\n * @default 1\n */\nDRACOExporter.MESH_EDGEBREAKER_ENCODING = 1;\n\n/**\n * Sequential encoding.\n *\n * @static\n * @constant\n * @type {number}\n * @default 0\n */\nDRACOExporter.MESH_SEQUENTIAL_ENCODING = 0;\n\n// Geometry type\n\nDRACOExporter.POINT_CLOUD = 0;\nDRACOExporter.TRIANGULAR_MESH = 1;\n\n// Attribute type\n\nDRACOExporter.INVALID = - 1;\nDRACOExporter.POSITION = 0;\nDRACOExporter.NORMAL = 1;\nDRACOExporter.COLOR = 2;\nDRACOExporter.TEX_COORD = 3;\nDRACOExporter.GENERIC = 4;\n\n/**\n * Export options of `DRACOExporter`.\n *\n * @typedef {Object} DRACOExporter~Options\n * @property {number} [decodeSpeed=5] - Indicates how to tune the encoder regarding decode speed (0 gives better speed but worst quality).\n * @property {number} [encodeSpeed=5] - Indicates how to tune the encoder parameters (0 gives better speed but worst quality).\n * @property {number} [encoderMethod=1] - Either sequential (very little compression) or Edgebreaker. Edgebreaker traverses the triangles of the mesh in a deterministic, spiral-like way which provides most of the benefits of this data format.\n * @property {Array<number>} [quantization=[ 16, 8, 8, 8, 8 ]] - Indicates the precision of each type of data stored in the draco file in the order (POSITION, NORMAL, COLOR, TEX_COORD, GENERIC).\n * @property {boolean} [exportUvs=true] - Whether to export UVs or not.\n * @property {boolean} [exportNormals=true] - Whether to export normals or not.\n * @property {boolean} [exportColor=false] - Whether to export colors or not.\n **/\n\nexport { DRACOExporter };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}