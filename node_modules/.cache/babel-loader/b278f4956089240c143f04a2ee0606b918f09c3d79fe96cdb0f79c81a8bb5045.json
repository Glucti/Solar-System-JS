{"ast":null,"code":"import { AnimationClip, AnimationMixer, Matrix4, Quaternion, QuaternionKeyframeTrack, SkeletonHelper, Vector3, VectorKeyframeTrack } from 'three';\n\n/**\n * @module SkeletonUtils\n * @three_import import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';\n */\n\nfunction getBoneName(bone, options) {\n  if (options.getBoneName !== undefined) {\n    return options.getBoneName(bone);\n  }\n  return options.names[bone.name];\n}\n\n/**\n * Retargets the skeleton from the given source 3D object to the\n * target 3D object.\n *\n * @param {Object3D} target - The target 3D object.\n * @param {Object3D} source - The source 3D object.\n * @param {module:SkeletonUtils~RetargetOptions} options - The options.\n */\nfunction retarget(target, source, options = {}) {\n  const quat = new Quaternion(),\n    scale = new Vector3(),\n    relativeMatrix = new Matrix4(),\n    globalMatrix = new Matrix4();\n  options.preserveBoneMatrix = options.preserveBoneMatrix !== undefined ? options.preserveBoneMatrix : true;\n  options.preserveBonePositions = options.preserveBonePositions !== undefined ? options.preserveBonePositions : true;\n  options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n  options.hip = options.hip !== undefined ? options.hip : 'hip';\n  options.hipInfluence = options.hipInfluence !== undefined ? options.hipInfluence : new Vector3(1, 1, 1);\n  options.scale = options.scale !== undefined ? options.scale : 1;\n  options.names = options.names || {};\n  const sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source),\n    bones = target.isObject3D ? target.skeleton.bones : getBones(target);\n  let bone, name, boneTo, bonesPosition;\n\n  // reset bones\n\n  if (target.isObject3D) {\n    target.skeleton.pose();\n  } else {\n    options.useTargetMatrix = true;\n    options.preserveBoneMatrix = false;\n  }\n  if (options.preserveBonePositions) {\n    bonesPosition = [];\n    for (let i = 0; i < bones.length; i++) {\n      bonesPosition.push(bones[i].position.clone());\n    }\n  }\n  if (options.preserveBoneMatrix) {\n    // reset matrix\n\n    target.updateMatrixWorld();\n    target.matrixWorld.identity();\n\n    // reset children matrix\n\n    for (let i = 0; i < target.children.length; ++i) {\n      target.children[i].updateMatrixWorld(true);\n    }\n  }\n  for (let i = 0; i < bones.length; ++i) {\n    bone = bones[i];\n    name = getBoneName(bone, options);\n    boneTo = getBoneByName(name, sourceBones);\n    globalMatrix.copy(bone.matrixWorld);\n    if (boneTo) {\n      boneTo.updateMatrixWorld();\n      if (options.useTargetMatrix) {\n        relativeMatrix.copy(boneTo.matrixWorld);\n      } else {\n        relativeMatrix.copy(target.matrixWorld).invert();\n        relativeMatrix.multiply(boneTo.matrixWorld);\n      }\n\n      // ignore scale to extract rotation\n\n      scale.setFromMatrixScale(relativeMatrix);\n      relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));\n\n      // apply to global matrix\n\n      globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n      if (target.isObject3D) {\n        if (options.localOffsets) {\n          if (options.localOffsets[bone.name]) {\n            globalMatrix.multiply(options.localOffsets[bone.name]);\n          }\n        }\n      }\n      globalMatrix.copyPosition(relativeMatrix);\n    }\n    if (name === options.hip) {\n      globalMatrix.elements[12] *= options.scale * options.hipInfluence.x;\n      globalMatrix.elements[13] *= options.scale * options.hipInfluence.y;\n      globalMatrix.elements[14] *= options.scale * options.hipInfluence.z;\n      if (options.hipPosition !== undefined) {\n        globalMatrix.elements[12] += options.hipPosition.x * options.scale;\n        globalMatrix.elements[13] += options.hipPosition.y * options.scale;\n        globalMatrix.elements[14] += options.hipPosition.z * options.scale;\n      }\n    }\n    if (bone.parent) {\n      bone.matrix.copy(bone.parent.matrixWorld).invert();\n      bone.matrix.multiply(globalMatrix);\n    } else {\n      bone.matrix.copy(globalMatrix);\n    }\n    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n    bone.updateMatrixWorld();\n  }\n  if (options.preserveBonePositions) {\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = getBoneName(bone, options) || bone.name;\n      if (name !== options.hip) {\n        bone.position.copy(bonesPosition[i]);\n      }\n    }\n  }\n  if (options.preserveBoneMatrix) {\n    // restore matrix\n\n    target.updateMatrixWorld(true);\n  }\n}\n\n/**\n * Retargets the animation clip of the source object to the\n * target 3D object.\n *\n * @param {Object3D} target - The target 3D object.\n * @param {Object3D} source - The source 3D object.\n * @param {AnimationClip} clip - The animation clip.\n * @param {module:SkeletonUtils~RetargetOptions} options - The options.\n * @return {AnimationClip} The retargeted animation clip.\n */\nfunction retargetClip(target, source, clip, options = {}) {\n  options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n\n  // Calculate the fps from the source clip based on the track with the most frames, unless fps is already provided.\n  options.fps = options.fps !== undefined ? options.fps : Math.max(...clip.tracks.map(track => track.times.length)) / clip.duration;\n  options.names = options.names || [];\n  if (!source.isObject3D) {\n    source = getHelperFromSkeleton(source);\n  }\n  const numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n    delta = clip.duration / (numFrames - 1),\n    convertedTracks = [],\n    mixer = new AnimationMixer(source),\n    bones = getBones(target.skeleton),\n    boneDatas = [];\n  let positionOffset, bone, boneTo, boneData, name;\n  mixer.clipAction(clip).play();\n\n  // trim\n\n  let start = 0,\n    end = numFrames;\n  if (options.trim !== undefined) {\n    start = Math.round(options.trim[0] * options.fps);\n    end = Math.min(Math.round(options.trim[1] * options.fps), numFrames) - start;\n    mixer.update(options.trim[0]);\n  } else {\n    mixer.update(0);\n  }\n  source.updateMatrixWorld();\n\n  //\n\n  for (let frame = 0; frame < end; ++frame) {\n    const time = frame * delta;\n    retarget(target, source, options);\n    for (let j = 0; j < bones.length; ++j) {\n      bone = bones[j];\n      name = getBoneName(bone, options) || bone.name;\n      boneTo = getBoneByName(name, source.skeleton);\n      if (boneTo) {\n        boneData = boneDatas[j] = boneDatas[j] || {\n          bone: bone\n        };\n        if (options.hip === name) {\n          if (!boneData.pos) {\n            boneData.pos = {\n              times: new Float32Array(end),\n              values: new Float32Array(end * 3)\n            };\n          }\n          if (options.useFirstFramePosition) {\n            if (frame === 0) {\n              positionOffset = bone.position.clone();\n            }\n            bone.position.sub(positionOffset);\n          }\n          boneData.pos.times[frame] = time;\n          bone.position.toArray(boneData.pos.values, frame * 3);\n        }\n        if (!boneData.quat) {\n          boneData.quat = {\n            times: new Float32Array(end),\n            values: new Float32Array(end * 4)\n          };\n        }\n        boneData.quat.times[frame] = time;\n        bone.quaternion.toArray(boneData.quat.values, frame * 4);\n      }\n    }\n    if (frame === end - 2) {\n      // last mixer update before final loop iteration\n      // make sure we do not go over or equal to clip duration\n      mixer.update(delta - 0.0000001);\n    } else {\n      mixer.update(delta);\n    }\n    source.updateMatrixWorld();\n  }\n  for (let i = 0; i < boneDatas.length; ++i) {\n    boneData = boneDatas[i];\n    if (boneData) {\n      if (boneData.pos) {\n        convertedTracks.push(new VectorKeyframeTrack('.bones[' + boneData.bone.name + '].position', boneData.pos.times, boneData.pos.values));\n      }\n      convertedTracks.push(new QuaternionKeyframeTrack('.bones[' + boneData.bone.name + '].quaternion', boneData.quat.times, boneData.quat.values));\n    }\n  }\n  mixer.uncacheAction(clip);\n  return new AnimationClip(clip.name, -1, convertedTracks);\n}\n\n/**\n * Clones the given 3D object and its descendants, ensuring that any `SkinnedMesh` instances are\n * correctly associated with their bones. Bones are also cloned, and must be descendants of the\n * object passed to this method. Other data, like geometries and materials, are reused by reference.\n *\n * @param {Object3D} source - The 3D object to clone.\n * @return {Object3D} The cloned 3D object.\n */\nfunction clone(source) {\n  const sourceLookup = new Map();\n  const cloneLookup = new Map();\n  const clone = source.clone();\n  parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n    sourceLookup.set(clonedNode, sourceNode);\n    cloneLookup.set(sourceNode, clonedNode);\n  });\n  clone.traverse(function (node) {\n    if (!node.isSkinnedMesh) return;\n    const clonedMesh = node;\n    const sourceMesh = sourceLookup.get(node);\n    const sourceBones = sourceMesh.skeleton.bones;\n    clonedMesh.skeleton = sourceMesh.skeleton.clone();\n    clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n    clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n      return cloneLookup.get(bone);\n    });\n    clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n  });\n  return clone;\n}\n\n// internal helper\n\nfunction getBoneByName(name, skeleton) {\n  for (let i = 0, bones = getBones(skeleton); i < bones.length; i++) {\n    if (name === bones[i].name) return bones[i];\n  }\n}\nfunction getBones(skeleton) {\n  return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n}\nfunction getHelperFromSkeleton(skeleton) {\n  const source = new SkeletonHelper(skeleton.bones[0]);\n  source.skeleton = skeleton;\n  return source;\n}\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\n\n/**\n * Retarget options of `SkeletonUtils`.\n *\n * @typedef {Object} module:SkeletonUtils~RetargetOptions\n * @property {boolean} [useFirstFramePosition=false] - Whether to use the position of the first frame or not.\n * @property {number} [fps] - The FPS of the clip.\n * @property {Object<string,string>} [names] - A dictionary for mapping target to source bone names.\n * @property {function(string):string} [getBoneName] - A function for mapping bone names. Alternative to `names`.\n * @property {Array<number>} [trim] - Whether to trim the clip or not. If set the array should hold two values for the start and end.\n * @property {boolean} [preserveBoneMatrix=true] - Whether to preserve bone matrices or not.\n * @property {boolean} [preserveBonePositions=true] - Whether to preserve bone positions or not.\n * @property {boolean} [useTargetMatrix=false] - Whether to use the target matrix or not.\n * @property {string} [hip='hip'] - The name of the source's hip bone.\n * @property {Vector3} [hipInfluence=(1,1,1)] - The hip influence.\n * @property {number} [scale=1] - The scale.\n **/\n\nexport { retarget, retargetClip, clone };","map":{"version":3,"names":["AnimationClip","AnimationMixer","Matrix4","Quaternion","QuaternionKeyframeTrack","SkeletonHelper","Vector3","VectorKeyframeTrack","getBoneName","bone","options","undefined","names","name","retarget","target","source","quat","scale","relativeMatrix","globalMatrix","preserveBoneMatrix","preserveBonePositions","useTargetMatrix","hip","hipInfluence","sourceBones","isObject3D","skeleton","bones","getBones","boneTo","bonesPosition","pose","i","length","push","position","clone","updateMatrixWorld","matrixWorld","identity","children","getBoneByName","copy","invert","multiply","setFromMatrixScale","set","x","y","z","makeRotationFromQuaternion","setFromRotationMatrix","localOffsets","copyPosition","elements","hipPosition","parent","matrix","decompose","quaternion","retargetClip","clip","useFirstFramePosition","fps","Math","max","tracks","map","track","times","duration","getHelperFromSkeleton","numFrames","round","delta","convertedTracks","mixer","boneDatas","positionOffset","boneData","clipAction","play","start","end","trim","min","update","frame","time","j","pos","Float32Array","values","sub","toArray","uncacheAction","sourceLookup","Map","cloneLookup","parallelTraverse","sourceNode","clonedNode","traverse","node","isSkinnedMesh","clonedMesh","sourceMesh","get","bindMatrix","bind","Array","isArray","a","b","callback"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/utils/SkeletonUtils.js"],"sourcesContent":["import {\n\tAnimationClip,\n\tAnimationMixer,\n\tMatrix4,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tSkeletonHelper,\n\tVector3,\n\tVectorKeyframeTrack\n} from 'three';\n\n/**\n * @module SkeletonUtils\n * @three_import import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';\n */\n\nfunction getBoneName( bone, options ) {\n\n\tif ( options.getBoneName !== undefined ) {\n\n\t\treturn options.getBoneName( bone );\n\n\t}\n\n\treturn options.names[ bone.name ];\n\n}\n\n/**\n * Retargets the skeleton from the given source 3D object to the\n * target 3D object.\n *\n * @param {Object3D} target - The target 3D object.\n * @param {Object3D} source - The source 3D object.\n * @param {module:SkeletonUtils~RetargetOptions} options - The options.\n */\nfunction retarget( target, source, options = {} ) {\n\n\tconst quat = new Quaternion(),\n\t\tscale = new Vector3(),\n\t\trelativeMatrix = new Matrix4(),\n\t\tglobalMatrix = new Matrix4();\n\n\toptions.preserveBoneMatrix = options.preserveBoneMatrix !== undefined ? options.preserveBoneMatrix : true;\n\toptions.preserveBonePositions = options.preserveBonePositions !== undefined ? options.preserveBonePositions : true;\n\toptions.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n\toptions.hip = options.hip !== undefined ? options.hip : 'hip';\n\toptions.hipInfluence = options.hipInfluence !== undefined ? options.hipInfluence : new Vector3( 1, 1, 1 );\n\toptions.scale = options.scale !== undefined ? options.scale : 1;\n\toptions.names = options.names || {};\n\n\tconst sourceBones = source.isObject3D ? source.skeleton.bones : getBones( source ),\n\t\tbones = target.isObject3D ? target.skeleton.bones : getBones( target );\n\n\tlet bone, name, boneTo,\n\t\tbonesPosition;\n\n\t// reset bones\n\n\tif ( target.isObject3D ) {\n\n\t\ttarget.skeleton.pose();\n\n\t} else {\n\n\t\toptions.useTargetMatrix = true;\n\t\toptions.preserveBoneMatrix = false;\n\n\t}\n\n\tif ( options.preserveBonePositions ) {\n\n\t\tbonesPosition = [];\n\n\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\tbonesPosition.push( bones[ i ].position.clone() );\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveBoneMatrix ) {\n\n\t\t// reset matrix\n\n\t\ttarget.updateMatrixWorld();\n\n\t\ttarget.matrixWorld.identity();\n\n\t\t// reset children matrix\n\n\t\tfor ( let i = 0; i < target.children.length; ++ i ) {\n\n\t\t\ttarget.children[ i ].updateMatrixWorld( true );\n\n\t\t}\n\n\t}\n\n\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\tbone = bones[ i ];\n\t\tname = getBoneName( bone, options );\n\n\t\tboneTo = getBoneByName( name, sourceBones );\n\n\t\tglobalMatrix.copy( bone.matrixWorld );\n\n\t\tif ( boneTo ) {\n\n\t\t\tboneTo.updateMatrixWorld();\n\n\t\t\tif ( options.useTargetMatrix ) {\n\n\t\t\t\trelativeMatrix.copy( boneTo.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\trelativeMatrix.copy( target.matrixWorld ).invert();\n\t\t\t\trelativeMatrix.multiply( boneTo.matrixWorld );\n\n\t\t\t}\n\n\t\t\t// ignore scale to extract rotation\n\n\t\t\tscale.setFromMatrixScale( relativeMatrix );\n\t\t\trelativeMatrix.scale( scale.set( 1 / scale.x, 1 / scale.y, 1 / scale.z ) );\n\n\t\t\t// apply to global matrix\n\n\t\t\tglobalMatrix.makeRotationFromQuaternion( quat.setFromRotationMatrix( relativeMatrix ) );\n\n\t\t\tif ( target.isObject3D ) {\n\n\t\t\t\tif ( options.localOffsets ) {\n\n\t\t\t\t\tif ( options.localOffsets[ bone.name ] ) {\n\n\t\t\t\t\t\tglobalMatrix.multiply( options.localOffsets[ bone.name ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tglobalMatrix.copyPosition( relativeMatrix );\n\n\t\t}\n\n\t\tif ( name === options.hip ) {\n\n\t\t\tglobalMatrix.elements[ 12 ] *= options.scale * options.hipInfluence.x;\n\t\t\tglobalMatrix.elements[ 13 ] *= options.scale * options.hipInfluence.y;\n\t\t\tglobalMatrix.elements[ 14 ] *= options.scale * options.hipInfluence.z;\n\n\t\t\tif ( options.hipPosition !== undefined ) {\n\n\t\t\t\tglobalMatrix.elements[ 12 ] += options.hipPosition.x * options.scale;\n\t\t\t\tglobalMatrix.elements[ 13 ] += options.hipPosition.y * options.scale;\n\t\t\t\tglobalMatrix.elements[ 14 ] += options.hipPosition.z * options.scale;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( bone.parent ) {\n\n\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\tbone.matrix.multiply( globalMatrix );\n\n\t\t} else {\n\n\t\t\tbone.matrix.copy( globalMatrix );\n\n\t\t}\n\n\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\tbone.updateMatrixWorld();\n\n\t}\n\n\tif ( options.preserveBonePositions ) {\n\n\t\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\t\tbone = bones[ i ];\n\t\t\tname = getBoneName( bone, options ) || bone.name;\n\n\t\t\tif ( name !== options.hip ) {\n\n\t\t\t\tbone.position.copy( bonesPosition[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveBoneMatrix ) {\n\n\t\t// restore matrix\n\n\t\ttarget.updateMatrixWorld( true );\n\n\t}\n\n}\n\n/**\n * Retargets the animation clip of the source object to the\n * target 3D object.\n *\n * @param {Object3D} target - The target 3D object.\n * @param {Object3D} source - The source 3D object.\n * @param {AnimationClip} clip - The animation clip.\n * @param {module:SkeletonUtils~RetargetOptions} options - The options.\n * @return {AnimationClip} The retargeted animation clip.\n */\nfunction retargetClip( target, source, clip, options = {} ) {\n\n\toptions.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n\n\t// Calculate the fps from the source clip based on the track with the most frames, unless fps is already provided.\n\toptions.fps = options.fps !== undefined ? options.fps : ( Math.max( ...clip.tracks.map( track => track.times.length ) ) / clip.duration );\n\toptions.names = options.names || [];\n\n\tif ( ! source.isObject3D ) {\n\n\t\tsource = getHelperFromSkeleton( source );\n\n\t}\n\n\tconst numFrames = Math.round( clip.duration * ( options.fps / 1000 ) * 1000 ),\n\t\tdelta = clip.duration / ( numFrames - 1 ),\n\t\tconvertedTracks = [],\n\t\tmixer = new AnimationMixer( source ),\n\t\tbones = getBones( target.skeleton ),\n\t\tboneDatas = [];\n\n\tlet positionOffset,\n\t\tbone, boneTo, boneData,\n\t\tname;\n\n\tmixer.clipAction( clip ).play();\n\n\t// trim\n\n\tlet start = 0, end = numFrames;\n\n\tif ( options.trim !== undefined ) {\n\n\t\tstart = Math.round( options.trim[ 0 ] * options.fps );\n\t\tend = Math.min( Math.round( options.trim[ 1 ] * options.fps ), numFrames ) - start;\n\n\t\tmixer.update( options.trim[ 0 ] );\n\n\t} else {\n\n\t\tmixer.update( 0 );\n\n\t}\n\n\tsource.updateMatrixWorld();\n\n\t//\n\n\tfor ( let frame = 0; frame < end; ++ frame ) {\n\n\t\tconst time = frame * delta;\n\n\t\tretarget( target, source, options );\n\n\t\tfor ( let j = 0; j < bones.length; ++ j ) {\n\n\t\t\tbone = bones[ j ];\n\t\t\tname = getBoneName( bone, options ) || bone.name;\n\t\t\tboneTo = getBoneByName( name, source.skeleton );\n\n\t\t\tif ( boneTo ) {\n\n\t\t\t\tboneData = boneDatas[ j ] = boneDatas[ j ] || { bone: bone };\n\n\t\t\t\tif ( options.hip === name ) {\n\n\t\t\t\t\tif ( ! boneData.pos ) {\n\n\t\t\t\t\t\tboneData.pos = {\n\t\t\t\t\t\t\ttimes: new Float32Array( end ),\n\t\t\t\t\t\t\tvalues: new Float32Array( end * 3 )\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( options.useFirstFramePosition ) {\n\n\t\t\t\t\t\tif ( frame === 0 ) {\n\n\t\t\t\t\t\t\tpositionOffset = bone.position.clone();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbone.position.sub( positionOffset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.pos.times[ frame ] = time;\n\n\t\t\t\t\tbone.position.toArray( boneData.pos.values, frame * 3 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! boneData.quat ) {\n\n\t\t\t\t\tboneData.quat = {\n\t\t\t\t\t\ttimes: new Float32Array( end ),\n\t\t\t\t\t\tvalues: new Float32Array( end * 4 )\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tboneData.quat.times[ frame ] = time;\n\n\t\t\t\tbone.quaternion.toArray( boneData.quat.values, frame * 4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( frame === end - 2 ) {\n\n\t\t\t// last mixer update before final loop iteration\n\t\t\t// make sure we do not go over or equal to clip duration\n\t\t\tmixer.update( delta - 0.0000001 );\n\n\t\t} else {\n\n\t\t\tmixer.update( delta );\n\n\t\t}\n\n\t\tsource.updateMatrixWorld();\n\n\t}\n\n\tfor ( let i = 0; i < boneDatas.length; ++ i ) {\n\n\t\tboneData = boneDatas[ i ];\n\n\t\tif ( boneData ) {\n\n\t\t\tif ( boneData.pos ) {\n\n\t\t\t\tconvertedTracks.push( new VectorKeyframeTrack(\n\t\t\t\t\t'.bones[' + boneData.bone.name + '].position',\n\t\t\t\t\tboneData.pos.times,\n\t\t\t\t\tboneData.pos.values\n\t\t\t\t) );\n\n\t\t\t}\n\n\t\t\tconvertedTracks.push( new QuaternionKeyframeTrack(\n\t\t\t\t'.bones[' + boneData.bone.name + '].quaternion',\n\t\t\t\tboneData.quat.times,\n\t\t\t\tboneData.quat.values\n\t\t\t) );\n\n\t\t}\n\n\t}\n\n\tmixer.uncacheAction( clip );\n\n\treturn new AnimationClip( clip.name, - 1, convertedTracks );\n\n}\n\n/**\n * Clones the given 3D object and its descendants, ensuring that any `SkinnedMesh` instances are\n * correctly associated with their bones. Bones are also cloned, and must be descendants of the\n * object passed to this method. Other data, like geometries and materials, are reused by reference.\n *\n * @param {Object3D} source - The 3D object to clone.\n * @return {Object3D} The cloned 3D object.\n */\nfunction clone( source ) {\n\n\tconst sourceLookup = new Map();\n\tconst cloneLookup = new Map();\n\n\tconst clone = source.clone();\n\n\tparallelTraverse( source, clone, function ( sourceNode, clonedNode ) {\n\n\t\tsourceLookup.set( clonedNode, sourceNode );\n\t\tcloneLookup.set( sourceNode, clonedNode );\n\n\t} );\n\n\tclone.traverse( function ( node ) {\n\n\t\tif ( ! node.isSkinnedMesh ) return;\n\n\t\tconst clonedMesh = node;\n\t\tconst sourceMesh = sourceLookup.get( node );\n\t\tconst sourceBones = sourceMesh.skeleton.bones;\n\n\t\tclonedMesh.skeleton = sourceMesh.skeleton.clone();\n\t\tclonedMesh.bindMatrix.copy( sourceMesh.bindMatrix );\n\n\t\tclonedMesh.skeleton.bones = sourceBones.map( function ( bone ) {\n\n\t\t\treturn cloneLookup.get( bone );\n\n\t\t} );\n\n\t\tclonedMesh.bind( clonedMesh.skeleton, clonedMesh.bindMatrix );\n\n\t} );\n\n\treturn clone;\n\n}\n\n// internal helper\n\nfunction getBoneByName( name, skeleton ) {\n\n\tfor ( let i = 0, bones = getBones( skeleton ); i < bones.length; i ++ ) {\n\n\t\tif ( name === bones[ i ].name )\n\n\t\t\treturn bones[ i ];\n\n\t}\n\n}\n\nfunction getBones( skeleton ) {\n\n\treturn Array.isArray( skeleton ) ? skeleton : skeleton.bones;\n\n}\n\n\nfunction getHelperFromSkeleton( skeleton ) {\n\n\tconst source = new SkeletonHelper( skeleton.bones[ 0 ] );\n\tsource.skeleton = skeleton;\n\n\treturn source;\n\n}\n\nfunction parallelTraverse( a, b, callback ) {\n\n\tcallback( a, b );\n\n\tfor ( let i = 0; i < a.children.length; i ++ ) {\n\n\t\tparallelTraverse( a.children[ i ], b.children[ i ], callback );\n\n\t}\n\n}\n\n/**\n * Retarget options of `SkeletonUtils`.\n *\n * @typedef {Object} module:SkeletonUtils~RetargetOptions\n * @property {boolean} [useFirstFramePosition=false] - Whether to use the position of the first frame or not.\n * @property {number} [fps] - The FPS of the clip.\n * @property {Object<string,string>} [names] - A dictionary for mapping target to source bone names.\n * @property {function(string):string} [getBoneName] - A function for mapping bone names. Alternative to `names`.\n * @property {Array<number>} [trim] - Whether to trim the clip or not. If set the array should hold two values for the start and end.\n * @property {boolean} [preserveBoneMatrix=true] - Whether to preserve bone matrices or not.\n * @property {boolean} [preserveBonePositions=true] - Whether to preserve bone positions or not.\n * @property {boolean} [useTargetMatrix=false] - Whether to use the target matrix or not.\n * @property {string} [hip='hip'] - The name of the source's hip bone.\n * @property {Vector3} [hipInfluence=(1,1,1)] - The hip influence.\n * @property {number} [scale=1] - The scale.\n **/\n\nexport {\n\tretarget,\n\tretargetClip,\n\tclone,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}