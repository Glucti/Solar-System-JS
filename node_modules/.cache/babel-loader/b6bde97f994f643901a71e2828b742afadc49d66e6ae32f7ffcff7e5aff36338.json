{"ast":null,"code":"import { BufferAttribute, BufferGeometry, Color, FileLoader, Group, LineBasicMaterial, LineSegments, Loader, Matrix4, Mesh, MeshStandardMaterial, SRGBColorSpace, Vector3, Ray } from 'three';\n\n// Special surface finish tag types.\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5;\n\n// State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\nconst FILE_LOCATION_TRY_PARTS = 0;\nconst FILE_LOCATION_TRY_P = 1;\nconst FILE_LOCATION_TRY_MODELS = 2;\nconst FILE_LOCATION_AS_IS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\nconst MAIN_COLOUR_CODE = '16';\nconst MAIN_EDGE_COLOUR_CODE = '24';\nconst COLOR_SPACE_LDRAW = SRGBColorSpace;\nconst _tempVec0 = new Vector3();\nconst _tempVec1 = new Vector3();\nclass ConditionalLineSegments extends LineSegments {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.isConditionalLine = true;\n  }\n}\nfunction generateFaceNormals(faces) {\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const face = faces[i];\n    const vertices = face.vertices;\n    const v0 = vertices[0];\n    const v1 = vertices[1];\n    const v2 = vertices[2];\n    _tempVec0.subVectors(v1, v0);\n    _tempVec1.subVectors(v2, v1);\n    face.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n  }\n}\nconst _ray = new Ray();\nfunction smoothNormals(faces, lineSegments, checkSubSegments = false) {\n  // NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because\n  // it allows edges to be smoothed as expected (see minifig arms).\n  // --\n  // And the vector values are initialize multiplied by 1 + 1e-10 to account for floating\n  // point errors on vertices along quantization boundaries. Ie after matrix multiplication\n  // vertices that should be merged might be set to \"1.7\" and \"1.6999...\" meaning they won't\n  // get merged. This added epsilon attempts to push these error values to the same quantized\n  // value for the sake of hashing. See \"AT-ST mini\" dishes. See mrdoob/three#23169.\n\n  const hashMultiplier = (1 + 1e-10) * 1e2;\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  function hashEdge(v0, v1) {\n    return `${hashVertex(v0)}_${hashVertex(v1)}`;\n  }\n\n  // converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected\n  // onto the original line.\n  function toNormalizedRay(v0, v1, targetRay) {\n    targetRay.direction.subVectors(v1, v0).normalize();\n    const scalar = v0.dot(targetRay.direction);\n    targetRay.origin.copy(v0).addScaledVector(targetRay.direction, -scalar);\n    return targetRay;\n  }\n  function hashRay(ray) {\n    return hashEdge(ray.origin, ray.direction);\n  }\n  const hardEdges = new Set();\n  const hardEdgeRays = new Map();\n  const halfEdgeList = {};\n  const normals = [];\n\n  // Save the list of hard edges by hash\n  for (let i = 0, l = lineSegments.length; i < l; i++) {\n    const ls = lineSegments[i];\n    const vertices = ls.vertices;\n    const v0 = vertices[0];\n    const v1 = vertices[1];\n    hardEdges.add(hashEdge(v0, v1));\n    hardEdges.add(hashEdge(v1, v0));\n\n    // only generate the hard edge ray map if we're checking subsegments because it's more expensive to check\n    // and requires more memory.\n    if (checkSubSegments) {\n      // add both ray directions to the map\n      const ray = toNormalizedRay(v0, v1, new Ray());\n      const rh1 = hashRay(ray);\n      if (!hardEdgeRays.has(rh1)) {\n        toNormalizedRay(v1, v0, ray);\n        const rh2 = hashRay(ray);\n        const info = {\n          ray,\n          distances: []\n        };\n        hardEdgeRays.set(rh1, info);\n        hardEdgeRays.set(rh2, info);\n      }\n\n      // store both segments ends in min, max order in the distances array to check if a face edge is a\n      // subsegment later.\n      const info = hardEdgeRays.get(rh1);\n      let d0 = info.ray.direction.dot(v0);\n      let d1 = info.ray.direction.dot(v1);\n      if (d0 > d1) {\n        [d0, d1] = [d1, d0];\n      }\n      info.distances.push(d0, d1);\n    }\n  }\n\n  // track the half edges associated with each triangle\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const tri = faces[i];\n    const vertices = tri.vertices;\n    const vertCount = vertices.length;\n    for (let i2 = 0; i2 < vertCount; i2++) {\n      const index = i2;\n      const next = (i2 + 1) % vertCount;\n      const v0 = vertices[index];\n      const v1 = vertices[next];\n      const hash = hashEdge(v0, v1);\n\n      // don't add the triangle if the edge is supposed to be hard\n      if (hardEdges.has(hash)) {\n        continue;\n      }\n\n      // if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds\n      if (checkSubSegments) {\n        toNormalizedRay(v0, v1, _ray);\n        const rayHash = hashRay(_ray);\n        if (hardEdgeRays.has(rayHash)) {\n          const info = hardEdgeRays.get(rayHash);\n          const {\n            ray,\n            distances\n          } = info;\n          let d0 = ray.direction.dot(v0);\n          let d1 = ray.direction.dot(v1);\n          if (d0 > d1) {\n            [d0, d1] = [d1, d0];\n          }\n\n          // return early if the face edge is found to be a subsegment of a line edge meaning the edge will have \"hard\" normals\n          let found = false;\n          for (let i = 0, l = distances.length; i < l; i += 2) {\n            if (d0 >= distances[i] && d1 <= distances[i + 1]) {\n              found = true;\n              break;\n            }\n          }\n          if (found) {\n            continue;\n          }\n        }\n      }\n      const info = {\n        index: index,\n        tri: tri\n      };\n      halfEdgeList[hash] = info;\n    }\n  }\n\n  // Iterate until we've tried to connect all faces to share normals\n  while (true) {\n    // Stop if there are no more faces left\n    let halfEdge = null;\n    for (const key in halfEdgeList) {\n      halfEdge = halfEdgeList[key];\n      break;\n    }\n    if (halfEdge === null) {\n      break;\n    }\n\n    // Exhaustively find all connected faces\n    const queue = [halfEdge];\n    while (queue.length > 0) {\n      // initialize all vertex normals in this triangle\n      const tri = queue.pop().tri;\n      const vertices = tri.vertices;\n      const vertNormals = tri.normals;\n      const faceNormal = tri.faceNormal;\n\n      // Check if any edge is connected to another triangle edge\n      const vertCount = vertices.length;\n      for (let i2 = 0; i2 < vertCount; i2++) {\n        const index = i2;\n        const next = (i2 + 1) % vertCount;\n        const v0 = vertices[index];\n        const v1 = vertices[next];\n\n        // delete this triangle from the list so it won't be found again\n        const hash = hashEdge(v0, v1);\n        delete halfEdgeList[hash];\n        const reverseHash = hashEdge(v1, v0);\n        const otherInfo = halfEdgeList[reverseHash];\n        if (otherInfo) {\n          const otherTri = otherInfo.tri;\n          const otherIndex = otherInfo.index;\n          const otherNormals = otherTri.normals;\n          const otherVertCount = otherNormals.length;\n          const otherFaceNormal = otherTri.faceNormal;\n\n          // NOTE: If the angle between faces is > 67.5 degrees then assume it's\n          // hard edge. There are some cases where the line segments do not line up exactly\n          // with or span multiple triangle edges (see Lunar Vehicle wheels).\n          if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n            continue;\n          }\n\n          // if this triangle has already been traversed then it won't be in\n          // the halfEdgeList. If it has not then add it to the queue and delete\n          // it so it won't be found again.\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherInfo);\n            delete halfEdgeList[reverseHash];\n          }\n\n          // share the first normal\n          const otherNext = (otherIndex + 1) % otherVertCount;\n          if (vertNormals[index] && otherNormals[otherNext] && vertNormals[index] !== otherNormals[otherNext]) {\n            otherNormals[otherNext].norm.add(vertNormals[index].norm);\n            vertNormals[index].norm = otherNormals[otherNext].norm;\n          }\n          let sharedNormal1 = vertNormals[index] || otherNormals[otherNext];\n          if (sharedNormal1 === null) {\n            // it's possible to encounter an edge of a triangle that has already been traversed meaning\n            // both edges already have different normals defined and shared. To work around this we create\n            // a wrapper object so when those edges are merged the normals can be updated everywhere.\n            sharedNormal1 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal1.norm);\n          }\n          if (vertNormals[index] === null) {\n            vertNormals[index] = sharedNormal1;\n            sharedNormal1.norm.add(faceNormal);\n          }\n          if (otherNormals[otherNext] === null) {\n            otherNormals[otherNext] = sharedNormal1;\n            sharedNormal1.norm.add(otherFaceNormal);\n          }\n\n          // share the second normal\n          if (vertNormals[next] && otherNormals[otherIndex] && vertNormals[next] !== otherNormals[otherIndex]) {\n            otherNormals[otherIndex].norm.add(vertNormals[next].norm);\n            vertNormals[next].norm = otherNormals[otherIndex].norm;\n          }\n          let sharedNormal2 = vertNormals[next] || otherNormals[otherIndex];\n          if (sharedNormal2 === null) {\n            sharedNormal2 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal2.norm);\n          }\n          if (vertNormals[next] === null) {\n            vertNormals[next] = sharedNormal2;\n            sharedNormal2.norm.add(faceNormal);\n          }\n          if (otherNormals[otherIndex] === null) {\n            otherNormals[otherIndex] = sharedNormal2;\n            sharedNormal2.norm.add(otherFaceNormal);\n          }\n        }\n      }\n    }\n  }\n\n  // The normals of each face have been added up so now we average them by normalizing the vector.\n  for (let i = 0, l = normals.length; i < l; i++) {\n    normals[i].normalize();\n  }\n}\nfunction isPartType(type) {\n  return type === 'Part' || type === 'Unofficial_Part';\n}\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === 'Subpart';\n}\nclass LineParser {\n  constructor(line, lineNumber) {\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = ' ';\n    this.lineNumber = lineNumber;\n  }\n  seekNonSpace() {\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n      if (this.currentChar !== ' ' && this.currentChar !== '\\t') {\n        return;\n      }\n      this.currentCharIndex++;\n    }\n  }\n  getToken() {\n    const pos0 = this.currentCharIndex++;\n\n    // Seek space\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n      if (this.currentChar === ' ' || this.currentChar === '\\t') {\n        break;\n      }\n      this.currentCharIndex++;\n    }\n    const pos1 = this.currentCharIndex;\n    this.seekNonSpace();\n    return this.line.substring(pos0, pos1);\n  }\n  getVector() {\n    return new Vector3(parseFloat(this.getToken()), parseFloat(this.getToken()), parseFloat(this.getToken()));\n  }\n  getRemainingString() {\n    return this.line.substring(this.currentCharIndex, this.lineLength);\n  }\n  isAtTheEnd() {\n    return this.currentCharIndex >= this.lineLength;\n  }\n  setToEnd() {\n    this.currentCharIndex = this.lineLength;\n  }\n  getLineNumberString() {\n    return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n  }\n}\n\n// Fetches and parses an intermediate representation of LDraw parts files.\nclass LDrawParsedCache {\n  constructor(loader) {\n    this.loader = loader;\n    this._cache = {};\n  }\n  cloneResult(original) {\n    const result = {};\n\n    // vertices are transformed and normals computed before being converted to geometry\n    // so these pieces must be cloned.\n    result.faces = original.faces.map(face => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map(v => v.clone()),\n        normals: face.normals.map(() => null),\n        faceNormal: null\n      };\n    });\n    result.conditionalSegments = original.conditionalSegments.map(face => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map(v => v.clone()),\n        controlPoints: face.controlPoints.map(v => v.clone())\n      };\n    });\n    result.lineSegments = original.lineSegments.map(face => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map(v => v.clone())\n      };\n    });\n\n    // none if this is subsequently modified\n    result.type = original.type;\n    result.category = original.category;\n    result.keywords = original.keywords;\n    result.author = original.author;\n    result.subobjects = original.subobjects;\n    result.fileName = original.fileName;\n    result.totalFaces = original.totalFaces;\n    result.startingBuildingStep = original.startingBuildingStep;\n    result.materials = original.materials;\n    result.group = null;\n    return result;\n  }\n  async fetchData(fileName) {\n    let triedLowerCase = false;\n    let locationState = FILE_LOCATION_TRY_PARTS;\n    while (locationState !== FILE_LOCATION_NOT_FOUND) {\n      let subobjectURL = fileName;\n      switch (locationState) {\n        case FILE_LOCATION_AS_IS:\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_PARTS:\n          subobjectURL = 'parts/' + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_P:\n          subobjectURL = 'p/' + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_MODELS:\n          subobjectURL = 'models/' + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_RELATIVE:\n          subobjectURL = fileName.substring(0, fileName.lastIndexOf('/') + 1) + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_ABSOLUTE:\n          if (triedLowerCase) {\n            // Try absolute path\n            locationState = FILE_LOCATION_NOT_FOUND;\n          } else {\n            // Next attempt is lower case\n            fileName = fileName.toLowerCase();\n            subobjectURL = fileName;\n            triedLowerCase = true;\n            locationState = FILE_LOCATION_TRY_PARTS;\n          }\n          break;\n      }\n      const loader = this.loader;\n      const fileLoader = new FileLoader(loader.manager);\n      fileLoader.setPath(loader.partsLibraryPath);\n      fileLoader.setRequestHeader(loader.requestHeader);\n      fileLoader.setWithCredentials(loader.withCredentials);\n      try {\n        const text = await fileLoader.loadAsync(subobjectURL);\n        return text;\n      } catch (_) {\n        continue;\n      }\n    }\n    throw new Error('LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.');\n  }\n  parse(text, fileName = null) {\n    const loader = this.loader;\n\n    // final results\n    const faces = [];\n    const lineSegments = [];\n    const conditionalSegments = [];\n    const subobjects = [];\n    const materials = {};\n    const getLocalMaterial = colorCode => {\n      return materials[colorCode] || null;\n    };\n    let type = 'Model';\n    let category = null;\n    let keywords = null;\n    let author = null;\n    let totalFaces = 0;\n\n    // split into lines\n    if (text.indexOf('\\r\\n') !== -1) {\n      // This is faster than String.split with regex that splits on both\n      text = text.replace(/\\r\\n/g, '\\n');\n    }\n    const lines = text.split('\\n');\n    const numLines = lines.length;\n    let parsingEmbeddedFiles = false;\n    let currentEmbeddedFileName = null;\n    let currentEmbeddedText = null;\n    let bfcCertified = false;\n    let bfcCCW = true;\n    let bfcInverted = false;\n    let bfcCull = true;\n    let startingBuildingStep = false;\n\n    // Parse all line commands\n    for (let lineIndex = 0; lineIndex < numLines; lineIndex++) {\n      const line = lines[lineIndex];\n      if (line.length === 0) continue;\n      if (parsingEmbeddedFiles) {\n        if (line.startsWith('0 FILE ')) {\n          // Save previous embedded file in the cache\n          this.setData(currentEmbeddedFileName, currentEmbeddedText);\n\n          // New embedded text file\n          currentEmbeddedFileName = line.substring(7);\n          currentEmbeddedText = '';\n        } else {\n          currentEmbeddedText += line + '\\n';\n        }\n        continue;\n      }\n      const lp = new LineParser(line, lineIndex + 1);\n      lp.seekNonSpace();\n      if (lp.isAtTheEnd()) {\n        // Empty line\n        continue;\n      }\n\n      // Parse the line type\n      const lineType = lp.getToken();\n      let material;\n      let colorCode;\n      let segment;\n      let ccw;\n      let doubleSided;\n      let v0, v1, v2, v3, c0, c1;\n      switch (lineType) {\n        // Line type 0: Comment or META\n        case '0':\n          // Parse meta directive\n          const meta = lp.getToken();\n          if (meta) {\n            switch (meta) {\n              case '!LDRAW_ORG':\n                type = lp.getToken();\n                break;\n              case '!COLOUR':\n                material = loader.parseColorMetaDirective(lp);\n                if (material) {\n                  materials[material.userData.code] = material;\n                } else {\n                  console.warn('LDrawLoader: Error parsing material' + lp.getLineNumberString());\n                }\n                break;\n              case '!CATEGORY':\n                category = lp.getToken();\n                break;\n              case '!KEYWORDS':\n                const newKeywords = lp.getRemainingString().split(',');\n                if (newKeywords.length > 0) {\n                  if (!keywords) {\n                    keywords = [];\n                  }\n                  newKeywords.forEach(function (keyword) {\n                    keywords.push(keyword.trim());\n                  });\n                }\n                break;\n              case 'FILE':\n                if (lineIndex > 0) {\n                  // Start embedded text files parsing\n                  parsingEmbeddedFiles = true;\n                  currentEmbeddedFileName = lp.getRemainingString();\n                  currentEmbeddedText = '';\n                  bfcCertified = false;\n                  bfcCCW = true;\n                }\n                break;\n              case 'BFC':\n                // Changes to the backface culling state\n                while (!lp.isAtTheEnd()) {\n                  const token = lp.getToken();\n                  switch (token) {\n                    case 'CERTIFY':\n                    case 'NOCERTIFY':\n                      bfcCertified = token === 'CERTIFY';\n                      bfcCCW = true;\n                      break;\n                    case 'CW':\n                    case 'CCW':\n                      bfcCCW = token === 'CCW';\n                      break;\n                    case 'INVERTNEXT':\n                      bfcInverted = true;\n                      break;\n                    case 'CLIP':\n                    case 'NOCLIP':\n                      bfcCull = token === 'CLIP';\n                      break;\n                    default:\n                      console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                      break;\n                  }\n                }\n                break;\n              case 'STEP':\n                startingBuildingStep = true;\n                break;\n              case 'Author:':\n                author = lp.getToken();\n                break;\n              default:\n                // Other meta directives are not implemented\n                break;\n            }\n          }\n          break;\n\n        // Line type 1: Sub-object file\n        case '1':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          const posX = parseFloat(lp.getToken());\n          const posY = parseFloat(lp.getToken());\n          const posZ = parseFloat(lp.getToken());\n          const m0 = parseFloat(lp.getToken());\n          const m1 = parseFloat(lp.getToken());\n          const m2 = parseFloat(lp.getToken());\n          const m3 = parseFloat(lp.getToken());\n          const m4 = parseFloat(lp.getToken());\n          const m5 = parseFloat(lp.getToken());\n          const m6 = parseFloat(lp.getToken());\n          const m7 = parseFloat(lp.getToken());\n          const m8 = parseFloat(lp.getToken());\n          const matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n          let fileName = lp.getRemainingString().trim().replace(/\\\\/g, '/');\n          if (loader.fileMap[fileName]) {\n            // Found the subobject path in the preloaded file path map\n            fileName = loader.fileMap[fileName];\n          } else {\n            // Standardized subfolders\n            if (fileName.startsWith('s/')) {\n              fileName = 'parts/' + fileName;\n            } else if (fileName.startsWith('48/')) {\n              fileName = 'p/' + fileName;\n            }\n          }\n          subobjects.push({\n            material: material,\n            colorCode: colorCode,\n            matrix: matrix,\n            fileName: fileName,\n            inverted: bfcInverted,\n            startingBuildingStep: startingBuildingStep\n          });\n          startingBuildingStep = false;\n          bfcInverted = false;\n          break;\n\n        // Line type 2: Line segment\n        case '2':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          v0 = lp.getVector();\n          v1 = lp.getVector();\n          segment = {\n            material: material,\n            colorCode: colorCode,\n            vertices: [v0, v1]\n          };\n          lineSegments.push(segment);\n          break;\n\n        // Line type 5: Conditional Line segment\n        case '5':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          v0 = lp.getVector();\n          v1 = lp.getVector();\n          c0 = lp.getVector();\n          c1 = lp.getVector();\n          segment = {\n            material: material,\n            colorCode: colorCode,\n            vertices: [v0, v1],\n            controlPoints: [c0, c1]\n          };\n          conditionalSegments.push(segment);\n          break;\n\n        // Line type 3: Triangle\n        case '3':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          ccw = bfcCCW;\n          doubleSided = !bfcCertified || !bfcCull;\n          if (ccw === true) {\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            v2 = lp.getVector();\n          } else {\n            v2 = lp.getVector();\n            v1 = lp.getVector();\n            v0 = lp.getVector();\n          }\n          faces.push({\n            material: material,\n            colorCode: colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2],\n            normals: [null, null, null]\n          });\n          totalFaces++;\n          if (doubleSided === true) {\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v2, v1, v0],\n              normals: [null, null, null]\n            });\n            totalFaces++;\n          }\n          break;\n\n        // Line type 4: Quadrilateral\n        case '4':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          ccw = bfcCCW;\n          doubleSided = !bfcCertified || !bfcCull;\n          if (ccw === true) {\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            v2 = lp.getVector();\n            v3 = lp.getVector();\n          } else {\n            v3 = lp.getVector();\n            v2 = lp.getVector();\n            v1 = lp.getVector();\n            v0 = lp.getVector();\n          }\n\n          // specifically place the triangle diagonal in the v0 and v1 slots so we can\n          // account for the doubling of vertices later when smoothing normals.\n          faces.push({\n            material: material,\n            colorCode: colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2, v3],\n            normals: [null, null, null, null]\n          });\n          totalFaces += 2;\n          if (doubleSided === true) {\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v3, v2, v1, v0],\n              normals: [null, null, null, null]\n            });\n            totalFaces += 2;\n          }\n          break;\n        default:\n          throw new Error('LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.');\n      }\n    }\n    if (parsingEmbeddedFiles) {\n      this.setData(currentEmbeddedFileName, currentEmbeddedText);\n    }\n    return {\n      faces,\n      conditionalSegments,\n      lineSegments,\n      type,\n      category,\n      keywords,\n      author,\n      subobjects,\n      totalFaces,\n      startingBuildingStep,\n      materials,\n      fileName,\n      group: null\n    };\n  }\n\n  // returns an (optionally cloned) instance of the data\n  getData(fileName, clone = true) {\n    const key = fileName.toLowerCase();\n    const result = this._cache[key];\n    if (result === null || result instanceof Promise) {\n      return null;\n    }\n    if (clone) {\n      return this.cloneResult(result);\n    } else {\n      return result;\n    }\n  }\n\n  // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n  // the data is ready to use and can be retrieved synchronously with \"getData\".\n  async ensureDataLoaded(fileName) {\n    const key = fileName.toLowerCase();\n    if (!(key in this._cache)) {\n      // replace the promise with a copy of the parsed data for immediate processing\n      this._cache[key] = this.fetchData(fileName).then(text => {\n        const info = this.parse(text, fileName);\n        this._cache[key] = info;\n        return info;\n      });\n    }\n    await this._cache[key];\n  }\n\n  // sets the data in the cache from parsed data\n  setData(fileName, text) {\n    const key = fileName.toLowerCase();\n    this._cache[key] = this.parse(text, fileName);\n  }\n}\n\n// returns the material for an associated color code. If the color code is 16 for a face or 24 for\n// an edge then the passthroughColorCode is used.\nfunction getMaterialFromCode(colorCode, parentColorCode, materialHierarchy, forEdge) {\n  const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n  if (isPassthrough) {\n    colorCode = parentColorCode;\n  }\n  return materialHierarchy[colorCode] || null;\n}\n\n// Class used to parse and build LDraw parts as three.js objects and cache them if they're a \"Part\" type.\nclass LDrawPartsGeometryCache {\n  constructor(loader) {\n    this.loader = loader;\n    this.parseCache = new LDrawParsedCache(loader);\n    this._cache = {};\n  }\n\n  // Convert the given file information into a mesh by processing subobjects.\n  async processIntoMesh(info) {\n    const loader = this.loader;\n    const parseCache = this.parseCache;\n    const faceMaterials = new Set();\n\n    // Processes the part subobject information to load child parts and merge geometry onto part\n    // piece object.\n    const processInfoSubobjects = async (info, subobject = null) => {\n      const subobjects = info.subobjects;\n      const promises = [];\n\n      // Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate\n      // group which lets instruction steps apply correctly.\n      for (let i = 0, l = subobjects.length; i < l; i++) {\n        const subobject = subobjects[i];\n        const promise = parseCache.ensureDataLoaded(subobject.fileName).then(() => {\n          const subobjectInfo = parseCache.getData(subobject.fileName, false);\n          if (!isPrimitiveType(subobjectInfo.type)) {\n            return this.loadModel(subobject.fileName).catch(error => {\n              console.warn(error);\n              return null;\n            });\n          }\n          return processInfoSubobjects(parseCache.getData(subobject.fileName), subobject);\n        });\n        promises.push(promise);\n      }\n      const group = new Group();\n      group.userData.category = info.category;\n      group.userData.keywords = info.keywords;\n      group.userData.author = info.author;\n      group.userData.type = info.type;\n      group.userData.fileName = info.fileName;\n      info.group = group;\n      const subobjectInfos = await Promise.all(promises);\n      for (let i = 0, l = subobjectInfos.length; i < l; i++) {\n        const subobject = info.subobjects[i];\n        const subobjectInfo = subobjectInfos[i];\n        if (subobjectInfo === null) {\n          // the subobject failed to load\n          continue;\n        }\n\n        // if the subobject was loaded as a separate group then apply the parent scopes materials\n        if (subobjectInfo.isGroup) {\n          const subobjectGroup = subobjectInfo;\n          subobject.matrix.decompose(subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale);\n          subobjectGroup.userData.startingBuildingStep = subobject.startingBuildingStep;\n          subobjectGroup.name = subobject.fileName;\n          loader.applyMaterialsToMesh(subobjectGroup, subobject.colorCode, info.materials);\n          subobjectGroup.userData.colorCode = subobject.colorCode;\n          group.add(subobjectGroup);\n          continue;\n        }\n\n        // add the subobject group if it has children in case it has both children and primitives\n        if (subobjectInfo.group.children.length) {\n          group.add(subobjectInfo.group);\n        }\n\n        // transform the primitives into the local space of the parent piece and append them to\n        // to the parent primitives list.\n        const parentLineSegments = info.lineSegments;\n        const parentConditionalSegments = info.conditionalSegments;\n        const parentFaces = info.faces;\n        const lineSegments = subobjectInfo.lineSegments;\n        const conditionalSegments = subobjectInfo.conditionalSegments;\n        const faces = subobjectInfo.faces;\n        const matrix = subobject.matrix;\n        const inverted = subobject.inverted;\n        const matrixScaleInverted = matrix.determinant() < 0;\n        const colorCode = subobject.colorCode;\n        const lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n        for (let i = 0, l = lineSegments.length; i < l; i++) {\n          const ls = lineSegments[i];\n          const vertices = ls.vertices;\n          vertices[0].applyMatrix4(matrix);\n          vertices[1].applyMatrix4(matrix);\n          ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n          ls.material = ls.material || getMaterialFromCode(ls.colorCode, ls.colorCode, info.materials, true);\n          parentLineSegments.push(ls);\n        }\n        for (let i = 0, l = conditionalSegments.length; i < l; i++) {\n          const os = conditionalSegments[i];\n          const vertices = os.vertices;\n          const controlPoints = os.controlPoints;\n          vertices[0].applyMatrix4(matrix);\n          vertices[1].applyMatrix4(matrix);\n          controlPoints[0].applyMatrix4(matrix);\n          controlPoints[1].applyMatrix4(matrix);\n          os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n          os.material = os.material || getMaterialFromCode(os.colorCode, os.colorCode, info.materials, true);\n          parentConditionalSegments.push(os);\n        }\n        for (let i = 0, l = faces.length; i < l; i++) {\n          const tri = faces[i];\n          const vertices = tri.vertices;\n          for (let i = 0, l = vertices.length; i < l; i++) {\n            vertices[i].applyMatrix4(matrix);\n          }\n          tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n          tri.material = tri.material || getMaterialFromCode(tri.colorCode, colorCode, info.materials, false);\n          faceMaterials.add(tri.colorCode);\n\n          // If the scale of the object is negated then the triangle winding order\n          // needs to be flipped.\n          if (matrixScaleInverted !== inverted) {\n            vertices.reverse();\n          }\n          parentFaces.push(tri);\n        }\n        info.totalFaces += subobjectInfo.totalFaces;\n      }\n\n      // Apply the parent subobjects pass through material code to this object. This is done several times due\n      // to material scoping.\n      if (subobject) {\n        loader.applyMaterialsToMesh(group, subobject.colorCode, info.materials);\n        group.userData.colorCode = subobject.colorCode;\n      }\n      return info;\n    };\n\n    // Track material use to see if we need to use the normal smooth slow path for hard edges.\n    for (let i = 0, l = info.faces; i < l; i++) {\n      faceMaterials.add(info.faces[i].colorCode);\n    }\n    await processInfoSubobjects(info);\n    if (loader.smoothNormals) {\n      const checkSubSegments = faceMaterials.size > 1;\n      generateFaceNormals(info.faces);\n      smoothNormals(info.faces, info.lineSegments, checkSubSegments);\n    }\n\n    // Add the primitive objects and metadata.\n    const group = info.group;\n    if (info.faces.length > 0) {\n      group.add(createObject(this.loader, info.faces, 3, false, info.totalFaces));\n    }\n    if (info.lineSegments.length > 0) {\n      group.add(createObject(this.loader, info.lineSegments, 2));\n    }\n    if (info.conditionalSegments.length > 0) {\n      group.add(createObject(this.loader, info.conditionalSegments, 2, true));\n    }\n    return group;\n  }\n  hasCachedModel(fileName) {\n    return fileName !== null && fileName.toLowerCase() in this._cache;\n  }\n  async getCachedModel(fileName) {\n    if (fileName !== null && this.hasCachedModel(fileName)) {\n      const key = fileName.toLowerCase();\n      const group = await this._cache[key];\n      return group.clone();\n    } else {\n      return null;\n    }\n  }\n\n  // Loads and parses the model with the given file name. Returns a cached copy if available.\n  async loadModel(fileName) {\n    const parseCache = this.parseCache;\n    const key = fileName.toLowerCase();\n    if (this.hasCachedModel(fileName)) {\n      // Return cached model if available.\n      return this.getCachedModel(fileName);\n    } else {\n      // Otherwise parse a new model.\n      // Ensure the file data is loaded and pre parsed.\n      await parseCache.ensureDataLoaded(fileName);\n      const info = parseCache.getData(fileName);\n      const promise = this.processIntoMesh(info);\n\n      // Now that the file has loaded it's possible that another part parse has been waiting in parallel\n      // so check the cache again to see if it's been added since the last async operation so we don't\n      // do unnecessary work.\n      if (this.hasCachedModel(fileName)) {\n        return this.getCachedModel(fileName);\n      }\n\n      // Cache object if it's a part so it can be reused later.\n      if (isPartType(info.type)) {\n        this._cache[key] = promise;\n      }\n\n      // return a copy\n      const group = await promise;\n      return group.clone();\n    }\n  }\n\n  // parses the given model text into a renderable object. Returns cached copy if available.\n  async parseModel(text) {\n    const parseCache = this.parseCache;\n    const info = parseCache.parse(text);\n    if (isPartType(info.type) && this.hasCachedModel(info.fileName)) {\n      return this.getCachedModel(info.fileName);\n    }\n    return this.processIntoMesh(info);\n  }\n}\nfunction sortByMaterial(a, b) {\n  if (a.colorCode === b.colorCode) {\n    return 0;\n  }\n  if (a.colorCode < b.colorCode) {\n    return -1;\n  }\n  return 1;\n}\nfunction createObject(loader, elements, elementSize, isConditionalSegments = false, totalElements = null) {\n  // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n  // With per face / segment material, implemented with mesh groups and materials array\n\n  // Sort the faces or line segments by color code to make later the mesh groups\n  elements.sort(sortByMaterial);\n  if (totalElements === null) {\n    totalElements = elements.length;\n  }\n  const positions = new Float32Array(elementSize * totalElements * 3);\n  const normals = elementSize === 3 ? new Float32Array(elementSize * totalElements * 3) : null;\n  const materials = [];\n  const quadArray = new Array(6);\n  const bufferGeometry = new BufferGeometry();\n  let prevMaterial = null;\n  let index0 = 0;\n  let numGroupVerts = 0;\n  let offset = 0;\n  for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    const elem = elements[iElem];\n    let vertices = elem.vertices;\n    if (vertices.length === 4) {\n      quadArray[0] = vertices[0];\n      quadArray[1] = vertices[1];\n      quadArray[2] = vertices[2];\n      quadArray[3] = vertices[0];\n      quadArray[4] = vertices[2];\n      quadArray[5] = vertices[3];\n      vertices = quadArray;\n    }\n    for (let j = 0, l = vertices.length; j < l; j++) {\n      const v = vertices[j];\n      const index = offset + j * 3;\n      positions[index + 0] = v.x;\n      positions[index + 1] = v.y;\n      positions[index + 2] = v.z;\n    }\n\n    // create the normals array if this is a set of faces\n    if (elementSize === 3) {\n      if (!elem.faceNormal) {\n        const v0 = vertices[0];\n        const v1 = vertices[1];\n        const v2 = vertices[2];\n        _tempVec0.subVectors(v1, v0);\n        _tempVec1.subVectors(v2, v1);\n        elem.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n      }\n      let elemNormals = elem.normals;\n      if (elemNormals.length === 4) {\n        quadArray[0] = elemNormals[0];\n        quadArray[1] = elemNormals[1];\n        quadArray[2] = elemNormals[2];\n        quadArray[3] = elemNormals[0];\n        quadArray[4] = elemNormals[2];\n        quadArray[5] = elemNormals[3];\n        elemNormals = quadArray;\n      }\n      for (let j = 0, l = elemNormals.length; j < l; j++) {\n        // use face normal if a vertex normal is not provided\n        let n = elem.faceNormal;\n        if (elemNormals[j]) {\n          n = elemNormals[j].norm;\n        }\n        const index = offset + j * 3;\n        normals[index + 0] = n.x;\n        normals[index + 1] = n.y;\n        normals[index + 2] = n.z;\n      }\n    }\n    if (prevMaterial !== elem.colorCode) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n      }\n      const material = elem.material;\n      if (material !== null) {\n        if (elementSize === 3) {\n          materials.push(material);\n        } else if (elementSize === 2) {\n          if (isConditionalSegments) {\n            const edgeMaterial = loader.edgeMaterialCache.get(material);\n            materials.push(loader.conditionalEdgeMaterialCache.get(edgeMaterial));\n          } else {\n            materials.push(loader.edgeMaterialCache.get(material));\n          }\n        }\n      } else {\n        // If a material has not been made available yet then keep the color code string in the material array\n        // to save the spot for the material once a parent scopes materials are being applied to the object.\n        materials.push(elem.colorCode);\n      }\n      prevMaterial = elem.colorCode;\n      index0 = offset / 3;\n      numGroupVerts = vertices.length;\n    } else {\n      numGroupVerts += vertices.length;\n    }\n    offset += 3 * vertices.length;\n  }\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n  }\n  bufferGeometry.setAttribute('position', new BufferAttribute(positions, 3));\n  if (normals !== null) {\n    bufferGeometry.setAttribute('normal', new BufferAttribute(normals, 3));\n  }\n  let object3d = null;\n  if (elementSize === 2) {\n    if (isConditionalSegments) {\n      object3d = new ConditionalLineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    } else {\n      object3d = new LineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    }\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n  }\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true;\n    const controlArray0 = new Float32Array(elements.length * 3 * 2);\n    const controlArray1 = new Float32Array(elements.length * 3 * 2);\n    const directionArray = new Float32Array(elements.length * 3 * 2);\n    for (let i = 0, l = elements.length; i < l; i++) {\n      const os = elements[i];\n      const vertices = os.vertices;\n      const controlPoints = os.controlPoints;\n      const c0 = controlPoints[0];\n      const c1 = controlPoints[1];\n      const v0 = vertices[0];\n      const v1 = vertices[1];\n      const index = i * 3 * 2;\n      controlArray0[index + 0] = c0.x;\n      controlArray0[index + 1] = c0.y;\n      controlArray0[index + 2] = c0.z;\n      controlArray0[index + 3] = c0.x;\n      controlArray0[index + 4] = c0.y;\n      controlArray0[index + 5] = c0.z;\n      controlArray1[index + 0] = c1.x;\n      controlArray1[index + 1] = c1.y;\n      controlArray1[index + 2] = c1.z;\n      controlArray1[index + 3] = c1.x;\n      controlArray1[index + 4] = c1.y;\n      controlArray1[index + 5] = c1.z;\n      directionArray[index + 0] = v1.x - v0.x;\n      directionArray[index + 1] = v1.y - v0.y;\n      directionArray[index + 2] = v1.z - v0.z;\n      directionArray[index + 3] = v1.x - v0.x;\n      directionArray[index + 4] = v1.y - v0.y;\n      directionArray[index + 5] = v1.z - v0.z;\n    }\n    bufferGeometry.setAttribute('control0', new BufferAttribute(controlArray0, 3, false));\n    bufferGeometry.setAttribute('control1', new BufferAttribute(controlArray1, 3, false));\n    bufferGeometry.setAttribute('direction', new BufferAttribute(directionArray, 3, false));\n  }\n  return object3d;\n}\n\n/**\n * A loader for the LDraw format.\n *\n * [LDraw]{@link https://ldraw.org/} (LEGO Draw) is an [open format specification]{@link https://ldraw.org/article/218.html}\n * for describing LEGO and other construction set 3D models.\n *\n * An LDraw asset (a text file usually with extension .ldr, .dat or .txt) can describe just a single construction\n * piece, or an entire model. In the case of a model the LDraw file can reference other LDraw files, which are\n * loaded from a library path set with `setPartsLibraryPath`. You usually download the LDraw official parts library,\n * extract to a folder and point setPartsLibraryPath to it.\n *\n * Library parts will be loaded by trial and error in subfolders 'parts', 'p' and 'models'. These file accesses\n * are not optimal for web environment, so a script tool has been made to pack an LDraw file with all its dependencies\n * into a single file, which loads much faster. See section 'Packing LDraw models'. The LDrawLoader example loads\n * several packed files. The official parts library is not included due to its large size.\n *\n * `LDrawLoader` supports the following extensions:\n * - !COLOUR: Color and surface finish declarations.\n * - BFC: Back Face Culling specification.\n * - !CATEGORY: Model/part category declarations.\n * - !KEYWORDS: Model/part keywords declarations.\n *\n * ```js\n * const loader = new LDrawLoader();\n * loader.setConditionalLineMaterial( LDrawConditionalLineMaterial ); // the type of line material depends on the used renderer\n * const object = await loader.loadAsync( 'models/ldraw/officialLibrary/models/car.ldr_Packed.mpd' );\n * scene.add( object );\n * ```\n *\n * @augments Loader\n * @three_import import { LDrawLoader } from 'three/addons/loaders/LDrawLoader.js';\n */\nclass LDrawLoader extends Loader {\n  /**\n   * Constructs a new LDraw loader.\n   *\n   * @param {LoadingManager} [manager] - The loading manager.\n   */\n  constructor(manager) {\n    super(manager);\n\n    // Array of THREE.Material\n    this.materials = [];\n    this.materialLibrary = {};\n    this.edgeMaterialCache = new WeakMap();\n    this.conditionalEdgeMaterialCache = new WeakMap();\n\n    // This also allows to handle the embedded text files (\"0 FILE\" lines)\n    this.partsCache = new LDrawPartsGeometryCache(this);\n\n    // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n    this.fileMap = {};\n\n    // If this flag is set to true the vertex normals will be smoothed.\n    this.smoothNormals = true;\n\n    // The path to load parts from the LDraw parts library from.\n    this.partsLibraryPath = '';\n\n    // this material type must be injected via setConditionalLineMaterial()\n    this.ConditionalLineMaterial = null;\n\n    // Material assigned to not available colors for meshes and edges\n    this.missingColorMaterial = new MeshStandardMaterial({\n      name: Loader.DEFAULT_MATERIAL_NAME,\n      color: 0xFF00FF,\n      roughness: 0.3,\n      metalness: 0\n    });\n    this.missingEdgeColorMaterial = new LineBasicMaterial({\n      name: Loader.DEFAULT_MATERIAL_NAME,\n      color: 0xFF00FF\n    });\n    this.missingConditionalEdgeColorMaterial = null;\n    this.edgeMaterialCache.set(this.missingColorMaterial, this.missingEdgeColorMaterial);\n    this.conditionalEdgeMaterialCache.set(this.missingEdgeColorMaterial, this.missingConditionalEdgeColorMaterial);\n  }\n\n  /**\n   * This method must be called prior to `load()` unless the model to load does not reference\n   * library parts (usually it will be a model with all its parts packed in a single file).\n   *\n   * @param {string} path - Path to library parts files to load referenced parts from.\n   * This is different from Loader.setPath, which indicates the path to load the main asset from.\n   * @return {LDrawLoader} A reference to this loader.\n   */\n  setPartsLibraryPath(path) {\n    this.partsLibraryPath = path;\n    return this;\n  }\n\n  /**\n   * Sets the conditional line material type which depends on the used renderer.\n   * Use {@link LDrawConditionalLineMaterial} when using `WebGLRenderer` and\n   * {@link LDrawConditionalLineNodeMaterial} when using `WebGPURenderer`.\n   *\n   * @param {(LDrawConditionalLineMaterial.constructor|LDrawConditionalLineNodeMaterial.constructor)} type - The conditional line material type.\n   * @return {LDrawLoader} A reference to this loader.\n   */\n  setConditionalLineMaterial(type) {\n    this.ConditionalLineMaterial = type;\n    this.missingConditionalEdgeColorMaterial = new this.ConditionalLineMaterial({\n      name: Loader.DEFAULT_MATERIAL_NAME,\n      fog: true,\n      color: 0xFF00FF\n    });\n    return this;\n  }\n\n  /**\n   * This async method preloads materials from a single LDraw file. In the official\n   * parts library there is a special file which is loaded always the first (LDConfig.ldr)\n   * and contains all the standard color codes. This method is intended to be used with\n   * not packed files, for example in an editor where materials are preloaded and parts\n   * are loaded on demand.\n   *\n   * @async\n   * @param {string} url - Path of the LDraw materials asset.\n   * @return {Promise} A Promise that resolves when the preload has finished.\n   */\n  async preloadMaterials(url) {\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    const text = await fileLoader.loadAsync(url);\n    const colorLineRegex = /^0 !COLOUR/;\n    const lines = text.split(/[\\n\\r]/g);\n    const materials = [];\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i];\n      if (colorLineRegex.test(line)) {\n        const directive = line.replace(colorLineRegex, '');\n        const material = this.parseColorMetaDirective(new LineParser(directive));\n        materials.push(material);\n      }\n    }\n    this.addMaterials(materials);\n  }\n\n  /**\n   * Starts loading from the given URL and passes the loaded LDraw asset\n   * to the `onLoad()` callback.\n   *\n   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n   * @param {function(Group)} onLoad - Executed when the loading process has been finished.\n   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n   * @param {onErrorCallback} onError - Executed when errors occur.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    fileLoader.load(url, text => {\n      // Initializes the materials library with default materials\n      this.addDefaultMaterials();\n      this.partsCache.parseModel(text).then(group => {\n        this.applyMaterialsToMesh(group, MAIN_COLOUR_CODE, this.materialLibrary, true);\n        this.computeBuildingSteps(group);\n        group.userData.fileName = url;\n        onLoad(group);\n      }).catch(onError);\n    }, onProgress, onError);\n  }\n\n  /**\n   * Parses the given LDraw data and returns the resulting group.\n   *\n   * @param {string} text - The raw VRML data as a string.\n   * @param {function(Group)} onLoad - Executed when the loading/parsing process has been finished.\n   * @param {onErrorCallback} onError - Executed when errors occur.\n   */\n  parse(text, onLoad, onError) {\n    this.partsCache.parseModel(text).then(group => {\n      this.applyMaterialsToMesh(group, MAIN_COLOUR_CODE, this.materialLibrary, true);\n      this.computeBuildingSteps(group);\n      group.userData.fileName = '';\n      onLoad(group);\n    }).catch(onError);\n  }\n\n  /**\n   * Sets the loader's material library. This method clears existing\n   * material definitions.\n   *\n   * @param {Array<Material>} materials - The materials to set.\n   * @return {LDrawLoader} A reference to this loader.\n   */\n  setMaterials(materials) {\n    this.clearMaterials();\n    this.addMaterials(materials);\n    return this;\n  }\n\n  /**\n   * Clears the loader's material library.\n   *\n   * @return {LDrawLoader} A reference to this loader.\n   */\n  clearMaterials() {\n    this.materialLibrary = {};\n    this.materials = [];\n    return this;\n  }\n\n  /**\n   * Adds a list of materials to the loader's material library.\n   *\n   * @param {Array<Material>} materials - The materials to add.\n   * @return {LDrawLoader} A reference to this loader.\n   */\n  addMaterials(materials) {\n    for (let i = 0, l = materials.length; i < l; i++) {\n      this.addMaterial(materials[i]);\n    }\n    return this;\n  }\n\n  /**\n   * Initializes the loader with default materials.\n   *\n   * @return {LDrawLoader} A reference to this loader.\n   */\n  addDefaultMaterials() {\n    // Add default main triangle and line edge materials (used in pieces that can be colored with a main color)\n    this.addMaterial(this.parseColorMetaDirective(new LineParser('Main_Colour CODE 16 VALUE #FF8080 EDGE #333333')));\n    this.addMaterial(this.parseColorMetaDirective(new LineParser('Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333')));\n    return this;\n  }\n\n  /**\n   * Sets a map which maps referenced library filenames to new filenames.\n   * If a fileMap is not specified (the default), library parts will be accessed by trial and\n   * error in subfolders 'parts', 'p' and 'models'.\n   *\n   * @param {Object<string,string>} fileMap - The file map to set.\n   * @return {LDrawLoader} A reference to this loader.\n   */\n  setFileMap(fileMap) {\n    this.fileMap = fileMap;\n    return this;\n  }\n\n  /**\n   * Adds a single material to the loader's material library.\n   *\n   * @param {Material} material - The material to add.\n   * @return {LDrawLoader} A reference to this loader.\n   */\n  addMaterial(material) {\n    // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n\n    const matLib = this.materialLibrary;\n    if (!matLib[material.userData.code]) {\n      this.materials.push(material);\n      matLib[material.userData.code] = material;\n    }\n    return this;\n  }\n\n  /**\n   * Returns a material for the given color code.\n   *\n   * @param {string} colorCode - The color code.\n   * @return {?Material} The material. Returns `null` if no material has been found.\n   */\n  getMaterial(colorCode) {\n    if (colorCode.startsWith('0x2')) {\n      // Special 'direct' material value (RGB color)\n      const color = colorCode.substring(3);\n      return this.parseColorMetaDirective(new LineParser('Direct_Color_' + color + ' CODE -1 VALUE #' + color + ' EDGE #' + color + ''));\n    }\n    return this.materialLibrary[colorCode] || null;\n  }\n\n  // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n  // in the material array if they need to be filled in.\n  applyMaterialsToMesh(group, parentColorCode, materialHierarchy, finalMaterialPass = false) {\n    // find any missing materials as indicated by a color code string and replace it with a material from the current material lib\n    const loader = this;\n    const parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n    group.traverse(c => {\n      if (c.isMesh || c.isLineSegments) {\n        if (Array.isArray(c.material)) {\n          for (let i = 0, l = c.material.length; i < l; i++) {\n            if (!c.material[i].isMaterial) {\n              c.material[i] = getMaterial(c, c.material[i]);\n            }\n          }\n        } else if (!c.material.isMaterial) {\n          c.material = getMaterial(c, c.material);\n        }\n      }\n    });\n\n    // Returns the appropriate material for the object (line or face) given color code. If the code is \"pass through\"\n    // (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's\n    // simply returned for the subsequent material application.\n    function getMaterial(c, colorCode) {\n      // if our parent is a passthrough color code and we don't have the current material color available then\n      // return early.\n      if (parentIsPassthrough && !(colorCode in materialHierarchy) && !finalMaterialPass) {\n        return colorCode;\n      }\n      const forEdge = c.isLineSegments || c.isConditionalLine;\n      const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n      if (isPassthrough) {\n        colorCode = parentColorCode;\n      }\n      let material = null;\n      if (colorCode in materialHierarchy) {\n        material = materialHierarchy[colorCode];\n      } else if (finalMaterialPass) {\n        // see if we can get the final material from the \"getMaterial\" function which will attempt to\n        // parse the \"direct\" colors\n        material = loader.getMaterial(colorCode);\n        if (material === null) {\n          // otherwise throw a warning if this is final opportunity to set the material\n          console.warn(`LDrawLoader: Material properties for code ${colorCode} not available.`);\n\n          // And return the 'missing color' material\n          material = loader.missingColorMaterial;\n        }\n      } else {\n        return colorCode;\n      }\n      if (c.isLineSegments) {\n        material = loader.edgeMaterialCache.get(material);\n        if (c.isConditionalLine) {\n          material = loader.conditionalEdgeMaterialCache.get(material);\n        }\n      }\n      return material;\n    }\n  }\n\n  /**\n   * Returns the Material for the main LDraw color.\n   *\n   * For an already loaded LDraw asset, returns the Material associated with the main color code.\n   * This method can be useful to modify the main material of a model or part that exposes it.\n   *\n   * The main color code is the standard way to color an LDraw part. It is '16' for triangles and\n   * '24' for edges. Usually a complete model will not expose the main color (that is, no part\n   * uses the code '16' at the top level, because they are assigned other specific colors) An LDraw\n   *  part file on the other hand will expose the code '16' to be colored, and can have additional\n   * fixed colors.\n   *\n   * @return {?Material} The material. Returns `null` if no material has been found.\n   */\n  getMainMaterial() {\n    return this.getMaterial(MAIN_COLOUR_CODE);\n  }\n\n  /**\n   * Returns the material for the edges main LDraw color.\n   *\n   * @return {?Material} The material. Returns `null` if no material has been found.\n   */\n  getMainEdgeMaterial() {\n    const mat = this.getMaterial(MAIN_EDGE_COLOUR_CODE);\n    return mat ? this.edgeMaterialCache.get(mat) : null;\n  }\n  parseColorMetaDirective(lineParser) {\n    // Parses a color definition and returns a THREE.Material\n\n    let code = null;\n\n    // Triangle and line colors\n    let fillColor = '#FF00FF';\n    let edgeColor = '#FF00FF';\n\n    // Transparency\n    let alpha = 1;\n    let isTransparent = false;\n    // Self-illumination:\n    let luminance = 0;\n    let finishType = FINISH_TYPE_DEFAULT;\n    let edgeMaterial = null;\n    const name = lineParser.getToken();\n    if (!name) {\n      throw new Error('LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.');\n    }\n\n    // Parse tag tokens and their parameters\n    let token = null;\n    while (true) {\n      token = lineParser.getToken();\n      if (!token) {\n        break;\n      }\n      if (!parseLuminance(token)) {\n        switch (token.toUpperCase()) {\n          case 'CODE':\n            code = lineParser.getToken();\n            break;\n          case 'VALUE':\n            fillColor = lineParser.getToken();\n            if (fillColor.startsWith('0x')) {\n              fillColor = '#' + fillColor.substring(2);\n            } else if (!fillColor.startsWith('#')) {\n              throw new Error('LDrawLoader: Invalid color while parsing material' + lineParser.getLineNumberString() + '.');\n            }\n            break;\n          case 'EDGE':\n            edgeColor = lineParser.getToken();\n            if (edgeColor.startsWith('0x')) {\n              edgeColor = '#' + edgeColor.substring(2);\n            } else if (!edgeColor.startsWith('#')) {\n              // Try to see if edge color is a color code\n              edgeMaterial = this.getMaterial(edgeColor);\n              if (!edgeMaterial) {\n                throw new Error('LDrawLoader: Invalid edge color while parsing material' + lineParser.getLineNumberString() + '.');\n              }\n\n              // Get the edge material for this triangle material\n              edgeMaterial = this.edgeMaterialCache.get(edgeMaterial);\n            }\n            break;\n          case 'ALPHA':\n            alpha = parseInt(lineParser.getToken());\n            if (isNaN(alpha)) {\n              throw new Error('LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.');\n            }\n            alpha = Math.max(0, Math.min(1, alpha / 255));\n            if (alpha < 1) {\n              isTransparent = true;\n            }\n            break;\n          case 'LUMINANCE':\n            if (!parseLuminance(lineParser.getToken())) {\n              throw new Error('LDrawLoader: Invalid luminance value in material definition' + lineParser.getLineNumberString() + '.');\n            }\n            break;\n          case 'CHROME':\n            finishType = FINISH_TYPE_CHROME;\n            break;\n          case 'PEARLESCENT':\n            finishType = FINISH_TYPE_PEARLESCENT;\n            break;\n          case 'RUBBER':\n            finishType = FINISH_TYPE_RUBBER;\n            break;\n          case 'MATTE_METALLIC':\n            finishType = FINISH_TYPE_MATTE_METALLIC;\n            break;\n          case 'METAL':\n            finishType = FINISH_TYPE_METAL;\n            break;\n          case 'MATERIAL':\n            // Not implemented\n            lineParser.setToEnd();\n            break;\n          default:\n            throw new Error('LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.');\n        }\n      }\n    }\n    let material = null;\n    switch (finishType) {\n      case FINISH_TYPE_DEFAULT:\n        material = new MeshStandardMaterial({\n          roughness: 0.3,\n          metalness: 0\n        });\n        break;\n      case FINISH_TYPE_PEARLESCENT:\n        // Try to imitate pearlescency by making the surface glossy\n        material = new MeshStandardMaterial({\n          roughness: 0.3,\n          metalness: 0.25\n        });\n        break;\n      case FINISH_TYPE_CHROME:\n        // Mirror finish surface\n        material = new MeshStandardMaterial({\n          roughness: 0,\n          metalness: 1\n        });\n        break;\n      case FINISH_TYPE_RUBBER:\n        // Rubber finish\n        material = new MeshStandardMaterial({\n          roughness: 0.9,\n          metalness: 0\n        });\n        break;\n      case FINISH_TYPE_MATTE_METALLIC:\n        // Brushed metal finish\n        material = new MeshStandardMaterial({\n          roughness: 0.8,\n          metalness: 0.4\n        });\n        break;\n      case FINISH_TYPE_METAL:\n        // Average metal finish\n        material = new MeshStandardMaterial({\n          roughness: 0.2,\n          metalness: 0.85\n        });\n        break;\n      default:\n        // Should not happen\n        break;\n    }\n    material.color.setStyle(fillColor, COLOR_SPACE_LDRAW);\n    material.transparent = isTransparent;\n    material.premultipliedAlpha = true;\n    material.opacity = alpha;\n    material.depthWrite = !isTransparent;\n    material.polygonOffset = true;\n    material.polygonOffsetFactor = 1;\n    if (luminance !== 0) {\n      material.emissive.setStyle(fillColor, COLOR_SPACE_LDRAW).multiplyScalar(luminance);\n    }\n    if (!edgeMaterial) {\n      // This is the material used for edges\n      edgeMaterial = new LineBasicMaterial({\n        color: new Color().setStyle(edgeColor, COLOR_SPACE_LDRAW),\n        transparent: isTransparent,\n        opacity: alpha,\n        depthWrite: !isTransparent\n      });\n      edgeMaterial.color;\n      edgeMaterial.userData.code = code;\n      edgeMaterial.name = name + ' - Edge';\n      if (this.ConditionalLineMaterial === null) {\n        throw new Error('THREE.LDrawLoader: ConditionalLineMaterial type must be specified via .setConditionalLineMaterial().');\n      }\n\n      // This is the material used for conditional edges\n      const conditionalEdgeMaterial = new this.ConditionalLineMaterial({\n        fog: true,\n        transparent: isTransparent,\n        depthWrite: !isTransparent,\n        color: new Color().setStyle(edgeColor, COLOR_SPACE_LDRAW),\n        opacity: alpha\n      });\n      conditionalEdgeMaterial.userData.code = code;\n      conditionalEdgeMaterial.name = name + ' - Conditional Edge';\n      this.conditionalEdgeMaterialCache.set(edgeMaterial, conditionalEdgeMaterial);\n    }\n    material.userData.code = code;\n    material.name = name;\n    this.edgeMaterialCache.set(material, edgeMaterial);\n    this.addMaterial(material);\n    return material;\n    function parseLuminance(token) {\n      // Returns success\n\n      let lum;\n      if (token.startsWith('LUMINANCE')) {\n        lum = parseInt(token.substring(9));\n      } else {\n        lum = parseInt(token);\n      }\n      if (isNaN(lum)) {\n        return false;\n      }\n      luminance = Math.max(0, Math.min(1, lum / 255));\n      return true;\n    }\n  }\n  computeBuildingSteps(model) {\n    // Sets userdata.buildingStep number in Group objects and userData.numBuildingSteps number in the root Group object.\n\n    let stepNumber = 0;\n    model.traverse(c => {\n      if (c.isGroup) {\n        if (c.userData.startingBuildingStep) {\n          stepNumber++;\n        }\n        c.userData.buildingStep = stepNumber;\n      }\n    });\n    model.userData.numBuildingSteps = stepNumber + 1;\n  }\n}\nexport { LDrawLoader };","map":{"version":3,"names":["BufferAttribute","BufferGeometry","Color","FileLoader","Group","LineBasicMaterial","LineSegments","Loader","Matrix4","Mesh","MeshStandardMaterial","SRGBColorSpace","Vector3","Ray","FINISH_TYPE_DEFAULT","FINISH_TYPE_CHROME","FINISH_TYPE_PEARLESCENT","FINISH_TYPE_RUBBER","FINISH_TYPE_MATTE_METALLIC","FINISH_TYPE_METAL","FILE_LOCATION_TRY_PARTS","FILE_LOCATION_TRY_P","FILE_LOCATION_TRY_MODELS","FILE_LOCATION_AS_IS","FILE_LOCATION_TRY_RELATIVE","FILE_LOCATION_TRY_ABSOLUTE","FILE_LOCATION_NOT_FOUND","MAIN_COLOUR_CODE","MAIN_EDGE_COLOUR_CODE","COLOR_SPACE_LDRAW","_tempVec0","_tempVec1","ConditionalLineSegments","constructor","geometry","material","isConditionalLine","generateFaceNormals","faces","i","l","length","face","vertices","v0","v1","v2","subVectors","faceNormal","crossVectors","normalize","_ray","smoothNormals","lineSegments","checkSubSegments","hashMultiplier","hashVertex","v","x","y","z","hashEdge","toNormalizedRay","targetRay","direction","scalar","dot","origin","copy","addScaledVector","hashRay","ray","hardEdges","Set","hardEdgeRays","Map","halfEdgeList","normals","ls","add","rh1","has","rh2","info","distances","set","get","d0","d1","push","tri","vertCount","i2","index","next","hash","rayHash","found","halfEdge","key","queue","pop","vertNormals","reverseHash","otherInfo","otherTri","otherIndex","otherNormals","otherVertCount","otherFaceNormal","Math","abs","otherNext","norm","sharedNormal1","sharedNormal2","isPartType","type","isPrimitiveType","test","LineParser","line","lineNumber","lineLength","currentCharIndex","currentChar","seekNonSpace","charAt","getToken","pos0","pos1","substring","getVector","parseFloat","getRemainingString","isAtTheEnd","setToEnd","getLineNumberString","LDrawParsedCache","loader","_cache","cloneResult","original","result","map","colorCode","clone","conditionalSegments","controlPoints","category","keywords","author","subobjects","fileName","totalFaces","startingBuildingStep","materials","group","fetchData","triedLowerCase","locationState","subobjectURL","lastIndexOf","toLowerCase","fileLoader","manager","setPath","partsLibraryPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","loadAsync","_","Error","parse","getLocalMaterial","indexOf","replace","lines","split","numLines","parsingEmbeddedFiles","currentEmbeddedFileName","currentEmbeddedText","bfcCertified","bfcCCW","bfcInverted","bfcCull","lineIndex","startsWith","setData","lp","lineType","segment","ccw","doubleSided","v3","c0","c1","meta","parseColorMetaDirective","userData","code","console","warn","newKeywords","forEach","keyword","trim","token","posX","posY","posZ","m0","m1","m2","m3","m4","m5","m6","m7","m8","matrix","fileMap","inverted","getData","Promise","ensureDataLoaded","then","getMaterialFromCode","parentColorCode","materialHierarchy","forEdge","isPassthrough","LDrawPartsGeometryCache","parseCache","processIntoMesh","faceMaterials","processInfoSubobjects","subobject","promises","promise","subobjectInfo","loadModel","catch","error","subobjectInfos","all","isGroup","subobjectGroup","decompose","position","quaternion","scale","name","applyMaterialsToMesh","children","parentLineSegments","parentConditionalSegments","parentFaces","matrixScaleInverted","determinant","lineColorCode","applyMatrix4","os","reverse","size","createObject","hasCachedModel","getCachedModel","parseModel","sortByMaterial","a","b","elements","elementSize","isConditionalSegments","totalElements","sort","positions","Float32Array","quadArray","Array","bufferGeometry","prevMaterial","index0","numGroupVerts","offset","iElem","nElem","elem","j","elemNormals","n","addGroup","edgeMaterial","edgeMaterialCache","conditionalEdgeMaterialCache","Infinity","setAttribute","object3d","controlArray0","controlArray1","directionArray","LDrawLoader","materialLibrary","WeakMap","partsCache","ConditionalLineMaterial","missingColorMaterial","DEFAULT_MATERIAL_NAME","color","roughness","metalness","missingEdgeColorMaterial","missingConditionalEdgeColorMaterial","setPartsLibraryPath","path","setConditionalLineMaterial","fog","preloadMaterials","url","colorLineRegex","directive","addMaterials","load","onLoad","onProgress","onError","addDefaultMaterials","computeBuildingSteps","setMaterials","clearMaterials","addMaterial","setFileMap","matLib","getMaterial","finalMaterialPass","parentIsPassthrough","traverse","c","isMesh","isLineSegments","isArray","isMaterial","getMainMaterial","getMainEdgeMaterial","mat","lineParser","fillColor","edgeColor","alpha","isTransparent","luminance","finishType","parseLuminance","toUpperCase","parseInt","isNaN","max","min","setStyle","transparent","premultipliedAlpha","opacity","depthWrite","polygonOffset","polygonOffsetFactor","emissive","multiplyScalar","conditionalEdgeMaterial","lum","model","stepNumber","buildingStep","numBuildingSteps"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/loaders/LDrawLoader.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tColor,\n\tFileLoader,\n\tGroup,\n\tLineBasicMaterial,\n\tLineSegments,\n\tLoader,\n\tMatrix4,\n\tMesh,\n\tMeshStandardMaterial,\n\tSRGBColorSpace,\n\tVector3,\n\tRay\n} from 'three';\n\n// Special surface finish tag types.\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5;\n\n// State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\nconst FILE_LOCATION_TRY_PARTS = 0;\nconst FILE_LOCATION_TRY_P = 1;\nconst FILE_LOCATION_TRY_MODELS = 2;\nconst FILE_LOCATION_AS_IS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\n\nconst MAIN_COLOUR_CODE = '16';\nconst MAIN_EDGE_COLOUR_CODE = '24';\n\nconst COLOR_SPACE_LDRAW = SRGBColorSpace;\n\nconst _tempVec0 = new Vector3();\nconst _tempVec1 = new Vector3();\n\n\nclass ConditionalLineSegments extends LineSegments {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\t\tthis.isConditionalLine = true;\n\n\t}\n\n}\n\nfunction generateFaceNormals( faces ) {\n\n\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tconst face = faces[ i ];\n\t\tconst vertices = face.vertices;\n\t\tconst v0 = vertices[ 0 ];\n\t\tconst v1 = vertices[ 1 ];\n\t\tconst v2 = vertices[ 2 ];\n\n\t\t_tempVec0.subVectors( v1, v0 );\n\t\t_tempVec1.subVectors( v2, v1 );\n\t\tface.faceNormal = new Vector3()\n\t\t\t.crossVectors( _tempVec0, _tempVec1 )\n\t\t\t.normalize();\n\n\t}\n\n}\n\nconst _ray = new Ray();\nfunction smoothNormals( faces, lineSegments, checkSubSegments = false ) {\n\n\t// NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because\n\t// it allows edges to be smoothed as expected (see minifig arms).\n\t// --\n\t// And the vector values are initialize multiplied by 1 + 1e-10 to account for floating\n\t// point errors on vertices along quantization boundaries. Ie after matrix multiplication\n\t// vertices that should be merged might be set to \"1.7\" and \"1.6999...\" meaning they won't\n\t// get merged. This added epsilon attempts to push these error values to the same quantized\n\t// value for the sake of hashing. See \"AT-ST mini\" dishes. See mrdoob/three#23169.\n\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\n\t\treturn `${ x },${ y },${ z }`;\n\n\t}\n\n\tfunction hashEdge( v0, v1 ) {\n\n\t\treturn `${ hashVertex( v0 ) }_${ hashVertex( v1 ) }`;\n\n\t}\n\n\t// converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected\n\t// onto the original line.\n\tfunction toNormalizedRay( v0, v1, targetRay ) {\n\n\t\ttargetRay.direction.subVectors( v1, v0 ).normalize();\n\n\t\tconst scalar = v0.dot( targetRay.direction );\n\t\ttargetRay.origin.copy( v0 ).addScaledVector( targetRay.direction, - scalar );\n\n\t\treturn targetRay;\n\n\t}\n\n\tfunction hashRay( ray ) {\n\n\t\treturn hashEdge( ray.origin, ray.direction );\n\n\t}\n\n\tconst hardEdges = new Set();\n\tconst hardEdgeRays = new Map();\n\tconst halfEdgeList = {};\n\tconst normals = [];\n\n\t// Save the list of hard edges by hash\n\tfor ( let i = 0, l = lineSegments.length; i < l; i ++ ) {\n\n\t\tconst ls = lineSegments[ i ];\n\t\tconst vertices = ls.vertices;\n\t\tconst v0 = vertices[ 0 ];\n\t\tconst v1 = vertices[ 1 ];\n\t\thardEdges.add( hashEdge( v0, v1 ) );\n\t\thardEdges.add( hashEdge( v1, v0 ) );\n\n\t\t// only generate the hard edge ray map if we're checking subsegments because it's more expensive to check\n\t\t// and requires more memory.\n\t\tif ( checkSubSegments ) {\n\n\t\t\t// add both ray directions to the map\n\t\t\tconst ray = toNormalizedRay( v0, v1, new Ray() );\n\t\t\tconst rh1 = hashRay( ray );\n\t\t\tif ( ! hardEdgeRays.has( rh1 ) ) {\n\n\t\t\t\ttoNormalizedRay( v1, v0, ray );\n\t\t\t\tconst rh2 = hashRay( ray );\n\n\t\t\t\tconst info = {\n\t\t\t\t\tray,\n\t\t\t\t\tdistances: [],\n\t\t\t\t};\n\n\t\t\t\thardEdgeRays.set( rh1, info );\n\t\t\t\thardEdgeRays.set( rh2, info );\n\n\t\t\t}\n\n\t\t\t// store both segments ends in min, max order in the distances array to check if a face edge is a\n\t\t\t// subsegment later.\n\t\t\tconst info = hardEdgeRays.get( rh1 );\n\t\t\tlet d0 = info.ray.direction.dot( v0 );\n\t\t\tlet d1 = info.ray.direction.dot( v1 );\n\t\t\tif ( d0 > d1 ) {\n\n\t\t\t\t[ d0, d1 ] = [ d1, d0 ];\n\n\t\t\t}\n\n\t\t\tinfo.distances.push( d0, d1 );\n\n\t\t}\n\n\t}\n\n\t// track the half edges associated with each triangle\n\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tconst tri = faces[ i ];\n\t\tconst vertices = tri.vertices;\n\t\tconst vertCount = vertices.length;\n\t\tfor ( let i2 = 0; i2 < vertCount; i2 ++ ) {\n\n\t\t\tconst index = i2;\n\t\t\tconst next = ( i2 + 1 ) % vertCount;\n\t\t\tconst v0 = vertices[ index ];\n\t\t\tconst v1 = vertices[ next ];\n\t\t\tconst hash = hashEdge( v0, v1 );\n\n\t\t\t// don't add the triangle if the edge is supposed to be hard\n\t\t\tif ( hardEdges.has( hash ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds\n\t\t\tif ( checkSubSegments ) {\n\n\t\t\t\ttoNormalizedRay( v0, v1, _ray );\n\n\t\t\t\tconst rayHash = hashRay( _ray );\n\t\t\t\tif ( hardEdgeRays.has( rayHash ) ) {\n\n\t\t\t\t\tconst info = hardEdgeRays.get( rayHash );\n\t\t\t\t\tconst { ray, distances } = info;\n\t\t\t\t\tlet d0 = ray.direction.dot( v0 );\n\t\t\t\t\tlet d1 = ray.direction.dot( v1 );\n\n\t\t\t\t\tif ( d0 > d1 ) {\n\n\t\t\t\t\t\t[ d0, d1 ] = [ d1, d0 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// return early if the face edge is found to be a subsegment of a line edge meaning the edge will have \"hard\" normals\n\t\t\t\t\tlet found = false;\n\t\t\t\t\tfor ( let i = 0, l = distances.length; i < l; i += 2 ) {\n\n\t\t\t\t\t\tif ( d0 >= distances[ i ] && d1 <= distances[ i + 1 ] ) {\n\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( found ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst info = {\n\t\t\t\tindex: index,\n\t\t\t\ttri: tri\n\t\t\t};\n\t\t\thalfEdgeList[ hash ] = info;\n\n\t\t}\n\n\t}\n\n\t// Iterate until we've tried to connect all faces to share normals\n\twhile ( true ) {\n\n\t\t// Stop if there are no more faces left\n\t\tlet halfEdge = null;\n\t\tfor ( const key in halfEdgeList ) {\n\n\t\t\thalfEdge = halfEdgeList[ key ];\n\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( halfEdge === null ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\t// Exhaustively find all connected faces\n\t\tconst queue = [ halfEdge ];\n\t\twhile ( queue.length > 0 ) {\n\n\t\t\t// initialize all vertex normals in this triangle\n\t\t\tconst tri = queue.pop().tri;\n\t\t\tconst vertices = tri.vertices;\n\t\t\tconst vertNormals = tri.normals;\n\t\t\tconst faceNormal = tri.faceNormal;\n\n\t\t\t// Check if any edge is connected to another triangle edge\n\t\t\tconst vertCount = vertices.length;\n\t\t\tfor ( let i2 = 0; i2 < vertCount; i2 ++ ) {\n\n\t\t\t\tconst index = i2;\n\t\t\t\tconst next = ( i2 + 1 ) % vertCount;\n\t\t\t\tconst v0 = vertices[ index ];\n\t\t\t\tconst v1 = vertices[ next ];\n\n\t\t\t\t// delete this triangle from the list so it won't be found again\n\t\t\t\tconst hash = hashEdge( v0, v1 );\n\t\t\t\tdelete halfEdgeList[ hash ];\n\n\t\t\t\tconst reverseHash = hashEdge( v1, v0 );\n\t\t\t\tconst otherInfo = halfEdgeList[ reverseHash ];\n\t\t\t\tif ( otherInfo ) {\n\n\t\t\t\t\tconst otherTri = otherInfo.tri;\n\t\t\t\t\tconst otherIndex = otherInfo.index;\n\t\t\t\t\tconst otherNormals = otherTri.normals;\n\t\t\t\t\tconst otherVertCount = otherNormals.length;\n\t\t\t\t\tconst otherFaceNormal = otherTri.faceNormal;\n\n\t\t\t\t\t// NOTE: If the angle between faces is > 67.5 degrees then assume it's\n\t\t\t\t\t// hard edge. There are some cases where the line segments do not line up exactly\n\t\t\t\t\t// with or span multiple triangle edges (see Lunar Vehicle wheels).\n\t\t\t\t\tif ( Math.abs( otherTri.faceNormal.dot( tri.faceNormal ) ) < 0.25 ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// if this triangle has already been traversed then it won't be in\n\t\t\t\t\t// the halfEdgeList. If it has not then add it to the queue and delete\n\t\t\t\t\t// it so it won't be found again.\n\t\t\t\t\tif ( reverseHash in halfEdgeList ) {\n\n\t\t\t\t\t\tqueue.push( otherInfo );\n\t\t\t\t\t\tdelete halfEdgeList[ reverseHash ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// share the first normal\n\t\t\t\t\tconst otherNext = ( otherIndex + 1 ) % otherVertCount;\n\t\t\t\t\tif (\n\t\t\t\t\t\tvertNormals[ index ] && otherNormals[ otherNext ] &&\n\t\t\t\t\t\tvertNormals[ index ] !== otherNormals[ otherNext ]\n\t\t\t\t\t) {\n\n\t\t\t\t\t\totherNormals[ otherNext ].norm.add( vertNormals[ index ].norm );\n\t\t\t\t\t\tvertNormals[ index ].norm = otherNormals[ otherNext ].norm;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet sharedNormal1 = vertNormals[ index ] || otherNormals[ otherNext ];\n\t\t\t\t\tif ( sharedNormal1 === null ) {\n\n\t\t\t\t\t\t// it's possible to encounter an edge of a triangle that has already been traversed meaning\n\t\t\t\t\t\t// both edges already have different normals defined and shared. To work around this we create\n\t\t\t\t\t\t// a wrapper object so when those edges are merged the normals can be updated everywhere.\n\t\t\t\t\t\tsharedNormal1 = { norm: new Vector3() };\n\t\t\t\t\t\tnormals.push( sharedNormal1.norm );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( vertNormals[ index ] === null ) {\n\n\t\t\t\t\t\tvertNormals[ index ] = sharedNormal1;\n\t\t\t\t\t\tsharedNormal1.norm.add( faceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( otherNormals[ otherNext ] === null ) {\n\n\t\t\t\t\t\totherNormals[ otherNext ] = sharedNormal1;\n\t\t\t\t\t\tsharedNormal1.norm.add( otherFaceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// share the second normal\n\t\t\t\t\tif (\n\t\t\t\t\t\tvertNormals[ next ] && otherNormals[ otherIndex ] &&\n\t\t\t\t\t\tvertNormals[ next ] !== otherNormals[ otherIndex ]\n\t\t\t\t\t) {\n\n\t\t\t\t\t\totherNormals[ otherIndex ].norm.add( vertNormals[ next ].norm );\n\t\t\t\t\t\tvertNormals[ next ].norm = otherNormals[ otherIndex ].norm;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet sharedNormal2 = vertNormals[ next ] || otherNormals[ otherIndex ];\n\t\t\t\t\tif ( sharedNormal2 === null ) {\n\n\t\t\t\t\t\tsharedNormal2 = { norm: new Vector3() };\n\t\t\t\t\t\tnormals.push( sharedNormal2.norm );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( vertNormals[ next ] === null ) {\n\n\t\t\t\t\t\tvertNormals[ next ] = sharedNormal2;\n\t\t\t\t\t\tsharedNormal2.norm.add( faceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( otherNormals[ otherIndex ] === null ) {\n\n\t\t\t\t\t\totherNormals[ otherIndex ] = sharedNormal2;\n\t\t\t\t\t\tsharedNormal2.norm.add( otherFaceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// The normals of each face have been added up so now we average them by normalizing the vector.\n\tfor ( let i = 0, l = normals.length; i < l; i ++ ) {\n\n\t\tnormals[ i ].normalize();\n\n\t}\n\n}\n\nfunction isPartType( type ) {\n\n\treturn type === 'Part' || type === 'Unofficial_Part';\n\n}\n\nfunction isPrimitiveType( type ) {\n\n\treturn /primitive/i.test( type ) || type === 'Subpart';\n\n}\n\nclass LineParser {\n\n\tconstructor( line, lineNumber ) {\n\n\t\tthis.line = line;\n\t\tthis.lineLength = line.length;\n\t\tthis.currentCharIndex = 0;\n\t\tthis.currentChar = ' ';\n\t\tthis.lineNumber = lineNumber;\n\n\t}\n\n\tseekNonSpace() {\n\n\t\twhile ( this.currentCharIndex < this.lineLength ) {\n\n\t\t\tthis.currentChar = this.line.charAt( this.currentCharIndex );\n\n\t\t\tif ( this.currentChar !== ' ' && this.currentChar !== '\\t' ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.currentCharIndex ++;\n\n\t\t}\n\n\t}\n\n\tgetToken() {\n\n\t\tconst pos0 = this.currentCharIndex ++;\n\n\t\t// Seek space\n\t\twhile ( this.currentCharIndex < this.lineLength ) {\n\n\t\t\tthis.currentChar = this.line.charAt( this.currentCharIndex );\n\n\t\t\tif ( this.currentChar === ' ' || this.currentChar === '\\t' ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.currentCharIndex ++;\n\n\t\t}\n\n\t\tconst pos1 = this.currentCharIndex;\n\n\t\tthis.seekNonSpace();\n\n\t\treturn this.line.substring( pos0, pos1 );\n\n\t}\n\n\tgetVector() {\n\n\t\treturn new Vector3( parseFloat( this.getToken() ), parseFloat( this.getToken() ), parseFloat( this.getToken() ) );\n\n\t}\n\n\tgetRemainingString() {\n\n\t\treturn this.line.substring( this.currentCharIndex, this.lineLength );\n\n\t}\n\n\tisAtTheEnd() {\n\n\t\treturn this.currentCharIndex >= this.lineLength;\n\n\t}\n\n\tsetToEnd() {\n\n\t\tthis.currentCharIndex = this.lineLength;\n\n\t}\n\n\tgetLineNumberString() {\n\n\t\treturn this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n\n\t}\n\n}\n\n// Fetches and parses an intermediate representation of LDraw parts files.\nclass LDrawParsedCache {\n\n\tconstructor( loader ) {\n\n\t\tthis.loader = loader;\n\t\tthis._cache = {};\n\n\t}\n\n\tcloneResult( original ) {\n\n\t\tconst result = {};\n\n\t\t// vertices are transformed and normals computed before being converted to geometry\n\t\t// so these pieces must be cloned.\n\t\tresult.faces = original.faces.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() ),\n\t\t\t\tnormals: face.normals.map( () => null ),\n\t\t\t\tfaceNormal: null\n\t\t\t};\n\n\t\t} );\n\n\t\tresult.conditionalSegments = original.conditionalSegments.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() ),\n\t\t\t\tcontrolPoints: face.controlPoints.map( v => v.clone() )\n\t\t\t};\n\n\t\t} );\n\n\t\tresult.lineSegments = original.lineSegments.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() )\n\t\t\t};\n\n\t\t} );\n\n\t\t// none if this is subsequently modified\n\t\tresult.type = original.type;\n\t\tresult.category = original.category;\n\t\tresult.keywords = original.keywords;\n\t\tresult.author = original.author;\n\t\tresult.subobjects = original.subobjects;\n\t\tresult.fileName = original.fileName;\n\t\tresult.totalFaces = original.totalFaces;\n\t\tresult.startingBuildingStep = original.startingBuildingStep;\n\t\tresult.materials = original.materials;\n\t\tresult.group = null;\n\t\treturn result;\n\n\t}\n\n\tasync fetchData( fileName ) {\n\n\t\tlet triedLowerCase = false;\n\t\tlet locationState = FILE_LOCATION_TRY_PARTS;\n\t\twhile ( locationState !== FILE_LOCATION_NOT_FOUND ) {\n\n\t\t\tlet subobjectURL = fileName;\n\t\t\tswitch ( locationState ) {\n\n\t\t\t\tcase FILE_LOCATION_AS_IS:\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_PARTS:\n\t\t\t\t\tsubobjectURL = 'parts/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_P:\n\t\t\t\t\tsubobjectURL = 'p/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_MODELS:\n\t\t\t\t\tsubobjectURL = 'models/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_RELATIVE:\n\t\t\t\t\tsubobjectURL = fileName.substring( 0, fileName.lastIndexOf( '/' ) + 1 ) + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_ABSOLUTE:\n\n\t\t\t\t\tif ( triedLowerCase ) {\n\n\t\t\t\t\t\t// Try absolute path\n\t\t\t\t\t\tlocationState = FILE_LOCATION_NOT_FOUND;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Next attempt is lower case\n\t\t\t\t\t\tfileName = fileName.toLowerCase();\n\t\t\t\t\t\tsubobjectURL = fileName;\n\t\t\t\t\t\ttriedLowerCase = true;\n\t\t\t\t\t\tlocationState = FILE_LOCATION_TRY_PARTS;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tconst loader = this.loader;\n\t\t\tconst fileLoader = new FileLoader( loader.manager );\n\t\t\tfileLoader.setPath( loader.partsLibraryPath );\n\t\t\tfileLoader.setRequestHeader( loader.requestHeader );\n\t\t\tfileLoader.setWithCredentials( loader.withCredentials );\n\n\t\t\ttry {\n\n\t\t\t\tconst text = await fileLoader.loadAsync( subobjectURL );\n\t\t\t\treturn text;\n\n\t\t\t} catch ( _ ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthrow new Error( 'LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.' );\n\n\t}\n\n\tparse( text, fileName = null ) {\n\n\t\tconst loader = this.loader;\n\n\t\t// final results\n\t\tconst faces = [];\n\t\tconst lineSegments = [];\n\t\tconst conditionalSegments = [];\n\t\tconst subobjects = [];\n\t\tconst materials = {};\n\n\t\tconst getLocalMaterial = colorCode => {\n\n\t\t\treturn materials[ colorCode ] || null;\n\n\t\t};\n\n\t\tlet type = 'Model';\n\t\tlet category = null;\n\t\tlet keywords = null;\n\t\tlet author = null;\n\t\tlet totalFaces = 0;\n\n\t\t// split into lines\n\t\tif ( text.indexOf( '\\r\\n' ) !== - 1 ) {\n\n\t\t\t// This is faster than String.split with regex that splits on both\n\t\t\ttext = text.replace( /\\r\\n/g, '\\n' );\n\n\t\t}\n\n\t\tconst lines = text.split( '\\n' );\n\t\tconst numLines = lines.length;\n\n\t\tlet parsingEmbeddedFiles = false;\n\t\tlet currentEmbeddedFileName = null;\n\t\tlet currentEmbeddedText = null;\n\n\t\tlet bfcCertified = false;\n\t\tlet bfcCCW = true;\n\t\tlet bfcInverted = false;\n\t\tlet bfcCull = true;\n\n\t\tlet startingBuildingStep = false;\n\n\t\t// Parse all line commands\n\t\tfor ( let lineIndex = 0; lineIndex < numLines; lineIndex ++ ) {\n\n\t\t\tconst line = lines[ lineIndex ];\n\n\t\t\tif ( line.length === 0 ) continue;\n\n\t\t\tif ( parsingEmbeddedFiles ) {\n\n\t\t\t\tif ( line.startsWith( '0 FILE ' ) ) {\n\n\t\t\t\t\t// Save previous embedded file in the cache\n\t\t\t\t\tthis.setData( currentEmbeddedFileName, currentEmbeddedText );\n\n\t\t\t\t\t// New embedded text file\n\t\t\t\t\tcurrentEmbeddedFileName = line.substring( 7 );\n\t\t\t\t\tcurrentEmbeddedText = '';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentEmbeddedText += line + '\\n';\n\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst lp = new LineParser( line, lineIndex + 1 );\n\t\t\tlp.seekNonSpace();\n\n\t\t\tif ( lp.isAtTheEnd() ) {\n\n\t\t\t\t// Empty line\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// Parse the line type\n\t\t\tconst lineType = lp.getToken();\n\n\t\t\tlet material;\n\t\t\tlet colorCode;\n\t\t\tlet segment;\n\t\t\tlet ccw;\n\t\t\tlet doubleSided;\n\t\t\tlet v0, v1, v2, v3, c0, c1;\n\n\t\t\tswitch ( lineType ) {\n\n\t\t\t\t// Line type 0: Comment or META\n\t\t\t\tcase '0':\n\n\t\t\t\t\t// Parse meta directive\n\t\t\t\t\tconst meta = lp.getToken();\n\n\t\t\t\t\tif ( meta ) {\n\n\t\t\t\t\t\tswitch ( meta ) {\n\n\t\t\t\t\t\t\tcase '!LDRAW_ORG':\n\n\t\t\t\t\t\t\t\ttype = lp.getToken();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!COLOUR':\n\n\t\t\t\t\t\t\t\tmaterial = loader.parseColorMetaDirective( lp );\n\t\t\t\t\t\t\t\tif ( material ) {\n\n\t\t\t\t\t\t\t\t\tmaterials[ material.userData.code ] = material;\n\n\t\t\t\t\t\t\t\t}\telse {\n\n\t\t\t\t\t\t\t\t\tconsole.warn( 'LDrawLoader: Error parsing material' + lp.getLineNumberString() );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!CATEGORY':\n\n\t\t\t\t\t\t\t\tcategory = lp.getToken();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!KEYWORDS':\n\n\t\t\t\t\t\t\t\tconst newKeywords = lp.getRemainingString().split( ',' );\n\t\t\t\t\t\t\t\tif ( newKeywords.length > 0 ) {\n\n\t\t\t\t\t\t\t\t\tif ( ! keywords ) {\n\n\t\t\t\t\t\t\t\t\t\tkeywords = [];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tnewKeywords.forEach( function ( keyword ) {\n\n\t\t\t\t\t\t\t\t\t\tkeywords.push( keyword.trim() );\n\n\t\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'FILE':\n\n\t\t\t\t\t\t\t\tif ( lineIndex > 0 ) {\n\n\t\t\t\t\t\t\t\t\t// Start embedded text files parsing\n\t\t\t\t\t\t\t\t\tparsingEmbeddedFiles = true;\n\t\t\t\t\t\t\t\t\tcurrentEmbeddedFileName = lp.getRemainingString();\n\t\t\t\t\t\t\t\t\tcurrentEmbeddedText = '';\n\n\t\t\t\t\t\t\t\t\tbfcCertified = false;\n\t\t\t\t\t\t\t\t\tbfcCCW = true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'BFC':\n\n\t\t\t\t\t\t\t\t// Changes to the backface culling state\n\t\t\t\t\t\t\t\twhile ( ! lp.isAtTheEnd() ) {\n\n\t\t\t\t\t\t\t\t\tconst token = lp.getToken();\n\n\t\t\t\t\t\t\t\t\tswitch ( token ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'CERTIFY':\n\t\t\t\t\t\t\t\t\t\tcase 'NOCERTIFY':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCertified = token === 'CERTIFY';\n\t\t\t\t\t\t\t\t\t\t\tbfcCCW = true;\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'CW':\n\t\t\t\t\t\t\t\t\t\tcase 'CCW':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCCW = token === 'CCW';\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'INVERTNEXT':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcInverted = true;\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'CLIP':\n\t\t\t\t\t\t\t\t\t\tcase 'NOCLIP':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCull = token === 'CLIP';\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.' );\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'STEP':\n\n\t\t\t\t\t\t\t\tstartingBuildingStep = true;\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'Author:':\n\n\t\t\t\t\t\t\t\tauthor = lp.getToken();\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t// Other meta directives are not implemented\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 1: Sub-object file\n\t\t\t\tcase '1':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\n\t\t\t\t\tconst posX = parseFloat( lp.getToken() );\n\t\t\t\t\tconst posY = parseFloat( lp.getToken() );\n\t\t\t\t\tconst posZ = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m0 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m1 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m2 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m3 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m4 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m5 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m6 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m7 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m8 = parseFloat( lp.getToken() );\n\n\t\t\t\t\tconst matrix = new Matrix4().set(\n\t\t\t\t\t\tm0, m1, m2, posX,\n\t\t\t\t\t\tm3, m4, m5, posY,\n\t\t\t\t\t\tm6, m7, m8, posZ,\n\t\t\t\t\t\t0, 0, 0, 1\n\t\t\t\t\t);\n\n\t\t\t\t\tlet fileName = lp.getRemainingString().trim().replace( /\\\\/g, '/' );\n\n\t\t\t\t\tif ( loader.fileMap[ fileName ] ) {\n\n\t\t\t\t\t\t// Found the subobject path in the preloaded file path map\n\t\t\t\t\t\tfileName = loader.fileMap[ fileName ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Standardized subfolders\n\t\t\t\t\t\tif ( fileName.startsWith( 's/' ) ) {\n\n\t\t\t\t\t\t\tfileName = 'parts/' + fileName;\n\n\t\t\t\t\t\t} else if ( fileName.startsWith( '48/' ) ) {\n\n\t\t\t\t\t\t\tfileName = 'p/' + fileName;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsubobjects.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tmatrix: matrix,\n\t\t\t\t\t\tfileName: fileName,\n\t\t\t\t\t\tinverted: bfcInverted,\n\t\t\t\t\t\tstartingBuildingStep: startingBuildingStep\n\t\t\t\t\t} );\n\n\t\t\t\t\tstartingBuildingStep = false;\n\t\t\t\t\tbfcInverted = false;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 2: Line segment\n\t\t\t\tcase '2':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\tv1 = lp.getVector();\n\n\t\t\t\t\tsegment = {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tvertices: [ v0, v1 ],\n\t\t\t\t\t};\n\n\t\t\t\t\tlineSegments.push( segment );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 5: Conditional Line segment\n\t\t\t\tcase '5':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\tc0 = lp.getVector();\n\t\t\t\t\tc1 = lp.getVector();\n\n\t\t\t\t\tsegment = {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tvertices: [ v0, v1 ],\n\t\t\t\t\t\tcontrolPoints: [ c0, c1 ],\n\t\t\t\t\t};\n\n\t\t\t\t\tconditionalSegments.push( segment );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 3: Triangle\n\t\t\t\tcase '3':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tccw = bfcCCW;\n\t\t\t\t\tdoubleSided = ! bfcCertified || ! bfcCull;\n\n\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv0 = lp.getVector();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\tvertices: [ v0, v1, v2 ],\n\t\t\t\t\t\tnormals: [ null, null, null ],\n\t\t\t\t\t} );\n\t\t\t\t\ttotalFaces ++;\n\n\t\t\t\t\tif ( doubleSided === true ) {\n\n\t\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\t\tvertices: [ v2, v1, v0 ],\n\t\t\t\t\t\t\tnormals: [ null, null, null ],\n\t\t\t\t\t\t} );\n\t\t\t\t\t\ttotalFaces ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 4: Quadrilateral\n\t\t\t\tcase '4':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tccw = bfcCCW;\n\t\t\t\t\tdoubleSided = ! bfcCertified || ! bfcCull;\n\n\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv3 = lp.getVector();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv3 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv0 = lp.getVector();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// specifically place the triangle diagonal in the v0 and v1 slots so we can\n\t\t\t\t\t// account for the doubling of vertices later when smoothing normals.\n\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\tvertices: [ v0, v1, v2, v3 ],\n\t\t\t\t\t\tnormals: [ null, null, null, null ],\n\t\t\t\t\t} );\n\t\t\t\t\ttotalFaces += 2;\n\n\t\t\t\t\tif ( doubleSided === true ) {\n\n\t\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\t\tvertices: [ v3, v2, v1, v0 ],\n\t\t\t\t\t\t\tnormals: [ null, null, null, null ],\n\t\t\t\t\t\t} );\n\t\t\t\t\t\ttotalFaces += 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parsingEmbeddedFiles ) {\n\n\t\t\tthis.setData( currentEmbeddedFileName, currentEmbeddedText );\n\n\t\t}\n\n\t\treturn {\n\t\t\tfaces,\n\t\t\tconditionalSegments,\n\t\t\tlineSegments,\n\t\t\ttype,\n\t\t\tcategory,\n\t\t\tkeywords,\n\t\t\tauthor,\n\t\t\tsubobjects,\n\t\t\ttotalFaces,\n\t\t\tstartingBuildingStep,\n\t\t\tmaterials,\n\t\t\tfileName,\n\t\t\tgroup: null\n\t\t};\n\n\t}\n\n\t// returns an (optionally cloned) instance of the data\n\tgetData( fileName, clone = true ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tconst result = this._cache[ key ];\n\t\tif ( result === null || result instanceof Promise ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( clone ) {\n\n\t\t\treturn this.cloneResult( result );\n\n\t\t} else {\n\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n\t// kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n\t// the data is ready to use and can be retrieved synchronously with \"getData\".\n\tasync ensureDataLoaded( fileName ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tif ( ! ( key in this._cache ) ) {\n\n\t\t\t// replace the promise with a copy of the parsed data for immediate processing\n\t\t\tthis._cache[ key ] = this.fetchData( fileName ).then( text => {\n\n\t\t\t\tconst info = this.parse( text, fileName );\n\t\t\t\tthis._cache[ key ] = info;\n\t\t\t\treturn info;\n\n\t\t\t} );\n\n\t\t}\n\n\t\tawait this._cache[ key ];\n\n\t}\n\n\t// sets the data in the cache from parsed data\n\tsetData( fileName, text ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tthis._cache[ key ] = this.parse( text, fileName );\n\n\t}\n\n}\n\n// returns the material for an associated color code. If the color code is 16 for a face or 24 for\n// an edge then the passthroughColorCode is used.\nfunction getMaterialFromCode( colorCode, parentColorCode, materialHierarchy, forEdge ) {\n\n\tconst isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\tif ( isPassthrough ) {\n\n\t\tcolorCode = parentColorCode;\n\n\t}\n\n\treturn materialHierarchy[ colorCode ] || null;\n\n}\n\n// Class used to parse and build LDraw parts as three.js objects and cache them if they're a \"Part\" type.\nclass LDrawPartsGeometryCache {\n\n\tconstructor( loader ) {\n\n\t\tthis.loader = loader;\n\t\tthis.parseCache = new LDrawParsedCache( loader );\n\t\tthis._cache = {};\n\n\t}\n\n\t// Convert the given file information into a mesh by processing subobjects.\n\tasync processIntoMesh( info ) {\n\n\t\tconst loader = this.loader;\n\t\tconst parseCache = this.parseCache;\n\t\tconst faceMaterials = new Set();\n\n\t\t// Processes the part subobject information to load child parts and merge geometry onto part\n\t\t// piece object.\n\t\tconst processInfoSubobjects = async ( info, subobject = null ) => {\n\n\t\t\tconst subobjects = info.subobjects;\n\t\t\tconst promises = [];\n\n\t\t\t// Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate\n\t\t\t// group which lets instruction steps apply correctly.\n\t\t\tfor ( let i = 0, l = subobjects.length; i < l; i ++ ) {\n\n\t\t\t\tconst subobject = subobjects[ i ];\n\t\t\t\tconst promise = parseCache.ensureDataLoaded( subobject.fileName ).then( () => {\n\n\t\t\t\t\tconst subobjectInfo = parseCache.getData( subobject.fileName, false );\n\t\t\t\t\tif ( ! isPrimitiveType( subobjectInfo.type ) ) {\n\n\t\t\t\t\t\treturn this.loadModel( subobject.fileName ).catch( error => {\n\n\t\t\t\t\t\t\tconsole.warn( error );\n\t\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn processInfoSubobjects( parseCache.getData( subobject.fileName ), subobject );\n\n\t\t\t\t} );\n\n\t\t\t\tpromises.push( promise );\n\n\t\t\t}\n\n\t\t\tconst group = new Group();\n\t\t\tgroup.userData.category = info.category;\n\t\t\tgroup.userData.keywords = info.keywords;\n\t\t\tgroup.userData.author = info.author;\n\t\t\tgroup.userData.type = info.type;\n\t\t\tgroup.userData.fileName = info.fileName;\n\t\t\tinfo.group = group;\n\n\t\t\tconst subobjectInfos = await Promise.all( promises );\n\t\t\tfor ( let i = 0, l = subobjectInfos.length; i < l; i ++ ) {\n\n\t\t\t\tconst subobject = info.subobjects[ i ];\n\t\t\t\tconst subobjectInfo = subobjectInfos[ i ];\n\n\t\t\t\tif ( subobjectInfo === null ) {\n\n\t\t\t\t\t// the subobject failed to load\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// if the subobject was loaded as a separate group then apply the parent scopes materials\n\t\t\t\tif ( subobjectInfo.isGroup ) {\n\n\t\t\t\t\tconst subobjectGroup = subobjectInfo;\n\t\t\t\t\tsubobject.matrix.decompose( subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale );\n\t\t\t\t\tsubobjectGroup.userData.startingBuildingStep = subobject.startingBuildingStep;\n\t\t\t\t\tsubobjectGroup.name = subobject.fileName;\n\n\t\t\t\t\tloader.applyMaterialsToMesh( subobjectGroup, subobject.colorCode, info.materials );\n\t\t\t\t\tsubobjectGroup.userData.colorCode = subobject.colorCode;\n\n\t\t\t\t\tgroup.add( subobjectGroup );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// add the subobject group if it has children in case it has both children and primitives\n\t\t\t\tif ( subobjectInfo.group.children.length ) {\n\n\t\t\t\t\tgroup.add( subobjectInfo.group );\n\n\t\t\t\t}\n\n\t\t\t\t// transform the primitives into the local space of the parent piece and append them to\n\t\t\t\t// to the parent primitives list.\n\t\t\t\tconst parentLineSegments = info.lineSegments;\n\t\t\t\tconst parentConditionalSegments = info.conditionalSegments;\n\t\t\t\tconst parentFaces = info.faces;\n\n\t\t\t\tconst lineSegments = subobjectInfo.lineSegments;\n\t\t\t\tconst conditionalSegments = subobjectInfo.conditionalSegments;\n\n\t\t\t\tconst faces = subobjectInfo.faces;\n\t\t\t\tconst matrix = subobject.matrix;\n\t\t\t\tconst inverted = subobject.inverted;\n\t\t\t\tconst matrixScaleInverted = matrix.determinant() < 0;\n\t\t\t\tconst colorCode = subobject.colorCode;\n\n\t\t\t\tconst lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n\t\t\t\tfor ( let i = 0, l = lineSegments.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst ls = lineSegments[ i ];\n\t\t\t\t\tconst vertices = ls.vertices;\n\t\t\t\t\tvertices[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tvertices[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n\t\t\t\t\tls.material = ls.material || getMaterialFromCode( ls.colorCode, ls.colorCode, info.materials, true );\n\n\t\t\t\t\tparentLineSegments.push( ls );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, l = conditionalSegments.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst os = conditionalSegments[ i ];\n\t\t\t\t\tconst vertices = os.vertices;\n\t\t\t\t\tconst controlPoints = os.controlPoints;\n\t\t\t\t\tvertices[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tvertices[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tcontrolPoints[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tcontrolPoints[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tos.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n\t\t\t\t\tos.material = os.material || getMaterialFromCode( os.colorCode, os.colorCode, info.materials, true );\n\n\t\t\t\t\tparentConditionalSegments.push( os );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst tri = faces[ i ];\n\t\t\t\t\tconst vertices = tri.vertices;\n\t\t\t\t\tfor ( let i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvertices[ i ].applyMatrix4( matrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n\t\t\t\t\ttri.material = tri.material || getMaterialFromCode( tri.colorCode, colorCode, info.materials, false );\n\t\t\t\t\tfaceMaterials.add( tri.colorCode );\n\n\t\t\t\t\t// If the scale of the object is negated then the triangle winding order\n\t\t\t\t\t// needs to be flipped.\n\t\t\t\t\tif ( matrixScaleInverted !== inverted ) {\n\n\t\t\t\t\t\tvertices.reverse();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tparentFaces.push( tri );\n\n\t\t\t\t}\n\n\t\t\t\tinfo.totalFaces += subobjectInfo.totalFaces;\n\n\t\t\t}\n\n\t\t\t// Apply the parent subobjects pass through material code to this object. This is done several times due\n\t\t\t// to material scoping.\n\t\t\tif ( subobject ) {\n\n\t\t\t\tloader.applyMaterialsToMesh( group, subobject.colorCode, info.materials );\n\t\t\t\tgroup.userData.colorCode = subobject.colorCode;\n\n\t\t\t}\n\n\t\t\treturn info;\n\n\t\t};\n\n\t\t// Track material use to see if we need to use the normal smooth slow path for hard edges.\n\t\tfor ( let i = 0, l = info.faces; i < l; i ++ ) {\n\n\t\t\tfaceMaterials.add( info.faces[ i ].colorCode );\n\n\t\t}\n\n\t\tawait processInfoSubobjects( info );\n\n\t\tif ( loader.smoothNormals ) {\n\n\t\t\tconst checkSubSegments = faceMaterials.size > 1;\n\t\t\tgenerateFaceNormals( info.faces );\n\t\t\tsmoothNormals( info.faces, info.lineSegments, checkSubSegments );\n\n\t\t}\n\n\t\t// Add the primitive objects and metadata.\n\t\tconst group = info.group;\n\t\tif ( info.faces.length > 0 ) {\n\n\t\t\tgroup.add( createObject( this.loader, info.faces, 3, false, info.totalFaces ) );\n\n\t\t}\n\n\t\tif ( info.lineSegments.length > 0 ) {\n\n\t\t\tgroup.add( createObject( this.loader, info.lineSegments, 2 ) );\n\n\t\t}\n\n\t\tif ( info.conditionalSegments.length > 0 ) {\n\n\t\t\tgroup.add( createObject( this.loader, info.conditionalSegments, 2, true ) );\n\n\t\t}\n\n\t\treturn group;\n\n\t}\n\n\thasCachedModel( fileName ) {\n\n\t\treturn fileName !== null && fileName.toLowerCase() in this._cache;\n\n\t}\n\n\tasync getCachedModel( fileName ) {\n\n\t\tif ( fileName !== null && this.hasCachedModel( fileName ) ) {\n\n\t\t\tconst key = fileName.toLowerCase();\n\t\t\tconst group = await this._cache[ key ];\n\t\t\treturn group.clone();\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t// Loads and parses the model with the given file name. Returns a cached copy if available.\n\tasync loadModel( fileName ) {\n\n\t\tconst parseCache = this.parseCache;\n\t\tconst key = fileName.toLowerCase();\n\t\tif ( this.hasCachedModel( fileName ) ) {\n\n\t\t\t// Return cached model if available.\n\t\t\treturn this.getCachedModel( fileName );\n\n\t\t} else {\n\n\t\t\t// Otherwise parse a new model.\n\t\t\t// Ensure the file data is loaded and pre parsed.\n\t\t\tawait parseCache.ensureDataLoaded( fileName );\n\n\t\t\tconst info = parseCache.getData( fileName );\n\t\t\tconst promise = this.processIntoMesh( info );\n\n\t\t\t// Now that the file has loaded it's possible that another part parse has been waiting in parallel\n\t\t\t// so check the cache again to see if it's been added since the last async operation so we don't\n\t\t\t// do unnecessary work.\n\t\t\tif ( this.hasCachedModel( fileName ) ) {\n\n\t\t\t\treturn this.getCachedModel( fileName );\n\n\t\t\t}\n\n\t\t\t// Cache object if it's a part so it can be reused later.\n\t\t\tif ( isPartType( info.type ) ) {\n\n\t\t\t\tthis._cache[ key ] = promise;\n\n\t\t\t}\n\n\t\t\t// return a copy\n\t\t\tconst group = await promise;\n\t\t\treturn group.clone();\n\n\t\t}\n\n\t}\n\n\t// parses the given model text into a renderable object. Returns cached copy if available.\n\tasync parseModel( text ) {\n\n\t\tconst parseCache = this.parseCache;\n\t\tconst info = parseCache.parse( text );\n\t\tif ( isPartType( info.type ) && this.hasCachedModel( info.fileName ) ) {\n\n\t\t\treturn this.getCachedModel( info.fileName );\n\n\t\t}\n\n\t\treturn this.processIntoMesh( info );\n\n\t}\n\n}\n\nfunction sortByMaterial( a, b ) {\n\n\tif ( a.colorCode === b.colorCode ) {\n\n\t\treturn 0;\n\n\t}\n\n\tif ( a.colorCode < b.colorCode ) {\n\n\t\treturn - 1;\n\n\t}\n\n\treturn 1;\n\n}\n\nfunction createObject( loader, elements, elementSize, isConditionalSegments = false, totalElements = null ) {\n\n\t// Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n\t// With per face / segment material, implemented with mesh groups and materials array\n\n\t// Sort the faces or line segments by color code to make later the mesh groups\n\telements.sort( sortByMaterial );\n\n\tif ( totalElements === null ) {\n\n\t\ttotalElements = elements.length;\n\n\t}\n\n\tconst positions = new Float32Array( elementSize * totalElements * 3 );\n\tconst normals = elementSize === 3 ? new Float32Array( elementSize * totalElements * 3 ) : null;\n\tconst materials = [];\n\n\tconst quadArray = new Array( 6 );\n\tconst bufferGeometry = new BufferGeometry();\n\tlet prevMaterial = null;\n\tlet index0 = 0;\n\tlet numGroupVerts = 0;\n\tlet offset = 0;\n\n\tfor ( let iElem = 0, nElem = elements.length; iElem < nElem; iElem ++ ) {\n\n\t\tconst elem = elements[ iElem ];\n\t\tlet vertices = elem.vertices;\n\t\tif ( vertices.length === 4 ) {\n\n\t\t\tquadArray[ 0 ] = vertices[ 0 ];\n\t\t\tquadArray[ 1 ] = vertices[ 1 ];\n\t\t\tquadArray[ 2 ] = vertices[ 2 ];\n\t\t\tquadArray[ 3 ] = vertices[ 0 ];\n\t\t\tquadArray[ 4 ] = vertices[ 2 ];\n\t\t\tquadArray[ 5 ] = vertices[ 3 ];\n\t\t\tvertices = quadArray;\n\n\t\t}\n\n\t\tfor ( let j = 0, l = vertices.length; j < l; j ++ ) {\n\n\t\t\tconst v = vertices[ j ];\n\t\t\tconst index = offset + j * 3;\n\t\t\tpositions[ index + 0 ] = v.x;\n\t\t\tpositions[ index + 1 ] = v.y;\n\t\t\tpositions[ index + 2 ] = v.z;\n\n\t\t}\n\n\t\t// create the normals array if this is a set of faces\n\t\tif ( elementSize === 3 ) {\n\n\t\t\tif ( ! elem.faceNormal ) {\n\n\t\t\t\tconst v0 = vertices[ 0 ];\n\t\t\t\tconst v1 = vertices[ 1 ];\n\t\t\t\tconst v2 = vertices[ 2 ];\n\t\t\t\t_tempVec0.subVectors( v1, v0 );\n\t\t\t\t_tempVec1.subVectors( v2, v1 );\n\t\t\t\telem.faceNormal = new Vector3()\n\t\t\t\t\t.crossVectors( _tempVec0, _tempVec1 )\n\t\t\t\t\t.normalize();\n\n\t\t\t}\n\n\t\t\tlet elemNormals = elem.normals;\n\t\t\tif ( elemNormals.length === 4 ) {\n\n\t\t\t\tquadArray[ 0 ] = elemNormals[ 0 ];\n\t\t\t\tquadArray[ 1 ] = elemNormals[ 1 ];\n\t\t\t\tquadArray[ 2 ] = elemNormals[ 2 ];\n\t\t\t\tquadArray[ 3 ] = elemNormals[ 0 ];\n\t\t\t\tquadArray[ 4 ] = elemNormals[ 2 ];\n\t\t\t\tquadArray[ 5 ] = elemNormals[ 3 ];\n\t\t\t\telemNormals = quadArray;\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0, l = elemNormals.length; j < l; j ++ ) {\n\n\t\t\t\t// use face normal if a vertex normal is not provided\n\t\t\t\tlet n = elem.faceNormal;\n\t\t\t\tif ( elemNormals[ j ] ) {\n\n\t\t\t\t\tn = elemNormals[ j ].norm;\n\n\t\t\t\t}\n\n\t\t\t\tconst index = offset + j * 3;\n\t\t\t\tnormals[ index + 0 ] = n.x;\n\t\t\t\tnormals[ index + 1 ] = n.y;\n\t\t\t\tnormals[ index + 2 ] = n.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( prevMaterial !== elem.colorCode ) {\n\n\t\t\tif ( prevMaterial !== null ) {\n\n\t\t\t\tbufferGeometry.addGroup( index0, numGroupVerts, materials.length - 1 );\n\n\t\t\t}\n\n\t\t\tconst material = elem.material;\n\n\t\t\tif ( material !== null ) {\n\n\t\t\t\tif ( elementSize === 3 ) {\n\n\t\t\t\t\tmaterials.push( material );\n\n\t\t\t\t} else if ( elementSize === 2 ) {\n\n\t\t\t\t\tif ( isConditionalSegments ) {\n\n\t\t\t\t\t\tconst edgeMaterial = loader.edgeMaterialCache.get( material );\n\n\t\t\t\t\t\tmaterials.push( loader.conditionalEdgeMaterialCache.get( edgeMaterial ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterials.push( loader.edgeMaterialCache.get( material ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// If a material has not been made available yet then keep the color code string in the material array\n\t\t\t\t// to save the spot for the material once a parent scopes materials are being applied to the object.\n\t\t\t\tmaterials.push( elem.colorCode );\n\n\t\t\t}\n\n\t\t\tprevMaterial = elem.colorCode;\n\t\t\tindex0 = offset / 3;\n\t\t\tnumGroupVerts = vertices.length;\n\n\t\t} else {\n\n\t\t\tnumGroupVerts += vertices.length;\n\n\t\t}\n\n\t\toffset += 3 * vertices.length;\n\n\t}\n\n\tif ( numGroupVerts > 0 ) {\n\n\t\tbufferGeometry.addGroup( index0, Infinity, materials.length - 1 );\n\n\t}\n\n\tbufferGeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\tif ( normals !== null ) {\n\n\t\tbufferGeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\n\t}\n\n\tlet object3d = null;\n\n\tif ( elementSize === 2 ) {\n\n\t\tif ( isConditionalSegments ) {\n\n\t\t\tobject3d = new ConditionalLineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t\t} else {\n\n\t\t\tobject3d = new LineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t\t}\n\n\t} else if ( elementSize === 3 ) {\n\n\t\tobject3d = new Mesh( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t}\n\n\tif ( isConditionalSegments ) {\n\n\t\tobject3d.isConditionalLine = true;\n\n\t\tconst controlArray0 = new Float32Array( elements.length * 3 * 2 );\n\t\tconst controlArray1 = new Float32Array( elements.length * 3 * 2 );\n\t\tconst directionArray = new Float32Array( elements.length * 3 * 2 );\n\t\tfor ( let i = 0, l = elements.length; i < l; i ++ ) {\n\n\t\t\tconst os = elements[ i ];\n\t\t\tconst vertices = os.vertices;\n\t\t\tconst controlPoints = os.controlPoints;\n\t\t\tconst c0 = controlPoints[ 0 ];\n\t\t\tconst c1 = controlPoints[ 1 ];\n\t\t\tconst v0 = vertices[ 0 ];\n\t\t\tconst v1 = vertices[ 1 ];\n\t\t\tconst index = i * 3 * 2;\n\t\t\tcontrolArray0[ index + 0 ] = c0.x;\n\t\t\tcontrolArray0[ index + 1 ] = c0.y;\n\t\t\tcontrolArray0[ index + 2 ] = c0.z;\n\t\t\tcontrolArray0[ index + 3 ] = c0.x;\n\t\t\tcontrolArray0[ index + 4 ] = c0.y;\n\t\t\tcontrolArray0[ index + 5 ] = c0.z;\n\n\t\t\tcontrolArray1[ index + 0 ] = c1.x;\n\t\t\tcontrolArray1[ index + 1 ] = c1.y;\n\t\t\tcontrolArray1[ index + 2 ] = c1.z;\n\t\t\tcontrolArray1[ index + 3 ] = c1.x;\n\t\t\tcontrolArray1[ index + 4 ] = c1.y;\n\t\t\tcontrolArray1[ index + 5 ] = c1.z;\n\n\t\t\tdirectionArray[ index + 0 ] = v1.x - v0.x;\n\t\t\tdirectionArray[ index + 1 ] = v1.y - v0.y;\n\t\t\tdirectionArray[ index + 2 ] = v1.z - v0.z;\n\t\t\tdirectionArray[ index + 3 ] = v1.x - v0.x;\n\t\t\tdirectionArray[ index + 4 ] = v1.y - v0.y;\n\t\t\tdirectionArray[ index + 5 ] = v1.z - v0.z;\n\n\t\t}\n\n\t\tbufferGeometry.setAttribute( 'control0', new BufferAttribute( controlArray0, 3, false ) );\n\t\tbufferGeometry.setAttribute( 'control1', new BufferAttribute( controlArray1, 3, false ) );\n\t\tbufferGeometry.setAttribute( 'direction', new BufferAttribute( directionArray, 3, false ) );\n\n\t}\n\n\treturn object3d;\n\n}\n\n/**\n * A loader for the LDraw format.\n *\n * [LDraw]{@link https://ldraw.org/} (LEGO Draw) is an [open format specification]{@link https://ldraw.org/article/218.html}\n * for describing LEGO and other construction set 3D models.\n *\n * An LDraw asset (a text file usually with extension .ldr, .dat or .txt) can describe just a single construction\n * piece, or an entire model. In the case of a model the LDraw file can reference other LDraw files, which are\n * loaded from a library path set with `setPartsLibraryPath`. You usually download the LDraw official parts library,\n * extract to a folder and point setPartsLibraryPath to it.\n *\n * Library parts will be loaded by trial and error in subfolders 'parts', 'p' and 'models'. These file accesses\n * are not optimal for web environment, so a script tool has been made to pack an LDraw file with all its dependencies\n * into a single file, which loads much faster. See section 'Packing LDraw models'. The LDrawLoader example loads\n * several packed files. The official parts library is not included due to its large size.\n *\n * `LDrawLoader` supports the following extensions:\n * - !COLOUR: Color and surface finish declarations.\n * - BFC: Back Face Culling specification.\n * - !CATEGORY: Model/part category declarations.\n * - !KEYWORDS: Model/part keywords declarations.\n *\n * ```js\n * const loader = new LDrawLoader();\n * loader.setConditionalLineMaterial( LDrawConditionalLineMaterial ); // the type of line material depends on the used renderer\n * const object = await loader.loadAsync( 'models/ldraw/officialLibrary/models/car.ldr_Packed.mpd' );\n * scene.add( object );\n * ```\n *\n * @augments Loader\n * @three_import import { LDrawLoader } from 'three/addons/loaders/LDrawLoader.js';\n */\nclass LDrawLoader extends Loader {\n\n\t/**\n\t * Constructs a new LDraw loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t// Array of THREE.Material\n\t\tthis.materials = [];\n\t\tthis.materialLibrary = {};\n\t\tthis.edgeMaterialCache = new WeakMap();\n\t\tthis.conditionalEdgeMaterialCache = new WeakMap();\n\n\t\t// This also allows to handle the embedded text files (\"0 FILE\" lines)\n\t\tthis.partsCache = new LDrawPartsGeometryCache( this );\n\n\t\t// This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\t\tthis.fileMap = {};\n\n\t\t// If this flag is set to true the vertex normals will be smoothed.\n\t\tthis.smoothNormals = true;\n\n\t\t// The path to load parts from the LDraw parts library from.\n\t\tthis.partsLibraryPath = '';\n\n\t\t// this material type must be injected via setConditionalLineMaterial()\n\t\tthis.ConditionalLineMaterial = null;\n\n\t\t// Material assigned to not available colors for meshes and edges\n\t\tthis.missingColorMaterial = new MeshStandardMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0xFF00FF, roughness: 0.3, metalness: 0 } );\n\t\tthis.missingEdgeColorMaterial = new LineBasicMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0xFF00FF } );\n\t\tthis.missingConditionalEdgeColorMaterial = null;\n\t\tthis.edgeMaterialCache.set( this.missingColorMaterial, this.missingEdgeColorMaterial );\n\t\tthis.conditionalEdgeMaterialCache.set( this.missingEdgeColorMaterial, this.missingConditionalEdgeColorMaterial );\n\n\t}\n\n\t/**\n\t * This method must be called prior to `load()` unless the model to load does not reference\n\t * library parts (usually it will be a model with all its parts packed in a single file).\n\t *\n\t * @param {string} path - Path to library parts files to load referenced parts from.\n\t * This is different from Loader.setPath, which indicates the path to load the main asset from.\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\tsetPartsLibraryPath( path ) {\n\n\t\tthis.partsLibraryPath = path;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the conditional line material type which depends on the used renderer.\n\t * Use {@link LDrawConditionalLineMaterial} when using `WebGLRenderer` and\n\t * {@link LDrawConditionalLineNodeMaterial} when using `WebGPURenderer`.\n\t *\n\t * @param {(LDrawConditionalLineMaterial.constructor|LDrawConditionalLineNodeMaterial.constructor)} type - The conditional line material type.\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\tsetConditionalLineMaterial( type ) {\n\n\t\tthis.ConditionalLineMaterial = type;\n\t\tthis.missingConditionalEdgeColorMaterial = new this.ConditionalLineMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, fog: true, color: 0xFF00FF } );\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * This async method preloads materials from a single LDraw file. In the official\n\t * parts library there is a special file which is loaded always the first (LDConfig.ldr)\n\t * and contains all the standard color codes. This method is intended to be used with\n\t * not packed files, for example in an editor where materials are preloaded and parts\n\t * are loaded on demand.\n\t *\n\t * @async\n\t * @param {string} url - Path of the LDraw materials asset.\n\t * @return {Promise} A Promise that resolves when the preload has finished.\n\t */\n\tasync preloadMaterials( url ) {\n\n\t\tconst fileLoader = new FileLoader( this.manager );\n\t\tfileLoader.setPath( this.path );\n\t\tfileLoader.setRequestHeader( this.requestHeader );\n\t\tfileLoader.setWithCredentials( this.withCredentials );\n\n\t\tconst text = await fileLoader.loadAsync( url );\n\t\tconst colorLineRegex = /^0 !COLOUR/;\n\t\tconst lines = text.split( /[\\n\\r]/g );\n\t\tconst materials = [];\n\t\tfor ( let i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\tconst line = lines[ i ];\n\t\t\tif ( colorLineRegex.test( line ) ) {\n\n\t\t\t\tconst directive = line.replace( colorLineRegex, '' );\n\t\t\t\tconst material = this.parseColorMetaDirective( new LineParser( directive ) );\n\t\t\t\tmaterials.push( material );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.addMaterials( materials );\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded LDraw asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(Group)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst fileLoader = new FileLoader( this.manager );\n\t\tfileLoader.setPath( this.path );\n\t\tfileLoader.setRequestHeader( this.requestHeader );\n\t\tfileLoader.setWithCredentials( this.withCredentials );\n\t\tfileLoader.load( url, text => {\n\n\t\t\t// Initializes the materials library with default materials\n\t\t\tthis.addDefaultMaterials();\n\n\t\t\tthis.partsCache\n\t\t\t\t.parseModel( text )\n\t\t\t\t.then( group => {\n\n\t\t\t\t\tthis.applyMaterialsToMesh( group, MAIN_COLOUR_CODE, this.materialLibrary, true );\n\t\t\t\t\tthis.computeBuildingSteps( group );\n\t\t\t\t\tgroup.userData.fileName = url;\n\t\t\t\t\tonLoad( group );\n\n\t\t\t\t} )\n\t\t\t\t.catch( onError );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given LDraw data and returns the resulting group.\n\t *\n\t * @param {string} text - The raw VRML data as a string.\n\t * @param {function(Group)} onLoad - Executed when the loading/parsing process has been finished.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tparse( text, onLoad, onError ) {\n\n\t\tthis.partsCache\n\t\t\t.parseModel( text )\n\t\t\t.then( group => {\n\n\t\t\t\tthis.applyMaterialsToMesh( group, MAIN_COLOUR_CODE, this.materialLibrary, true );\n\t\t\t\tthis.computeBuildingSteps( group );\n\t\t\t\tgroup.userData.fileName = '';\n\t\t\t\tonLoad( group );\n\n\t\t\t} )\n\t\t\t.catch( onError );\n\n\t}\n\n\t/**\n\t * Sets the loader's material library. This method clears existing\n\t * material definitions.\n\t *\n\t * @param {Array<Material>} materials - The materials to set.\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\tsetMaterials( materials ) {\n\n\t\tthis.clearMaterials();\n\t\tthis.addMaterials( materials );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Clears the loader's material library.\n\t *\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\tclearMaterials() {\n\n\t\tthis.materialLibrary = {};\n\t\tthis.materials = [];\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds a list of materials to the loader's material library.\n\t *\n\t * @param {Array<Material>} materials - The materials to add.\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\taddMaterials( materials ) {\n\n\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tthis.addMaterial( materials[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Initializes the loader with default materials.\n\t *\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\taddDefaultMaterials() {\n\n\t\t// Add default main triangle and line edge materials (used in pieces that can be colored with a main color)\n\t\tthis.addMaterial( this.parseColorMetaDirective( new LineParser( 'Main_Colour CODE 16 VALUE #FF8080 EDGE #333333' ) ) );\n\t\tthis.addMaterial( this.parseColorMetaDirective( new LineParser( 'Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333' ) ) );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets a map which maps referenced library filenames to new filenames.\n\t * If a fileMap is not specified (the default), library parts will be accessed by trial and\n\t * error in subfolders 'parts', 'p' and 'models'.\n\t *\n\t * @param {Object<string,string>} fileMap - The file map to set.\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\tsetFileMap( fileMap ) {\n\n\t\tthis.fileMap = fileMap;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds a single material to the loader's material library.\n\t *\n\t * @param {Material} material - The material to add.\n\t * @return {LDrawLoader} A reference to this loader.\n\t */\n\taddMaterial( material ) {\n\n\t\t// Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n\n\t\tconst matLib = this.materialLibrary;\n\t\tif ( ! matLib[ material.userData.code ] ) {\n\n\t\t\tthis.materials.push( material );\n\t\t\tmatLib[ material.userData.code ] = material;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a material for the given color code.\n\t *\n\t * @param {string} colorCode - The color code.\n\t * @return {?Material} The material. Returns `null` if no material has been found.\n\t */\n\tgetMaterial( colorCode ) {\n\n\t\tif ( colorCode.startsWith( '0x2' ) ) {\n\n\t\t\t// Special 'direct' material value (RGB color)\n\t\t\tconst color = colorCode.substring( 3 );\n\n\t\t\treturn this.parseColorMetaDirective( new LineParser( 'Direct_Color_' + color + ' CODE -1 VALUE #' + color + ' EDGE #' + color + '' ) );\n\n\t\t}\n\n\t\treturn this.materialLibrary[ colorCode ] || null;\n\n\t}\n\n\t// Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n\t// in the material array if they need to be filled in.\n\tapplyMaterialsToMesh( group, parentColorCode, materialHierarchy, finalMaterialPass = false ) {\n\n\t\t// find any missing materials as indicated by a color code string and replace it with a material from the current material lib\n\t\tconst loader = this;\n\t\tconst parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n\t\tgroup.traverse( c => {\n\n\t\t\tif ( c.isMesh || c.isLineSegments ) {\n\n\t\t\t\tif ( Array.isArray( c.material ) ) {\n\n\t\t\t\t\tfor ( let i = 0, l = c.material.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( ! c.material[ i ].isMaterial ) {\n\n\t\t\t\t\t\t\tc.material[ i ] = getMaterial( c, c.material[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( ! c.material.isMaterial ) {\n\n\t\t\t\t\tc.material = getMaterial( c, c.material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\n\t\t// Returns the appropriate material for the object (line or face) given color code. If the code is \"pass through\"\n\t\t// (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's\n\t\t// simply returned for the subsequent material application.\n\t\tfunction getMaterial( c, colorCode ) {\n\n\t\t\t// if our parent is a passthrough color code and we don't have the current material color available then\n\t\t\t// return early.\n\t\t\tif ( parentIsPassthrough && ! ( colorCode in materialHierarchy ) && ! finalMaterialPass ) {\n\n\t\t\t\treturn colorCode;\n\n\t\t\t}\n\n\t\t\tconst forEdge = c.isLineSegments || c.isConditionalLine;\n\t\t\tconst isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\t\t\tif ( isPassthrough ) {\n\n\t\t\t\tcolorCode = parentColorCode;\n\n\t\t\t}\n\n\t\t\tlet material = null;\n\t\t\tif ( colorCode in materialHierarchy ) {\n\n\t\t\t\tmaterial = materialHierarchy[ colorCode ];\n\n\t\t\t} else if ( finalMaterialPass ) {\n\n\t\t\t\t// see if we can get the final material from the \"getMaterial\" function which will attempt to\n\t\t\t\t// parse the \"direct\" colors\n\t\t\t\tmaterial = loader.getMaterial( colorCode );\n\t\t\t\tif ( material === null ) {\n\n\t\t\t\t\t// otherwise throw a warning if this is final opportunity to set the material\n\t\t\t\t\tconsole.warn( `LDrawLoader: Material properties for code ${ colorCode } not available.` );\n\n\t\t\t\t\t// And return the 'missing color' material\n\t\t\t\t\tmaterial = loader.missingColorMaterial;\n\n\t\t\t\t}\n\n\n\t\t\t} else {\n\n\t\t\t\treturn colorCode;\n\n\t\t\t}\n\n\t\t\tif ( c.isLineSegments ) {\n\n\t\t\t\tmaterial = loader.edgeMaterialCache.get( material );\n\n\t\t\t\tif ( c.isConditionalLine ) {\n\n\t\t\t\t\tmaterial = loader.conditionalEdgeMaterialCache.get( material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the Material for the main LDraw color.\n\t *\n\t * For an already loaded LDraw asset, returns the Material associated with the main color code.\n\t * This method can be useful to modify the main material of a model or part that exposes it.\n\t *\n\t * The main color code is the standard way to color an LDraw part. It is '16' for triangles and\n\t * '24' for edges. Usually a complete model will not expose the main color (that is, no part\n\t * uses the code '16' at the top level, because they are assigned other specific colors) An LDraw\n\t *  part file on the other hand will expose the code '16' to be colored, and can have additional\n\t * fixed colors.\n\t *\n\t * @return {?Material} The material. Returns `null` if no material has been found.\n\t */\n\tgetMainMaterial() {\n\n\t\treturn this.getMaterial( MAIN_COLOUR_CODE );\n\n\t}\n\n\t/**\n\t * Returns the material for the edges main LDraw color.\n\t *\n\t * @return {?Material} The material. Returns `null` if no material has been found.\n\t */\n\tgetMainEdgeMaterial() {\n\n\t\tconst mat = this.getMaterial( MAIN_EDGE_COLOUR_CODE );\n\t\treturn mat ? this.edgeMaterialCache.get( mat ) : null;\n\n\t}\n\n\tparseColorMetaDirective( lineParser ) {\n\n\t\t// Parses a color definition and returns a THREE.Material\n\n\t\tlet code = null;\n\n\t\t// Triangle and line colors\n\t\tlet fillColor = '#FF00FF';\n\t\tlet edgeColor = '#FF00FF';\n\n\t\t// Transparency\n\t\tlet alpha = 1;\n\t\tlet isTransparent = false;\n\t\t// Self-illumination:\n\t\tlet luminance = 0;\n\n\t\tlet finishType = FINISH_TYPE_DEFAULT;\n\n\t\tlet edgeMaterial = null;\n\n\t\tconst name = lineParser.getToken();\n\t\tif ( ! name ) {\n\n\t\t\tthrow new Error( 'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.' );\n\n\t\t}\n\n\t\t// Parse tag tokens and their parameters\n\t\tlet token = null;\n\t\twhile ( true ) {\n\n\t\t\ttoken = lineParser.getToken();\n\n\t\t\tif ( ! token ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( ! parseLuminance( token ) ) {\n\n\t\t\t\tswitch ( token.toUpperCase() ) {\n\n\t\t\t\t\tcase 'CODE':\n\n\t\t\t\t\t\tcode = lineParser.getToken();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'VALUE':\n\n\t\t\t\t\t\tfillColor = lineParser.getToken();\n\t\t\t\t\t\tif ( fillColor.startsWith( '0x' ) ) {\n\n\t\t\t\t\t\t\tfillColor = '#' + fillColor.substring( 2 );\n\n\t\t\t\t\t\t} else if ( ! fillColor.startsWith( '#' ) ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid color while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'EDGE':\n\n\t\t\t\t\t\tedgeColor = lineParser.getToken();\n\t\t\t\t\t\tif ( edgeColor.startsWith( '0x' ) ) {\n\n\t\t\t\t\t\t\tedgeColor = '#' + edgeColor.substring( 2 );\n\n\t\t\t\t\t\t} else if ( ! edgeColor.startsWith( '#' ) ) {\n\n\t\t\t\t\t\t\t// Try to see if edge color is a color code\n\t\t\t\t\t\t\tedgeMaterial = this.getMaterial( edgeColor );\n\t\t\t\t\t\t\tif ( ! edgeMaterial ) {\n\n\t\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid edge color while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get the edge material for this triangle material\n\t\t\t\t\t\t\tedgeMaterial = this.edgeMaterialCache.get( edgeMaterial );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ALPHA':\n\n\t\t\t\t\t\talpha = parseInt( lineParser.getToken() );\n\n\t\t\t\t\t\tif ( isNaN( alpha ) ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\talpha = Math.max( 0, Math.min( 1, alpha / 255 ) );\n\n\t\t\t\t\t\tif ( alpha < 1 ) {\n\n\t\t\t\t\t\t\tisTransparent = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LUMINANCE':\n\n\t\t\t\t\t\tif ( ! parseLuminance( lineParser.getToken() ) ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid luminance value in material definition' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CHROME':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_CHROME;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PEARLESCENT':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_PEARLESCENT;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'RUBBER':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_RUBBER;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'MATTE_METALLIC':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_MATTE_METALLIC;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'METAL':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_METAL;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'MATERIAL':\n\t\t\t\t\t\t// Not implemented\n\t\t\t\t\t\tlineParser.setToEnd();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet material = null;\n\n\t\tswitch ( finishType ) {\n\n\t\t\tcase FINISH_TYPE_DEFAULT:\n\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.3, metalness: 0 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_PEARLESCENT:\n\n\t\t\t\t// Try to imitate pearlescency by making the surface glossy\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.3, metalness: 0.25 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_CHROME:\n\n\t\t\t\t// Mirror finish surface\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0, metalness: 1 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_RUBBER:\n\n\t\t\t\t// Rubber finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.9, metalness: 0 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_MATTE_METALLIC:\n\n\t\t\t\t// Brushed metal finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.8, metalness: 0.4 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_METAL:\n\n\t\t\t\t// Average metal finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.2, metalness: 0.85 } );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// Should not happen\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tmaterial.color.setStyle( fillColor, COLOR_SPACE_LDRAW );\n\t\tmaterial.transparent = isTransparent;\n\t\tmaterial.premultipliedAlpha = true;\n\t\tmaterial.opacity = alpha;\n\t\tmaterial.depthWrite = ! isTransparent;\n\n\t\tmaterial.polygonOffset = true;\n\t\tmaterial.polygonOffsetFactor = 1;\n\n\t\tif ( luminance !== 0 ) {\n\n\t\t\tmaterial.emissive.setStyle( fillColor, COLOR_SPACE_LDRAW ).multiplyScalar( luminance );\n\n\t\t}\n\n\t\tif ( ! edgeMaterial ) {\n\n\t\t\t// This is the material used for edges\n\t\t\tedgeMaterial = new LineBasicMaterial( {\n\t\t\t\tcolor: new Color().setStyle( edgeColor, COLOR_SPACE_LDRAW ),\n\t\t\t\ttransparent: isTransparent,\n\t\t\t\topacity: alpha,\n\t\t\t\tdepthWrite: ! isTransparent\n\t\t\t} );\n\t\t\tedgeMaterial.color;\n\t\t\tedgeMaterial.userData.code = code;\n\t\t\tedgeMaterial.name = name + ' - Edge';\n\n\t\t\tif ( this.ConditionalLineMaterial === null ) {\n\n\t\t\t\tthrow new Error( 'THREE.LDrawLoader: ConditionalLineMaterial type must be specified via .setConditionalLineMaterial().' );\n\n\t\t\t}\n\n\t\t\t// This is the material used for conditional edges\n\t\t\tconst conditionalEdgeMaterial = new this.ConditionalLineMaterial( {\n\n\t\t\t\tfog: true,\n\t\t\t\ttransparent: isTransparent,\n\t\t\t\tdepthWrite: ! isTransparent,\n\t\t\t\tcolor: new Color().setStyle( edgeColor, COLOR_SPACE_LDRAW ),\n\t\t\t\topacity: alpha,\n\n\t\t\t} );\n\t\t\tconditionalEdgeMaterial.userData.code = code;\n\t\t\tconditionalEdgeMaterial.name = name + ' - Conditional Edge';\n\n\t\t\tthis.conditionalEdgeMaterialCache.set( edgeMaterial, conditionalEdgeMaterial );\n\n\t\t}\n\n\t\tmaterial.userData.code = code;\n\t\tmaterial.name = name;\n\n\t\tthis.edgeMaterialCache.set( material, edgeMaterial );\n\n\t\tthis.addMaterial( material );\n\n\t\treturn material;\n\n\t\tfunction parseLuminance( token ) {\n\n\t\t\t// Returns success\n\n\t\t\tlet lum;\n\n\t\t\tif ( token.startsWith( 'LUMINANCE' ) ) {\n\n\t\t\t\tlum = parseInt( token.substring( 9 ) );\n\n\t\t\t} else {\n\n\t\t\t\tlum = parseInt( token );\n\n\t\t\t}\n\n\t\t\tif ( isNaN( lum ) ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tluminance = Math.max( 0, Math.min( 1, lum / 255 ) );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\tcomputeBuildingSteps( model ) {\n\n\t\t// Sets userdata.buildingStep number in Group objects and userData.numBuildingSteps number in the root Group object.\n\n\t\tlet stepNumber = 0;\n\n\t\tmodel.traverse( c => {\n\n\t\t\tif ( c.isGroup ) {\n\n\t\t\t\tif ( c.userData.startingBuildingStep ) {\n\n\t\t\t\t\tstepNumber ++;\n\n\t\t\t\t}\n\n\t\t\t\tc.userData.buildingStep = stepNumber;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tmodel.userData.numBuildingSteps = stepNumber + 1;\n\n\t}\n\n}\n\nexport { LDrawLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}