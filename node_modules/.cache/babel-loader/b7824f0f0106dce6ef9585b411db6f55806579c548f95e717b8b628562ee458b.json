{"ast":null,"code":"import { ClampToEdgeWrapping, DoubleSide, LinearFilter, Mesh, MeshBasicMaterial, PlaneGeometry, Texture, SRGBColorSpace } from 'three';\n\n/**\n * This class has been made to hold a slice of a volume data.\n *\n * @see {@link Volume}\n * @three_import import { VolumeSlice } from 'three/addons/misc/VolumeSlice.js';\n */\nclass VolumeSlice {\n  /**\n   * Constructs a new volume slice.\n   *\n  \t * @param {Volume} volume - The associated volume.\n  \t * @param {number} [index=0] - The index of the slice.\n  \t * @param {('x'|'y'|'z')} [axis='z'] - For now only 'x', 'y' or 'z' but later it will change to a normal vector.\n   */\n  constructor(volume, index = 0, axis = 'z') {\n    const slice = this;\n\n    /**\n     * The associated volume.\n     *\n     * @type {Volume}\n     */\n    this.volume = volume;\n    Object.defineProperty(this, 'index', {\n      get: function () {\n        return index;\n      },\n      /**\n       * The index of the slice, if changed, will automatically call updateGeometry at the next repaint.\n       *\n       * @name VolumeSlice#index\n       * @type {number}\n       * @default 0\n       * @param {number} value\n       * @return {number}\n       */\n      set: function (value) {\n        index = value;\n        slice.geometryNeedsUpdate = true;\n        return index;\n      }\n    });\n\n    /**\n     * The normal axis.\n     *\n     * @type {('x'|'y'|'z')}\n     */\n    this.axis = axis;\n\n    /**\n     * The final canvas used for the texture.\n     *\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas = document.createElement('canvas');\n\n    /**\n     * The rendering context of the canvas.\n     *\n     * @type {CanvasRenderingContext2D}\n     */\n    this.ctx;\n\n    /**\n     * The intermediary canvas used to paint the data.\n     *\n     * @type {HTMLCanvasElement}\n     */\n    this.canvasBuffer = document.createElement('canvas');\n\n    /**\n     * The rendering context of the canvas buffer,\n     *\n     * @type {CanvasRenderingContext2D}\n     */\n    this.ctxBuffer;\n    this.updateGeometry();\n    const canvasMap = new Texture(this.canvas);\n    canvasMap.minFilter = LinearFilter;\n    canvasMap.generateMipmaps = false;\n    canvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping;\n    canvasMap.colorSpace = SRGBColorSpace;\n    const material = new MeshBasicMaterial({\n      map: canvasMap,\n      side: DoubleSide,\n      transparent: true\n    });\n\n    /**\n     * The mesh ready to get used in the scene.\n     *\n     * @type {Mesh}\n     */\n    this.mesh = new Mesh(this.geometry, material);\n    this.mesh.matrixAutoUpdate = false;\n\n    /**\n     * If set to `true`, `updateGeometry()` will be triggered at the next repaint.\n     *\n     * @type {boolean}\n     * @default true\n     */\n    this.geometryNeedsUpdate = true;\n    this.repaint();\n\n    /**\n     * Width of slice in the original coordinate system, corresponds to the width of the buffer canvas.\n     *\n     * @type {number}\n     * @default 0\n     */\n    this.iLength = 0;\n\n    /**\n     * Height of slice in the original coordinate system, corresponds to the height of the buffer canvas.\n     *\n     * @type {number}\n     * @default 0\n     */\n    this.jLength = 0;\n\n    /**\n     * Function that allow the slice to access right data.\n     *\n     * @type {?Function}\n     * @see {@link Volume#extractPerpendicularPlane}\n     */\n    this.sliceAccess = null;\n  }\n\n  /**\n   * Refresh the texture and the geometry if geometryNeedsUpdate is set to `true`.\n   */\n  repaint() {\n    if (this.geometryNeedsUpdate) {\n      this.updateGeometry();\n    }\n    const iLength = this.iLength,\n      jLength = this.jLength,\n      sliceAccess = this.sliceAccess,\n      volume = this.volume,\n      canvas = this.canvasBuffer,\n      ctx = this.ctxBuffer;\n\n    // get the imageData and pixel array from the canvas\n    const imgData = ctx.getImageData(0, 0, iLength, jLength);\n    const data = imgData.data;\n    const volumeData = volume.data;\n    const upperThreshold = volume.upperThreshold;\n    const lowerThreshold = volume.lowerThreshold;\n    const windowLow = volume.windowLow;\n    const windowHigh = volume.windowHigh;\n\n    // manipulate some pixel elements\n    let pixelCount = 0;\n    if (volume.dataType === 'label') {\n      console.error('THREE.VolumeSlice.repaint: label are not supported yet');\n\n      // This part is currently useless but will be used when colortables will be handled\n\n      // for ( let j = 0; j < jLength; j ++ ) {\n\n      // \tfor ( let i = 0; i < iLength; i ++ ) {\n\n      // \t\tlet label = volumeData[ sliceAccess( i, j ) ];\n      // \t\tlabel = label >= this.colorMap.length ? ( label % this.colorMap.length ) + 1 : label;\n      // \t\tconst color = this.colorMap[ label ];\n      // \t\tdata[ 4 * pixelCount ] = ( color >> 24 ) & 0xff;\n      // \t\tdata[ 4 * pixelCount + 1 ] = ( color >> 16 ) & 0xff;\n      // \t\tdata[ 4 * pixelCount + 2 ] = ( color >> 8 ) & 0xff;\n      // \t\tdata[ 4 * pixelCount + 3 ] = color & 0xff;\n      // \t\tpixelCount ++;\n\n      // \t}\n\n      // }\n    } else {\n      for (let j = 0; j < jLength; j++) {\n        for (let i = 0; i < iLength; i++) {\n          let value = volumeData[sliceAccess(i, j)];\n          let alpha = 0xff;\n          //apply threshold\n          alpha = upperThreshold >= value ? lowerThreshold <= value ? alpha : 0 : 0;\n          //apply window level\n          value = Math.floor(255 * (value - windowLow) / (windowHigh - windowLow));\n          value = value > 255 ? 255 : value < 0 ? 0 : value | 0;\n          data[4 * pixelCount] = value;\n          data[4 * pixelCount + 1] = value;\n          data[4 * pixelCount + 2] = value;\n          data[4 * pixelCount + 3] = alpha;\n          pixelCount++;\n        }\n      }\n    }\n    ctx.putImageData(imgData, 0, 0);\n    this.ctx.drawImage(canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height);\n    this.mesh.material.map.needsUpdate = true;\n  }\n\n  /**\n   * Refresh the geometry according to axis and index.\n   * @see {@link Volume#extractPerpendicularPlane}\n   */\n  updateGeometry() {\n    const extracted = this.volume.extractPerpendicularPlane(this.axis, this.index);\n    this.sliceAccess = extracted.sliceAccess;\n    this.jLength = extracted.jLength;\n    this.iLength = extracted.iLength;\n    this.matrix = extracted.matrix;\n    this.canvas.width = extracted.planeWidth;\n    this.canvas.height = extracted.planeHeight;\n    this.canvasBuffer.width = this.iLength;\n    this.canvasBuffer.height = this.jLength;\n    this.ctx = this.canvas.getContext('2d');\n    this.ctxBuffer = this.canvasBuffer.getContext('2d');\n    if (this.geometry) this.geometry.dispose(); // dispose existing geometry\n\n    this.geometry = new PlaneGeometry(extracted.planeWidth, extracted.planeHeight);\n    if (this.mesh) {\n      this.mesh.geometry = this.geometry;\n      //reset mesh matrix\n      this.mesh.matrix.identity();\n      this.mesh.applyMatrix4(this.matrix);\n    }\n    this.geometryNeedsUpdate = false;\n  }\n}\nexport { VolumeSlice };","map":{"version":3,"names":["ClampToEdgeWrapping","DoubleSide","LinearFilter","Mesh","MeshBasicMaterial","PlaneGeometry","Texture","SRGBColorSpace","VolumeSlice","constructor","volume","index","axis","slice","Object","defineProperty","get","set","value","geometryNeedsUpdate","canvas","document","createElement","ctx","canvasBuffer","ctxBuffer","updateGeometry","canvasMap","minFilter","generateMipmaps","wrapS","wrapT","colorSpace","material","map","side","transparent","mesh","geometry","matrixAutoUpdate","repaint","iLength","jLength","sliceAccess","imgData","getImageData","data","volumeData","upperThreshold","lowerThreshold","windowLow","windowHigh","pixelCount","dataType","console","error","j","i","alpha","Math","floor","putImageData","drawImage","width","height","needsUpdate","extracted","extractPerpendicularPlane","matrix","planeWidth","planeHeight","getContext","dispose","identity","applyMatrix4"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/misc/VolumeSlice.js"],"sourcesContent":["import {\n\tClampToEdgeWrapping,\n\tDoubleSide,\n\tLinearFilter,\n\tMesh,\n\tMeshBasicMaterial,\n\tPlaneGeometry,\n\tTexture,\n\tSRGBColorSpace\n} from 'three';\n\n/**\n * This class has been made to hold a slice of a volume data.\n *\n * @see {@link Volume}\n * @three_import import { VolumeSlice } from 'three/addons/misc/VolumeSlice.js';\n */\nclass VolumeSlice {\n\n\t/**\n\t * Constructs a new volume slice.\n\t *\n \t * @param {Volume} volume - The associated volume.\n \t * @param {number} [index=0] - The index of the slice.\n \t * @param {('x'|'y'|'z')} [axis='z'] - For now only 'x', 'y' or 'z' but later it will change to a normal vector.\n\t */\n\tconstructor( volume, index = 0, axis = 'z' ) {\n\n\t\tconst slice = this;\n\n\t\t/**\n\t\t * The associated volume.\n\t\t *\n\t\t * @type {Volume}\n\t\t */\n\t\tthis.volume = volume;\n\n\t\tObject.defineProperty( this, 'index', {\n\t\t\tget: function () {\n\n\t\t\t\treturn index;\n\n\t\t\t},\n\t\t\t/**\n\t\t\t * The index of the slice, if changed, will automatically call updateGeometry at the next repaint.\n\t\t\t *\n\t\t\t * @name VolumeSlice#index\n\t\t\t * @type {number}\n\t\t\t * @default 0\n\t\t\t * @param {number} value\n\t\t\t * @return {number}\n\t\t\t */\n\t\t\tset: function ( value ) {\n\n\t\t\t\tindex = value;\n\t\t\t\tslice.geometryNeedsUpdate = true;\n\t\t\t\treturn index;\n\n\t\t\t}\n\t\t} );\n\n\t\t/**\n\t\t * The normal axis.\n\t\t *\n\t\t * @type {('x'|'y'|'z')}\n\t\t */\n\t\tthis.axis = axis;\n\n\t\t/**\n\t\t * The final canvas used for the texture.\n\t\t *\n\t\t * @type {HTMLCanvasElement}\n\t\t */\n\t\tthis.canvas = document.createElement( 'canvas' );\n\n\t\t/**\n\t\t * The rendering context of the canvas.\n\t\t *\n\t\t * @type {CanvasRenderingContext2D}\n\t\t */\n\t\tthis.ctx;\n\n\t\t/**\n\t\t * The intermediary canvas used to paint the data.\n\t\t *\n\t\t * @type {HTMLCanvasElement}\n\t\t */\n\t\tthis.canvasBuffer = document.createElement( 'canvas' );\n\n\t\t/**\n\t\t * The rendering context of the canvas buffer,\n\t\t *\n\t\t * @type {CanvasRenderingContext2D}\n\t\t */\n\t\tthis.ctxBuffer;\n\n\t\tthis.updateGeometry();\n\n\n\t\tconst canvasMap = new Texture( this.canvas );\n\t\tcanvasMap.minFilter = LinearFilter;\n\t\tcanvasMap.generateMipmaps = false;\n\t\tcanvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping;\n\t\tcanvasMap.colorSpace = SRGBColorSpace;\n\t\tconst material = new MeshBasicMaterial( { map: canvasMap, side: DoubleSide, transparent: true } );\n\n\t\t/**\n\t\t * The mesh ready to get used in the scene.\n\t\t *\n\t\t * @type {Mesh}\n\t\t */\n\t\tthis.mesh = new Mesh( this.geometry, material );\n\t\tthis.mesh.matrixAutoUpdate = false;\n\n\t\t/**\n\t\t * If set to `true`, `updateGeometry()` will be triggered at the next repaint.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.geometryNeedsUpdate = true;\n\t\tthis.repaint();\n\n\t\t/**\n\t\t * Width of slice in the original coordinate system, corresponds to the width of the buffer canvas.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.iLength = 0;\n\n\t\t/**\n\t\t * Height of slice in the original coordinate system, corresponds to the height of the buffer canvas.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.jLength = 0;\n\n\t\t/**\n\t\t * Function that allow the slice to access right data.\n\t\t *\n\t\t * @type {?Function}\n\t\t * @see {@link Volume#extractPerpendicularPlane}\n\t\t */\n\t\tthis.sliceAccess = null;\n\n\t}\n\n\t/**\n\t * Refresh the texture and the geometry if geometryNeedsUpdate is set to `true`.\n\t */\n\trepaint() {\n\n\t\tif ( this.geometryNeedsUpdate ) {\n\n\t\t\tthis.updateGeometry();\n\n\t\t}\n\n\t\tconst iLength = this.iLength,\n\t\t\tjLength = this.jLength,\n\t\t\tsliceAccess = this.sliceAccess,\n\t\t\tvolume = this.volume,\n\t\t\tcanvas = this.canvasBuffer,\n\t\t\tctx = this.ctxBuffer;\n\n\n\t\t// get the imageData and pixel array from the canvas\n\t\tconst imgData = ctx.getImageData( 0, 0, iLength, jLength );\n\t\tconst data = imgData.data;\n\t\tconst volumeData = volume.data;\n\t\tconst upperThreshold = volume.upperThreshold;\n\t\tconst lowerThreshold = volume.lowerThreshold;\n\t\tconst windowLow = volume.windowLow;\n\t\tconst windowHigh = volume.windowHigh;\n\n\t\t// manipulate some pixel elements\n\t\tlet pixelCount = 0;\n\n\t\tif ( volume.dataType === 'label' ) {\n\n\t\t\tconsole.error( 'THREE.VolumeSlice.repaint: label are not supported yet' );\n\n\t\t\t// This part is currently useless but will be used when colortables will be handled\n\n\t\t\t// for ( let j = 0; j < jLength; j ++ ) {\n\n\t\t\t// \tfor ( let i = 0; i < iLength; i ++ ) {\n\n\t\t\t// \t\tlet label = volumeData[ sliceAccess( i, j ) ];\n\t\t\t// \t\tlabel = label >= this.colorMap.length ? ( label % this.colorMap.length ) + 1 : label;\n\t\t\t// \t\tconst color = this.colorMap[ label ];\n\t\t\t// \t\tdata[ 4 * pixelCount ] = ( color >> 24 ) & 0xff;\n\t\t\t// \t\tdata[ 4 * pixelCount + 1 ] = ( color >> 16 ) & 0xff;\n\t\t\t// \t\tdata[ 4 * pixelCount + 2 ] = ( color >> 8 ) & 0xff;\n\t\t\t// \t\tdata[ 4 * pixelCount + 3 ] = color & 0xff;\n\t\t\t// \t\tpixelCount ++;\n\n\t\t\t// \t}\n\n\t\t\t// }\n\n\t\t} else {\n\n\t\t\tfor ( let j = 0; j < jLength; j ++ ) {\n\n\t\t\t\tfor ( let i = 0; i < iLength; i ++ ) {\n\n\t\t\t\t\tlet value = volumeData[ sliceAccess( i, j ) ];\n\t\t\t\t\tlet alpha = 0xff;\n\t\t\t\t\t//apply threshold\n\t\t\t\t\talpha = upperThreshold >= value ? ( lowerThreshold <= value ? alpha : 0 ) : 0;\n\t\t\t\t\t//apply window level\n\t\t\t\t\tvalue = Math.floor( 255 * ( value - windowLow ) / ( windowHigh - windowLow ) );\n\t\t\t\t\tvalue = value > 255 ? 255 : ( value < 0 ? 0 : value | 0 );\n\n\t\t\t\t\tdata[ 4 * pixelCount ] = value;\n\t\t\t\t\tdata[ 4 * pixelCount + 1 ] = value;\n\t\t\t\t\tdata[ 4 * pixelCount + 2 ] = value;\n\t\t\t\t\tdata[ 4 * pixelCount + 3 ] = alpha;\n\t\t\t\t\tpixelCount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tctx.putImageData( imgData, 0, 0 );\n\t\tthis.ctx.drawImage( canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height );\n\n\n\t\tthis.mesh.material.map.needsUpdate = true;\n\n\t}\n\n\t/**\n\t * Refresh the geometry according to axis and index.\n\t * @see {@link Volume#extractPerpendicularPlane}\n\t */\n\tupdateGeometry() {\n\n\t\tconst extracted = this.volume.extractPerpendicularPlane( this.axis, this.index );\n\t\tthis.sliceAccess = extracted.sliceAccess;\n\t\tthis.jLength = extracted.jLength;\n\t\tthis.iLength = extracted.iLength;\n\t\tthis.matrix = extracted.matrix;\n\n\t\tthis.canvas.width = extracted.planeWidth;\n\t\tthis.canvas.height = extracted.planeHeight;\n\t\tthis.canvasBuffer.width = this.iLength;\n\t\tthis.canvasBuffer.height = this.jLength;\n\t\tthis.ctx = this.canvas.getContext( '2d' );\n\t\tthis.ctxBuffer = this.canvasBuffer.getContext( '2d' );\n\n\t\tif ( this.geometry ) this.geometry.dispose(); // dispose existing geometry\n\n\t\tthis.geometry = new PlaneGeometry( extracted.planeWidth, extracted.planeHeight );\n\n\t\tif ( this.mesh ) {\n\n\t\t\tthis.mesh.geometry = this.geometry;\n\t\t\t//reset mesh matrix\n\t\t\tthis.mesh.matrix.identity();\n\t\t\tthis.mesh.applyMatrix4( this.matrix );\n\n\t\t}\n\n\t\tthis.geometryNeedsUpdate = false;\n\n\t}\n\n}\n\nexport { VolumeSlice };\n"],"mappings":"AAAA,SACCA,mBAAmB,EACnBC,UAAU,EACVC,YAAY,EACZC,IAAI,EACJC,iBAAiB,EACjBC,aAAa,EACbC,OAAO,EACPC,cAAc,QACR,OAAO;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,WAAW,CAAC;EAEjB;AACD;AACA;AACA;AACA;AACA;AACA;EACCC,WAAWA,CAAEC,MAAM,EAAEC,KAAK,GAAG,CAAC,EAAEC,IAAI,GAAG,GAAG,EAAG;IAE5C,MAAMC,KAAK,GAAG,IAAI;;IAElB;AACF;AACA;AACA;AACA;IACE,IAAI,CAACH,MAAM,GAAGA,MAAM;IAEpBI,MAAM,CAACC,cAAc,CAAE,IAAI,EAAE,OAAO,EAAE;MACrCC,GAAG,EAAE,SAAAA,CAAA,EAAY;QAEhB,OAAOL,KAAK;MAEb,CAAC;MACD;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACGM,GAAG,EAAE,SAAAA,CAAWC,KAAK,EAAG;QAEvBP,KAAK,GAAGO,KAAK;QACbL,KAAK,CAACM,mBAAmB,GAAG,IAAI;QAChC,OAAOR,KAAK;MAEb;IACD,CAAE,CAAC;;IAEH;AACF;AACA;AACA;AACA;IACE,IAAI,CAACC,IAAI,GAAGA,IAAI;;IAEhB;AACF;AACA;AACA;AACA;IACE,IAAI,CAACQ,MAAM,GAAGC,QAAQ,CAACC,aAAa,CAAE,QAAS,CAAC;;IAEhD;AACF;AACA;AACA;AACA;IACE,IAAI,CAACC,GAAG;;IAER;AACF;AACA;AACA;AACA;IACE,IAAI,CAACC,YAAY,GAAGH,QAAQ,CAACC,aAAa,CAAE,QAAS,CAAC;;IAEtD;AACF;AACA;AACA;AACA;IACE,IAAI,CAACG,SAAS;IAEd,IAAI,CAACC,cAAc,CAAC,CAAC;IAGrB,MAAMC,SAAS,GAAG,IAAIrB,OAAO,CAAE,IAAI,CAACc,MAAO,CAAC;IAC5CO,SAAS,CAACC,SAAS,GAAG1B,YAAY;IAClCyB,SAAS,CAACE,eAAe,GAAG,KAAK;IACjCF,SAAS,CAACG,KAAK,GAAGH,SAAS,CAACI,KAAK,GAAG/B,mBAAmB;IACvD2B,SAAS,CAACK,UAAU,GAAGzB,cAAc;IACrC,MAAM0B,QAAQ,GAAG,IAAI7B,iBAAiB,CAAE;MAAE8B,GAAG,EAAEP,SAAS;MAAEQ,IAAI,EAAElC,UAAU;MAAEmC,WAAW,EAAE;IAAK,CAAE,CAAC;;IAEjG;AACF;AACA;AACA;AACA;IACE,IAAI,CAACC,IAAI,GAAG,IAAIlC,IAAI,CAAE,IAAI,CAACmC,QAAQ,EAAEL,QAAS,CAAC;IAC/C,IAAI,CAACI,IAAI,CAACE,gBAAgB,GAAG,KAAK;;IAElC;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACpB,mBAAmB,GAAG,IAAI;IAC/B,IAAI,CAACqB,OAAO,CAAC,CAAC;;IAEd;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,OAAO,GAAG,CAAC;;IAEhB;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,OAAO,GAAG,CAAC;;IAEhB;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,WAAW,GAAG,IAAI;EAExB;;EAEA;AACD;AACA;EACCH,OAAOA,CAAA,EAAG;IAET,IAAK,IAAI,CAACrB,mBAAmB,EAAG;MAE/B,IAAI,CAACO,cAAc,CAAC,CAAC;IAEtB;IAEA,MAAMe,OAAO,GAAG,IAAI,CAACA,OAAO;MAC3BC,OAAO,GAAG,IAAI,CAACA,OAAO;MACtBC,WAAW,GAAG,IAAI,CAACA,WAAW;MAC9BjC,MAAM,GAAG,IAAI,CAACA,MAAM;MACpBU,MAAM,GAAG,IAAI,CAACI,YAAY;MAC1BD,GAAG,GAAG,IAAI,CAACE,SAAS;;IAGrB;IACA,MAAMmB,OAAO,GAAGrB,GAAG,CAACsB,YAAY,CAAE,CAAC,EAAE,CAAC,EAAEJ,OAAO,EAAEC,OAAQ,CAAC;IAC1D,MAAMI,IAAI,GAAGF,OAAO,CAACE,IAAI;IACzB,MAAMC,UAAU,GAAGrC,MAAM,CAACoC,IAAI;IAC9B,MAAME,cAAc,GAAGtC,MAAM,CAACsC,cAAc;IAC5C,MAAMC,cAAc,GAAGvC,MAAM,CAACuC,cAAc;IAC5C,MAAMC,SAAS,GAAGxC,MAAM,CAACwC,SAAS;IAClC,MAAMC,UAAU,GAAGzC,MAAM,CAACyC,UAAU;;IAEpC;IACA,IAAIC,UAAU,GAAG,CAAC;IAElB,IAAK1C,MAAM,CAAC2C,QAAQ,KAAK,OAAO,EAAG;MAElCC,OAAO,CAACC,KAAK,CAAE,wDAAyD,CAAC;;MAEzE;;MAEA;;MAEA;;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;MAEA;;MAEA;IAED,CAAC,MAAM;MAEN,KAAM,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGd,OAAO,EAAEc,CAAC,EAAG,EAAG;QAEpC,KAAM,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,OAAO,EAAEgB,CAAC,EAAG,EAAG;UAEpC,IAAIvC,KAAK,GAAG6B,UAAU,CAAEJ,WAAW,CAAEc,CAAC,EAAED,CAAE,CAAC,CAAE;UAC7C,IAAIE,KAAK,GAAG,IAAI;UAChB;UACAA,KAAK,GAAGV,cAAc,IAAI9B,KAAK,GAAK+B,cAAc,IAAI/B,KAAK,GAAGwC,KAAK,GAAG,CAAC,GAAK,CAAC;UAC7E;UACAxC,KAAK,GAAGyC,IAAI,CAACC,KAAK,CAAE,GAAG,IAAK1C,KAAK,GAAGgC,SAAS,CAAE,IAAKC,UAAU,GAAGD,SAAS,CAAG,CAAC;UAC9EhC,KAAK,GAAGA,KAAK,GAAG,GAAG,GAAG,GAAG,GAAKA,KAAK,GAAG,CAAC,GAAG,CAAC,GAAGA,KAAK,GAAG,CAAG;UAEzD4B,IAAI,CAAE,CAAC,GAAGM,UAAU,CAAE,GAAGlC,KAAK;UAC9B4B,IAAI,CAAE,CAAC,GAAGM,UAAU,GAAG,CAAC,CAAE,GAAGlC,KAAK;UAClC4B,IAAI,CAAE,CAAC,GAAGM,UAAU,GAAG,CAAC,CAAE,GAAGlC,KAAK;UAClC4B,IAAI,CAAE,CAAC,GAAGM,UAAU,GAAG,CAAC,CAAE,GAAGM,KAAK;UAClCN,UAAU,EAAG;QAEd;MAED;IAED;IAEA7B,GAAG,CAACsC,YAAY,CAAEjB,OAAO,EAAE,CAAC,EAAE,CAAE,CAAC;IACjC,IAAI,CAACrB,GAAG,CAACuC,SAAS,CAAE1C,MAAM,EAAE,CAAC,EAAE,CAAC,EAAEqB,OAAO,EAAEC,OAAO,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,CAACtB,MAAM,CAAC2C,KAAK,EAAE,IAAI,CAAC3C,MAAM,CAAC4C,MAAO,CAAC;IAGjG,IAAI,CAAC3B,IAAI,CAACJ,QAAQ,CAACC,GAAG,CAAC+B,WAAW,GAAG,IAAI;EAE1C;;EAEA;AACD;AACA;AACA;EACCvC,cAAcA,CAAA,EAAG;IAEhB,MAAMwC,SAAS,GAAG,IAAI,CAACxD,MAAM,CAACyD,yBAAyB,CAAE,IAAI,CAACvD,IAAI,EAAE,IAAI,CAACD,KAAM,CAAC;IAChF,IAAI,CAACgC,WAAW,GAAGuB,SAAS,CAACvB,WAAW;IACxC,IAAI,CAACD,OAAO,GAAGwB,SAAS,CAACxB,OAAO;IAChC,IAAI,CAACD,OAAO,GAAGyB,SAAS,CAACzB,OAAO;IAChC,IAAI,CAAC2B,MAAM,GAAGF,SAAS,CAACE,MAAM;IAE9B,IAAI,CAAChD,MAAM,CAAC2C,KAAK,GAAGG,SAAS,CAACG,UAAU;IACxC,IAAI,CAACjD,MAAM,CAAC4C,MAAM,GAAGE,SAAS,CAACI,WAAW;IAC1C,IAAI,CAAC9C,YAAY,CAACuC,KAAK,GAAG,IAAI,CAACtB,OAAO;IACtC,IAAI,CAACjB,YAAY,CAACwC,MAAM,GAAG,IAAI,CAACtB,OAAO;IACvC,IAAI,CAACnB,GAAG,GAAG,IAAI,CAACH,MAAM,CAACmD,UAAU,CAAE,IAAK,CAAC;IACzC,IAAI,CAAC9C,SAAS,GAAG,IAAI,CAACD,YAAY,CAAC+C,UAAU,CAAE,IAAK,CAAC;IAErD,IAAK,IAAI,CAACjC,QAAQ,EAAG,IAAI,CAACA,QAAQ,CAACkC,OAAO,CAAC,CAAC,CAAC,CAAC;;IAE9C,IAAI,CAAClC,QAAQ,GAAG,IAAIjC,aAAa,CAAE6D,SAAS,CAACG,UAAU,EAAEH,SAAS,CAACI,WAAY,CAAC;IAEhF,IAAK,IAAI,CAACjC,IAAI,EAAG;MAEhB,IAAI,CAACA,IAAI,CAACC,QAAQ,GAAG,IAAI,CAACA,QAAQ;MAClC;MACA,IAAI,CAACD,IAAI,CAAC+B,MAAM,CAACK,QAAQ,CAAC,CAAC;MAC3B,IAAI,CAACpC,IAAI,CAACqC,YAAY,CAAE,IAAI,CAACN,MAAO,CAAC;IAEtC;IAEA,IAAI,CAACjD,mBAAmB,GAAG,KAAK;EAEjC;AAED;AAEA,SAASX,WAAW","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}