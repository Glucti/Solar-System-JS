{"ast":null,"code":"import { BufferGeometry, Float32BufferAttribute, Vector3 } from 'three';\n\n/**\n * This class can be used to generate a geometry based on a parametric surface.\n *\n * Reference: [Mesh Generation with Python]{@link https://prideout.net/blog/old/blog/index.html@p=44.html}\n *\n * ```js\n * const geometry = new THREE.ParametricGeometry( klein, 25, 25 );\n * const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );\n * const klein = new THREE.Mesh( geometry, material );\n * scene.add( klein );\n * ```\n *\n * @augments BufferGeometry\n * @three_import import { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';\n */\nclass ParametricGeometry extends BufferGeometry {\n  /**\n   * Constructs a new parametric geometry.\n   *\n   * @param {ParametricGeometry~Func} func - The parametric function. Default is a function that generates a curved plane surface.\n   * @param {number} [slices=8] - The number of slices to use for the parametric function.\n   * @param {number} [stacks=8] - The stacks of slices to use for the parametric function.\n   */\n  constructor(func = (u, v, target) => target.set(u, v, Math.cos(u) * Math.sin(v)), slices = 8, stacks = 8) {\n    super();\n    this.type = 'ParametricGeometry';\n\n    /**\n     * Holds the constructor parameters that have been\n     * used to generate the geometry. Any modification\n     * after instantiation does not change the geometry.\n     *\n     * @type {Object}\n     */\n    this.parameters = {\n      func: func,\n      slices: slices,\n      stacks: stacks\n    };\n\n    // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    const EPS = 0.00001;\n    const normal = new Vector3();\n    const p0 = new Vector3(),\n      p1 = new Vector3();\n    const pu = new Vector3(),\n      pv = new Vector3();\n\n    // generate vertices, normals and uvs\n\n    const sliceCount = slices + 1;\n    for (let i = 0; i <= stacks; i++) {\n      const v = i / stacks;\n      for (let j = 0; j <= slices; j++) {\n        const u = j / slices;\n\n        // vertex\n\n        func(u, v, p0);\n        vertices.push(p0.x, p0.y, p0.z);\n\n        // normal\n\n        // approximate tangent vectors via finite differences\n\n        if (u - EPS >= 0) {\n          func(u - EPS, v, p1);\n          pu.subVectors(p0, p1);\n        } else {\n          func(u + EPS, v, p1);\n          pu.subVectors(p1, p0);\n        }\n        if (v - EPS >= 0) {\n          func(u, v - EPS, p1);\n          pv.subVectors(p0, p1);\n        } else {\n          func(u, v + EPS, p1);\n          pv.subVectors(p1, p0);\n        }\n\n        // cross product of tangent vectors returns surface normal\n\n        normal.crossVectors(pu, pv).normalize();\n        normals.push(normal.x, normal.y, normal.z);\n\n        // uv\n\n        uvs.push(u, v);\n      }\n    }\n\n    // generate indices\n\n    for (let i = 0; i < stacks; i++) {\n      for (let j = 0; j < slices; j++) {\n        const a = i * sliceCount + j;\n        const b = i * sliceCount + j + 1;\n        const c = (i + 1) * sliceCount + j + 1;\n        const d = (i + 1) * sliceCount + j;\n\n        // faces one and two\n\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    }\n\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n  copy(source) {\n    super.copy(source);\n    this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n}\n\n/**\n * Parametric function definition of `ParametricGeometry`.\n *\n * @callback ParametricGeometry~Func\n * @param {number} u - The `u` coordinate on the surface in the range `[0,1]`.\n * @param {number} v - The `v` coordinate on the surface in the range `[0,1]`.\n * @param {Vector3} target - The target vector that is used to store the method's result.\n */\n\nexport { ParametricGeometry };","map":{"version":3,"names":["BufferGeometry","Float32BufferAttribute","Vector3","ParametricGeometry","constructor","func","u","v","target","set","Math","cos","sin","slices","stacks","type","parameters","indices","vertices","normals","uvs","EPS","normal","p0","p1","pu","pv","sliceCount","i","j","push","x","y","z","subVectors","crossVectors","normalize","a","b","c","d","setIndex","setAttribute","copy","source","Object","assign"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/geometries/ParametricGeometry.js"],"sourcesContent":["import {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tVector3\n} from 'three';\n\n/**\n * This class can be used to generate a geometry based on a parametric surface.\n *\n * Reference: [Mesh Generation with Python]{@link https://prideout.net/blog/old/blog/index.html@p=44.html}\n *\n * ```js\n * const geometry = new THREE.ParametricGeometry( klein, 25, 25 );\n * const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );\n * const klein = new THREE.Mesh( geometry, material );\n * scene.add( klein );\n * ```\n *\n * @augments BufferGeometry\n * @three_import import { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';\n */\nclass ParametricGeometry extends BufferGeometry {\n\n\t/**\n\t * Constructs a new parametric geometry.\n\t *\n\t * @param {ParametricGeometry~Func} func - The parametric function. Default is a function that generates a curved plane surface.\n\t * @param {number} [slices=8] - The number of slices to use for the parametric function.\n\t * @param {number} [stacks=8] - The stacks of slices to use for the parametric function.\n\t */\n\tconstructor( func = ( u, v, target ) => target.set( u, v, Math.cos( u ) * Math.sin( v ) ), slices = 8, stacks = 8 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ParametricGeometry';\n\n\t\t/**\n\t\t * Holds the constructor parameters that have been\n\t\t * used to generate the geometry. Any modification\n\t\t * after instantiation does not change the geometry.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.parameters = {\n\t\t\tfunc: func,\n\t\t\tslices: slices,\n\t\t\tstacks: stacks\n\t\t};\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\tconst EPS = 0.00001;\n\n\t\tconst normal = new Vector3();\n\n\t\tconst p0 = new Vector3(), p1 = new Vector3();\n\t\tconst pu = new Vector3(), pv = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tconst sliceCount = slices + 1;\n\n\t\tfor ( let i = 0; i <= stacks; i ++ ) {\n\n\t\t\tconst v = i / stacks;\n\n\t\t\tfor ( let j = 0; j <= slices; j ++ ) {\n\n\t\t\t\tconst u = j / slices;\n\n\t\t\t\t// vertex\n\n\t\t\t\tfunc( u, v, p0 );\n\t\t\t\tvertices.push( p0.x, p0.y, p0.z );\n\n\t\t\t\t// normal\n\n\t\t\t\t// approximate tangent vectors via finite differences\n\n\t\t\t\tif ( u - EPS >= 0 ) {\n\n\t\t\t\t\tfunc( u - EPS, v, p1 );\n\t\t\t\t\tpu.subVectors( p0, p1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfunc( u + EPS, v, p1 );\n\t\t\t\t\tpu.subVectors( p1, p0 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( v - EPS >= 0 ) {\n\n\t\t\t\t\tfunc( u, v - EPS, p1 );\n\t\t\t\t\tpv.subVectors( p0, p1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfunc( u, v + EPS, p1 );\n\t\t\t\t\tpv.subVectors( p1, p0 );\n\n\t\t\t\t}\n\n\t\t\t\t// cross product of tangent vectors returns surface normal\n\n\t\t\t\tnormal.crossVectors( pu, pv ).normalize();\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( u, v );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( let i = 0; i < stacks; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < slices; j ++ ) {\n\n\t\t\t\tconst a = i * sliceCount + j;\n\t\t\t\tconst b = i * sliceCount + j + 1;\n\t\t\t\tconst c = ( i + 1 ) * sliceCount + j + 1;\n\t\t\t\tconst d = ( i + 1 ) * sliceCount + j;\n\n\t\t\t\t// faces one and two\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * Parametric function definition of `ParametricGeometry`.\n *\n * @callback ParametricGeometry~Func\n * @param {number} u - The `u` coordinate on the surface in the range `[0,1]`.\n * @param {number} v - The `v` coordinate on the surface in the range `[0,1]`.\n * @param {Vector3} target - The target vector that is used to store the method's result.\n */\n\nexport { ParametricGeometry };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}