{"ast":null,"code":"import { DataTexture, Matrix4, RepeatWrapping, Vector2, Vector3 } from 'three';\n\n/**\n * @module GTAOShader\n * @three_import import { GTAOShader } from 'three/addons/shaders/GTAOShader.js';\n */\n\n/**\n * GTAO shader. Use by {@link GTAOPass}.\n *\n * References:\n * - [Practical Realtime Strategies for Accurate Indirect Occlusion]{@link https://iryoku.com/downloads/Practical-Realtime-Strategies-for-Accurate-Indirect-Occlusion.pdf}.\n * - [Horizon-Based Indirect Lighting (HBIL)]{@link https://github.com/Patapom/GodComplex/blob/master/Tests/TestHBIL/2018%20Mayaux%20-%20Horizon-Based%20Indirect%20Lighting%20(HBIL).pdf}\n *\n * @constant\n * @type {ShaderMaterial~Shader}\n */\nconst GTAOShader = {\n  name: 'GTAOShader',\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n    SAMPLES: 16,\n    NORMAL_VECTOR_TYPE: 1,\n    DEPTH_SWIZZLING: 'x',\n    SCREEN_SPACE_RADIUS: 0,\n    SCREEN_SPACE_RADIUS_SCALE: 100.0,\n    SCENE_CLIP_BOX: 0\n  },\n  uniforms: {\n    tNormal: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    tNoise: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2()\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    },\n    cameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    cameraProjectionMatrixInverse: {\n      value: new Matrix4()\n    },\n    cameraWorldMatrix: {\n      value: new Matrix4()\n    },\n    radius: {\n      value: 0.25\n    },\n    distanceExponent: {\n      value: 1.\n    },\n    thickness: {\n      value: 1.\n    },\n    distanceFallOff: {\n      value: 1.\n    },\n    scale: {\n      value: 1.\n    },\n    sceneBoxMin: {\n      value: new Vector3(-1, -1, -1)\n    },\n    sceneBoxMax: {\n      value: new Vector3(1, 1, 1)\n    }\n  },\n  vertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}`,\n  fragmentShader: /* glsl */`\n\t\tvarying vec2 vUv;\n\t\tuniform highp sampler2D tNormal;\n\t\tuniform highp sampler2D tDepth;\n\t\tuniform sampler2D tNoise;\n\t\tuniform vec2 resolution;\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tuniform mat4 cameraProjectionMatrix;\n\t\tuniform mat4 cameraProjectionMatrixInverse;\n\t\tuniform mat4 cameraWorldMatrix;\n\t\tuniform float radius;\n\t\tuniform float distanceExponent;\n\t\tuniform float thickness;\n\t\tuniform float distanceFallOff;\n\t\tuniform float scale;\n\t\t#if SCENE_CLIP_BOX == 1\n\t\t\tuniform vec3 sceneBoxMin;\n\t\t\tuniform vec3 sceneBoxMax;\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <packing>\n\n\t\t#ifndef FRAGMENT_OUTPUT\n\t\t#define FRAGMENT_OUTPUT vec4(vec3(ao), 1.)\n\t\t#endif\n\n\t\tvec3 getViewPosition(const in vec2 screenPosition, const in float depth) {\n\t\t\tvec4 clipSpacePosition = vec4(vec3(screenPosition, depth) * 2.0 - 1.0, 1.0);\n\t\t\tvec4 viewSpacePosition = cameraProjectionMatrixInverse * clipSpacePosition;\n\t\t\treturn viewSpacePosition.xyz / viewSpacePosition.w;\n\t\t}\n\n\t\tfloat getDepth(const vec2 uv) {\n\t\t\treturn textureLod(tDepth, uv.xy, 0.0).DEPTH_SWIZZLING;\n\t\t}\n\n\t\tfloat fetchDepth(const ivec2 uv) {\n\t\t\treturn texelFetch(tDepth, uv.xy, 0).DEPTH_SWIZZLING;\n\t\t}\n\n\t\tfloat getViewZ(const in float depth) {\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\t\t\t\treturn perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n\t\t\t#else\n\t\t\t\treturn orthographicDepthToViewZ(depth, cameraNear, cameraFar);\n\t\t\t#endif\n\t\t}\n\n\t\tvec3 computeNormalFromDepth(const vec2 uv) {\n\t\t\tvec2 size = vec2(textureSize(tDepth, 0));\n\t\t\tivec2 p = ivec2(uv * size);\n\t\t\tfloat c0 = fetchDepth(p);\n\t\t\tfloat l2 = fetchDepth(p - ivec2(2, 0));\n\t\t\tfloat l1 = fetchDepth(p - ivec2(1, 0));\n\t\t\tfloat r1 = fetchDepth(p + ivec2(1, 0));\n\t\t\tfloat r2 = fetchDepth(p + ivec2(2, 0));\n\t\t\tfloat b2 = fetchDepth(p - ivec2(0, 2));\n\t\t\tfloat b1 = fetchDepth(p - ivec2(0, 1));\n\t\t\tfloat t1 = fetchDepth(p + ivec2(0, 1));\n\t\t\tfloat t2 = fetchDepth(p + ivec2(0, 2));\n\t\t\tfloat dl = abs((2.0 * l1 - l2) - c0);\n\t\t\tfloat dr = abs((2.0 * r1 - r2) - c0);\n\t\t\tfloat db = abs((2.0 * b1 - b2) - c0);\n\t\t\tfloat dt = abs((2.0 * t1 - t2) - c0);\n\t\t\tvec3 ce = getViewPosition(uv, c0).xyz;\n\t\t\tvec3 dpdx = (dl < dr) ? ce - getViewPosition((uv - vec2(1.0 / size.x, 0.0)), l1).xyz : -ce + getViewPosition((uv + vec2(1.0 / size.x, 0.0)), r1).xyz;\n\t\t\tvec3 dpdy = (db < dt) ? ce - getViewPosition((uv - vec2(0.0, 1.0 / size.y)), b1).xyz : -ce + getViewPosition((uv + vec2(0.0, 1.0 / size.y)), t1).xyz;\n\t\t\treturn normalize(cross(dpdx, dpdy));\n\t\t}\n\n\t\tvec3 getViewNormal(const vec2 uv) {\n\t\t\t#if NORMAL_VECTOR_TYPE == 2\n\t\t\t\treturn normalize(textureLod(tNormal, uv, 0.).rgb);\n\t\t\t#elif NORMAL_VECTOR_TYPE == 1\n\t\t\t\treturn unpackRGBToNormal(textureLod(tNormal, uv, 0.).rgb);\n\t\t\t#else\n\t\t\t\treturn computeNormalFromDepth(uv);\n\t\t\t#endif\n\t\t}\n\n\t\tvec3 getSceneUvAndDepth(vec3 sampleViewPos) {\n\t\t\tvec4 sampleClipPos = cameraProjectionMatrix * vec4(sampleViewPos, 1.);\n\t\t\tvec2 sampleUv = sampleClipPos.xy / sampleClipPos.w * 0.5 + 0.5;\n\t\t\tfloat sampleSceneDepth = getDepth(sampleUv);\n\t\t\treturn vec3(sampleUv, sampleSceneDepth);\n\t\t}\n\n\t\tvoid main() {\n\t\t\tfloat depth = getDepth(vUv.xy);\n\t\t\tif (depth >= 1.0) {\n\t\t\t\tdiscard;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvec3 viewPos = getViewPosition(vUv, depth);\n\t\t\tvec3 viewNormal = getViewNormal(vUv);\n\n\t\t\tfloat radiusToUse = radius;\n\t\t\tfloat distanceFalloffToUse = thickness;\n\t\t\t#if SCREEN_SPACE_RADIUS == 1\n\t\t\t\tfloat radiusScale = getViewPosition(vec2(0.5 + float(SCREEN_SPACE_RADIUS_SCALE) / resolution.x, 0.0), depth).x;\n\t\t\t\tradiusToUse *= radiusScale;\n\t\t\t\tdistanceFalloffToUse *= radiusScale;\n\t\t\t#endif\n\n\t\t\t#if SCENE_CLIP_BOX == 1\n\t\t\t\tvec3 worldPos = (cameraWorldMatrix * vec4(viewPos, 1.0)).xyz;\n\t\t\t\tfloat boxDistance = length(max(vec3(0.0), max(sceneBoxMin - worldPos, worldPos - sceneBoxMax)));\n\t\t\t\tif (boxDistance > radiusToUse) {\n\t\t\t\t\tdiscard;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t\tvec2 noiseResolution = vec2(textureSize(tNoise, 0));\n\t\t\tvec2 noiseUv = vUv * resolution / noiseResolution;\n\t\t\tvec4 noiseTexel = textureLod(tNoise, noiseUv, 0.0);\n\t\t\tvec3 randomVec = noiseTexel.xyz * 2.0 - 1.0;\n\t\t\tvec3 tangent = normalize(vec3(randomVec.xy, 0.));\n\t\t\tvec3 bitangent = vec3(-tangent.y, tangent.x, 0.);\n\t\t\tmat3 kernelMatrix = mat3(tangent, bitangent, vec3(0., 0., 1.));\n\n\t\t\tconst int DIRECTIONS = SAMPLES < 30 ? 3 : 5;\n\t\t\tconst int STEPS = (SAMPLES + DIRECTIONS - 1) / DIRECTIONS;\n\t\t\tfloat ao = 0.0;\n\t\t\tfor (int i = 0; i < DIRECTIONS; ++i) {\n\n\t\t\t\tfloat angle = float(i) / float(DIRECTIONS) * PI;\n\t\t\t\tvec4 sampleDir = vec4(cos(angle), sin(angle), 0., 0.5 + 0.5 * noiseTexel.w);\n\t\t\t\tsampleDir.xyz = normalize(kernelMatrix * sampleDir.xyz);\n\n\t\t\t\tvec3 viewDir = normalize(-viewPos.xyz);\n\t\t\t\tvec3 sliceBitangent = normalize(cross(sampleDir.xyz, viewDir));\n\t\t\t\tvec3 sliceTangent = cross(sliceBitangent, viewDir);\n\t\t\t\tvec3 normalInSlice = normalize(viewNormal - sliceBitangent * dot(viewNormal, sliceBitangent));\n\n\t\t\t\tvec3 tangentToNormalInSlice = cross(normalInSlice, sliceBitangent);\n\t\t\t\tvec2 cosHorizons = vec2(dot(viewDir, tangentToNormalInSlice), dot(viewDir, -tangentToNormalInSlice));\n\n\t\t\t\tfor (int j = 0; j < STEPS; ++j) {\n\t\t\t\t\tvec3 sampleViewOffset = sampleDir.xyz * radiusToUse * sampleDir.w * pow(float(j + 1) / float(STEPS), distanceExponent);\n\n\t\t\t\t\tvec3 sampleSceneUvDepth = getSceneUvAndDepth(viewPos + sampleViewOffset);\n\t\t\t\t\tvec3 sampleSceneViewPos = getViewPosition(sampleSceneUvDepth.xy, sampleSceneUvDepth.z);\n\t\t\t\t\tvec3 viewDelta = sampleSceneViewPos - viewPos;\n\t\t\t\t\tif (abs(viewDelta.z) < thickness) {\n\t\t\t\t\t\tfloat sampleCosHorizon = dot(viewDir, normalize(viewDelta));\n\t\t\t\t\t\tcosHorizons.x += max(0., (sampleCosHorizon - cosHorizons.x) * mix(1., 2. / float(j + 2), distanceFallOff));\n\t\t\t\t\t}\n\n\t\t\t\t\tsampleSceneUvDepth = getSceneUvAndDepth(viewPos - sampleViewOffset);\n\t\t\t\t\tsampleSceneViewPos = getViewPosition(sampleSceneUvDepth.xy, sampleSceneUvDepth.z);\n\t\t\t\t\tviewDelta = sampleSceneViewPos - viewPos;\n\t\t\t\t\tif (abs(viewDelta.z) < thickness) {\n\t\t\t\t\t\tfloat sampleCosHorizon = dot(viewDir, normalize(viewDelta));\n\t\t\t\t\t\tcosHorizons.y += max(0., (sampleCosHorizon - cosHorizons.y) * mix(1., 2. / float(j + 2), distanceFallOff));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvec2 sinHorizons = sqrt(1. - cosHorizons * cosHorizons);\n\t\t\t\tfloat nx = dot(normalInSlice, sliceTangent);\n\t\t\t\tfloat ny = dot(normalInSlice, viewDir);\n\t\t\t\tfloat nxb = 1. / 2. * (acos(cosHorizons.y) - acos(cosHorizons.x) + sinHorizons.x * cosHorizons.x - sinHorizons.y * cosHorizons.y);\n\t\t\t\tfloat nyb = 1. / 2. * (2. - cosHorizons.x * cosHorizons.x - cosHorizons.y * cosHorizons.y);\n\t\t\t\tfloat occlusion = nx * nxb + ny * nyb;\n\t\t\t\tao += occlusion;\n\t\t\t}\n\n\t\t\tao = clamp(ao / float(DIRECTIONS), 0., 1.);\n\t\t#if SCENE_CLIP_BOX == 1\n\t\t\tao = mix(ao, 1., smoothstep(0., radiusToUse, boxDistance));\n\t\t#endif\n\t\t\tao = pow(ao, scale);\n\n\t\t\tgl_FragColor = FRAGMENT_OUTPUT;\n\t\t}`\n};\n\n/**\n * GTAO depth shader. Use by {@link GTAOPass}.\n *\n * @constant\n * @type {Object}\n */\nconst GTAODepthShader = {\n  name: 'GTAODepthShader',\n  defines: {\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    }\n  },\n  vertexShader: /* glsl */`\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}`,\n  fragmentShader: /* glsl */`\n\t\tuniform sampler2D tDepth;\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tvarying vec2 vUv;\n\n\t\t#include <packing>\n\n\t\tfloat getLinearDepth( const in vec2 screenPosition ) {\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\t\t\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\n\t\t\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\t\t\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\t\t\t#else\n\t\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\t\t\t#endif\n\t\t}\n\n\t\tvoid main() {\n\t\t\tfloat depth = getLinearDepth( vUv );\n\t\t\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\n\n\t\t}`\n};\n\n/**\n * GTAO blend shader. Use by {@link GTAOPass}.\n *\n * @constant\n * @type {Object}\n */\nconst GTAOBlendShader = {\n  name: 'GTAOBlendShader',\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    intensity: {\n      value: 1.0\n    }\n  },\n  vertexShader: /* glsl */`\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}`,\n  fragmentShader: /* glsl */`\n\t\tuniform float intensity;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4(mix(vec3(1.), texel.rgb, intensity), texel.a);\n\t\t}`\n};\nfunction generateMagicSquareNoise(size = 5) {\n  const noiseSize = Math.floor(size) % 2 === 0 ? Math.floor(size) + 1 : Math.floor(size);\n  const magicSquare = generateMagicSquare(noiseSize);\n  const noiseSquareSize = magicSquare.length;\n  const data = new Uint8Array(noiseSquareSize * 4);\n  for (let inx = 0; inx < noiseSquareSize; ++inx) {\n    const iAng = magicSquare[inx];\n    const angle = 2 * Math.PI * iAng / noiseSquareSize;\n    const randomVec = new Vector3(Math.cos(angle), Math.sin(angle), 0).normalize();\n    data[inx * 4] = (randomVec.x * 0.5 + 0.5) * 255;\n    data[inx * 4 + 1] = (randomVec.y * 0.5 + 0.5) * 255;\n    data[inx * 4 + 2] = 127;\n    data[inx * 4 + 3] = 255;\n  }\n  const noiseTexture = new DataTexture(data, noiseSize, noiseSize);\n  noiseTexture.wrapS = RepeatWrapping;\n  noiseTexture.wrapT = RepeatWrapping;\n  noiseTexture.needsUpdate = true;\n  return noiseTexture;\n}\nfunction generateMagicSquare(size) {\n  const noiseSize = Math.floor(size) % 2 === 0 ? Math.floor(size) + 1 : Math.floor(size);\n  const noiseSquareSize = noiseSize * noiseSize;\n  const magicSquare = Array(noiseSquareSize).fill(0);\n  let i = Math.floor(noiseSize / 2);\n  let j = noiseSize - 1;\n  for (let num = 1; num <= noiseSquareSize;) {\n    if (i === -1 && j === noiseSize) {\n      j = noiseSize - 2;\n      i = 0;\n    } else {\n      if (j === noiseSize) {\n        j = 0;\n      }\n      if (i < 0) {\n        i = noiseSize - 1;\n      }\n    }\n    if (magicSquare[i * noiseSize + j] !== 0) {\n      j -= 2;\n      i++;\n      continue;\n    } else {\n      magicSquare[i * noiseSize + j] = num++;\n    }\n    j++;\n    i--;\n  }\n  return magicSquare;\n}\nexport { generateMagicSquareNoise, GTAOShader, GTAODepthShader, GTAOBlendShader };","map":{"version":3,"names":["DataTexture","Matrix4","RepeatWrapping","Vector2","Vector3","GTAOShader","name","defines","PERSPECTIVE_CAMERA","SAMPLES","NORMAL_VECTOR_TYPE","DEPTH_SWIZZLING","SCREEN_SPACE_RADIUS","SCREEN_SPACE_RADIUS_SCALE","SCENE_CLIP_BOX","uniforms","tNormal","value","tDepth","tNoise","resolution","cameraNear","cameraFar","cameraProjectionMatrix","cameraProjectionMatrixInverse","cameraWorldMatrix","radius","distanceExponent","thickness","distanceFallOff","scale","sceneBoxMin","sceneBoxMax","vertexShader","fragmentShader","GTAODepthShader","GTAOBlendShader","tDiffuse","intensity","generateMagicSquareNoise","size","noiseSize","Math","floor","magicSquare","generateMagicSquare","noiseSquareSize","length","data","Uint8Array","inx","iAng","angle","PI","randomVec","cos","sin","normalize","x","y","noiseTexture","wrapS","wrapT","needsUpdate","Array","fill","i","j","num"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/shaders/GTAOShader.js"],"sourcesContent":["import {\n\tDataTexture,\n\tMatrix4,\n\tRepeatWrapping,\n\tVector2,\n\tVector3,\n} from 'three';\n\n/**\n * @module GTAOShader\n * @three_import import { GTAOShader } from 'three/addons/shaders/GTAOShader.js';\n */\n\n/**\n * GTAO shader. Use by {@link GTAOPass}.\n *\n * References:\n * - [Practical Realtime Strategies for Accurate Indirect Occlusion]{@link https://iryoku.com/downloads/Practical-Realtime-Strategies-for-Accurate-Indirect-Occlusion.pdf}.\n * - [Horizon-Based Indirect Lighting (HBIL)]{@link https://github.com/Patapom/GodComplex/blob/master/Tests/TestHBIL/2018%20Mayaux%20-%20Horizon-Based%20Indirect%20Lighting%20(HBIL).pdf}\n *\n * @constant\n * @type {ShaderMaterial~Shader}\n */\nconst GTAOShader = {\n\n\tname: 'GTAOShader',\n\n\tdefines: {\n\t\tPERSPECTIVE_CAMERA: 1,\n\t\tSAMPLES: 16,\n\t\tNORMAL_VECTOR_TYPE: 1,\n\t\tDEPTH_SWIZZLING: 'x',\n\t\tSCREEN_SPACE_RADIUS: 0,\n\t\tSCREEN_SPACE_RADIUS_SCALE: 100.0,\n\t\tSCENE_CLIP_BOX: 0,\n\t},\n\n\tuniforms: {\n\t\ttNormal: { value: null },\n\t\ttDepth: { value: null },\n\t\ttNoise: { value: null },\n\t\tresolution: { value: new Vector2() },\n\t\tcameraNear: { value: null },\n\t\tcameraFar: { value: null },\n\t\tcameraProjectionMatrix: { value: new Matrix4() },\n\t\tcameraProjectionMatrixInverse: { value: new Matrix4() },\n\t\tcameraWorldMatrix: { value: new Matrix4() },\n\t\tradius: { value: 0.25 },\n\t\tdistanceExponent: { value: 1. },\n\t\tthickness: { value: 1. },\n\t\tdistanceFallOff: { value: 1. },\n\t\tscale: { value: 1. },\n\t\tsceneBoxMin: { value: new Vector3( - 1, - 1, - 1 ) },\n\t\tsceneBoxMax: { value: new Vector3( 1, 1, 1 ) },\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\t\tvarying vec2 vUv;\n\t\tuniform highp sampler2D tNormal;\n\t\tuniform highp sampler2D tDepth;\n\t\tuniform sampler2D tNoise;\n\t\tuniform vec2 resolution;\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tuniform mat4 cameraProjectionMatrix;\n\t\tuniform mat4 cameraProjectionMatrixInverse;\n\t\tuniform mat4 cameraWorldMatrix;\n\t\tuniform float radius;\n\t\tuniform float distanceExponent;\n\t\tuniform float thickness;\n\t\tuniform float distanceFallOff;\n\t\tuniform float scale;\n\t\t#if SCENE_CLIP_BOX == 1\n\t\t\tuniform vec3 sceneBoxMin;\n\t\t\tuniform vec3 sceneBoxMax;\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <packing>\n\n\t\t#ifndef FRAGMENT_OUTPUT\n\t\t#define FRAGMENT_OUTPUT vec4(vec3(ao), 1.)\n\t\t#endif\n\n\t\tvec3 getViewPosition(const in vec2 screenPosition, const in float depth) {\n\t\t\tvec4 clipSpacePosition = vec4(vec3(screenPosition, depth) * 2.0 - 1.0, 1.0);\n\t\t\tvec4 viewSpacePosition = cameraProjectionMatrixInverse * clipSpacePosition;\n\t\t\treturn viewSpacePosition.xyz / viewSpacePosition.w;\n\t\t}\n\n\t\tfloat getDepth(const vec2 uv) {\n\t\t\treturn textureLod(tDepth, uv.xy, 0.0).DEPTH_SWIZZLING;\n\t\t}\n\n\t\tfloat fetchDepth(const ivec2 uv) {\n\t\t\treturn texelFetch(tDepth, uv.xy, 0).DEPTH_SWIZZLING;\n\t\t}\n\n\t\tfloat getViewZ(const in float depth) {\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\t\t\t\treturn perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n\t\t\t#else\n\t\t\t\treturn orthographicDepthToViewZ(depth, cameraNear, cameraFar);\n\t\t\t#endif\n\t\t}\n\n\t\tvec3 computeNormalFromDepth(const vec2 uv) {\n\t\t\tvec2 size = vec2(textureSize(tDepth, 0));\n\t\t\tivec2 p = ivec2(uv * size);\n\t\t\tfloat c0 = fetchDepth(p);\n\t\t\tfloat l2 = fetchDepth(p - ivec2(2, 0));\n\t\t\tfloat l1 = fetchDepth(p - ivec2(1, 0));\n\t\t\tfloat r1 = fetchDepth(p + ivec2(1, 0));\n\t\t\tfloat r2 = fetchDepth(p + ivec2(2, 0));\n\t\t\tfloat b2 = fetchDepth(p - ivec2(0, 2));\n\t\t\tfloat b1 = fetchDepth(p - ivec2(0, 1));\n\t\t\tfloat t1 = fetchDepth(p + ivec2(0, 1));\n\t\t\tfloat t2 = fetchDepth(p + ivec2(0, 2));\n\t\t\tfloat dl = abs((2.0 * l1 - l2) - c0);\n\t\t\tfloat dr = abs((2.0 * r1 - r2) - c0);\n\t\t\tfloat db = abs((2.0 * b1 - b2) - c0);\n\t\t\tfloat dt = abs((2.0 * t1 - t2) - c0);\n\t\t\tvec3 ce = getViewPosition(uv, c0).xyz;\n\t\t\tvec3 dpdx = (dl < dr) ? ce - getViewPosition((uv - vec2(1.0 / size.x, 0.0)), l1).xyz : -ce + getViewPosition((uv + vec2(1.0 / size.x, 0.0)), r1).xyz;\n\t\t\tvec3 dpdy = (db < dt) ? ce - getViewPosition((uv - vec2(0.0, 1.0 / size.y)), b1).xyz : -ce + getViewPosition((uv + vec2(0.0, 1.0 / size.y)), t1).xyz;\n\t\t\treturn normalize(cross(dpdx, dpdy));\n\t\t}\n\n\t\tvec3 getViewNormal(const vec2 uv) {\n\t\t\t#if NORMAL_VECTOR_TYPE == 2\n\t\t\t\treturn normalize(textureLod(tNormal, uv, 0.).rgb);\n\t\t\t#elif NORMAL_VECTOR_TYPE == 1\n\t\t\t\treturn unpackRGBToNormal(textureLod(tNormal, uv, 0.).rgb);\n\t\t\t#else\n\t\t\t\treturn computeNormalFromDepth(uv);\n\t\t\t#endif\n\t\t}\n\n\t\tvec3 getSceneUvAndDepth(vec3 sampleViewPos) {\n\t\t\tvec4 sampleClipPos = cameraProjectionMatrix * vec4(sampleViewPos, 1.);\n\t\t\tvec2 sampleUv = sampleClipPos.xy / sampleClipPos.w * 0.5 + 0.5;\n\t\t\tfloat sampleSceneDepth = getDepth(sampleUv);\n\t\t\treturn vec3(sampleUv, sampleSceneDepth);\n\t\t}\n\n\t\tvoid main() {\n\t\t\tfloat depth = getDepth(vUv.xy);\n\t\t\tif (depth >= 1.0) {\n\t\t\t\tdiscard;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvec3 viewPos = getViewPosition(vUv, depth);\n\t\t\tvec3 viewNormal = getViewNormal(vUv);\n\n\t\t\tfloat radiusToUse = radius;\n\t\t\tfloat distanceFalloffToUse = thickness;\n\t\t\t#if SCREEN_SPACE_RADIUS == 1\n\t\t\t\tfloat radiusScale = getViewPosition(vec2(0.5 + float(SCREEN_SPACE_RADIUS_SCALE) / resolution.x, 0.0), depth).x;\n\t\t\t\tradiusToUse *= radiusScale;\n\t\t\t\tdistanceFalloffToUse *= radiusScale;\n\t\t\t#endif\n\n\t\t\t#if SCENE_CLIP_BOX == 1\n\t\t\t\tvec3 worldPos = (cameraWorldMatrix * vec4(viewPos, 1.0)).xyz;\n\t\t\t\tfloat boxDistance = length(max(vec3(0.0), max(sceneBoxMin - worldPos, worldPos - sceneBoxMax)));\n\t\t\t\tif (boxDistance > radiusToUse) {\n\t\t\t\t\tdiscard;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t\tvec2 noiseResolution = vec2(textureSize(tNoise, 0));\n\t\t\tvec2 noiseUv = vUv * resolution / noiseResolution;\n\t\t\tvec4 noiseTexel = textureLod(tNoise, noiseUv, 0.0);\n\t\t\tvec3 randomVec = noiseTexel.xyz * 2.0 - 1.0;\n\t\t\tvec3 tangent = normalize(vec3(randomVec.xy, 0.));\n\t\t\tvec3 bitangent = vec3(-tangent.y, tangent.x, 0.);\n\t\t\tmat3 kernelMatrix = mat3(tangent, bitangent, vec3(0., 0., 1.));\n\n\t\t\tconst int DIRECTIONS = SAMPLES < 30 ? 3 : 5;\n\t\t\tconst int STEPS = (SAMPLES + DIRECTIONS - 1) / DIRECTIONS;\n\t\t\tfloat ao = 0.0;\n\t\t\tfor (int i = 0; i < DIRECTIONS; ++i) {\n\n\t\t\t\tfloat angle = float(i) / float(DIRECTIONS) * PI;\n\t\t\t\tvec4 sampleDir = vec4(cos(angle), sin(angle), 0., 0.5 + 0.5 * noiseTexel.w);\n\t\t\t\tsampleDir.xyz = normalize(kernelMatrix * sampleDir.xyz);\n\n\t\t\t\tvec3 viewDir = normalize(-viewPos.xyz);\n\t\t\t\tvec3 sliceBitangent = normalize(cross(sampleDir.xyz, viewDir));\n\t\t\t\tvec3 sliceTangent = cross(sliceBitangent, viewDir);\n\t\t\t\tvec3 normalInSlice = normalize(viewNormal - sliceBitangent * dot(viewNormal, sliceBitangent));\n\n\t\t\t\tvec3 tangentToNormalInSlice = cross(normalInSlice, sliceBitangent);\n\t\t\t\tvec2 cosHorizons = vec2(dot(viewDir, tangentToNormalInSlice), dot(viewDir, -tangentToNormalInSlice));\n\n\t\t\t\tfor (int j = 0; j < STEPS; ++j) {\n\t\t\t\t\tvec3 sampleViewOffset = sampleDir.xyz * radiusToUse * sampleDir.w * pow(float(j + 1) / float(STEPS), distanceExponent);\n\n\t\t\t\t\tvec3 sampleSceneUvDepth = getSceneUvAndDepth(viewPos + sampleViewOffset);\n\t\t\t\t\tvec3 sampleSceneViewPos = getViewPosition(sampleSceneUvDepth.xy, sampleSceneUvDepth.z);\n\t\t\t\t\tvec3 viewDelta = sampleSceneViewPos - viewPos;\n\t\t\t\t\tif (abs(viewDelta.z) < thickness) {\n\t\t\t\t\t\tfloat sampleCosHorizon = dot(viewDir, normalize(viewDelta));\n\t\t\t\t\t\tcosHorizons.x += max(0., (sampleCosHorizon - cosHorizons.x) * mix(1., 2. / float(j + 2), distanceFallOff));\n\t\t\t\t\t}\n\n\t\t\t\t\tsampleSceneUvDepth = getSceneUvAndDepth(viewPos - sampleViewOffset);\n\t\t\t\t\tsampleSceneViewPos = getViewPosition(sampleSceneUvDepth.xy, sampleSceneUvDepth.z);\n\t\t\t\t\tviewDelta = sampleSceneViewPos - viewPos;\n\t\t\t\t\tif (abs(viewDelta.z) < thickness) {\n\t\t\t\t\t\tfloat sampleCosHorizon = dot(viewDir, normalize(viewDelta));\n\t\t\t\t\t\tcosHorizons.y += max(0., (sampleCosHorizon - cosHorizons.y) * mix(1., 2. / float(j + 2), distanceFallOff));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvec2 sinHorizons = sqrt(1. - cosHorizons * cosHorizons);\n\t\t\t\tfloat nx = dot(normalInSlice, sliceTangent);\n\t\t\t\tfloat ny = dot(normalInSlice, viewDir);\n\t\t\t\tfloat nxb = 1. / 2. * (acos(cosHorizons.y) - acos(cosHorizons.x) + sinHorizons.x * cosHorizons.x - sinHorizons.y * cosHorizons.y);\n\t\t\t\tfloat nyb = 1. / 2. * (2. - cosHorizons.x * cosHorizons.x - cosHorizons.y * cosHorizons.y);\n\t\t\t\tfloat occlusion = nx * nxb + ny * nyb;\n\t\t\t\tao += occlusion;\n\t\t\t}\n\n\t\t\tao = clamp(ao / float(DIRECTIONS), 0., 1.);\n\t\t#if SCENE_CLIP_BOX == 1\n\t\t\tao = mix(ao, 1., smoothstep(0., radiusToUse, boxDistance));\n\t\t#endif\n\t\t\tao = pow(ao, scale);\n\n\t\t\tgl_FragColor = FRAGMENT_OUTPUT;\n\t\t}`\n\n};\n\n/**\n * GTAO depth shader. Use by {@link GTAOPass}.\n *\n * @constant\n * @type {Object}\n */\nconst GTAODepthShader = {\n\n\tname: 'GTAODepthShader',\n\n\tdefines: {\n\t\tPERSPECTIVE_CAMERA: 1\n\t},\n\n\tuniforms: {\n\t\ttDepth: { value: null },\n\t\tcameraNear: { value: null },\n\t\tcameraFar: { value: null },\n\t},\n\n\tvertexShader: /* glsl */`\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\t\tuniform sampler2D tDepth;\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tvarying vec2 vUv;\n\n\t\t#include <packing>\n\n\t\tfloat getLinearDepth( const in vec2 screenPosition ) {\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\t\t\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\n\t\t\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\t\t\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\t\t\t#else\n\t\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\t\t\t#endif\n\t\t}\n\n\t\tvoid main() {\n\t\t\tfloat depth = getLinearDepth( vUv );\n\t\t\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\n\n\t\t}`\n\n};\n\n/**\n * GTAO blend shader. Use by {@link GTAOPass}.\n *\n * @constant\n * @type {Object}\n */\nconst GTAOBlendShader = {\n\n\tname: 'GTAOBlendShader',\n\n\tuniforms: {\n\t\ttDiffuse: { value: null },\n\t\tintensity: { value: 1.0 }\n\t},\n\n\tvertexShader: /* glsl */`\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\t\tuniform float intensity;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4(mix(vec3(1.), texel.rgb, intensity), texel.a);\n\t\t}`\n\n};\n\n\nfunction generateMagicSquareNoise( size = 5 ) {\n\n\tconst noiseSize = Math.floor( size ) % 2 === 0 ? Math.floor( size ) + 1 : Math.floor( size );\n\tconst magicSquare = generateMagicSquare( noiseSize );\n\tconst noiseSquareSize = magicSquare.length;\n\tconst data = new Uint8Array( noiseSquareSize * 4 );\n\n\tfor ( let inx = 0; inx < noiseSquareSize; ++ inx ) {\n\n\t\tconst iAng = magicSquare[ inx ];\n\t\tconst angle = ( 2 * Math.PI * iAng ) / noiseSquareSize;\n\t\tconst randomVec = new Vector3(\n\t\t\tMath.cos( angle ),\n\t\t\tMath.sin( angle ),\n\t\t\t0\n\t\t).normalize();\n\t\tdata[ inx * 4 ] = ( randomVec.x * 0.5 + 0.5 ) * 255;\n\t\tdata[ inx * 4 + 1 ] = ( randomVec.y * 0.5 + 0.5 ) * 255;\n\t\tdata[ inx * 4 + 2 ] = 127;\n\t\tdata[ inx * 4 + 3 ] = 255;\n\n\t}\n\n\tconst noiseTexture = new DataTexture( data, noiseSize, noiseSize );\n\tnoiseTexture.wrapS = RepeatWrapping;\n\tnoiseTexture.wrapT = RepeatWrapping;\n\tnoiseTexture.needsUpdate = true;\n\n\treturn noiseTexture;\n\n}\n\nfunction generateMagicSquare( size ) {\n\n\tconst noiseSize = Math.floor( size ) % 2 === 0 ? Math.floor( size ) + 1 : Math.floor( size );\n\tconst noiseSquareSize = noiseSize * noiseSize;\n\tconst magicSquare = Array( noiseSquareSize ).fill( 0 );\n\tlet i = Math.floor( noiseSize / 2 );\n\tlet j = noiseSize - 1;\n\n\tfor ( let num = 1; num <= noiseSquareSize; ) {\n\n\t\tif ( i === - 1 && j === noiseSize ) {\n\n\t\t\tj = noiseSize - 2;\n\t\t\ti = 0;\n\n\t\t} else {\n\n\t\t\tif ( j === noiseSize ) {\n\n\t\t\t\tj = 0;\n\n\t\t\t}\n\n\t\t\tif ( i < 0 ) {\n\n\t\t\t\ti = noiseSize - 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( magicSquare[ i * noiseSize + j ] !== 0 ) {\n\n\t\t\tj -= 2;\n\t\t\ti ++;\n\t\t\tcontinue;\n\n\t\t} else {\n\n\t\t\tmagicSquare[ i * noiseSize + j ] = num ++;\n\n\t\t}\n\n\t\tj ++;\n\t\ti --;\n\n\t}\n\n\treturn magicSquare;\n\n}\n\n\nexport { generateMagicSquareNoise, GTAOShader, GTAODepthShader, GTAOBlendShader };\n"],"mappings":"AAAA,SACCA,WAAW,EACXC,OAAO,EACPC,cAAc,EACdC,OAAO,EACPC,OAAO,QACD,OAAO;;AAEd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,UAAU,GAAG;EAElBC,IAAI,EAAE,YAAY;EAElBC,OAAO,EAAE;IACRC,kBAAkB,EAAE,CAAC;IACrBC,OAAO,EAAE,EAAE;IACXC,kBAAkB,EAAE,CAAC;IACrBC,eAAe,EAAE,GAAG;IACpBC,mBAAmB,EAAE,CAAC;IACtBC,yBAAyB,EAAE,KAAK;IAChCC,cAAc,EAAE;EACjB,CAAC;EAEDC,QAAQ,EAAE;IACTC,OAAO,EAAE;MAAEC,KAAK,EAAE;IAAK,CAAC;IACxBC,MAAM,EAAE;MAAED,KAAK,EAAE;IAAK,CAAC;IACvBE,MAAM,EAAE;MAAEF,KAAK,EAAE;IAAK,CAAC;IACvBG,UAAU,EAAE;MAAEH,KAAK,EAAE,IAAId,OAAO,CAAC;IAAE,CAAC;IACpCkB,UAAU,EAAE;MAAEJ,KAAK,EAAE;IAAK,CAAC;IAC3BK,SAAS,EAAE;MAAEL,KAAK,EAAE;IAAK,CAAC;IAC1BM,sBAAsB,EAAE;MAAEN,KAAK,EAAE,IAAIhB,OAAO,CAAC;IAAE,CAAC;IAChDuB,6BAA6B,EAAE;MAAEP,KAAK,EAAE,IAAIhB,OAAO,CAAC;IAAE,CAAC;IACvDwB,iBAAiB,EAAE;MAAER,KAAK,EAAE,IAAIhB,OAAO,CAAC;IAAE,CAAC;IAC3CyB,MAAM,EAAE;MAAET,KAAK,EAAE;IAAK,CAAC;IACvBU,gBAAgB,EAAE;MAAEV,KAAK,EAAE;IAAG,CAAC;IAC/BW,SAAS,EAAE;MAAEX,KAAK,EAAE;IAAG,CAAC;IACxBY,eAAe,EAAE;MAAEZ,KAAK,EAAE;IAAG,CAAC;IAC9Ba,KAAK,EAAE;MAAEb,KAAK,EAAE;IAAG,CAAC;IACpBc,WAAW,EAAE;MAAEd,KAAK,EAAE,IAAIb,OAAO,CAAE,CAAE,CAAC,EAAE,CAAE,CAAC,EAAE,CAAE,CAAE;IAAE,CAAC;IACpD4B,WAAW,EAAE;MAAEf,KAAK,EAAE,IAAIb,OAAO,CAAE,CAAC,EAAE,CAAC,EAAE,CAAE;IAAE;EAC9C,CAAC;EAED6B,YAAY,EAAE,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;EAEHC,cAAc,EAAE,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,eAAe,GAAG;EAEvB7B,IAAI,EAAE,iBAAiB;EAEvBC,OAAO,EAAE;IACRC,kBAAkB,EAAE;EACrB,CAAC;EAEDO,QAAQ,EAAE;IACTG,MAAM,EAAE;MAAED,KAAK,EAAE;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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}