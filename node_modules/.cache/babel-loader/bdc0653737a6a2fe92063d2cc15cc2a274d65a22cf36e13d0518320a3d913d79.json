{"ast":null,"code":"import { BackSide, Color, ShaderMaterial, UniformsLib, UniformsUtils } from 'three';\n\n/**\n * An outline effect for toon shaders.\n *\n * Note that this class can only be used with {@link WebGLRenderer}.\n * When using {@link WebGPURenderer}, use {@link ToonOutlinePassNode}.\n *\n * ```js\n * const effect = new OutlineEffect( renderer );\n *\n * function render() {\n *\n * \teffect.render( scene, camera );\n *\n * }\n * ```\n *\n * @three_import import { OutlineEffect } from 'three/addons/effects/OutlineEffect.js';\n */\nclass OutlineEffect {\n  /**\n   * Constructs a new outline effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {OutlineEffect~Options} [parameters] - The configuration parameter.\n   */\n  constructor(renderer, parameters = {}) {\n    this.enabled = true;\n    const defaultThickness = parameters.defaultThickness !== undefined ? parameters.defaultThickness : 0.003;\n    const defaultColor = new Color().fromArray(parameters.defaultColor !== undefined ? parameters.defaultColor : [0, 0, 0]);\n    const defaultAlpha = parameters.defaultAlpha !== undefined ? parameters.defaultAlpha : 1.0;\n    const defaultKeepAlive = parameters.defaultKeepAlive !== undefined ? parameters.defaultKeepAlive : false;\n\n    // object.material.uuid -> outlineMaterial or\n    // object.material[ n ].uuid -> outlineMaterial\n    // save at the outline material creation and release\n    // if it's unused removeThresholdCount frames\n    // unless keepAlive is true.\n    const cache = {};\n    const removeThresholdCount = 60;\n\n    // outlineMaterial.uuid -> object.material or\n    // outlineMaterial.uuid -> object.material[ n ]\n    // save before render and release after render.\n    const originalMaterials = {};\n\n    // object.uuid -> originalOnBeforeRender\n    // save before render and release after render.\n    const originalOnBeforeRenders = {};\n\n    //this.cache = cache;  // for debug\n\n    const uniformsOutline = {\n      outlineThickness: {\n        value: defaultThickness\n      },\n      outlineColor: {\n        value: defaultColor\n      },\n      outlineAlpha: {\n        value: defaultAlpha\n      }\n    };\n    const vertexShader = ['#include <common>', '#include <uv_pars_vertex>', '#include <displacementmap_pars_vertex>', '#include <fog_pars_vertex>', '#include <morphtarget_pars_vertex>', '#include <skinning_pars_vertex>', '#include <logdepthbuf_pars_vertex>', '#include <clipping_planes_pars_vertex>', 'uniform float outlineThickness;', 'vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {', '\tfloat thickness = outlineThickness;', '\tconst float ratio = 1.0;',\n    // TODO: support outline thickness ratio for each vertex\n    '\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );',\n    // NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n    '\tvec4 norm = normalize( pos - pos2 );', '\treturn pos + norm * thickness * pos.w * ratio;', '}', 'void main() {', '\t#include <uv_vertex>', '\t#include <beginnormal_vertex>', '\t#include <morphnormal_vertex>', '\t#include <skinbase_vertex>', '\t#include <skinnormal_vertex>', '\t#include <begin_vertex>', '\t#include <morphtarget_vertex>', '\t#include <skinning_vertex>', '\t#include <displacementmap_vertex>', '\t#include <project_vertex>', '\tvec3 outlineNormal = - objectNormal;',\n    // the outline material is always rendered with BackSide\n\n    '\tgl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );', '\t#include <logdepthbuf_vertex>', '\t#include <clipping_planes_vertex>', '\t#include <fog_vertex>', '}'].join('\\n');\n    const fragmentShader = ['#include <common>', '#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', '#include <clipping_planes_pars_fragment>', 'uniform vec3 outlineColor;', 'uniform float outlineAlpha;', 'void main() {', '\t#include <clipping_planes_fragment>', '\t#include <logdepthbuf_fragment>', '\tgl_FragColor = vec4( outlineColor, outlineAlpha );', '\t#include <tonemapping_fragment>', '\t#include <colorspace_fragment>', '\t#include <fog_fragment>', '\t#include <premultiplied_alpha_fragment>', '}'].join('\\n');\n    function createMaterial() {\n      return new ShaderMaterial({\n        type: 'OutlineEffect',\n        uniforms: UniformsUtils.merge([UniformsLib['fog'], UniformsLib['displacementmap'], uniformsOutline]),\n        vertexShader: vertexShader,\n        fragmentShader: fragmentShader,\n        side: BackSide\n      });\n    }\n    function getOutlineMaterialFromCache(originalMaterial) {\n      let data = cache[originalMaterial.uuid];\n      if (data === undefined) {\n        data = {\n          material: createMaterial(),\n          used: true,\n          keepAlive: defaultKeepAlive,\n          count: 0\n        };\n        cache[originalMaterial.uuid] = data;\n      }\n      data.used = true;\n      return data.material;\n    }\n    function getOutlineMaterial(originalMaterial) {\n      const outlineMaterial = getOutlineMaterialFromCache(originalMaterial);\n      originalMaterials[outlineMaterial.uuid] = originalMaterial;\n      updateOutlineMaterial(outlineMaterial, originalMaterial);\n      return outlineMaterial;\n    }\n    function isCompatible(object) {\n      const geometry = object.geometry;\n      const hasNormals = geometry !== undefined && geometry.attributes.normal !== undefined;\n      return object.isMesh === true && object.material !== undefined && hasNormals === true;\n    }\n    function setOutlineMaterial(object) {\n      if (isCompatible(object) === false) return;\n      if (Array.isArray(object.material)) {\n        for (let i = 0, il = object.material.length; i < il; i++) {\n          object.material[i] = getOutlineMaterial(object.material[i]);\n        }\n      } else {\n        object.material = getOutlineMaterial(object.material);\n      }\n      originalOnBeforeRenders[object.uuid] = object.onBeforeRender;\n      object.onBeforeRender = onBeforeRender;\n    }\n    function restoreOriginalMaterial(object) {\n      if (isCompatible(object) === false) return;\n      if (Array.isArray(object.material)) {\n        for (let i = 0, il = object.material.length; i < il; i++) {\n          object.material[i] = originalMaterials[object.material[i].uuid];\n        }\n      } else {\n        object.material = originalMaterials[object.material.uuid];\n      }\n      object.onBeforeRender = originalOnBeforeRenders[object.uuid];\n    }\n    function onBeforeRender(renderer, scene, camera, geometry, material) {\n      const originalMaterial = originalMaterials[material.uuid];\n\n      // just in case\n      if (originalMaterial === undefined) return;\n      updateUniforms(material, originalMaterial);\n    }\n    function updateUniforms(material, originalMaterial) {\n      const outlineParameters = originalMaterial.userData.outlineParameters;\n      material.uniforms.outlineAlpha.value = originalMaterial.opacity;\n      if (outlineParameters !== undefined) {\n        if (outlineParameters.thickness !== undefined) material.uniforms.outlineThickness.value = outlineParameters.thickness;\n        if (outlineParameters.color !== undefined) material.uniforms.outlineColor.value.fromArray(outlineParameters.color);\n        if (outlineParameters.alpha !== undefined) material.uniforms.outlineAlpha.value = outlineParameters.alpha;\n      }\n      if (originalMaterial.displacementMap) {\n        material.uniforms.displacementMap.value = originalMaterial.displacementMap;\n        material.uniforms.displacementScale.value = originalMaterial.displacementScale;\n        material.uniforms.displacementBias.value = originalMaterial.displacementBias;\n      }\n    }\n    function updateOutlineMaterial(material, originalMaterial) {\n      if (material.name === 'invisible') return;\n      const outlineParameters = originalMaterial.userData.outlineParameters;\n      material.fog = originalMaterial.fog;\n      material.toneMapped = originalMaterial.toneMapped;\n      material.premultipliedAlpha = originalMaterial.premultipliedAlpha;\n      material.displacementMap = originalMaterial.displacementMap;\n      if (outlineParameters !== undefined) {\n        if (originalMaterial.visible === false) {\n          material.visible = false;\n        } else {\n          material.visible = outlineParameters.visible !== undefined ? outlineParameters.visible : true;\n        }\n        material.transparent = outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0 ? true : originalMaterial.transparent;\n        if (outlineParameters.keepAlive !== undefined) cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;\n      } else {\n        material.transparent = originalMaterial.transparent;\n        material.visible = originalMaterial.visible;\n      }\n      if (originalMaterial.wireframe === true || originalMaterial.depthTest === false) material.visible = false;\n      if (originalMaterial.clippingPlanes) {\n        material.clipping = true;\n        material.clippingPlanes = originalMaterial.clippingPlanes;\n        material.clipIntersection = originalMaterial.clipIntersection;\n        material.clipShadows = originalMaterial.clipShadows;\n      }\n      material.version = originalMaterial.version; // update outline material if necessary\n    }\n    function cleanupCache() {\n      let keys;\n\n      // clear originalMaterials\n      keys = Object.keys(originalMaterials);\n      for (let i = 0, il = keys.length; i < il; i++) {\n        originalMaterials[keys[i]] = undefined;\n      }\n\n      // clear originalOnBeforeRenders\n      keys = Object.keys(originalOnBeforeRenders);\n      for (let i = 0, il = keys.length; i < il; i++) {\n        originalOnBeforeRenders[keys[i]] = undefined;\n      }\n\n      // remove unused outlineMaterial from cache\n      keys = Object.keys(cache);\n      for (let i = 0, il = keys.length; i < il; i++) {\n        const key = keys[i];\n        if (cache[key].used === false) {\n          cache[key].count++;\n          if (cache[key].keepAlive === false && cache[key].count > removeThresholdCount) {\n            delete cache[key];\n          }\n        } else {\n          cache[key].used = false;\n          cache[key].count = 0;\n        }\n      }\n    }\n\n    /**\n     * When using this effect, this method should be called instead of the\n     * default {@link WebGLRenderer#render}.\n     *\n     * @param {Object3D} scene - The scene to render.\n     * @param {Camera} camera - The camera.\n     */\n    this.render = function (scene, camera) {\n      if (this.enabled === false) {\n        renderer.render(scene, camera);\n        return;\n      }\n      const currentAutoClear = renderer.autoClear;\n      renderer.autoClear = this.autoClear;\n      renderer.render(scene, camera);\n      renderer.autoClear = currentAutoClear;\n      this.renderOutline(scene, camera);\n    };\n\n    /**\n     * This method can be used to render outlines in VR.\n     *\n     * ```js\n     * const effect = new OutlineEffect( renderer );\n     * let renderingOutline = false;\n     *\n     * scene.onAfterRender = function () {\n     *\n     * \tif ( renderingOutline ) return;\n     *\n     * \trenderingOutline = true;\n     * \teffect.renderOutline( scene, camera );\n     * \trenderingOutline = false;\n     * };\n     *\n     * function render() {\n     * \trenderer.render( scene, camera );\n     * }\n     * ```\n     *\n     * @param {Object3D} scene - The scene to render.\n     * @param {Camera} camera - The camera.\n     */\n    this.renderOutline = function (scene, camera) {\n      const currentAutoClear = renderer.autoClear;\n      const currentSceneAutoUpdate = scene.matrixWorldAutoUpdate;\n      const currentSceneBackground = scene.background;\n      const currentShadowMapEnabled = renderer.shadowMap.enabled;\n      scene.matrixWorldAutoUpdate = false;\n      scene.background = null;\n      renderer.autoClear = false;\n      renderer.shadowMap.enabled = false;\n      scene.traverse(setOutlineMaterial);\n      renderer.render(scene, camera);\n      scene.traverse(restoreOriginalMaterial);\n      cleanupCache();\n      scene.matrixWorldAutoUpdate = currentSceneAutoUpdate;\n      scene.background = currentSceneBackground;\n      renderer.autoClear = currentAutoClear;\n      renderer.shadowMap.enabled = currentShadowMapEnabled;\n    };\n\n    /**\n     * Resizes the effect.\n     *\n     * @param {number} width - The width of the effect in logical pixels.\n     * @param {number} height - The height of the effect in logical pixels.\n     */\n    this.setSize = function (width, height) {\n      renderer.setSize(width, height);\n    };\n  }\n}\n\n/**\n * This type represents configuration settings of `OutlineEffect`.\n *\n * @typedef {Object} OutlineEffect~Options\n * @property {number} [defaultThickness=0.003] - The outline thickness.\n * @property {Array<number>} [defaultColor=[0,0,0]] - The outline color.\n * @property {number} [defaultAlpha=1] - The outline alpha value.\n * @property {boolean} [defaultKeepAlive=false] - Whether to keep alive cached internal materials or not.\n **/\n\nexport { OutlineEffect };","map":{"version":3,"names":["BackSide","Color","ShaderMaterial","UniformsLib","UniformsUtils","OutlineEffect","constructor","renderer","parameters","enabled","defaultThickness","undefined","defaultColor","fromArray","defaultAlpha","defaultKeepAlive","cache","removeThresholdCount","originalMaterials","originalOnBeforeRenders","uniformsOutline","outlineThickness","value","outlineColor","outlineAlpha","vertexShader","join","fragmentShader","createMaterial","type","uniforms","merge","side","getOutlineMaterialFromCache","originalMaterial","data","uuid","material","used","keepAlive","count","getOutlineMaterial","outlineMaterial","updateOutlineMaterial","isCompatible","object","geometry","hasNormals","attributes","normal","isMesh","setOutlineMaterial","Array","isArray","i","il","length","onBeforeRender","restoreOriginalMaterial","scene","camera","updateUniforms","outlineParameters","userData","opacity","thickness","color","alpha","displacementMap","displacementScale","displacementBias","name","fog","toneMapped","premultipliedAlpha","visible","transparent","wireframe","depthTest","clippingPlanes","clipping","clipIntersection","clipShadows","version","cleanupCache","keys","Object","key","render","currentAutoClear","autoClear","renderOutline","currentSceneAutoUpdate","matrixWorldAutoUpdate","currentSceneBackground","background","currentShadowMapEnabled","shadowMap","traverse","setSize","width","height"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/effects/OutlineEffect.js"],"sourcesContent":["import {\n\tBackSide,\n\tColor,\n\tShaderMaterial,\n\tUniformsLib,\n\tUniformsUtils\n} from 'three';\n\n/**\n * An outline effect for toon shaders.\n *\n * Note that this class can only be used with {@link WebGLRenderer}.\n * When using {@link WebGPURenderer}, use {@link ToonOutlinePassNode}.\n *\n * ```js\n * const effect = new OutlineEffect( renderer );\n *\n * function render() {\n *\n * \teffect.render( scene, camera );\n *\n * }\n * ```\n *\n * @three_import import { OutlineEffect } from 'three/addons/effects/OutlineEffect.js';\n */\nclass OutlineEffect {\n\n\t/**\n\t * Constructs a new outline effect.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {OutlineEffect~Options} [parameters] - The configuration parameter.\n\t */\n\tconstructor( renderer, parameters = {} ) {\n\n\t\tthis.enabled = true;\n\n\t\tconst defaultThickness = parameters.defaultThickness !== undefined ? parameters.defaultThickness : 0.003;\n\t\tconst defaultColor = new Color().fromArray( parameters.defaultColor !== undefined ? parameters.defaultColor : [ 0, 0, 0 ] );\n\t\tconst defaultAlpha = parameters.defaultAlpha !== undefined ? parameters.defaultAlpha : 1.0;\n\t\tconst defaultKeepAlive = parameters.defaultKeepAlive !== undefined ? parameters.defaultKeepAlive : false;\n\n\t\t// object.material.uuid -> outlineMaterial or\n\t\t// object.material[ n ].uuid -> outlineMaterial\n\t\t// save at the outline material creation and release\n\t\t// if it's unused removeThresholdCount frames\n\t\t// unless keepAlive is true.\n\t\tconst cache = {};\n\n\t\tconst removeThresholdCount = 60;\n\n\t\t// outlineMaterial.uuid -> object.material or\n\t\t// outlineMaterial.uuid -> object.material[ n ]\n\t\t// save before render and release after render.\n\t\tconst originalMaterials = {};\n\n\t\t// object.uuid -> originalOnBeforeRender\n\t\t// save before render and release after render.\n\t\tconst originalOnBeforeRenders = {};\n\n\t\t//this.cache = cache;  // for debug\n\n\t\tconst uniformsOutline = {\n\t\t\toutlineThickness: { value: defaultThickness },\n\t\t\toutlineColor: { value: defaultColor },\n\t\t\toutlineAlpha: { value: defaultAlpha }\n\t\t};\n\n\t\tconst vertexShader = [\n\t\t\t'#include <common>',\n\t\t\t'#include <uv_pars_vertex>',\n\t\t\t'#include <displacementmap_pars_vertex>',\n\t\t\t'#include <fog_pars_vertex>',\n\t\t\t'#include <morphtarget_pars_vertex>',\n\t\t\t'#include <skinning_pars_vertex>',\n\t\t\t'#include <logdepthbuf_pars_vertex>',\n\t\t\t'#include <clipping_planes_pars_vertex>',\n\n\t\t\t'uniform float outlineThickness;',\n\n\t\t\t'vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {',\n\t\t\t'\tfloat thickness = outlineThickness;',\n\t\t\t'\tconst float ratio = 1.0;', // TODO: support outline thickness ratio for each vertex\n\t\t\t'\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );',\n\t\t\t// NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n\t\t\t'\tvec4 norm = normalize( pos - pos2 );',\n\t\t\t'\treturn pos + norm * thickness * pos.w * ratio;',\n\t\t\t'}',\n\n\t\t\t'void main() {',\n\n\t\t\t'\t#include <uv_vertex>',\n\n\t\t\t'\t#include <beginnormal_vertex>',\n\t\t\t'\t#include <morphnormal_vertex>',\n\t\t\t'\t#include <skinbase_vertex>',\n\t\t\t'\t#include <skinnormal_vertex>',\n\n\t\t\t'\t#include <begin_vertex>',\n\t\t\t'\t#include <morphtarget_vertex>',\n\t\t\t'\t#include <skinning_vertex>',\n\t\t\t'\t#include <displacementmap_vertex>',\n\t\t\t'\t#include <project_vertex>',\n\n\t\t\t'\tvec3 outlineNormal = - objectNormal;', // the outline material is always rendered with BackSide\n\n\t\t\t'\tgl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );',\n\n\t\t\t'\t#include <logdepthbuf_vertex>',\n\t\t\t'\t#include <clipping_planes_vertex>',\n\t\t\t'\t#include <fog_vertex>',\n\n\t\t\t'}',\n\n\t\t].join( '\\n' );\n\n\t\tconst fragmentShader = [\n\n\t\t\t'#include <common>',\n\t\t\t'#include <fog_pars_fragment>',\n\t\t\t'#include <logdepthbuf_pars_fragment>',\n\t\t\t'#include <clipping_planes_pars_fragment>',\n\n\t\t\t'uniform vec3 outlineColor;',\n\t\t\t'uniform float outlineAlpha;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\t#include <clipping_planes_fragment>',\n\t\t\t'\t#include <logdepthbuf_fragment>',\n\n\t\t\t'\tgl_FragColor = vec4( outlineColor, outlineAlpha );',\n\n\t\t\t'\t#include <tonemapping_fragment>',\n\t\t\t'\t#include <colorspace_fragment>',\n\t\t\t'\t#include <fog_fragment>',\n\t\t\t'\t#include <premultiplied_alpha_fragment>',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' );\n\n\t\tfunction createMaterial() {\n\n\t\t\treturn new ShaderMaterial( {\n\t\t\t\ttype: 'OutlineEffect',\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\t\tUniformsLib[ 'fog' ],\n\t\t\t\t\tUniformsLib[ 'displacementmap' ],\n\t\t\t\t\tuniformsOutline\n\t\t\t\t] ),\n\t\t\t\tvertexShader: vertexShader,\n\t\t\t\tfragmentShader: fragmentShader,\n\t\t\t\tside: BackSide\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction getOutlineMaterialFromCache( originalMaterial ) {\n\n\t\t\tlet data = cache[ originalMaterial.uuid ];\n\n\t\t\tif ( data === undefined ) {\n\n\t\t\t\tdata = {\n\t\t\t\t\tmaterial: createMaterial(),\n\t\t\t\t\tused: true,\n\t\t\t\t\tkeepAlive: defaultKeepAlive,\n\t\t\t\t\tcount: 0\n\t\t\t\t};\n\n\t\t\t\tcache[ originalMaterial.uuid ] = data;\n\n\t\t\t}\n\n\t\t\tdata.used = true;\n\n\t\t\treturn data.material;\n\n\t\t}\n\n\t\tfunction getOutlineMaterial( originalMaterial ) {\n\n\t\t\tconst outlineMaterial = getOutlineMaterialFromCache( originalMaterial );\n\n\t\t\toriginalMaterials[ outlineMaterial.uuid ] = originalMaterial;\n\n\t\t\tupdateOutlineMaterial( outlineMaterial, originalMaterial );\n\n\t\t\treturn outlineMaterial;\n\n\t\t}\n\n\t\tfunction isCompatible( object ) {\n\n\t\t\tconst geometry = object.geometry;\n\t\t\tconst hasNormals = ( geometry !== undefined ) && ( geometry.attributes.normal !== undefined );\n\n\t\t\treturn ( object.isMesh === true && object.material !== undefined && hasNormals === true );\n\n\t\t}\n\n\t\tfunction setOutlineMaterial( object ) {\n\n\t\t\tif ( isCompatible( object ) === false ) return;\n\n\t\t\tif ( Array.isArray( object.material ) ) {\n\n\t\t\t\tfor ( let i = 0, il = object.material.length; i < il; i ++ ) {\n\n\t\t\t\t\tobject.material[ i ] = getOutlineMaterial( object.material[ i ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tobject.material = getOutlineMaterial( object.material );\n\n\t\t\t}\n\n\t\t\toriginalOnBeforeRenders[ object.uuid ] = object.onBeforeRender;\n\t\t\tobject.onBeforeRender = onBeforeRender;\n\n\t\t}\n\n\t\tfunction restoreOriginalMaterial( object ) {\n\n\t\t\tif ( isCompatible( object ) === false ) return;\n\n\t\t\tif ( Array.isArray( object.material ) ) {\n\n\t\t\t\tfor ( let i = 0, il = object.material.length; i < il; i ++ ) {\n\n\t\t\t\t\tobject.material[ i ] = originalMaterials[ object.material[ i ].uuid ];\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tobject.material = originalMaterials[ object.material.uuid ];\n\n\t\t\t}\n\n\t\t\tobject.onBeforeRender = originalOnBeforeRenders[ object.uuid ];\n\n\t\t}\n\n\t\tfunction onBeforeRender( renderer, scene, camera, geometry, material ) {\n\n\t\t\tconst originalMaterial = originalMaterials[ material.uuid ];\n\n\t\t\t// just in case\n\t\t\tif ( originalMaterial === undefined ) return;\n\n\t\t\tupdateUniforms( material, originalMaterial );\n\n\t\t}\n\n\t\tfunction updateUniforms( material, originalMaterial ) {\n\n\t\t\tconst outlineParameters = originalMaterial.userData.outlineParameters;\n\n\t\t\tmaterial.uniforms.outlineAlpha.value = originalMaterial.opacity;\n\n\t\t\tif ( outlineParameters !== undefined ) {\n\n\t\t\t\tif ( outlineParameters.thickness !== undefined ) material.uniforms.outlineThickness.value = outlineParameters.thickness;\n\t\t\t\tif ( outlineParameters.color !== undefined ) material.uniforms.outlineColor.value.fromArray( outlineParameters.color );\n\t\t\t\tif ( outlineParameters.alpha !== undefined ) material.uniforms.outlineAlpha.value = outlineParameters.alpha;\n\n\t\t\t}\n\n\t\t\tif ( originalMaterial.displacementMap ) {\n\n\t\t\t\tmaterial.uniforms.displacementMap.value = originalMaterial.displacementMap;\n\t\t\t\tmaterial.uniforms.displacementScale.value = originalMaterial.displacementScale;\n\t\t\t\tmaterial.uniforms.displacementBias.value = originalMaterial.displacementBias;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction updateOutlineMaterial( material, originalMaterial ) {\n\n\t\t\tif ( material.name === 'invisible' ) return;\n\n\t\t\tconst outlineParameters = originalMaterial.userData.outlineParameters;\n\n\t\t\tmaterial.fog = originalMaterial.fog;\n\t\t\tmaterial.toneMapped = originalMaterial.toneMapped;\n\t\t\tmaterial.premultipliedAlpha = originalMaterial.premultipliedAlpha;\n\t\t\tmaterial.displacementMap = originalMaterial.displacementMap;\n\n\t\t\tif ( outlineParameters !== undefined ) {\n\n\t\t\t\tif ( originalMaterial.visible === false ) {\n\n\t\t\t\t\tmaterial.visible = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial.visible = ( outlineParameters.visible !== undefined ) ? outlineParameters.visible : true;\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.transparent = ( outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0 ) ? true : originalMaterial.transparent;\n\n\t\t\t\tif ( outlineParameters.keepAlive !== undefined ) cache[ originalMaterial.uuid ].keepAlive = outlineParameters.keepAlive;\n\n\t\t\t} else {\n\n\t\t\t\tmaterial.transparent = originalMaterial.transparent;\n\t\t\t\tmaterial.visible = originalMaterial.visible;\n\n\t\t\t}\n\n\t\t\tif ( originalMaterial.wireframe === true || originalMaterial.depthTest === false ) material.visible = false;\n\n\t\t\tif ( originalMaterial.clippingPlanes ) {\n\n\t\t\t\tmaterial.clipping = true;\n\n\t\t\t\tmaterial.clippingPlanes = originalMaterial.clippingPlanes;\n\t\t\t\tmaterial.clipIntersection = originalMaterial.clipIntersection;\n\t\t\t\tmaterial.clipShadows = originalMaterial.clipShadows;\n\n\t\t\t}\n\n\t\t\tmaterial.version = originalMaterial.version; // update outline material if necessary\n\n\t\t}\n\n\t\tfunction cleanupCache() {\n\n\t\t\tlet keys;\n\n\t\t\t// clear originalMaterials\n\t\t\tkeys = Object.keys( originalMaterials );\n\n\t\t\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\t\toriginalMaterials[ keys[ i ] ] = undefined;\n\n\t\t\t}\n\n\t\t\t// clear originalOnBeforeRenders\n\t\t\tkeys = Object.keys( originalOnBeforeRenders );\n\n\t\t\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\t\toriginalOnBeforeRenders[ keys[ i ] ] = undefined;\n\n\t\t\t}\n\n\t\t\t// remove unused outlineMaterial from cache\n\t\t\tkeys = Object.keys( cache );\n\n\t\t\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\t\tconst key = keys[ i ];\n\n\t\t\t\tif ( cache[ key ].used === false ) {\n\n\t\t\t\t\tcache[ key ].count ++;\n\n\t\t\t\t\tif ( cache[ key ].keepAlive === false && cache[ key ].count > removeThresholdCount ) {\n\n\t\t\t\t\t\tdelete cache[ key ];\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcache[ key ].used = false;\n\t\t\t\t\tcache[ key ].count = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * When using this effect, this method should be called instead of the\n\t\t * default {@link WebGLRenderer#render}.\n\t\t *\n\t\t * @param {Object3D} scene - The scene to render.\n\t\t * @param {Camera} camera - The camera.\n\t\t */\n\t\tthis.render = function ( scene, camera ) {\n\n\t\t\tif ( this.enabled === false ) {\n\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst currentAutoClear = renderer.autoClear;\n\t\t\trenderer.autoClear = this.autoClear;\n\n\t\t\trenderer.render( scene, camera );\n\n\t\t\trenderer.autoClear = currentAutoClear;\n\n\t\t\tthis.renderOutline( scene, camera );\n\n\t\t};\n\n\t\t/**\n\t\t * This method can be used to render outlines in VR.\n\t\t *\n\t\t * ```js\n\t\t * const effect = new OutlineEffect( renderer );\n\t\t * let renderingOutline = false;\n\t\t *\n\t\t * scene.onAfterRender = function () {\n\t\t *\n\t\t * \tif ( renderingOutline ) return;\n\t\t *\n\t\t * \trenderingOutline = true;\n\t\t * \teffect.renderOutline( scene, camera );\n\t\t * \trenderingOutline = false;\n\t\t * };\n\t\t *\n\t\t * function render() {\n\t\t * \trenderer.render( scene, camera );\n\t\t * }\n\t\t * ```\n\t\t *\n\t\t * @param {Object3D} scene - The scene to render.\n\t\t * @param {Camera} camera - The camera.\n\t\t */\n\t\tthis.renderOutline = function ( scene, camera ) {\n\n\t\t\tconst currentAutoClear = renderer.autoClear;\n\t\t\tconst currentSceneAutoUpdate = scene.matrixWorldAutoUpdate;\n\t\t\tconst currentSceneBackground = scene.background;\n\t\t\tconst currentShadowMapEnabled = renderer.shadowMap.enabled;\n\n\t\t\tscene.matrixWorldAutoUpdate = false;\n\t\t\tscene.background = null;\n\t\t\trenderer.autoClear = false;\n\t\t\trenderer.shadowMap.enabled = false;\n\n\t\t\tscene.traverse( setOutlineMaterial );\n\n\t\t\trenderer.render( scene, camera );\n\n\t\t\tscene.traverse( restoreOriginalMaterial );\n\n\t\t\tcleanupCache();\n\n\t\t\tscene.matrixWorldAutoUpdate = currentSceneAutoUpdate;\n\t\t\tscene.background = currentSceneBackground;\n\t\t\trenderer.autoClear = currentAutoClear;\n\t\t\trenderer.shadowMap.enabled = currentShadowMapEnabled;\n\n\t\t};\n\n\t\t/**\n\t\t * Resizes the effect.\n\t\t *\n\t\t * @param {number} width - The width of the effect in logical pixels.\n\t\t * @param {number} height - The height of the effect in logical pixels.\n\t\t */\n\t\tthis.setSize = function ( width, height ) {\n\n\t\t\trenderer.setSize( width, height );\n\n\t\t};\n\n\t}\n\n}\n\n/**\n * This type represents configuration settings of `OutlineEffect`.\n *\n * @typedef {Object} OutlineEffect~Options\n * @property {number} [defaultThickness=0.003] - The outline thickness.\n * @property {Array<number>} [defaultColor=[0,0,0]] - The outline color.\n * @property {number} [defaultAlpha=1] - The outline alpha value.\n * @property {boolean} [defaultKeepAlive=false] - Whether to keep alive cached internal materials or not.\n **/\n\n\nexport { OutlineEffect };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}