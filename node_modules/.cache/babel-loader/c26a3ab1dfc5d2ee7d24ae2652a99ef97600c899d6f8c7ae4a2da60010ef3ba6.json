{"ast":null,"code":"/**\n * @module SortUtils\n * @three_import import * as SortUtils from 'three/addons/utils/SortUtils.js';\n */\n\nconst POWER = 3;\nconst BIT_MAX = 32;\nconst BIN_BITS = 1 << POWER;\nconst BIN_SIZE = 1 << BIN_BITS;\nconst BIN_MAX = BIN_SIZE - 1;\nconst ITERATIONS = BIT_MAX / BIN_BITS;\nconst bins = new Array(ITERATIONS);\nconst bins_buffer = new ArrayBuffer((ITERATIONS + 1) * BIN_SIZE * 4);\nlet c = 0;\nfor (let i = 0; i < ITERATIONS + 1; i++) {\n  bins[i] = new Uint32Array(bins_buffer, c, BIN_SIZE);\n  c += BIN_SIZE * 4;\n}\nconst defaultGet = el => el;\n\n/**\n * Hybrid radix sort from.\n *\n * - {@link https://gist.github.com/sciecode/93ed864dd77c5c8803c6a86698d68dab}\n * - {@link https://github.com/mrdoob/three.js/pull/27202#issuecomment-1817640271}\n *\n * Expects unsigned 32b integer values.\n *\n * @function\n * @param {Array<Object>} arr - The array to sort.\n * @param {Object} opt - The options\n */\nexport const radixSort = (arr, opt) => {\n  const len = arr.length;\n  const options = opt || {};\n  const aux = options.aux || new arr.constructor(len);\n  const get = options.get || defaultGet;\n  const data = [arr, aux];\n  let compare, accumulate, recurse;\n  if (options.reversed) {\n    compare = (a, b) => a < b;\n    accumulate = bin => {\n      for (let j = BIN_SIZE - 2; j >= 0; j--) bin[j] += bin[j + 1];\n    };\n    recurse = (cache, depth, start) => {\n      let prev = 0;\n      for (let j = BIN_MAX; j >= 0; j--) {\n        const cur = cache[j],\n          diff = cur - prev;\n        if (diff != 0) {\n          if (diff > 32) radixSortBlock(depth + 1, start + prev, diff);else insertionSortBlock(depth + 1, start + prev, diff);\n          prev = cur;\n        }\n      }\n    };\n  } else {\n    compare = (a, b) => a > b;\n    accumulate = bin => {\n      for (let j = 1; j < BIN_SIZE; j++) bin[j] += bin[j - 1];\n    };\n    recurse = (cache, depth, start) => {\n      let prev = 0;\n      for (let j = 0; j < BIN_SIZE; j++) {\n        const cur = cache[j],\n          diff = cur - prev;\n        if (diff != 0) {\n          if (diff > 32) radixSortBlock(depth + 1, start + prev, diff);else insertionSortBlock(depth + 1, start + prev, diff);\n          prev = cur;\n        }\n      }\n    };\n  }\n  const insertionSortBlock = (depth, start, len) => {\n    const a = data[depth & 1];\n    const b = data[depth + 1 & 1];\n    for (let j = start + 1; j < start + len; j++) {\n      const p = a[j],\n        t = get(p) >>> 0;\n      let i = j;\n      while (i > start) {\n        if (compare(get(a[i - 1]) >>> 0, t)) a[i] = a[--i];else break;\n      }\n      a[i] = p;\n    }\n    if ((depth & 1) == 1) {\n      for (let i = start; i < start + len; i++) b[i] = a[i];\n    }\n  };\n  const radixSortBlock = (depth, start, len) => {\n    const a = data[depth & 1];\n    const b = data[depth + 1 & 1];\n    const shift = 3 - depth << POWER;\n    const end = start + len;\n    const cache = bins[depth];\n    const bin = bins[depth + 1];\n    bin.fill(0);\n    for (let j = start; j < end; j++) bin[get(a[j]) >>> shift & BIN_MAX]++;\n    accumulate(bin);\n    cache.set(bin);\n    for (let j = end - 1; j >= start; j--) b[start + --bin[get(a[j]) >>> shift & BIN_MAX]] = a[j];\n    if (depth == ITERATIONS - 1) return;\n    recurse(cache, depth, start);\n  };\n  radixSortBlock(0, 0, len);\n};","map":{"version":3,"names":["POWER","BIT_MAX","BIN_BITS","BIN_SIZE","BIN_MAX","ITERATIONS","bins","Array","bins_buffer","ArrayBuffer","c","i","Uint32Array","defaultGet","el","radixSort","arr","opt","len","length","options","aux","constructor","get","data","compare","accumulate","recurse","reversed","a","b","bin","j","cache","depth","start","prev","cur","diff","radixSortBlock","insertionSortBlock","p","t","shift","end","fill","set"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/utils/SortUtils.js"],"sourcesContent":["\n/**\n * @module SortUtils\n * @three_import import * as SortUtils from 'three/addons/utils/SortUtils.js';\n */\n\nconst POWER = 3;\nconst BIT_MAX = 32;\nconst BIN_BITS = 1 << POWER;\nconst BIN_SIZE = 1 << BIN_BITS;\nconst BIN_MAX = BIN_SIZE - 1;\nconst ITERATIONS = BIT_MAX / BIN_BITS;\n\nconst bins = new Array( ITERATIONS );\nconst bins_buffer = new ArrayBuffer( ( ITERATIONS + 1 ) * BIN_SIZE * 4 );\n\nlet c = 0;\nfor ( let i = 0; i < ( ITERATIONS + 1 ); i ++ ) {\n\n\tbins[ i ] = new Uint32Array( bins_buffer, c, BIN_SIZE );\n\tc += BIN_SIZE * 4;\n\n}\n\nconst defaultGet = ( el ) => el;\n\n/**\n * Hybrid radix sort from.\n *\n * - {@link https://gist.github.com/sciecode/93ed864dd77c5c8803c6a86698d68dab}\n * - {@link https://github.com/mrdoob/three.js/pull/27202#issuecomment-1817640271}\n *\n * Expects unsigned 32b integer values.\n *\n * @function\n * @param {Array<Object>} arr - The array to sort.\n * @param {Object} opt - The options\n */\nexport const radixSort = ( arr, opt ) => {\n\n\tconst len = arr.length;\n\n\tconst options = opt || {};\n\tconst aux = options.aux || new arr.constructor( len );\n\tconst get = options.get || defaultGet;\n\n\tconst data = [ arr, aux ];\n\n\tlet compare, accumulate, recurse;\n\n\tif ( options.reversed ) {\n\n\t\tcompare = ( a, b ) => a < b;\n\t\taccumulate = ( bin ) => {\n\n\t\t\tfor ( let j = BIN_SIZE - 2; j >= 0; j -- )\n\t\t\t\tbin[ j ] += bin[ j + 1 ];\n\n\t\t};\n\n\t\trecurse = ( cache, depth, start ) => {\n\n\t\t\tlet prev = 0;\n\t\t\tfor ( let j = BIN_MAX; j >= 0; j -- ) {\n\n\t\t\t\tconst cur = cache[ j ], diff = cur - prev;\n\t\t\t\tif ( diff != 0 ) {\n\n\t\t\t\t\tif ( diff > 32 )\n\t\t\t\t\t\tradixSortBlock( depth + 1, start + prev, diff );\n\t\t\t\t\telse\n\t\t\t\t\t\tinsertionSortBlock( depth + 1, start + prev, diff );\n\t\t\t\t\tprev = cur;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t} else {\n\n\t\tcompare = ( a, b ) => a > b;\n\t\taccumulate = ( bin ) => {\n\n\t\t\tfor ( let j = 1; j < BIN_SIZE; j ++ )\n\t\t\t\tbin[ j ] += bin[ j - 1 ];\n\n\t\t};\n\n\t\trecurse = ( cache, depth, start ) => {\n\n\t\t\tlet prev = 0;\n\t\t\tfor ( let j = 0; j < BIN_SIZE; j ++ ) {\n\n\t\t\t\tconst cur = cache[ j ], diff = cur - prev;\n\t\t\t\tif ( diff != 0 ) {\n\n\t\t\t\t\tif ( diff > 32 )\n\t\t\t\t\t\tradixSortBlock( depth + 1, start + prev, diff );\n\t\t\t\t\telse\n\t\t\t\t\t\tinsertionSortBlock( depth + 1, start + prev, diff );\n\t\t\t\t\tprev = cur;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tconst insertionSortBlock = ( depth, start, len ) => {\n\n\t\tconst a = data[ depth & 1 ];\n\t\tconst b = data[ ( depth + 1 ) & 1 ];\n\n\t\tfor ( let j = start + 1; j < start + len; j ++ ) {\n\n\t\t\tconst p = a[ j ], t = get( p ) >>> 0;\n\t\t\tlet i = j;\n\t\t\twhile ( i > start ) {\n\n\t\t\t\tif ( compare( get( a[ i - 1 ] ) >>> 0, t ) )\n\t\t\t\t\ta[ i ] = a[ -- i ];\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\ta[ i ] = p;\n\n\t\t}\n\n\t\tif ( ( depth & 1 ) == 1 ) {\n\n\t\t\tfor ( let i = start; i < start + len; i ++ )\n\t\t\t\tb[ i ] = a[ i ];\n\n\t\t}\n\n\t};\n\n\tconst radixSortBlock = ( depth, start, len ) => {\n\n\t\tconst a = data[ depth & 1 ];\n\t\tconst b = data[ ( depth + 1 ) & 1 ];\n\n\t\tconst shift = ( 3 - depth ) << POWER;\n\t\tconst end = start + len;\n\n\t\tconst cache = bins[ depth ];\n\t\tconst bin = bins[ depth + 1 ];\n\n\t\tbin.fill( 0 );\n\n\t\tfor ( let j = start; j < end; j ++ )\n\t\t\tbin[ ( get( a[ j ] ) >>> shift ) & BIN_MAX ] ++;\n\n\t\taccumulate( bin );\n\n\t\tcache.set( bin );\n\n\t\tfor ( let j = end - 1; j >= start; j -- )\n\t\t\tb[ start + -- bin[ ( get( a[ j ] ) >>> shift ) & BIN_MAX ] ] = a[ j ];\n\n\t\tif ( depth == ITERATIONS - 1 ) return;\n\n\t\trecurse( cache, depth, start );\n\n\t};\n\n\tradixSortBlock( 0, 0, len );\n\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}