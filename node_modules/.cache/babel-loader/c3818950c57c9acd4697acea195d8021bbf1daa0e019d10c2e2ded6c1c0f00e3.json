{"ast":null,"code":"import { Vector3, Matrix4 } from 'three';\nconst inverseProjectionMatrix = new Matrix4();\n\n/**\n * Represents the frustum of a CSM instance.\n *\n * @three_import import { CSMFrustum } from 'three/addons/csm/CSMFrustum.js';\n */\nclass CSMFrustum {\n  /**\n   * Constructs a new CSM frustum.\n   *\n   * @param {CSMFrustum~Data} [data] - The CSM data.\n   */\n  constructor(data) {\n    data = data || {};\n\n    /**\n     * The zNear value. This value depends on whether the CSM\n     * is used with WebGL or WebGPU. Both API use different\n     * conventions for their projection matrices.\n     *\n     * @type {number}\n     */\n    this.zNear = data.webGL === true ? -1 : 0;\n\n    /**\n     * An object representing the vertices of the near and\n     * far plane in view space.\n     *\n     * @type {Object}\n     */\n    this.vertices = {\n      near: [new Vector3(), new Vector3(), new Vector3(), new Vector3()],\n      far: [new Vector3(), new Vector3(), new Vector3(), new Vector3()]\n    };\n    if (data.projectionMatrix !== undefined) {\n      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 10000);\n    }\n  }\n\n  /**\n   * Setups this CSM frustum from the given projection matrix and max far value.\n   *\n   * @param {Matrix4} projectionMatrix - The projection matrix, usually of the scene's camera.\n   * @param {number} maxFar - The maximum far value.\n   * @returns {Object} An object representing the vertices of the near and far plane in view space.\n   */\n  setFromProjectionMatrix(projectionMatrix, maxFar) {\n    const zNear = this.zNear;\n    const isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;\n    inverseProjectionMatrix.copy(projectionMatrix).invert();\n\n    // 3 --- 0  vertices.near/far order\n    // |     |\n    // 2 --- 1\n    // clip space spans from [-1, 1]\n\n    this.vertices.near[0].set(1, 1, zNear);\n    this.vertices.near[1].set(1, -1, zNear);\n    this.vertices.near[2].set(-1, -1, zNear);\n    this.vertices.near[3].set(-1, 1, zNear);\n    this.vertices.near.forEach(function (v) {\n      v.applyMatrix4(inverseProjectionMatrix);\n    });\n    this.vertices.far[0].set(1, 1, 1);\n    this.vertices.far[1].set(1, -1, 1);\n    this.vertices.far[2].set(-1, -1, 1);\n    this.vertices.far[3].set(-1, 1, 1);\n    this.vertices.far.forEach(function (v) {\n      v.applyMatrix4(inverseProjectionMatrix);\n      const absZ = Math.abs(v.z);\n      if (isOrthographic) {\n        v.z *= Math.min(maxFar / absZ, 1.0);\n      } else {\n        v.multiplyScalar(Math.min(maxFar / absZ, 1.0));\n      }\n    });\n    return this.vertices;\n  }\n\n  /**\n   * Splits the CSM frustum by the given array. The new CSM frustum are pushed into the given\n   * target array.\n   *\n   * @param {Array<number>} breaks - An array of numbers in the range `[0,1]` the defines how the\n   * CSM frustum should be split up.\n   * @param {Array<CSMFrustum>} target - The target array that holds the new CSM frustums.\n   */\n  split(breaks, target) {\n    while (breaks.length > target.length) {\n      target.push(new CSMFrustum());\n    }\n    target.length = breaks.length;\n    for (let i = 0; i < breaks.length; i++) {\n      const cascade = target[i];\n      if (i === 0) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].copy(this.vertices.near[j]);\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i - 1]);\n        }\n      }\n      if (i === breaks.length - 1) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].copy(this.vertices.far[j]);\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i]);\n        }\n      }\n    }\n  }\n\n  /**\n   * Transforms the given target CSM frustum into the different coordinate system defined by the\n   * given camera matrix.\n   *\n   * @param {Matrix4} cameraMatrix - The matrix that defines the new coordinate system.\n   * @param {CSMFrustum} target - The CSM to convert.\n   */\n  toSpace(cameraMatrix, target) {\n    for (let i = 0; i < 4; i++) {\n      target.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(cameraMatrix);\n      target.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(cameraMatrix);\n    }\n  }\n}\n\n/**\n * Constructor data of `CSMFrustum`.\n *\n * @typedef {Object} CSMFrustum~Data\n * @property {boolean} [webGL] - Whether this CSM frustum is used with WebGL or WebGPU.\n * @property {Matrix4} [projectionMatrix] - A projection matrix usually of the scene's camera.\n * @property {number} [maxFar] - The maximum far value.\n **/\n\nexport { CSMFrustum };","map":{"version":3,"names":["Vector3","Matrix4","inverseProjectionMatrix","CSMFrustum","constructor","data","zNear","webGL","vertices","near","far","projectionMatrix","undefined","setFromProjectionMatrix","maxFar","isOrthographic","elements","copy","invert","set","forEach","v","applyMatrix4","absZ","Math","abs","z","min","multiplyScalar","split","breaks","target","length","push","i","cascade","j","lerpVectors","toSpace","cameraMatrix"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/csm/CSMFrustum.js"],"sourcesContent":["import { Vector3, Matrix4 } from 'three';\n\nconst inverseProjectionMatrix = new Matrix4();\n\n/**\n * Represents the frustum of a CSM instance.\n *\n * @three_import import { CSMFrustum } from 'three/addons/csm/CSMFrustum.js';\n */\nclass CSMFrustum {\n\n\t/**\n\t * Constructs a new CSM frustum.\n\t *\n\t * @param {CSMFrustum~Data} [data] - The CSM data.\n\t */\n\tconstructor( data ) {\n\n\t\tdata = data || {};\n\n\t\t/**\n\t\t * The zNear value. This value depends on whether the CSM\n\t\t * is used with WebGL or WebGPU. Both API use different\n\t\t * conventions for their projection matrices.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.zNear = data.webGL === true ? - 1 : 0;\n\n\t\t/**\n\t\t * An object representing the vertices of the near and\n\t\t * far plane in view space.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.vertices = {\n\t\t\tnear: [\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3()\n\t\t\t],\n\t\t\tfar: [\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3()\n\t\t\t]\n\t\t};\n\n\t\tif ( data.projectionMatrix !== undefined ) {\n\n\t\t\tthis.setFromProjectionMatrix( data.projectionMatrix, data.maxFar || 10000 );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Setups this CSM frustum from the given projection matrix and max far value.\n\t *\n\t * @param {Matrix4} projectionMatrix - The projection matrix, usually of the scene's camera.\n\t * @param {number} maxFar - The maximum far value.\n\t * @returns {Object} An object representing the vertices of the near and far plane in view space.\n\t */\n\tsetFromProjectionMatrix( projectionMatrix, maxFar ) {\n\n\t\tconst zNear = this.zNear;\n\t\tconst isOrthographic = projectionMatrix.elements[ 2 * 4 + 3 ] === 0;\n\n\t\tinverseProjectionMatrix.copy( projectionMatrix ).invert();\n\n\t\t// 3 --- 0  vertices.near/far order\n\t\t// |     |\n\t\t// 2 --- 1\n\t\t// clip space spans from [-1, 1]\n\n\t\tthis.vertices.near[ 0 ].set( 1, 1, zNear );\n\t\tthis.vertices.near[ 1 ].set( 1, - 1, zNear );\n\t\tthis.vertices.near[ 2 ].set( - 1, - 1, zNear );\n\t\tthis.vertices.near[ 3 ].set( - 1, 1, zNear );\n\t\tthis.vertices.near.forEach( function ( v ) {\n\n\t\t\tv.applyMatrix4( inverseProjectionMatrix );\n\n\t\t} );\n\n\t\tthis.vertices.far[ 0 ].set( 1, 1, 1 );\n\t\tthis.vertices.far[ 1 ].set( 1, - 1, 1 );\n\t\tthis.vertices.far[ 2 ].set( - 1, - 1, 1 );\n\t\tthis.vertices.far[ 3 ].set( - 1, 1, 1 );\n\t\tthis.vertices.far.forEach( function ( v ) {\n\n\t\t\tv.applyMatrix4( inverseProjectionMatrix );\n\n\t\t\tconst absZ = Math.abs( v.z );\n\t\t\tif ( isOrthographic ) {\n\n\t\t\t\tv.z *= Math.min( maxFar / absZ, 1.0 );\n\n\t\t\t} else {\n\n\t\t\t\tv.multiplyScalar( Math.min( maxFar / absZ, 1.0 ) );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn this.vertices;\n\n\t}\n\n\t/**\n\t * Splits the CSM frustum by the given array. The new CSM frustum are pushed into the given\n\t * target array.\n\t *\n\t * @param {Array<number>} breaks - An array of numbers in the range `[0,1]` the defines how the\n\t * CSM frustum should be split up.\n\t * @param {Array<CSMFrustum>} target - The target array that holds the new CSM frustums.\n\t */\n\tsplit( breaks, target ) {\n\n\t\twhile ( breaks.length > target.length ) {\n\n\t\t\ttarget.push( new CSMFrustum() );\n\n\t\t}\n\n\t\ttarget.length = breaks.length;\n\n\t\tfor ( let i = 0; i < breaks.length; i ++ ) {\n\n\t\t\tconst cascade = target[ i ];\n\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\tcascade.vertices.near[ j ].copy( this.vertices.near[ j ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\tcascade.vertices.near[ j ].lerpVectors( this.vertices.near[ j ], this.vertices.far[ j ], breaks[ i - 1 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( i === breaks.length - 1 ) {\n\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\tcascade.vertices.far[ j ].copy( this.vertices.far[ j ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\tcascade.vertices.far[ j ].lerpVectors( this.vertices.near[ j ], this.vertices.far[ j ], breaks[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Transforms the given target CSM frustum into the different coordinate system defined by the\n\t * given camera matrix.\n\t *\n\t * @param {Matrix4} cameraMatrix - The matrix that defines the new coordinate system.\n\t * @param {CSMFrustum} target - The CSM to convert.\n\t */\n\ttoSpace( cameraMatrix, target ) {\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\ttarget.vertices.near[ i ]\n\t\t\t\t.copy( this.vertices.near[ i ] )\n\t\t\t\t.applyMatrix4( cameraMatrix );\n\n\t\t\ttarget.vertices.far[ i ]\n\t\t\t\t.copy( this.vertices.far[ i ] )\n\t\t\t\t.applyMatrix4( cameraMatrix );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Constructor data of `CSMFrustum`.\n *\n * @typedef {Object} CSMFrustum~Data\n * @property {boolean} [webGL] - Whether this CSM frustum is used with WebGL or WebGPU.\n * @property {Matrix4} [projectionMatrix] - A projection matrix usually of the scene's camera.\n * @property {number} [maxFar] - The maximum far value.\n **/\n\nexport { CSMFrustum };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}