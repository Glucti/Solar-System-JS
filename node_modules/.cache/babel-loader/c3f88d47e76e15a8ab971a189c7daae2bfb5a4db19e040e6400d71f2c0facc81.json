{"ast":null,"code":"import { Line3, Plane, Triangle, Vector3 } from 'three';\nconst Visible = 0;\nconst Deleted = 1;\nconst _v1 = new Vector3();\nconst _line3 = new Line3();\nconst _plane = new Plane();\nconst _closestPoint = new Vector3();\nconst _triangle = new Triangle();\n\n/**\n * Can be used to compute the convex hull in 3D space for a given set of points. It\n * is primarily intended for {@link ConvexGeometry}.\n *\n * This Quickhull 3D implementation is a port of [quickhull3d]{@link https://github.com/maurizzzio/quickhull3d/}\n * by Mauricio Poppe.\n *\n * @three_import import { ConvexHull } from 'three/addons/math/ConvexHull.js';\n */\nclass ConvexHull {\n  /**\n   * Constructs a new convex hull.\n   */\n  constructor() {\n    this.tolerance = -1;\n    this.faces = []; // the generated faces of the convex hull\n    this.newFaces = []; // this array holds the faces that are generated within a single iteration\n\n    // the vertex lists work as follows:\n    //\n    // let 'a' and 'b' be 'Face' instances\n    // let 'v' be points wrapped as instance of 'Vertex'\n    //\n    //     [v, v, ..., v, v, v, ...]\n    //      ^             ^\n    //      |             |\n    //  a.outside     b.outside\n    //\n    this.assigned = new VertexList();\n    this.unassigned = new VertexList();\n    this.vertices = []; // vertices of the hull (internal representation of given geometry data)\n  }\n\n  /**\n   * Computes to convex hull for the given array of points.\n   *\n   * @param {Array<Vector3>} points - The array of points in 3D space.\n   * @return {ConvexHull} A reference to this convex hull.\n   */\n  setFromPoints(points) {\n    // The algorithm needs at least four points.\n\n    if (points.length >= 4) {\n      this.makeEmpty();\n      for (let i = 0, l = points.length; i < l; i++) {\n        this.vertices.push(new VertexNode(points[i]));\n      }\n      this._compute();\n    }\n    return this;\n  }\n\n  /**\n   * Computes the convex hull of the given 3D object (including its descendants),\n   * accounting for the world transforms of both the 3D object and its descendants.\n   *\n   * @param {Object3D} object - The 3D object to compute the convex hull for.\n   * @return {ConvexHull} A reference to this convex hull.\n   */\n  setFromObject(object) {\n    const points = [];\n    object.updateMatrixWorld(true);\n    object.traverse(function (node) {\n      const geometry = node.geometry;\n      if (geometry !== undefined) {\n        const attribute = geometry.attributes.position;\n        if (attribute !== undefined) {\n          for (let i = 0, l = attribute.count; i < l; i++) {\n            const point = new Vector3();\n            point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\n            points.push(point);\n          }\n        }\n      }\n    });\n    return this.setFromPoints(points);\n  }\n\n  /**\n   * Returns `true` if the given point lies in the convex hull.\n   *\n   * @param {Vector3} point - The point to test.\n   * @return {boolean} Whether the given point lies in the convex hull or not.\n   */\n  containsPoint(point) {\n    const faces = this.faces;\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i];\n\n      // compute signed distance and check on what half space the point lies\n\n      if (face.distanceToPoint(point) > this.tolerance) return false;\n    }\n    return true;\n  }\n\n  /**\n   * Computes the intersections point of the given ray and this convex hull.\n   *\n   * @param {Ray} ray - The ray to test.\n   * @param {Vector3} target - The target vector that is used to store the method's result.\n   * @return {Vector3|null} The intersection point. Returns `null` if not intersection was detected.\n   */\n  intersectRay(ray, target) {\n    // based on \"Fast Ray-Convex Polyhedron Intersection\" by Eric Haines, GRAPHICS GEMS II\n\n    const faces = this.faces;\n    let tNear = -Infinity;\n    let tFar = Infinity;\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i];\n\n      // interpret faces as planes for the further computation\n\n      const vN = face.distanceToPoint(ray.origin);\n      const vD = face.normal.dot(ray.direction);\n\n      // if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n      // the ray is turned away or parallel to the plane, there is no intersection\n\n      if (vN > 0 && vD >= 0) return null;\n\n      // compute the distance from the ray’s origin to the intersection with the plane\n\n      const t = vD !== 0 ? -vN / vD : 0;\n\n      // only proceed if the distance is positive. a negative distance means the intersection point\n      // lies \"behind\" the origin\n\n      if (t <= 0) continue;\n\n      // now categorized plane as front-facing or back-facing\n\n      if (vD > 0) {\n        // plane faces away from the ray, so this plane is a back-face\n\n        tFar = Math.min(t, tFar);\n      } else {\n        // front-face\n\n        tNear = Math.max(t, tNear);\n      }\n      if (tNear > tFar) {\n        // if tNear ever is greater than tFar, the ray must miss the convex hull\n\n        return null;\n      }\n    }\n\n    // evaluate intersection point\n\n    // always try tNear first since its the closer intersection point\n\n    if (tNear !== -Infinity) {\n      ray.at(tNear, target);\n    } else {\n      ray.at(tFar, target);\n    }\n    return target;\n  }\n\n  /**\n   * Returns `true` if the given ray intersects with this convex hull.\n   *\n   * @param {Ray} ray - The ray to test.\n   * @return {boolean} Whether the given ray intersects with this convex hull or not.\n   */\n  intersectsRay(ray) {\n    return this.intersectRay(ray, _v1) !== null;\n  }\n\n  /**\n   * Makes the convex hull empty.\n   *\n   * @return {ConvexHull} A reference to this convex hull.\n   */\n  makeEmpty() {\n    this.faces = [];\n    this.vertices = [];\n    return this;\n  }\n\n  // private\n\n  /**\n   * Adds a vertex to the 'assigned' list of vertices and assigns it to the given face.\n   *\n   * @private\n   * @param {VertexNode} vertex - The vertex to add.\n   * @param {Face} face - The target face.\n   * @return {ConvexHull} A reference to this convex hull.\n   */\n  _addVertexToFace(vertex, face) {\n    vertex.face = face;\n    if (face.outside === null) {\n      this.assigned.append(vertex);\n    } else {\n      this.assigned.insertBefore(face.outside, vertex);\n    }\n    face.outside = vertex;\n    return this;\n  }\n\n  /**\n   * Removes a vertex from the 'assigned' list of vertices and from the given face.\n   * It also makes sure that the link from 'face' to the first vertex it sees in 'assigned'\n   * is linked correctly after the removal.\n   *\n   * @private\n   * @param {VertexNode} vertex - The vertex to remove.\n   * @param {Face} face - The target face.\n   * @return {ConvexHull} A reference to this convex hull.\n   */\n  _removeVertexFromFace(vertex, face) {\n    if (vertex === face.outside) {\n      // fix face.outside link\n\n      if (vertex.next !== null && vertex.next.face === face) {\n        // face has at least 2 outside vertices, move the 'outside' reference\n\n        face.outside = vertex.next;\n      } else {\n        // vertex was the only outside vertex that face had\n\n        face.outside = null;\n      }\n    }\n    this.assigned.remove(vertex);\n    return this;\n  }\n\n  /**\n   * Removes all the visible vertices that a given face is able to see which are stored in\n   * the 'assigned' vertex list.\n   *\n   * @private\n   * @param {Face} face - The target face.\n   * @return {VertexNode|undefined} A reference to this convex hull.\n   */\n  _removeAllVerticesFromFace(face) {\n    if (face.outside !== null) {\n      // reference to the first and last vertex of this face\n\n      const start = face.outside;\n      let end = face.outside;\n      while (end.next !== null && end.next.face === face) {\n        end = end.next;\n      }\n      this.assigned.removeSubList(start, end);\n\n      // fix references\n\n      start.prev = end.next = null;\n      face.outside = null;\n      return start;\n    }\n  }\n\n  /**\n   * Removes all the visible vertices that `face` is able to see.\n   *\n   * - If `absorbingFace` doesn't exist, then all the removed vertices will be added to the 'unassigned' vertex list.\n   * - If `absorbingFace` exists, then this method will assign all the vertices of 'face' that can see 'absorbingFace'.\n   * - If a vertex cannot see `absorbingFace`, it's added to the 'unassigned' vertex list.\n   *\n   * @private\n   * @param {Face} face - The given face.\n   * @param {Face} [absorbingFace] - An optional face that tries to absorb the vertices of the first face.\n   * @return {ConvexHull} A reference to this convex hull.\n   */\n  _deleteFaceVertices(face, absorbingFace) {\n    const faceVertices = this._removeAllVerticesFromFace(face);\n    if (faceVertices !== undefined) {\n      if (absorbingFace === undefined) {\n        // mark the vertices to be reassigned to some other face\n\n        this.unassigned.appendChain(faceVertices);\n      } else {\n        // if there's an absorbing face try to assign as many vertices as possible to it\n\n        let vertex = faceVertices;\n        do {\n          // we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n          // will be changed by upcoming method calls\n\n          const nextVertex = vertex.next;\n          const distance = absorbingFace.distanceToPoint(vertex.point);\n\n          // check if 'vertex' is able to see 'absorbingFace'\n\n          if (distance > this.tolerance) {\n            this._addVertexToFace(vertex, absorbingFace);\n          } else {\n            this.unassigned.append(vertex);\n          }\n\n          // now assign next vertex\n\n          vertex = nextVertex;\n        } while (vertex !== null);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Reassigns as many vertices as possible from the unassigned list to the new faces.\n   *\n   * @private\n   * @param {Array<Face>} newFaces - The new faces.\n   * @return {ConvexHull} A reference to this convex hull.\n   */\n  _resolveUnassignedPoints(newFaces) {\n    if (this.unassigned.isEmpty() === false) {\n      let vertex = this.unassigned.first();\n      do {\n        // buffer 'next' reference, see ._deleteFaceVertices()\n\n        const nextVertex = vertex.next;\n        let maxDistance = this.tolerance;\n        let maxFace = null;\n        for (let i = 0; i < newFaces.length; i++) {\n          const face = newFaces[i];\n          if (face.mark === Visible) {\n            const distance = face.distanceToPoint(vertex.point);\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              maxFace = face;\n            }\n            if (maxDistance > 1000 * this.tolerance) break;\n          }\n        }\n\n        // 'maxFace' can be null e.g. if there are identical vertices\n\n        if (maxFace !== null) {\n          this._addVertexToFace(vertex, maxFace);\n        }\n        vertex = nextVertex;\n      } while (vertex !== null);\n    }\n    return this;\n  }\n\n  /**\n   * Computes the extremes values (min/max vectors) which will be used to\n   * compute the initial hull.\n   *\n   * @private\n   * @return {Object} The extremes.\n   */\n  _computeExtremes() {\n    const min = new Vector3();\n    const max = new Vector3();\n    const minVertices = [];\n    const maxVertices = [];\n\n    // initially assume that the first vertex is the min/max\n\n    for (let i = 0; i < 3; i++) {\n      minVertices[i] = maxVertices[i] = this.vertices[0];\n    }\n    min.copy(this.vertices[0].point);\n    max.copy(this.vertices[0].point);\n\n    // compute the min/max vertex on all six directions\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = this.vertices[i];\n      const point = vertex.point;\n\n      // update the min coordinates\n\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) < min.getComponent(j)) {\n          min.setComponent(j, point.getComponent(j));\n          minVertices[j] = vertex;\n        }\n      }\n\n      // update the max coordinates\n\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) > max.getComponent(j)) {\n          max.setComponent(j, point.getComponent(j));\n          maxVertices[j] = vertex;\n        }\n      }\n    }\n\n    // use min/max vectors to compute an optimal epsilon\n\n    this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\n    return {\n      min: minVertices,\n      max: maxVertices\n    };\n  }\n\n  /**\n   * Computes the initial simplex assigning to its faces all the points that are\n   * candidates to form part of the hull.\n   *\n   * @private\n   * @return {ConvexHull} A reference to this convex hull.\n   */\n  _computeInitialHull() {\n    const vertices = this.vertices;\n    const extremes = this._computeExtremes();\n    const min = extremes.min;\n    const max = extremes.max;\n\n    // 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n    // (max.x - min.x)\n    // (max.y - min.y)\n    // (max.z - min.z)\n\n    let maxDistance = 0;\n    let index = 0;\n    for (let i = 0; i < 3; i++) {\n      const distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\n      if (distance > maxDistance) {\n        maxDistance = distance;\n        index = i;\n      }\n    }\n    const v0 = min[index];\n    const v1 = max[index];\n    let v2;\n    let v3;\n\n    // 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n    maxDistance = 0;\n    _line3.set(v0.point, v1.point);\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n      if (vertex !== v0 && vertex !== v1) {\n        _line3.closestPointToPoint(vertex.point, true, _closestPoint);\n        const distance = _closestPoint.distanceToSquared(vertex.point);\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          v2 = vertex;\n        }\n      }\n    }\n\n    // 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n    maxDistance = -1;\n    _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\n        const distance = Math.abs(_plane.distanceToPoint(vertex.point));\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          v3 = vertex;\n        }\n      }\n    }\n    const faces = [];\n    if (_plane.distanceToPoint(v3.point) < 0) {\n      // the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n\n      faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2));\n\n      // set the twin edge\n\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3;\n\n        // join face[ i ] i > 0, with the first face\n\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j));\n\n        // join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n        faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\n      }\n    } else {\n      // the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n\n      faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0));\n\n      // set the twin edge\n\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3;\n\n        // join face[ i ] i > 0, with the first face\n\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3));\n\n        // join face[ i ] with face[ i + 1 ]\n\n        faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));\n      }\n    }\n\n    // the initial hull is the tetrahedron\n\n    for (let i = 0; i < 4; i++) {\n      this.faces.push(faces[i]);\n    }\n\n    // initial assignment of vertices to the faces of the tetrahedron\n\n    for (let i = 0, l = vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\n        maxDistance = this.tolerance;\n        let maxFace = null;\n        for (let j = 0; j < 4; j++) {\n          const distance = this.faces[j].distanceToPoint(vertex.point);\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            maxFace = this.faces[j];\n          }\n        }\n        if (maxFace !== null) {\n          this._addVertexToFace(vertex, maxFace);\n        }\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Removes inactive (e.g. deleted) faces from the internal face list.\n   *\n   * @private\n   * @return {ConvexHull} A reference to this convex hull.\n   */\n  _reindexFaces() {\n    const activeFaces = [];\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      if (face.mark === Visible) {\n        activeFaces.push(face);\n      }\n    }\n    this.faces = activeFaces;\n    return this;\n  }\n\n  /**\n   * Finds the next vertex to create faces with the current hull.\n   *\n   * - Let the initial face be the first face existing in the 'assigned' vertex list.\n   * - If a face doesn't exist then return since there're no vertices left.\n   * - Otherwise for each vertex that face sees find the one furthest away from it.\n   *\n   * @private\n   * @return {?VertexNode} The next vertex to add.\n   */\n  _nextVertexToAdd() {\n    // if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n\n    if (this.assigned.isEmpty() === false) {\n      let eyeVertex,\n        maxDistance = 0;\n\n      // grab the first available face and start with the first visible vertex of that face\n\n      const eyeFace = this.assigned.first().face;\n      let vertex = eyeFace.outside;\n\n      // now calculate the farthest vertex that face can see\n\n      do {\n        const distance = eyeFace.distanceToPoint(vertex.point);\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          eyeVertex = vertex;\n        }\n        vertex = vertex.next;\n      } while (vertex !== null && vertex.face === eyeFace);\n      return eyeVertex;\n    }\n  }\n\n  /**\n   * Computes a chain of half edges in CCW order called the 'horizon'. For an edge\n   * to be part of the horizon it must join a face that can see 'eyePoint' and a face\n   * that cannot see 'eyePoint'.\n   *\n   * @private\n   * @param {Vector3} eyePoint - The 3D-coordinates of a point.\n   * @param {HalfEdge} crossEdge - The edge used to jump to the current face.\n   * @param {Face} face - The current face being tested.\n   * @param {Array<HalfEdge>} horizon - The edges that form part of the horizon in CCW order.\n   * @return {ConvexHull} A reference to this convex hull.\n   */\n  _computeHorizon(eyePoint, crossEdge, face, horizon) {\n    // moves face's vertices to the 'unassigned' vertex list\n\n    this._deleteFaceVertices(face);\n    face.mark = Deleted;\n    let edge;\n    if (crossEdge === null) {\n      edge = crossEdge = face.getEdge(0);\n    } else {\n      // start from the next edge since 'crossEdge' was already analyzed\n      // (actually 'crossEdge.twin' was the edge who called this method recursively)\n\n      edge = crossEdge.next;\n    }\n    do {\n      const twinEdge = edge.twin;\n      const oppositeFace = twinEdge.face;\n      if (oppositeFace.mark === Visible) {\n        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n          // the opposite face can see the vertex, so proceed with next edge\n\n          this._computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\n        } else {\n          // the opposite face can't see the vertex, so this edge is part of the horizon\n\n          horizon.push(edge);\n        }\n      }\n      edge = edge.next;\n    } while (edge !== crossEdge);\n    return this;\n  }\n\n  /**\n   * Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head'\n   * in CCW order. All the half edges are created in CCW order thus the face is always pointing\n   * outside the hull.\n   *\n   * @private\n   * @param {VertexNode} eyeVertex - The vertex that is added to the hull.\n   * @param {HalfEdge} horizonEdge - A single edge of the horizon.\n   * @return {HalfEdge} The half edge whose vertex is the eyeVertex.\n   */\n  _addAdjoiningFace(eyeVertex, horizonEdge) {\n    // all the half edges are created in ccw order thus the face is always pointing outside the hull\n\n    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\n    this.faces.push(face);\n\n    // join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n    face.getEdge(-1).setTwin(horizonEdge.twin);\n    return face.getEdge(0); // the half edge whose vertex is the eyeVertex\n  }\n\n  /**\n   * Adds 'horizon.length' faces to the hull, each face will be linked with the horizon\n   * opposite face and the face on the left/right.\n   *\n   * @private\n   * @param {VertexNode} eyeVertex - The vertex that is added to the hull.\n   * @param {Array<HalfEdge>} horizon - The horizon.\n   * @return {ConvexHull} A reference to this convex hull.\n   */\n  _addNewFaces(eyeVertex, horizon) {\n    this.newFaces = [];\n    let firstSideEdge = null;\n    let previousSideEdge = null;\n    for (let i = 0; i < horizon.length; i++) {\n      const horizonEdge = horizon[i];\n\n      // returns the right side edge\n\n      const sideEdge = this._addAdjoiningFace(eyeVertex, horizonEdge);\n      if (firstSideEdge === null) {\n        firstSideEdge = sideEdge;\n      } else {\n        // joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n\n        sideEdge.next.setTwin(previousSideEdge);\n      }\n      this.newFaces.push(sideEdge.face);\n      previousSideEdge = sideEdge;\n    }\n\n    // perform final join of new faces\n\n    firstSideEdge.next.setTwin(previousSideEdge);\n    return this;\n  }\n\n  /**\n   * Adds a vertex to the hull with the following algorithm:\n   *\n   * - Compute the 'horizon' which is a chain of half edges. For an edge to belong to this group\n   * it must be the edge connecting a face that can see 'eyeVertex' and a face which cannot see 'eyeVertex'.\n   * - All the faces that can see 'eyeVertex' have its visible vertices removed from the assigned vertex list.\n   * - A new set of faces is created with each edge of the 'horizon' and 'eyeVertex'. Each face is connected\n   * with the opposite horizon face and the face on the left/right.\n   * - The vertices removed from all the visible faces are assigned to the new faces if possible.\n   *\n   * @private\n   * @param {VertexNode} eyeVertex - The vertex to add.\n   * @return {ConvexHull} A reference to this convex hull.\n   */\n  _addVertexToHull(eyeVertex) {\n    const horizon = [];\n    this.unassigned.clear();\n\n    // remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n    this._removeVertexFromFace(eyeVertex, eyeVertex.face);\n    this._computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\n    this._addNewFaces(eyeVertex, horizon);\n\n    // reassign 'unassigned' vertices to the new faces\n\n    this._resolveUnassignedPoints(this.newFaces);\n    return this;\n  }\n\n  /**\n   * Cleans up internal properties after computing the convex hull.\n   *\n   * @private\n   * @return {ConvexHull} A reference to this convex hull.\n   */\n  _cleanup() {\n    this.assigned.clear();\n    this.unassigned.clear();\n    this.newFaces = [];\n    return this;\n  }\n\n  /**\n   * Starts the execution of the quick hull algorithm.\n   *\n   * @private\n   * @return {ConvexHull} A reference to this convex hull.\n   */\n  _compute() {\n    let vertex;\n    this._computeInitialHull();\n\n    // add all available vertices gradually to the hull\n\n    while ((vertex = this._nextVertexToAdd()) !== undefined) {\n      this._addVertexToHull(vertex);\n    }\n    this._reindexFaces();\n    this._cleanup();\n    return this;\n  }\n}\n\n/**\n * Represents a section bounded by a specific amount of half-edges.\n * The current implementation assumes that a face always consist of three edges.\n *\n * @private\n */\nclass Face {\n  /**\n   * Constructs a new face.\n   */\n  constructor() {\n    /**\n     * The normal vector of the face.\n     *\n     * @private\n     * @type {Vector3}\n     */\n    this.normal = new Vector3();\n\n    /**\n     * The midpoint or centroid of the face.\n     *\n     * @private\n     * @type {Vector3}\n     */\n    this.midpoint = new Vector3();\n\n    /**\n     * The area of the face.\n     *\n     * @private\n     * @type {number}\n     * @default 0\n     */\n    this.area = 0;\n\n    /**\n     * Signed distance from face to the origin.\n     *\n     * @private\n     * @type {number}\n     * @default 0\n     */\n    this.constant = 0;\n\n    /**\n     * Reference to a vertex in a vertex list this face can see.\n     *\n     * @private\n     * @type {?VertexNode}\n     * @default null\n     */\n    this.outside = null; // reference to a vertex in a vertex list this face can see\n    this.mark = Visible;\n\n    /**\n     * Reference to the base edge of a face. To retrieve all edges, you can use the\n     * `next` reference of the current edge.\n     *\n     * @private\n     * @type {?HalfEdge}\n     * @default null\n     */\n    this.edge = null;\n  }\n\n  /**\n   * Creates a face from the given vertex nodes.\n   *\n   * @private\n   * @param {VertexNode} a - The first vertex node.\n   * @param {VertexNode} b - The second vertex node.\n   * @param {VertexNode} c - The third vertex node.\n   * @return {Face} The created face.\n   */\n  static create(a, b, c) {\n    const face = new Face();\n    const e0 = new HalfEdge(a, face);\n    const e1 = new HalfEdge(b, face);\n    const e2 = new HalfEdge(c, face);\n\n    // join edges\n\n    e0.next = e2.prev = e1;\n    e1.next = e0.prev = e2;\n    e2.next = e1.prev = e0;\n\n    // main half edge reference\n\n    face.edge = e0;\n    return face.compute();\n  }\n\n  /**\n   * Returns an edge by the given index.\n   *\n   * @private\n   * @param {number} i - The edge index.\n   * @return {HalfEdge} The edge.\n   */\n  getEdge(i) {\n    let edge = this.edge;\n    while (i > 0) {\n      edge = edge.next;\n      i--;\n    }\n    while (i < 0) {\n      edge = edge.prev;\n      i++;\n    }\n    return edge;\n  }\n\n  /**\n   * Computes all properties of the face.\n   *\n   * @private\n   * @return {Face} A reference to this face.\n   */\n  compute() {\n    const a = this.edge.tail();\n    const b = this.edge.head();\n    const c = this.edge.next.head();\n    _triangle.set(a.point, b.point, c.point);\n    _triangle.getNormal(this.normal);\n    _triangle.getMidpoint(this.midpoint);\n    this.area = _triangle.getArea();\n    this.constant = this.normal.dot(this.midpoint);\n    return this;\n  }\n\n  /**\n   * Returns the signed distance from a given point to the plane representation of this face.\n   *\n   * @private\n   * @param {Vector3} point - The point to compute the distance to.\n   * @return {number} The distance.\n   */\n  distanceToPoint(point) {\n    return this.normal.dot(point) - this.constant;\n  }\n}\n\n/**\n * The basis for a half-edge data structure, also known as doubly\n * connected edge list (DCEL).\n *\n * @private\n */\nclass HalfEdge {\n  /**\n   * Constructs a new half edge.\n   *\n   * @param {VertexNode} vertex - A reference to its destination vertex.\n   * @param {Face} face - A reference to its face.\n   */\n  constructor(vertex, face) {\n    /**\n     * A reference to its destination vertex.\n     *\n     * @private\n     * @type {VertexNode}\n     */\n    this.vertex = vertex;\n\n    /**\n     * Reference to the previous half-edge of the same face.\n     *\n     * @private\n     * @type {?HalfEdge}\n     * @default null\n     */\n    this.prev = null;\n\n    /**\n     * Reference to the next half-edge of the same face.\n     *\n     * @private\n     * @type {?HalfEdge}\n     * @default null\n     */\n    this.next = null;\n\n    /**\n     * Reference to the twin half-edge to reach the opposite face.\n     *\n     * @private\n     * @type {?HalfEdge}\n     * @default null\n     */\n    this.twin = null;\n\n    /**\n     * A reference to its face.\n     *\n     * @private\n     * @type {Face}\n     */\n    this.face = face;\n  }\n\n  /**\n   * Returns the destination vertex.\n   *\n   * @private\n   * @return {VertexNode} The destination vertex.\n   */\n  head() {\n    return this.vertex;\n  }\n\n  /**\n   * Returns the origin vertex.\n   *\n   * @private\n   * @return {VertexNode} The destination vertex.\n   */\n  tail() {\n    return this.prev ? this.prev.vertex : null;\n  }\n\n  /**\n   * Returns the Euclidean length (straight-line length) of the edge.\n   *\n   * @private\n   * @return {number} The edge's length.\n   */\n  length() {\n    const head = this.head();\n    const tail = this.tail();\n    if (tail !== null) {\n      return tail.point.distanceTo(head.point);\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the square of the Euclidean length (straight-line length) of the edge.\n   *\n   * @private\n   * @return {number} The square of the edge's length.\n   */\n  lengthSquared() {\n    const head = this.head();\n    const tail = this.tail();\n    if (tail !== null) {\n      return tail.point.distanceToSquared(head.point);\n    }\n    return -1;\n  }\n\n  /**\n   * Sets the twin edge of this half-edge. It also ensures that the twin reference\n   * of the given half-edge is correctly set.\n   *\n   * @private\n   * @param {HalfEdge} edge - The twin edge to set.\n   * @return {HalfEdge} A reference to this edge.\n   */\n  setTwin(edge) {\n    this.twin = edge;\n    edge.twin = this;\n    return this;\n  }\n}\n\n/**\n * A vertex as a double linked list node.\n *\n * @private\n */\nclass VertexNode {\n  /**\n   * Constructs a new vertex node.\n   *\n   * @param {Vector3} point - A point in 3D space.\n   */\n  constructor(point) {\n    /**\n     * A point in 3D space.\n     *\n     * @private\n     * @type {Vector3}\n     */\n    this.point = point;\n\n    /**\n     * Reference to the previous vertex in the double linked list.\n     *\n     * @private\n     * @type {?VertexNode}\n     * @default null\n     */\n    this.prev = null;\n\n    /**\n     * Reference to the next vertex in the double linked list.\n     *\n     * @private\n     * @type {?VertexNode}\n     * @default null\n     */\n    this.next = null;\n\n    /**\n     * Reference to the face that is able to see this vertex.\n     *\n     * @private\n     * @type {?Face}\n     * @default null\n     */\n    this.face = null;\n  }\n}\n\n/**\n * A doubly linked list of vertices.\n *\n * @private\n */\nclass VertexList {\n  /**\n   * Constructs a new vertex list.\n   */\n  constructor() {\n    /**\n     * Reference to the first vertex of the linked list.\n     *\n     * @private\n     * @type {?VertexNode}\n     * @default null\n     */\n    this.head = null;\n\n    /**\n     * Reference to the last vertex of the linked list.\n     *\n     * @private\n     * @type {?VertexNode}\n     * @default null\n     */\n    this.tail = null;\n  }\n\n  /**\n   * Returns the head reference.\n   *\n   * @private\n   * @return {VertexNode} The head reference.\n   */\n  first() {\n    return this.head;\n  }\n\n  /**\n   * Returns the tail reference.\n   *\n   * @private\n   * @return {VertexNode} The tail reference.\n   */\n  last() {\n    return this.tail;\n  }\n\n  /**\n   * Clears the linked list.\n   *\n   * @private\n   * @return {VertexList} A reference to this vertex list.\n   */\n  clear() {\n    this.head = this.tail = null;\n    return this;\n  }\n\n  /**\n   * Inserts a vertex before a target vertex.\n   *\n   * @private\n   * @param {VertexNode} target - The target.\n   * @param {VertexNode} vertex - The vertex to insert.\n   * @return {VertexList} A reference to this vertex list.\n   */\n  insertBefore(target, vertex) {\n    vertex.prev = target.prev;\n    vertex.next = target;\n    if (vertex.prev === null) {\n      this.head = vertex;\n    } else {\n      vertex.prev.next = vertex;\n    }\n    target.prev = vertex;\n    return this;\n  }\n\n  /**\n   * Inserts a vertex after a target vertex.\n   *\n   * @private\n   * @param {VertexNode} target - The target.\n   * @param {VertexNode} vertex - The vertex to insert.\n   * @return {VertexList} A reference to this vertex list.\n   */\n  insertAfter(target, vertex) {\n    vertex.prev = target;\n    vertex.next = target.next;\n    if (vertex.next === null) {\n      this.tail = vertex;\n    } else {\n      vertex.next.prev = vertex;\n    }\n    target.next = vertex;\n    return this;\n  }\n\n  /**\n   * Appends a vertex to this vertex list.\n   *\n   * @private\n   * @param {VertexNode} vertex - The vertex to append.\n   * @return {VertexList} A reference to this vertex list.\n   */\n  append(vertex) {\n    if (this.head === null) {\n      this.head = vertex;\n    } else {\n      this.tail.next = vertex;\n    }\n    vertex.prev = this.tail;\n    vertex.next = null; // the tail has no subsequent vertex\n\n    this.tail = vertex;\n    return this;\n  }\n\n  /**\n   * Appends a chain of vertices where the given vertex is the head.\n   *\n   * @private\n   * @param {VertexNode} vertex - The head vertex of a chain of vertices.\n   * @return {VertexList} A reference to this vertex list.\n   */\n  appendChain(vertex) {\n    if (this.head === null) {\n      this.head = vertex;\n    } else {\n      this.tail.next = vertex;\n    }\n    vertex.prev = this.tail;\n\n    // ensure that the 'tail' reference points to the last vertex of the chain\n\n    while (vertex.next !== null) {\n      vertex = vertex.next;\n    }\n    this.tail = vertex;\n    return this;\n  }\n\n  /**\n   * Removes a vertex from the linked list.\n   *\n   * @private\n   * @param {VertexNode} vertex - The vertex to remove.\n   * @return {VertexList} A reference to this vertex list.\n   */\n  remove(vertex) {\n    if (vertex.prev === null) {\n      this.head = vertex.next;\n    } else {\n      vertex.prev.next = vertex.next;\n    }\n    if (vertex.next === null) {\n      this.tail = vertex.prev;\n    } else {\n      vertex.next.prev = vertex.prev;\n    }\n    return this;\n  }\n\n  /**\n   * Removes a sublist of vertices from the linked list.\n   *\n   * @private\n   * @param {VertexNode} a - The head of the sublist.\n   * @param {VertexNode} b - The tail of the sublist.\n   * @return {VertexList} A reference to this vertex list.\n   */\n  removeSubList(a, b) {\n    if (a.prev === null) {\n      this.head = b.next;\n    } else {\n      a.prev.next = b.next;\n    }\n    if (b.next === null) {\n      this.tail = a.prev;\n    } else {\n      b.next.prev = a.prev;\n    }\n    return this;\n  }\n\n  /**\n   * Returns `true` if the linked list is empty.\n   *\n   * @private\n   * @return {boolean} Whether the linked list is empty or not.\n   */\n  isEmpty() {\n    return this.head === null;\n  }\n}\nexport { ConvexHull, Face, HalfEdge, VertexNode, VertexList };","map":{"version":3,"names":["Line3","Plane","Triangle","Vector3","Visible","Deleted","_v1","_line3","_plane","_closestPoint","_triangle","ConvexHull","constructor","tolerance","faces","newFaces","assigned","VertexList","unassigned","vertices","setFromPoints","points","length","makeEmpty","i","l","push","VertexNode","_compute","setFromObject","object","updateMatrixWorld","traverse","node","geometry","undefined","attribute","attributes","position","count","point","fromBufferAttribute","applyMatrix4","matrixWorld","containsPoint","face","distanceToPoint","intersectRay","ray","target","tNear","Infinity","tFar","vN","origin","vD","normal","dot","direction","t","Math","min","max","at","intersectsRay","_addVertexToFace","vertex","outside","append","insertBefore","_removeVertexFromFace","next","remove","_removeAllVerticesFromFace","start","end","removeSubList","prev","_deleteFaceVertices","absorbingFace","faceVertices","appendChain","nextVertex","distance","_resolveUnassignedPoints","isEmpty","first","maxDistance","maxFace","mark","_computeExtremes","minVertices","maxVertices","copy","j","getComponent","setComponent","Number","EPSILON","abs","x","y","z","_computeInitialHull","extremes","index","v0","v1","v2","v3","set","closestPointToPoint","distanceToSquared","setFromCoplanarPoints","Face","create","getEdge","setTwin","_reindexFaces","activeFaces","_nextVertexToAdd","eyeVertex","eyeFace","_computeHorizon","eyePoint","crossEdge","horizon","edge","twinEdge","twin","oppositeFace","_addAdjoiningFace","horizonEdge","tail","head","_addNewFaces","firstSideEdge","previousSideEdge","sideEdge","_addVertexToHull","clear","_cleanup","midpoint","area","constant","a","b","c","e0","HalfEdge","e1","e2","compute","getNormal","getMidpoint","getArea","distanceTo","lengthSquared","last","insertAfter"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/math/ConvexHull.js"],"sourcesContent":["import {\n\tLine3,\n\tPlane,\n\tTriangle,\n\tVector3\n} from 'three';\n\nconst Visible = 0;\nconst Deleted = 1;\n\nconst _v1 = new Vector3();\nconst _line3 = new Line3();\nconst _plane = new Plane();\nconst _closestPoint = new Vector3();\nconst _triangle = new Triangle();\n\n/**\n * Can be used to compute the convex hull in 3D space for a given set of points. It\n * is primarily intended for {@link ConvexGeometry}.\n *\n * This Quickhull 3D implementation is a port of [quickhull3d]{@link https://github.com/maurizzzio/quickhull3d/}\n * by Mauricio Poppe.\n *\n * @three_import import { ConvexHull } from 'three/addons/math/ConvexHull.js';\n */\nclass ConvexHull {\n\n\t/**\n\t * Constructs a new convex hull.\n\t */\n\tconstructor() {\n\n\t\tthis.tolerance = - 1;\n\n\t\tthis.faces = []; // the generated faces of the convex hull\n\t\tthis.newFaces = []; // this array holds the faces that are generated within a single iteration\n\n\t\t// the vertex lists work as follows:\n\t\t//\n\t\t// let 'a' and 'b' be 'Face' instances\n\t\t// let 'v' be points wrapped as instance of 'Vertex'\n\t\t//\n\t\t//     [v, v, ..., v, v, v, ...]\n\t\t//      ^             ^\n\t\t//      |             |\n\t\t//  a.outside     b.outside\n\t\t//\n\t\tthis.assigned = new VertexList();\n\t\tthis.unassigned = new VertexList();\n\n\t\tthis.vertices = []; // vertices of the hull (internal representation of given geometry data)\n\n\t}\n\n\t/**\n\t * Computes to convex hull for the given array of points.\n\t *\n\t * @param {Array<Vector3>} points - The array of points in 3D space.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\tsetFromPoints( points ) {\n\n\t\t// The algorithm needs at least four points.\n\n\t\tif ( points.length >= 4 ) {\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tthis.vertices.push( new VertexNode( points[ i ] ) );\n\n\t\t\t}\n\n\t\t\tthis._compute();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes the convex hull of the given 3D object (including its descendants),\n\t * accounting for the world transforms of both the 3D object and its descendants.\n\t *\n\t * @param {Object3D} object - The 3D object to compute the convex hull for.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\tsetFromObject( object ) {\n\n\t\tconst points = [];\n\n\t\tobject.updateMatrixWorld( true );\n\n\t\tobject.traverse( function ( node ) {\n\n\t\t\tconst geometry = node.geometry;\n\n\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\tconst attribute = geometry.attributes.position;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tfor ( let i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst point = new Vector3();\n\n\t\t\t\t\t\tpoint.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\tpoints.push( point );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn this.setFromPoints( points );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given point lies in the convex hull.\n\t *\n\t * @param {Vector3} point - The point to test.\n\t * @return {boolean} Whether the given point lies in the convex hull or not.\n\t */\n\tcontainsPoint( point ) {\n\n\t\tconst faces = this.faces;\n\n\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\n\t\t\t// compute signed distance and check on what half space the point lies\n\n\t\t\tif ( face.distanceToPoint( point ) > this.tolerance ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Computes the intersections point of the given ray and this convex hull.\n\t *\n\t * @param {Ray} ray - The ray to test.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3|null} The intersection point. Returns `null` if not intersection was detected.\n\t */\n\tintersectRay( ray, target ) {\n\n\t\t// based on \"Fast Ray-Convex Polyhedron Intersection\" by Eric Haines, GRAPHICS GEMS II\n\n\t\tconst faces = this.faces;\n\n\t\tlet tNear = - Infinity;\n\t\tlet tFar = Infinity;\n\n\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\n\t\t\t// interpret faces as planes for the further computation\n\n\t\t\tconst vN = face.distanceToPoint( ray.origin );\n\t\t\tconst vD = face.normal.dot( ray.direction );\n\n\t\t\t// if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n\t\t\t// the ray is turned away or parallel to the plane, there is no intersection\n\n\t\t\tif ( vN > 0 && vD >= 0 ) return null;\n\n\t\t\t// compute the distance from the ray’s origin to the intersection with the plane\n\n\t\t\tconst t = ( vD !== 0 ) ? ( - vN / vD ) : 0;\n\n\t\t\t// only proceed if the distance is positive. a negative distance means the intersection point\n\t\t\t// lies \"behind\" the origin\n\n\t\t\tif ( t <= 0 ) continue;\n\n\t\t\t// now categorized plane as front-facing or back-facing\n\n\t\t\tif ( vD > 0 ) {\n\n\t\t\t\t// plane faces away from the ray, so this plane is a back-face\n\n\t\t\t\ttFar = Math.min( t, tFar );\n\n\t\t\t} else {\n\n\t\t\t\t// front-face\n\n\t\t\t\ttNear = Math.max( t, tNear );\n\n\t\t\t}\n\n\t\t\tif ( tNear > tFar ) {\n\n\t\t\t\t// if tNear ever is greater than tFar, the ray must miss the convex hull\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// evaluate intersection point\n\n\t\t// always try tNear first since its the closer intersection point\n\n\t\tif ( tNear !== - Infinity ) {\n\n\t\t\tray.at( tNear, target );\n\n\t\t} else {\n\n\t\t\tray.at( tFar, target );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given ray intersects with this convex hull.\n\t *\n\t * @param {Ray} ray - The ray to test.\n\t * @return {boolean} Whether the given ray intersects with this convex hull or not.\n\t */\n\tintersectsRay( ray ) {\n\n\t\treturn this.intersectRay( ray, _v1 ) !== null;\n\n\t}\n\n\t/**\n\t * Makes the convex hull empty.\n\t *\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\tmakeEmpty() {\n\n\t\tthis.faces = [];\n\t\tthis.vertices = [];\n\n\t\treturn this;\n\n\t}\n\n\t// private\n\n\t/**\n\t * Adds a vertex to the 'assigned' list of vertices and assigns it to the given face.\n\t *\n\t * @private\n\t * @param {VertexNode} vertex - The vertex to add.\n\t * @param {Face} face - The target face.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_addVertexToFace( vertex, face ) {\n\n\t\tvertex.face = face;\n\n\t\tif ( face.outside === null ) {\n\n\t\t\tthis.assigned.append( vertex );\n\n\t\t} else {\n\n\t\t\tthis.assigned.insertBefore( face.outside, vertex );\n\n\t\t}\n\n\t\tface.outside = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Removes a vertex from the 'assigned' list of vertices and from the given face.\n\t * It also makes sure that the link from 'face' to the first vertex it sees in 'assigned'\n\t * is linked correctly after the removal.\n\t *\n\t * @private\n\t * @param {VertexNode} vertex - The vertex to remove.\n\t * @param {Face} face - The target face.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_removeVertexFromFace( vertex, face ) {\n\n\t\tif ( vertex === face.outside ) {\n\n\t\t\t// fix face.outside link\n\n\t\t\tif ( vertex.next !== null && vertex.next.face === face ) {\n\n\t\t\t\t// face has at least 2 outside vertices, move the 'outside' reference\n\n\t\t\t\tface.outside = vertex.next;\n\n\t\t\t} else {\n\n\t\t\t\t// vertex was the only outside vertex that face had\n\n\t\t\t\tface.outside = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.assigned.remove( vertex );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Removes all the visible vertices that a given face is able to see which are stored in\n\t * the 'assigned' vertex list.\n\t *\n\t * @private\n\t * @param {Face} face - The target face.\n\t * @return {VertexNode|undefined} A reference to this convex hull.\n\t */\n\t_removeAllVerticesFromFace( face ) {\n\n\t\tif ( face.outside !== null ) {\n\n\t\t\t// reference to the first and last vertex of this face\n\n\t\t\tconst start = face.outside;\n\t\t\tlet end = face.outside;\n\n\t\t\twhile ( end.next !== null && end.next.face === face ) {\n\n\t\t\t\tend = end.next;\n\n\t\t\t}\n\n\t\t\tthis.assigned.removeSubList( start, end );\n\n\t\t\t// fix references\n\n\t\t\tstart.prev = end.next = null;\n\t\t\tface.outside = null;\n\n\t\t\treturn start;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Removes all the visible vertices that `face` is able to see.\n\t *\n\t * - If `absorbingFace` doesn't exist, then all the removed vertices will be added to the 'unassigned' vertex list.\n\t * - If `absorbingFace` exists, then this method will assign all the vertices of 'face' that can see 'absorbingFace'.\n\t * - If a vertex cannot see `absorbingFace`, it's added to the 'unassigned' vertex list.\n\t *\n\t * @private\n\t * @param {Face} face - The given face.\n\t * @param {Face} [absorbingFace] - An optional face that tries to absorb the vertices of the first face.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_deleteFaceVertices( face, absorbingFace ) {\n\n\t\tconst faceVertices = this._removeAllVerticesFromFace( face );\n\n\t\tif ( faceVertices !== undefined ) {\n\n\t\t\tif ( absorbingFace === undefined ) {\n\n\t\t\t\t// mark the vertices to be reassigned to some other face\n\n\t\t\t\tthis.unassigned.appendChain( faceVertices );\n\n\n\t\t\t} else {\n\n\t\t\t\t// if there's an absorbing face try to assign as many vertices as possible to it\n\n\t\t\t\tlet vertex = faceVertices;\n\n\t\t\t\tdo {\n\n\t\t\t\t\t// we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n\t\t\t\t\t// will be changed by upcoming method calls\n\n\t\t\t\t\tconst nextVertex = vertex.next;\n\n\t\t\t\t\tconst distance = absorbingFace.distanceToPoint( vertex.point );\n\n\t\t\t\t\t// check if 'vertex' is able to see 'absorbingFace'\n\n\t\t\t\t\tif ( distance > this.tolerance ) {\n\n\t\t\t\t\t\tthis._addVertexToFace( vertex, absorbingFace );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.unassigned.append( vertex );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// now assign next vertex\n\n\t\t\t\t\tvertex = nextVertex;\n\n\t\t\t\t} while ( vertex !== null );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Reassigns as many vertices as possible from the unassigned list to the new faces.\n\t *\n\t * @private\n\t * @param {Array<Face>} newFaces - The new faces.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_resolveUnassignedPoints( newFaces ) {\n\n\t\tif ( this.unassigned.isEmpty() === false ) {\n\n\t\t\tlet vertex = this.unassigned.first();\n\n\t\t\tdo {\n\n\t\t\t\t// buffer 'next' reference, see ._deleteFaceVertices()\n\n\t\t\t\tconst nextVertex = vertex.next;\n\n\t\t\t\tlet maxDistance = this.tolerance;\n\n\t\t\t\tlet maxFace = null;\n\n\t\t\t\tfor ( let i = 0; i < newFaces.length; i ++ ) {\n\n\t\t\t\t\tconst face = newFaces[ i ];\n\n\t\t\t\t\tif ( face.mark === Visible ) {\n\n\t\t\t\t\t\tconst distance = face.distanceToPoint( vertex.point );\n\n\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\tmaxFace = face;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( maxDistance > 1000 * this.tolerance ) break;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// 'maxFace' can be null e.g. if there are identical vertices\n\n\t\t\t\tif ( maxFace !== null ) {\n\n\t\t\t\t\tthis._addVertexToFace( vertex, maxFace );\n\n\t\t\t\t}\n\n\t\t\t\tvertex = nextVertex;\n\n\t\t\t} while ( vertex !== null );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes the extremes values (min/max vectors) which will be used to\n\t * compute the initial hull.\n\t *\n\t * @private\n\t * @return {Object} The extremes.\n\t */\n\t_computeExtremes() {\n\n\t\tconst min = new Vector3();\n\t\tconst max = new Vector3();\n\n\t\tconst minVertices = [];\n\t\tconst maxVertices = [];\n\n\t\t// initially assume that the first vertex is the min/max\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tminVertices[ i ] = maxVertices[ i ] = this.vertices[ 0 ];\n\n\t\t}\n\n\t\tmin.copy( this.vertices[ 0 ].point );\n\t\tmax.copy( this.vertices[ 0 ].point );\n\n\t\t// compute the min/max vertex on all six directions\n\n\t\tfor ( let i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\tconst vertex = this.vertices[ i ];\n\t\t\tconst point = vertex.point;\n\n\t\t\t// update the min coordinates\n\n\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\tif ( point.getComponent( j ) < min.getComponent( j ) ) {\n\n\t\t\t\t\tmin.setComponent( j, point.getComponent( j ) );\n\t\t\t\t\tminVertices[ j ] = vertex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the max coordinates\n\n\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\tif ( point.getComponent( j ) > max.getComponent( j ) ) {\n\n\t\t\t\t\tmax.setComponent( j, point.getComponent( j ) );\n\t\t\t\t\tmaxVertices[ j ] = vertex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use min/max vectors to compute an optimal epsilon\n\n\t\tthis.tolerance = 3 * Number.EPSILON * (\n\t\t\tMath.max( Math.abs( min.x ), Math.abs( max.x ) ) +\n\t\t\tMath.max( Math.abs( min.y ), Math.abs( max.y ) ) +\n\t\t\tMath.max( Math.abs( min.z ), Math.abs( max.z ) )\n\t\t);\n\n\t\treturn { min: minVertices, max: maxVertices };\n\n\t}\n\n\t/**\n\t * Computes the initial simplex assigning to its faces all the points that are\n\t * candidates to form part of the hull.\n\t *\n\t * @private\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_computeInitialHull() {\n\n\t\tconst vertices = this.vertices;\n\t\tconst extremes = this._computeExtremes();\n\t\tconst min = extremes.min;\n\t\tconst max = extremes.max;\n\n\t\t// 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n\t\t// (max.x - min.x)\n\t\t// (max.y - min.y)\n\t\t// (max.z - min.z)\n\n\t\tlet maxDistance = 0;\n\t\tlet index = 0;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst distance = max[ i ].point.getComponent( i ) - min[ i ].point.getComponent( i );\n\n\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\tmaxDistance = distance;\n\t\t\t\tindex = i;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst v0 = min[ index ];\n\t\tconst v1 = max[ index ];\n\t\tlet v2;\n\t\tlet v3;\n\n\t\t// 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n\t\tmaxDistance = 0;\n\t\t_line3.set( v0.point, v1.point );\n\n\t\tfor ( let i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\tconst vertex = vertices[ i ];\n\n\t\t\tif ( vertex !== v0 && vertex !== v1 ) {\n\n\t\t\t\t_line3.closestPointToPoint( vertex.point, true, _closestPoint );\n\n\t\t\t\tconst distance = _closestPoint.distanceToSquared( vertex.point );\n\n\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\tv2 = vertex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n\t\tmaxDistance = - 1;\n\t\t_plane.setFromCoplanarPoints( v0.point, v1.point, v2.point );\n\n\t\tfor ( let i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\tconst vertex = vertices[ i ];\n\n\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 ) {\n\n\t\t\t\tconst distance = Math.abs( _plane.distanceToPoint( vertex.point ) );\n\n\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\tv3 = vertex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst faces = [];\n\n\t\tif ( _plane.distanceToPoint( v3.point ) < 0 ) {\n\n\t\t\t// the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n\n\t\t\tfaces.push(\n\t\t\t\tFace.create( v0, v1, v2 ),\n\t\t\t\tFace.create( v3, v1, v0 ),\n\t\t\t\tFace.create( v3, v2, v1 ),\n\t\t\t\tFace.create( v3, v0, v2 )\n\t\t\t);\n\n\t\t\t// set the twin edge\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst j = ( i + 1 ) % 3;\n\n\t\t\t\t// join face[ i ] i > 0, with the first face\n\n\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( j ) );\n\n\t\t\t\t// join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n\t\t\t\tfaces[ i + 1 ].getEdge( 1 ).setTwin( faces[ j + 1 ].getEdge( 0 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n\n\t\t\tfaces.push(\n\t\t\t\tFace.create( v0, v2, v1 ),\n\t\t\t\tFace.create( v3, v0, v1 ),\n\t\t\t\tFace.create( v3, v1, v2 ),\n\t\t\t\tFace.create( v3, v2, v0 )\n\t\t\t);\n\n\t\t\t// set the twin edge\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst j = ( i + 1 ) % 3;\n\n\t\t\t\t// join face[ i ] i > 0, with the first face\n\n\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( ( 3 - i ) % 3 ) );\n\n\t\t\t\t// join face[ i ] with face[ i + 1 ]\n\n\t\t\t\tfaces[ i + 1 ].getEdge( 0 ).setTwin( faces[ j + 1 ].getEdge( 1 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// the initial hull is the tetrahedron\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\tthis.faces.push( faces[ i ] );\n\n\t\t}\n\n\t\t// initial assignment of vertices to the faces of the tetrahedron\n\n\t\tfor ( let i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\tconst vertex = vertices[ i ];\n\n\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3 ) {\n\n\t\t\t\tmaxDistance = this.tolerance;\n\t\t\t\tlet maxFace = null;\n\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\tconst distance = this.faces[ j ].distanceToPoint( vertex.point );\n\n\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\tmaxFace = this.faces[ j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( maxFace !== null ) {\n\n\t\t\t\t\tthis._addVertexToFace( vertex, maxFace );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Removes inactive (e.g. deleted) faces from the internal face list.\n\t *\n\t * @private\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_reindexFaces() {\n\n\t\tconst activeFaces = [];\n\n\t\tfor ( let i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\tconst face = this.faces[ i ];\n\n\t\t\tif ( face.mark === Visible ) {\n\n\t\t\t\tactiveFaces.push( face );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.faces = activeFaces;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Finds the next vertex to create faces with the current hull.\n\t *\n\t * - Let the initial face be the first face existing in the 'assigned' vertex list.\n\t * - If a face doesn't exist then return since there're no vertices left.\n\t * - Otherwise for each vertex that face sees find the one furthest away from it.\n\t *\n\t * @private\n\t * @return {?VertexNode} The next vertex to add.\n\t */\n\t_nextVertexToAdd() {\n\n\t\t// if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n\n\t\tif ( this.assigned.isEmpty() === false ) {\n\n\t\t\tlet eyeVertex, maxDistance = 0;\n\n\t\t\t// grab the first available face and start with the first visible vertex of that face\n\n\t\t\tconst eyeFace = this.assigned.first().face;\n\t\t\tlet vertex = eyeFace.outside;\n\n\t\t\t// now calculate the farthest vertex that face can see\n\n\t\t\tdo {\n\n\t\t\t\tconst distance = eyeFace.distanceToPoint( vertex.point );\n\n\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\teyeVertex = vertex;\n\n\t\t\t\t}\n\n\t\t\t\tvertex = vertex.next;\n\n\t\t\t} while ( vertex !== null && vertex.face === eyeFace );\n\n\t\t\treturn eyeVertex;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Computes a chain of half edges in CCW order called the 'horizon'. For an edge\n\t * to be part of the horizon it must join a face that can see 'eyePoint' and a face\n\t * that cannot see 'eyePoint'.\n\t *\n\t * @private\n\t * @param {Vector3} eyePoint - The 3D-coordinates of a point.\n\t * @param {HalfEdge} crossEdge - The edge used to jump to the current face.\n\t * @param {Face} face - The current face being tested.\n\t * @param {Array<HalfEdge>} horizon - The edges that form part of the horizon in CCW order.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_computeHorizon( eyePoint, crossEdge, face, horizon ) {\n\n\t\t// moves face's vertices to the 'unassigned' vertex list\n\n\t\tthis._deleteFaceVertices( face );\n\n\t\tface.mark = Deleted;\n\n\t\tlet edge;\n\n\t\tif ( crossEdge === null ) {\n\n\t\t\tedge = crossEdge = face.getEdge( 0 );\n\n\t\t} else {\n\n\t\t\t// start from the next edge since 'crossEdge' was already analyzed\n\t\t\t// (actually 'crossEdge.twin' was the edge who called this method recursively)\n\n\t\t\tedge = crossEdge.next;\n\n\t\t}\n\n\t\tdo {\n\n\t\t\tconst twinEdge = edge.twin;\n\t\t\tconst oppositeFace = twinEdge.face;\n\n\t\t\tif ( oppositeFace.mark === Visible ) {\n\n\t\t\t\tif ( oppositeFace.distanceToPoint( eyePoint ) > this.tolerance ) {\n\n\t\t\t\t\t// the opposite face can see the vertex, so proceed with next edge\n\n\t\t\t\t\tthis._computeHorizon( eyePoint, twinEdge, oppositeFace, horizon );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// the opposite face can't see the vertex, so this edge is part of the horizon\n\n\t\t\t\t\thorizon.push( edge );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tedge = edge.next;\n\n\t\t} while ( edge !== crossEdge );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head'\n\t * in CCW order. All the half edges are created in CCW order thus the face is always pointing\n\t * outside the hull.\n\t *\n\t * @private\n\t * @param {VertexNode} eyeVertex - The vertex that is added to the hull.\n\t * @param {HalfEdge} horizonEdge - A single edge of the horizon.\n\t * @return {HalfEdge} The half edge whose vertex is the eyeVertex.\n\t */\n\t_addAdjoiningFace( eyeVertex, horizonEdge ) {\n\n\t\t// all the half edges are created in ccw order thus the face is always pointing outside the hull\n\n\t\tconst face = Face.create( eyeVertex, horizonEdge.tail(), horizonEdge.head() );\n\n\t\tthis.faces.push( face );\n\n\t\t// join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n\t\tface.getEdge( - 1 ).setTwin( horizonEdge.twin );\n\n\t\treturn face.getEdge( 0 ); // the half edge whose vertex is the eyeVertex\n\n\n\t}\n\n\t/**\n\t * Adds 'horizon.length' faces to the hull, each face will be linked with the horizon\n\t * opposite face and the face on the left/right.\n\t *\n\t * @private\n\t * @param {VertexNode} eyeVertex - The vertex that is added to the hull.\n\t * @param {Array<HalfEdge>} horizon - The horizon.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_addNewFaces( eyeVertex, horizon ) {\n\n\t\tthis.newFaces = [];\n\n\t\tlet firstSideEdge = null;\n\t\tlet previousSideEdge = null;\n\n\t\tfor ( let i = 0; i < horizon.length; i ++ ) {\n\n\t\t\tconst horizonEdge = horizon[ i ];\n\n\t\t\t// returns the right side edge\n\n\t\t\tconst sideEdge = this._addAdjoiningFace( eyeVertex, horizonEdge );\n\n\t\t\tif ( firstSideEdge === null ) {\n\n\t\t\t\tfirstSideEdge = sideEdge;\n\n\t\t\t} else {\n\n\t\t\t\t// joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n\n\t\t\t\tsideEdge.next.setTwin( previousSideEdge );\n\n\t\t\t}\n\n\t\t\tthis.newFaces.push( sideEdge.face );\n\t\t\tpreviousSideEdge = sideEdge;\n\n\t\t}\n\n\t\t// perform final join of new faces\n\n\t\tfirstSideEdge.next.setTwin( previousSideEdge );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds a vertex to the hull with the following algorithm:\n\t *\n\t * - Compute the 'horizon' which is a chain of half edges. For an edge to belong to this group\n\t * it must be the edge connecting a face that can see 'eyeVertex' and a face which cannot see 'eyeVertex'.\n\t * - All the faces that can see 'eyeVertex' have its visible vertices removed from the assigned vertex list.\n\t * - A new set of faces is created with each edge of the 'horizon' and 'eyeVertex'. Each face is connected\n\t * with the opposite horizon face and the face on the left/right.\n\t * - The vertices removed from all the visible faces are assigned to the new faces if possible.\n\t *\n\t * @private\n\t * @param {VertexNode} eyeVertex - The vertex to add.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_addVertexToHull( eyeVertex ) {\n\n\t\tconst horizon = [];\n\n\t\tthis.unassigned.clear();\n\n\t\t// remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n\t\tthis._removeVertexFromFace( eyeVertex, eyeVertex.face );\n\n\t\tthis._computeHorizon( eyeVertex.point, null, eyeVertex.face, horizon );\n\n\t\tthis._addNewFaces( eyeVertex, horizon );\n\n\t\t// reassign 'unassigned' vertices to the new faces\n\n\t\tthis._resolveUnassignedPoints( this.newFaces );\n\n\t\treturn\tthis;\n\n\t}\n\n\t/**\n\t * Cleans up internal properties after computing the convex hull.\n\t *\n\t * @private\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_cleanup() {\n\n\t\tthis.assigned.clear();\n\t\tthis.unassigned.clear();\n\t\tthis.newFaces = [];\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Starts the execution of the quick hull algorithm.\n\t *\n\t * @private\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_compute() {\n\n\t\tlet vertex;\n\n\t\tthis._computeInitialHull();\n\n\t\t// add all available vertices gradually to the hull\n\n\t\twhile ( ( vertex = this._nextVertexToAdd() ) !== undefined ) {\n\n\t\t\tthis._addVertexToHull( vertex );\n\n\t\t}\n\n\t\tthis._reindexFaces();\n\n\t\tthis._cleanup();\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * Represents a section bounded by a specific amount of half-edges.\n * The current implementation assumes that a face always consist of three edges.\n *\n * @private\n */\nclass Face {\n\n\t/**\n\t * Constructs a new face.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * The normal vector of the face.\n\t\t *\n\t\t * @private\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.normal = new Vector3();\n\n\t\t/**\n\t\t * The midpoint or centroid of the face.\n\t\t *\n\t\t * @private\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.midpoint = new Vector3();\n\n\t\t/**\n\t\t * The area of the face.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.area = 0;\n\n\t\t/**\n\t\t * Signed distance from face to the origin.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.constant = 0;\n\n\t\t/**\n\t\t * Reference to a vertex in a vertex list this face can see.\n\t\t *\n\t\t * @private\n\t\t * @type {?VertexNode}\n\t\t * @default null\n\t\t */\n\t\tthis.outside = null; // reference to a vertex in a vertex list this face can see\n\t\tthis.mark = Visible;\n\n\t\t/**\n\t\t * Reference to the base edge of a face. To retrieve all edges, you can use the\n\t\t * `next` reference of the current edge.\n\t\t *\n\t\t * @private\n\t\t * @type {?HalfEdge}\n\t\t * @default null\n\t\t */\n\t\tthis.edge = null;\n\n\t}\n\n\t/**\n\t * Creates a face from the given vertex nodes.\n\t *\n\t * @private\n\t * @param {VertexNode} a - The first vertex node.\n\t * @param {VertexNode} b - The second vertex node.\n\t * @param {VertexNode} c - The third vertex node.\n\t * @return {Face} The created face.\n\t */\n\tstatic create( a, b, c ) {\n\n\t\tconst face = new Face();\n\n\t\tconst e0 = new HalfEdge( a, face );\n\t\tconst e1 = new HalfEdge( b, face );\n\t\tconst e2 = new HalfEdge( c, face );\n\n\t\t// join edges\n\n\t\te0.next = e2.prev = e1;\n\t\te1.next = e0.prev = e2;\n\t\te2.next = e1.prev = e0;\n\n\t\t// main half edge reference\n\n\t\tface.edge = e0;\n\n\t\treturn face.compute();\n\n\t}\n\n\t/**\n\t * Returns an edge by the given index.\n\t *\n\t * @private\n\t * @param {number} i - The edge index.\n\t * @return {HalfEdge} The edge.\n\t */\n\tgetEdge( i ) {\n\n\t\tlet edge = this.edge;\n\n\t\twhile ( i > 0 ) {\n\n\t\t\tedge = edge.next;\n\t\t\ti --;\n\n\t\t}\n\n\t\twhile ( i < 0 ) {\n\n\t\t\tedge = edge.prev;\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn edge;\n\n\t}\n\n\t/**\n\t * Computes all properties of the face.\n\t *\n\t * @private\n\t * @return {Face} A reference to this face.\n\t */\n\tcompute() {\n\n\t\tconst a = this.edge.tail();\n\t\tconst b = this.edge.head();\n\t\tconst c = this.edge.next.head();\n\n\t\t_triangle.set( a.point, b.point, c.point );\n\n\t\t_triangle.getNormal( this.normal );\n\t\t_triangle.getMidpoint( this.midpoint );\n\t\tthis.area = _triangle.getArea();\n\n\t\tthis.constant = this.normal.dot( this.midpoint );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the signed distance from a given point to the plane representation of this face.\n\t *\n\t * @private\n\t * @param {Vector3} point - The point to compute the distance to.\n\t * @return {number} The distance.\n\t */\n\tdistanceToPoint( point ) {\n\n\t\treturn this.normal.dot( point ) - this.constant;\n\n\t}\n\n}\n\n/**\n * The basis for a half-edge data structure, also known as doubly\n * connected edge list (DCEL).\n *\n * @private\n */\nclass HalfEdge {\n\n\t/**\n\t * Constructs a new half edge.\n\t *\n\t * @param {VertexNode} vertex - A reference to its destination vertex.\n\t * @param {Face} face - A reference to its face.\n\t */\n\tconstructor( vertex, face ) {\n\n\t\t/**\n\t\t * A reference to its destination vertex.\n\t\t *\n\t\t * @private\n\t\t * @type {VertexNode}\n\t\t */\n\t\tthis.vertex = vertex;\n\n\t\t/**\n\t\t * Reference to the previous half-edge of the same face.\n\t\t *\n\t\t * @private\n\t\t * @type {?HalfEdge}\n\t\t * @default null\n\t\t */\n\t\tthis.prev = null;\n\n\t\t/**\n\t\t * Reference to the next half-edge of the same face.\n\t\t *\n\t\t * @private\n\t\t * @type {?HalfEdge}\n\t\t * @default null\n\t\t */\n\t\tthis.next = null;\n\n\t\t/**\n\t\t * Reference to the twin half-edge to reach the opposite face.\n\t\t *\n\t\t * @private\n\t\t * @type {?HalfEdge}\n\t\t * @default null\n\t\t */\n\t\tthis.twin = null;\n\n\t\t/**\n\t\t * A reference to its face.\n\t\t *\n\t\t * @private\n\t\t * @type {Face}\n\t\t */\n\t\tthis.face = face;\n\n\t}\n\n\t/**\n\t * Returns the destination vertex.\n\t *\n\t * @private\n\t * @return {VertexNode} The destination vertex.\n\t */\n\thead() {\n\n\t\treturn this.vertex;\n\n\t}\n\n\t/**\n\t * Returns the origin vertex.\n\t *\n\t * @private\n\t * @return {VertexNode} The destination vertex.\n\t */\n\ttail() {\n\n\t\treturn this.prev ? this.prev.vertex : null;\n\n\t}\n\n\t/**\n\t * Returns the Euclidean length (straight-line length) of the edge.\n\t *\n\t * @private\n\t * @return {number} The edge's length.\n\t */\n\tlength() {\n\n\t\tconst head = this.head();\n\t\tconst tail = this.tail();\n\n\t\tif ( tail !== null ) {\n\n\t\t\treturn tail.point.distanceTo( head.point );\n\n\t\t}\n\n\t\treturn - 1;\n\n\t}\n\n\t/**\n\t * Returns the square of the Euclidean length (straight-line length) of the edge.\n\t *\n\t * @private\n\t * @return {number} The square of the edge's length.\n\t */\n\tlengthSquared() {\n\n\t\tconst head = this.head();\n\t\tconst tail = this.tail();\n\n\t\tif ( tail !== null ) {\n\n\t\t\treturn tail.point.distanceToSquared( head.point );\n\n\t\t}\n\n\t\treturn - 1;\n\n\t}\n\n\t/**\n\t * Sets the twin edge of this half-edge. It also ensures that the twin reference\n\t * of the given half-edge is correctly set.\n\t *\n\t * @private\n\t * @param {HalfEdge} edge - The twin edge to set.\n\t * @return {HalfEdge} A reference to this edge.\n\t */\n\tsetTwin( edge ) {\n\n\t\tthis.twin = edge;\n\t\tedge.twin = this;\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * A vertex as a double linked list node.\n *\n * @private\n */\nclass VertexNode {\n\n\t/**\n\t * Constructs a new vertex node.\n\t *\n\t * @param {Vector3} point - A point in 3D space.\n\t */\n\tconstructor( point ) {\n\n\t\t/**\n\t\t * A point in 3D space.\n\t\t *\n\t\t * @private\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.point = point;\n\n\t\t/**\n\t\t * Reference to the previous vertex in the double linked list.\n\t\t *\n\t\t * @private\n\t\t * @type {?VertexNode}\n\t\t * @default null\n\t\t */\n\t\tthis.prev = null;\n\n\t\t/**\n\t\t * Reference to the next vertex in the double linked list.\n\t\t *\n\t\t * @private\n\t\t * @type {?VertexNode}\n\t\t * @default null\n\t\t */\n\t\tthis.next = null;\n\n\t\t/**\n\t\t * Reference to the face that is able to see this vertex.\n\t\t *\n\t\t * @private\n\t\t * @type {?Face}\n\t\t * @default null\n\t\t */\n\t\tthis.face = null;\n\n\t}\n\n}\n\n/**\n * A doubly linked list of vertices.\n *\n * @private\n */\nclass VertexList {\n\n\t/**\n\t * Constructs a new vertex list.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * Reference to the first vertex of the linked list.\n\t\t *\n\t\t * @private\n\t\t * @type {?VertexNode}\n\t\t * @default null\n\t\t */\n\t\tthis.head = null;\n\n\t\t/**\n\t\t * Reference to the last vertex of the linked list.\n\t\t *\n\t\t * @private\n\t\t * @type {?VertexNode}\n\t\t * @default null\n\t\t */\n\t\tthis.tail = null;\n\n\t}\n\n\t/**\n\t * Returns the head reference.\n\t *\n\t * @private\n\t * @return {VertexNode} The head reference.\n\t */\n\tfirst() {\n\n\t\treturn this.head;\n\n\t}\n\n\t/**\n\t * Returns the tail reference.\n\t *\n\t * @private\n\t * @return {VertexNode} The tail reference.\n\t */\n\tlast() {\n\n\t\treturn this.tail;\n\n\t}\n\n\t/**\n\t * Clears the linked list.\n\t *\n\t * @private\n\t * @return {VertexList} A reference to this vertex list.\n\t */\n\tclear() {\n\n\t\tthis.head = this.tail = null;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Inserts a vertex before a target vertex.\n\t *\n\t * @private\n\t * @param {VertexNode} target - The target.\n\t * @param {VertexNode} vertex - The vertex to insert.\n\t * @return {VertexList} A reference to this vertex list.\n\t */\n\tinsertBefore( target, vertex ) {\n\n\t\tvertex.prev = target.prev;\n\t\tvertex.next = target;\n\n\t\tif ( vertex.prev === null ) {\n\n\t\t\tthis.head = vertex;\n\n\t\t} else {\n\n\t\t\tvertex.prev.next = vertex;\n\n\t\t}\n\n\t\ttarget.prev = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Inserts a vertex after a target vertex.\n\t *\n\t * @private\n\t * @param {VertexNode} target - The target.\n\t * @param {VertexNode} vertex - The vertex to insert.\n\t * @return {VertexList} A reference to this vertex list.\n\t */\n\tinsertAfter( target, vertex ) {\n\n\t\tvertex.prev = target;\n\t\tvertex.next = target.next;\n\n\t\tif ( vertex.next === null ) {\n\n\t\t\tthis.tail = vertex;\n\n\t\t} else {\n\n\t\t\tvertex.next.prev = vertex;\n\n\t\t}\n\n\t\ttarget.next = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Appends a vertex to this vertex list.\n\t *\n\t * @private\n\t * @param {VertexNode} vertex - The vertex to append.\n\t * @return {VertexList} A reference to this vertex list.\n\t */\n\tappend( vertex ) {\n\n\t\tif ( this.head === null ) {\n\n\t\t\tthis.head = vertex;\n\n\t\t} else {\n\n\t\t\tthis.tail.next = vertex;\n\n\t\t}\n\n\t\tvertex.prev = this.tail;\n\t\tvertex.next = null; // the tail has no subsequent vertex\n\n\t\tthis.tail = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Appends a chain of vertices where the given vertex is the head.\n\t *\n\t * @private\n\t * @param {VertexNode} vertex - The head vertex of a chain of vertices.\n\t * @return {VertexList} A reference to this vertex list.\n\t */\n\tappendChain( vertex ) {\n\n\t\tif ( this.head === null ) {\n\n\t\t\tthis.head = vertex;\n\n\t\t} else {\n\n\t\t\tthis.tail.next = vertex;\n\n\t\t}\n\n\t\tvertex.prev = this.tail;\n\n\t\t// ensure that the 'tail' reference points to the last vertex of the chain\n\n\t\twhile ( vertex.next !== null ) {\n\n\t\t\tvertex = vertex.next;\n\n\t\t}\n\n\t\tthis.tail = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Removes a vertex from the linked list.\n\t *\n\t * @private\n\t * @param {VertexNode} vertex - The vertex to remove.\n\t * @return {VertexList} A reference to this vertex list.\n\t */\n\tremove( vertex ) {\n\n\t\tif ( vertex.prev === null ) {\n\n\t\t\tthis.head = vertex.next;\n\n\t\t} else {\n\n\t\t\tvertex.prev.next = vertex.next;\n\n\t\t}\n\n\t\tif ( vertex.next === null ) {\n\n\t\t\tthis.tail = vertex.prev;\n\n\t\t} else {\n\n\t\t\tvertex.next.prev = vertex.prev;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Removes a sublist of vertices from the linked list.\n\t *\n\t * @private\n\t * @param {VertexNode} a - The head of the sublist.\n\t * @param {VertexNode} b - The tail of the sublist.\n\t * @return {VertexList} A reference to this vertex list.\n\t */\n\tremoveSubList( a, b ) {\n\n\t\tif ( a.prev === null ) {\n\n\t\t\tthis.head = b.next;\n\n\t\t} else {\n\n\t\t\ta.prev.next = b.next;\n\n\t\t}\n\n\t\tif ( b.next === null ) {\n\n\t\t\tthis.tail = a.prev;\n\n\t\t} else {\n\n\t\t\tb.next.prev = a.prev;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if the linked list is empty.\n\t *\n\t * @private\n\t * @return {boolean} Whether the linked list is empty or not.\n\t */\n\tisEmpty() {\n\n\t\treturn this.head === null;\n\n\t}\n\n}\n\nexport { ConvexHull, Face, HalfEdge, VertexNode, VertexList };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}