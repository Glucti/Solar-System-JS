{"ast":null,"code":"import { AdditiveBlending, BufferGeometry, Color, DoubleSide, FileLoader, Float32BufferAttribute, Group, Loader, LoaderUtils, Matrix4, Mesh, MeshPhongMaterial, TextureLoader } from 'three';\n\n/**\n * A loader for the 3DS format, based on lib3ds.\n *\n * Loads geometry with uv and materials basic properties with texture support.\n *\n * ```js\n * const loader = new TDSLoader();\n * loader.setResourcePath( 'models/3ds/portalgun/textures/' );\n * const object = await loader.loadAsync( 'models/3ds/portalgun/portalgun.3ds' );\n * scene.add( object );\n *\n * @augments Loader\n * @three_import import { TDSLoader } from 'three/addons/loaders/TDSLoader.js';\n */\nclass TDSLoader extends Loader {\n  /**\n   * Constructs a new 3DS loader.\n   *\n   * @param {LoadingManager} [manager] - The loading manager.\n   */\n  constructor(manager) {\n    super(manager);\n\n    /**\n     * Whether debug mode should be enabled or not.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    this.debug = false;\n\n    // internals\n\n    this.group = null;\n    this.materials = [];\n    this.meshes = [];\n  }\n\n  /**\n   * Starts loading from the given URL and passes the loaded 3DS asset\n   * to the `onLoad()` callback.\n   *\n   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n   * @param {function(Group)} onLoad - Executed when the loading process has been finished.\n   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n   * @param {onErrorCallback} onError - Executed when errors occur.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (data) {\n      try {\n        onLoad(scope.parse(data, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  /**\n   * Parses the given 3DS data and returns the resulting data.\n   *\n   * @param {ArrayBuffer} arraybuffer - The raw 3DS data as an array buffer.\n   * @param {string} path - The asset path.\n   * @return {Group} The parsed asset represented as a group.\n   */\n  parse(arraybuffer, path) {\n    this.group = new Group();\n    this.materials = [];\n    this.meshes = [];\n    this.readFile(arraybuffer, path);\n    for (let i = 0; i < this.meshes.length; i++) {\n      this.group.add(this.meshes[i]);\n    }\n    return this.group;\n  }\n\n  /**\n   * Decode file content to read 3ds data.\n   *\n   * @private\n   * @param {ArrayBuffer} arraybuffer - Arraybuffer data to be loaded.\n   * @param {string} path - Path for external resources.\n   */\n  readFile(arraybuffer, path) {\n    const data = new DataView(arraybuffer);\n    const chunk = new Chunk(data, 0, this.debugMessage);\n    if (chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC) {\n      let next = chunk.readChunk();\n      while (next) {\n        if (next.id === M3D_VERSION) {\n          const version = next.readDWord();\n          this.debugMessage('3DS file version: ' + version);\n        } else if (next.id === MDATA) {\n          this.readMeshData(next, path);\n        } else {\n          this.debugMessage('Unknown main chunk: ' + next.hexId);\n        }\n        next = chunk.readChunk();\n      }\n    }\n    this.debugMessage('Parsed ' + this.meshes.length + ' meshes');\n  }\n\n  /**\n   * Read mesh data chunk.\n   *\n   * @private\n   * @param {Chunk} chunk - to read mesh from\n   * @param {string} path - Path for external resources.\n   */\n  readMeshData(chunk, path) {\n    let next = chunk.readChunk();\n    while (next) {\n      if (next.id === MESH_VERSION) {\n        const version = +next.readDWord();\n        this.debugMessage('Mesh Version: ' + version);\n      } else if (next.id === MASTER_SCALE) {\n        const scale = next.readFloat();\n        this.debugMessage('Master scale: ' + scale);\n        this.group.scale.set(scale, scale, scale);\n      } else if (next.id === NAMED_OBJECT) {\n        this.debugMessage('Named Object');\n        this.readNamedObject(next);\n      } else if (next.id === MAT_ENTRY) {\n        this.debugMessage('Material');\n        this.readMaterialEntry(next, path);\n      } else {\n        this.debugMessage('Unknown MDATA chunk: ' + next.hexId);\n      }\n      next = chunk.readChunk();\n    }\n  }\n\n  /**\n   * Read named object chunk.\n   *\n   * @private\n   * @param {Chunk} chunk - Chunk in use.\n   */\n  readNamedObject(chunk) {\n    const name = chunk.readString();\n    let next = chunk.readChunk();\n    while (next) {\n      if (next.id === N_TRI_OBJECT) {\n        const mesh = this.readMesh(next);\n        mesh.name = name;\n        this.meshes.push(mesh);\n      } else {\n        this.debugMessage('Unknown named object chunk: ' + next.hexId);\n      }\n      next = chunk.readChunk();\n    }\n  }\n\n  /**\n   * Read material data chunk and add it to the material list.\n   *\n   * @private\n   * @param {Chunk} chunk - Chunk in use.\n   * @param {string} path - Path for external resources.\n   */\n  readMaterialEntry(chunk, path) {\n    let next = chunk.readChunk();\n    const material = new MeshPhongMaterial();\n    while (next) {\n      if (next.id === MAT_NAME) {\n        material.name = next.readString();\n        this.debugMessage('   Name: ' + material.name);\n      } else if (next.id === MAT_WIRE) {\n        this.debugMessage('   Wireframe');\n        material.wireframe = true;\n      } else if (next.id === MAT_WIRE_SIZE) {\n        const value = next.readByte();\n        material.wireframeLinewidth = value;\n        this.debugMessage('   Wireframe Thickness: ' + value);\n      } else if (next.id === MAT_TWO_SIDE) {\n        material.side = DoubleSide;\n        this.debugMessage('   DoubleSided');\n      } else if (next.id === MAT_ADDITIVE) {\n        this.debugMessage('   Additive Blending');\n        material.blending = AdditiveBlending;\n      } else if (next.id === MAT_DIFFUSE) {\n        this.debugMessage('   Diffuse Color');\n        material.color = this.readColor(next);\n      } else if (next.id === MAT_SPECULAR) {\n        this.debugMessage('   Specular Color');\n        material.specular = this.readColor(next);\n      } else if (next.id === MAT_AMBIENT) {\n        this.debugMessage('   Ambient color');\n        material.color = this.readColor(next);\n      } else if (next.id === MAT_SHININESS) {\n        const shininess = this.readPercentage(next);\n        material.shininess = shininess * 100;\n        this.debugMessage('   Shininess : ' + shininess);\n      } else if (next.id === MAT_TRANSPARENCY) {\n        const transparency = this.readPercentage(next);\n        material.opacity = 1 - transparency;\n        this.debugMessage('  Transparency : ' + transparency);\n        material.transparent = material.opacity < 1 ? true : false;\n      } else if (next.id === MAT_TEXMAP) {\n        this.debugMessage('   ColorMap');\n        material.map = this.readMap(next, path);\n      } else if (next.id === MAT_BUMPMAP) {\n        this.debugMessage('   BumpMap');\n        material.bumpMap = this.readMap(next, path);\n      } else if (next.id === MAT_OPACMAP) {\n        this.debugMessage('   OpacityMap');\n        material.alphaMap = this.readMap(next, path);\n      } else if (next.id === MAT_SPECMAP) {\n        this.debugMessage('   SpecularMap');\n        material.specularMap = this.readMap(next, path);\n      } else {\n        this.debugMessage('   Unknown material chunk: ' + next.hexId);\n      }\n      next = chunk.readChunk();\n    }\n    this.materials[material.name] = material;\n  }\n\n  /**\n   * Read mesh data chunk.\n   *\n   * @private\n   * @param {Chunk} chunk - Chunk in use.\n   * @return {Mesh} - The parsed mesh.\n   */\n  readMesh(chunk) {\n    let next = chunk.readChunk();\n    const geometry = new BufferGeometry();\n    const material = new MeshPhongMaterial();\n    const mesh = new Mesh(geometry, material);\n    mesh.name = 'mesh';\n    while (next) {\n      if (next.id === POINT_ARRAY) {\n        const points = next.readWord();\n        this.debugMessage('   Vertex: ' + points);\n\n        //BufferGeometry\n\n        const vertices = [];\n        for (let i = 0; i < points; i++) {\n          vertices.push(next.readFloat());\n          vertices.push(next.readFloat());\n          vertices.push(next.readFloat());\n        }\n        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n      } else if (next.id === FACE_ARRAY) {\n        this.readFaceArray(next, mesh);\n      } else if (next.id === TEX_VERTS) {\n        const texels = next.readWord();\n        this.debugMessage('   UV: ' + texels);\n\n        //BufferGeometry\n\n        const uvs = [];\n        for (let i = 0; i < texels; i++) {\n          uvs.push(next.readFloat());\n          uvs.push(next.readFloat());\n        }\n        geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n      } else if (next.id === MESH_MATRIX) {\n        this.debugMessage('   Transformation Matrix (TODO)');\n        const values = [];\n        for (let i = 0; i < 12; i++) {\n          values[i] = next.readFloat();\n        }\n        const matrix = new Matrix4();\n\n        //X Line\n        matrix.elements[0] = values[0];\n        matrix.elements[1] = values[6];\n        matrix.elements[2] = values[3];\n        matrix.elements[3] = values[9];\n\n        //Y Line\n        matrix.elements[4] = values[2];\n        matrix.elements[5] = values[8];\n        matrix.elements[6] = values[5];\n        matrix.elements[7] = values[11];\n\n        //Z Line\n        matrix.elements[8] = values[1];\n        matrix.elements[9] = values[7];\n        matrix.elements[10] = values[4];\n        matrix.elements[11] = values[10];\n\n        //W Line\n        matrix.elements[12] = 0;\n        matrix.elements[13] = 0;\n        matrix.elements[14] = 0;\n        matrix.elements[15] = 1;\n        matrix.transpose();\n        const inverse = new Matrix4();\n        inverse.copy(matrix).invert();\n        geometry.applyMatrix4(inverse);\n        matrix.decompose(mesh.position, mesh.quaternion, mesh.scale);\n      } else {\n        this.debugMessage('   Unknown mesh chunk: ' + next.hexId);\n      }\n      next = chunk.readChunk();\n    }\n    geometry.computeVertexNormals();\n    return mesh;\n  }\n\n  /**\n   * Read face array data chunk.\n   *\n   * @private\n   * @param {Chunk} chunk - Chunk in use.\n   * @param {Mesh} mesh - Mesh to be filled with the data read.\n   */\n  readFaceArray(chunk, mesh) {\n    const faces = chunk.readWord();\n    this.debugMessage('   Faces: ' + faces);\n    const index = [];\n    for (let i = 0; i < faces; ++i) {\n      index.push(chunk.readWord(), chunk.readWord(), chunk.readWord());\n      chunk.readWord(); // visibility\n    }\n    mesh.geometry.setIndex(index);\n\n    //The rest of the FACE_ARRAY chunk is subchunks\n\n    let materialIndex = 0;\n    let start = 0;\n    while (!chunk.endOfChunk) {\n      const subchunk = chunk.readChunk();\n      if (subchunk.id === MSH_MAT_GROUP) {\n        this.debugMessage('      Material Group');\n        const group = this.readMaterialGroup(subchunk);\n        const count = group.index.length * 3; // assuming successive indices\n\n        mesh.geometry.addGroup(start, count, materialIndex);\n        start += count;\n        materialIndex++;\n        const material = this.materials[group.name];\n        if (Array.isArray(mesh.material) === false) mesh.material = [];\n        if (material !== undefined) {\n          mesh.material.push(material);\n        }\n      } else {\n        this.debugMessage('      Unknown face array chunk: ' + subchunk.hexId);\n      }\n    }\n    if (mesh.material.length === 1) mesh.material = mesh.material[0]; // for backwards compatibility\n  }\n\n  /**\n   * Read texture map data chunk.\n   *\n   * @private\n   * @param {Chunk} chunk - Chunk in use.\n   * @param {string} path - Path for external resources.\n   * @return {Texture} Texture read from this data chunk.\n   */\n  readMap(chunk, path) {\n    let next = chunk.readChunk();\n    let texture = {};\n    const loader = new TextureLoader(this.manager);\n    loader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    while (next) {\n      if (next.id === MAT_MAPNAME) {\n        const name = next.readString();\n        texture = loader.load(name);\n        this.debugMessage('      File: ' + path + name);\n      } else if (next.id === MAT_MAP_UOFFSET) {\n        texture.offset.x = next.readFloat();\n        this.debugMessage('      OffsetX: ' + texture.offset.x);\n      } else if (next.id === MAT_MAP_VOFFSET) {\n        texture.offset.y = next.readFloat();\n        this.debugMessage('      OffsetY: ' + texture.offset.y);\n      } else if (next.id === MAT_MAP_USCALE) {\n        texture.repeat.x = next.readFloat();\n        this.debugMessage('      RepeatX: ' + texture.repeat.x);\n      } else if (next.id === MAT_MAP_VSCALE) {\n        texture.repeat.y = next.readFloat();\n        this.debugMessage('      RepeatY: ' + texture.repeat.y);\n      } else {\n        this.debugMessage('      Unknown map chunk: ' + next.hexId);\n      }\n      next = chunk.readChunk();\n    }\n    return texture;\n  }\n\n  /**\n   * Read material group data chunk.\n   *\n   * @private\n   * @param {Chunk} chunk - Chunk in use.\n   * @return {Object} Object with name and index of the object.\n   */\n  readMaterialGroup(chunk) {\n    const name = chunk.readString();\n    const numFaces = chunk.readWord();\n    this.debugMessage('         Name: ' + name);\n    this.debugMessage('         Faces: ' + numFaces);\n    const index = [];\n    for (let i = 0; i < numFaces; ++i) {\n      index.push(chunk.readWord());\n    }\n    return {\n      name: name,\n      index: index\n    };\n  }\n\n  /**\n   * Read a color value.\n   *\n   * @private\n   * @param {Chunk} chunk - Chunk.\n   * @return {Color} Color value read.\n   */\n  readColor(chunk) {\n    const subChunk = chunk.readChunk();\n    const color = new Color();\n    if (subChunk.id === COLOR_24 || subChunk.id === LIN_COLOR_24) {\n      const r = subChunk.readByte();\n      const g = subChunk.readByte();\n      const b = subChunk.readByte();\n      color.setRGB(r / 255, g / 255, b / 255);\n      this.debugMessage('      Color: ' + color.r + ', ' + color.g + ', ' + color.b);\n    } else if (subChunk.id === COLOR_F || subChunk.id === LIN_COLOR_F) {\n      const r = subChunk.readFloat();\n      const g = subChunk.readFloat();\n      const b = subChunk.readFloat();\n      color.setRGB(r, g, b);\n      this.debugMessage('      Color: ' + color.r + ', ' + color.g + ', ' + color.b);\n    } else {\n      this.debugMessage('      Unknown color chunk: ' + subChunk.hexId);\n    }\n    return color;\n  }\n\n  /**\n   * Read percentage value.\n   *\n   * @private\n   * @param {Chunk} chunk - Chunk to read data from.\n   * @return {number} Data read from the dataview.\n   */\n  readPercentage(chunk) {\n    const subChunk = chunk.readChunk();\n    switch (subChunk.id) {\n      case INT_PERCENTAGE:\n        return subChunk.readShort() / 100;\n        break;\n      case FLOAT_PERCENTAGE:\n        return subChunk.readFloat();\n        break;\n      default:\n        this.debugMessage('      Unknown percentage chunk: ' + subChunk.hexId);\n        return 0;\n    }\n  }\n\n  /**\n   * Print debug message to the console.\n   *\n   * Is controlled by a flag to show or hide debug messages.\n   *\n   * @private\n   * @param {Object} message - Debug message to print to the console.\n   */\n  debugMessage(message) {\n    if (this.debug) {\n      console.log(message);\n    }\n  }\n}\n\n/**\n * Read data/sub-chunks from chunk.\n *\n * @private\n */\nclass Chunk {\n  /**\n   * Create a new chunk\n   *\n   * @private\n   * @param {DataView} data - DataView to read from.\n   * @param {number} position - In data.\n   * @param {Function} debugMessage - Logging callback.\n   */\n  constructor(data, position, debugMessage) {\n    this.data = data;\n    // the offset to the begin of this chunk\n    this.offset = position;\n    // the current reading position\n    this.position = position;\n    this.debugMessage = debugMessage;\n    if (this.debugMessage instanceof Function) {\n      this.debugMessage = function () {};\n    }\n    this.id = this.readWord();\n    this.size = this.readDWord();\n    this.end = this.offset + this.size;\n    if (this.end > data.byteLength) {\n      this.debugMessage('Bad chunk size for chunk at ' + position);\n    }\n  }\n\n  /**\n   * Reads a sub cchunk.\n   *\n   * @private\n   * @return {Chunk | null} next sub chunk.\n   */\n  readChunk() {\n    if (this.endOfChunk) {\n      return null;\n    }\n    try {\n      const next = new Chunk(this.data, this.position, this.debugMessage);\n      this.position += next.size;\n      return next;\n    } catch (e) {\n      this.debugMessage('Unable to read chunk at ' + this.position);\n      return null;\n    }\n  }\n\n  /**\n   * Returns the ID of this chunk as Hex\n   *\n   * @private\n   * @return {string} hex-string of id\n   */\n  get hexId() {\n    return this.id.toString(16);\n  }\n  get endOfChunk() {\n    return this.position >= this.end;\n  }\n\n  /**\n   * Read byte value.\n   *\n   * @private\n   * @return {number} Data read from the dataview.\n   */\n  readByte() {\n    const v = this.data.getUint8(this.position, true);\n    this.position += 1;\n    return v;\n  }\n\n  /**\n   * Read 32 bit float value.\n   *\n   * @private\n   * @return {number} Data read from the dataview.\n   */\n  readFloat() {\n    try {\n      const v = this.data.getFloat32(this.position, true);\n      this.position += 4;\n      return v;\n    } catch (e) {\n      this.debugMessage(e + ' ' + this.position + ' ' + this.data.byteLength);\n      return 0;\n    }\n  }\n\n  /**\n   * Read 32 bit signed integer value.\n   *\n   * @private\n   * @return {number} Data read from the dataview.\n   */\n  readInt() {\n    const v = this.data.getInt32(this.position, true);\n    this.position += 4;\n    return v;\n  }\n\n  /**\n   * Read 16 bit signed integer value.\n   *\n   * @private\n   * @return {number} Data read from the dataview.\n   */\n  readShort() {\n    const v = this.data.getInt16(this.position, true);\n    this.position += 2;\n    return v;\n  }\n\n  /**\n   * Read 64 bit unsigned integer value.\n   *\n   * @private\n   * @return {number} Data read from the dataview.\n   */\n  readDWord() {\n    const v = this.data.getUint32(this.position, true);\n    this.position += 4;\n    return v;\n  }\n\n  /**\n   * Read 32 bit unsigned integer value.\n   *\n   * @private\n   * @return {number} Data read from the dataview.\n   */\n  readWord() {\n    const v = this.data.getUint16(this.position, true);\n    this.position += 2;\n    return v;\n  }\n\n  /**\n   * Read NULL terminated ASCII string value from chunk-pos.\n   *\n   * @private\n   * @return {string} Data read from the dataview.\n   */\n  readString() {\n    let s = '';\n    let c = this.readByte();\n    while (c) {\n      s += String.fromCharCode(c);\n      c = this.readByte();\n    }\n    return s;\n  }\n}\n\n// const NULL_CHUNK = 0x0000;\nconst M3DMAGIC = 0x4D4D;\n// const SMAGIC = 0x2D2D;\n// const LMAGIC = 0x2D3D;\nconst MLIBMAGIC = 0x3DAA;\n// const MATMAGIC = 0x3DFF;\nconst CMAGIC = 0xC23D;\nconst M3D_VERSION = 0x0002;\n// const M3D_KFVERSION = 0x0005;\nconst COLOR_F = 0x0010;\nconst COLOR_24 = 0x0011;\nconst LIN_COLOR_24 = 0x0012;\nconst LIN_COLOR_F = 0x0013;\nconst INT_PERCENTAGE = 0x0030;\nconst FLOAT_PERCENTAGE = 0x0031;\nconst MDATA = 0x3D3D;\nconst MESH_VERSION = 0x3D3E;\nconst MASTER_SCALE = 0x0100;\n// const LO_SHADOW_BIAS = 0x1400;\n// const HI_SHADOW_BIAS = 0x1410;\n// const SHADOW_MAP_SIZE = 0x1420;\n// const SHADOW_SAMPLES = 0x1430;\n// const SHADOW_RANGE = 0x1440;\n// const SHADOW_FILTER = 0x1450;\n// const RAY_BIAS = 0x1460;\n// const O_CONSTS = 0x1500;\n// const AMBIENT_LIGHT = 0x2100;\n// const BIT_MAP = 0x1100;\n// const SOLID_BGND = 0x1200;\n// const V_GRADIENT = 0x1300;\n// const USE_BIT_MAP = 0x1101;\n// const USE_SOLID_BGND = 0x1201;\n// const USE_V_GRADIENT = 0x1301;\n// const FOG = 0x2200;\n// const FOG_BGND = 0x2210;\n// const LAYER_FOG = 0x2302;\n// const DISTANCE_CUE = 0x2300;\n// const DCUE_BGND = 0x2310;\n// const USE_FOG = 0x2201;\n// const USE_LAYER_FOG = 0x2303;\n// const USE_DISTANCE_CUE = 0x2301;\nconst MAT_ENTRY = 0xAFFF;\nconst MAT_NAME = 0xA000;\nconst MAT_AMBIENT = 0xA010;\nconst MAT_DIFFUSE = 0xA020;\nconst MAT_SPECULAR = 0xA030;\nconst MAT_SHININESS = 0xA040;\n// const MAT_SHIN2PCT = 0xA041;\nconst MAT_TRANSPARENCY = 0xA050;\n// const MAT_XPFALL = 0xA052;\n// const MAT_USE_XPFALL = 0xA240;\n// const MAT_REFBLUR = 0xA053;\n// const MAT_SHADING = 0xA100;\n// const MAT_USE_REFBLUR = 0xA250;\n// const MAT_SELF_ILLUM = 0xA084;\nconst MAT_TWO_SIDE = 0xA081;\n// const MAT_DECAL = 0xA082;\nconst MAT_ADDITIVE = 0xA083;\nconst MAT_WIRE = 0xA085;\n// const MAT_FACEMAP = 0xA088;\n// const MAT_TRANSFALLOFF_IN = 0xA08A;\n// const MAT_PHONGSOFT = 0xA08C;\n// const MAT_WIREABS = 0xA08E;\nconst MAT_WIRE_SIZE = 0xA087;\nconst MAT_TEXMAP = 0xA200;\n// const MAT_SXP_TEXT_DATA = 0xA320;\n// const MAT_TEXMASK = 0xA33E;\n// const MAT_SXP_TEXTMASK_DATA = 0xA32A;\n// const MAT_TEX2MAP = 0xA33A;\n// const MAT_SXP_TEXT2_DATA = 0xA321;\n// const MAT_TEX2MASK = 0xA340;\n// const MAT_SXP_TEXT2MASK_DATA = 0xA32C;\nconst MAT_OPACMAP = 0xA210;\n// const MAT_SXP_OPAC_DATA = 0xA322;\n// const MAT_OPACMASK = 0xA342;\n// const MAT_SXP_OPACMASK_DATA = 0xA32E;\nconst MAT_BUMPMAP = 0xA230;\n// const MAT_SXP_BUMP_DATA = 0xA324;\n// const MAT_BUMPMASK = 0xA344;\n// const MAT_SXP_BUMPMASK_DATA = 0xA330;\nconst MAT_SPECMAP = 0xA204;\n// const MAT_SXP_SPEC_DATA = 0xA325;\n// const MAT_SPECMASK = 0xA348;\n// const MAT_SXP_SPECMASK_DATA = 0xA332;\n// const MAT_SHINMAP = 0xA33C;\n// const MAT_SXP_SHIN_DATA = 0xA326;\n// const MAT_SHINMASK = 0xA346;\n// const MAT_SXP_SHINMASK_DATA = 0xA334;\n// const MAT_SELFIMAP = 0xA33D;\n// const MAT_SXP_SELFI_DATA = 0xA328;\n// const MAT_SELFIMASK = 0xA34A;\n// const MAT_SXP_SELFIMASK_DATA = 0xA336;\n// const MAT_REFLMAP = 0xA220;\n// const MAT_REFLMASK = 0xA34C;\n// const MAT_SXP_REFLMASK_DATA = 0xA338;\n// const MAT_ACUBIC = 0xA310;\nconst MAT_MAPNAME = 0xA300;\n// const MAT_MAP_TILING = 0xA351;\n// const MAT_MAP_TEXBLUR = 0xA353;\nconst MAT_MAP_USCALE = 0xA354;\nconst MAT_MAP_VSCALE = 0xA356;\nconst MAT_MAP_UOFFSET = 0xA358;\nconst MAT_MAP_VOFFSET = 0xA35A;\n// const MAT_MAP_ANG = 0xA35C;\n// const MAT_MAP_COL1 = 0xA360;\n// const MAT_MAP_COL2 = 0xA362;\n// const MAT_MAP_RCOL = 0xA364;\n// const MAT_MAP_GCOL = 0xA366;\n// const MAT_MAP_BCOL = 0xA368;\nconst NAMED_OBJECT = 0x4000;\n// const N_DIRECT_LIGHT = 0x4600;\n// const DL_OFF = 0x4620;\n// const DL_OUTER_RANGE = 0x465A;\n// const DL_INNER_RANGE = 0x4659;\n// const DL_MULTIPLIER = 0x465B;\n// const DL_EXCLUDE = 0x4654;\n// const DL_ATTENUATE = 0x4625;\n// const DL_SPOTLIGHT = 0x4610;\n// const DL_SPOT_ROLL = 0x4656;\n// const DL_SHADOWED = 0x4630;\n// const DL_LOCAL_SHADOW2 = 0x4641;\n// const DL_SEE_CONE = 0x4650;\n// const DL_SPOT_RECTANGULAR = 0x4651;\n// const DL_SPOT_ASPECT = 0x4657;\n// const DL_SPOT_PROJECTOR = 0x4653;\n// const DL_SPOT_OVERSHOOT = 0x4652;\n// const DL_RAY_BIAS = 0x4658;\n// const DL_RAYSHAD = 0x4627;\n// const N_CAMERA = 0x4700;\n// const CAM_SEE_CONE = 0x4710;\n// const CAM_RANGES = 0x4720;\n// const OBJ_HIDDEN = 0x4010;\n// const OBJ_VIS_LOFTER = 0x4011;\n// const OBJ_DOESNT_CAST = 0x4012;\n// const OBJ_DONT_RECVSHADOW = 0x4017;\n// const OBJ_MATTE = 0x4013;\n// const OBJ_FAST = 0x4014;\n// const OBJ_PROCEDURAL = 0x4015;\n// const OBJ_FROZEN = 0x4016;\nconst N_TRI_OBJECT = 0x4100;\nconst POINT_ARRAY = 0x4110;\n// const POINT_FLAG_ARRAY = 0x4111;\nconst FACE_ARRAY = 0x4120;\nconst MSH_MAT_GROUP = 0x4130;\n// const SMOOTH_GROUP = 0x4150;\n// const MSH_BOXMAP = 0x4190;\nconst TEX_VERTS = 0x4140;\nconst MESH_MATRIX = 0x4160;\n// const MESH_COLOR = 0x4165;\n// const MESH_TEXTURE_INFO = 0x4170;\n// const KFDATA = 0xB000;\n// const KFHDR = 0xB00A;\n// const KFSEG = 0xB008;\n// const KFCURTIME = 0xB009;\n// const AMBIENT_NODE_TAG = 0xB001;\n// const OBJECT_NODE_TAG = 0xB002;\n// const CAMERA_NODE_TAG = 0xB003;\n// const TARGET_NODE_TAG = 0xB004;\n// const LIGHT_NODE_TAG = 0xB005;\n// const L_TARGET_NODE_TAG = 0xB006;\n// const SPOTLIGHT_NODE_TAG = 0xB007;\n// const NODE_ID = 0xB030;\n// const NODE_HDR = 0xB010;\n// const PIVOT = 0xB013;\n// const INSTANCE_NAME = 0xB011;\n// const MORPH_SMOOTH = 0xB015;\n// const BOUNDBOX = 0xB014;\n// const POS_TRACK_TAG = 0xB020;\n// const COL_TRACK_TAG = 0xB025;\n// const ROT_TRACK_TAG = 0xB021;\n// const SCL_TRACK_TAG = 0xB022;\n// const MORPH_TRACK_TAG = 0xB026;\n// const FOV_TRACK_TAG = 0xB023;\n// const ROLL_TRACK_TAG = 0xB024;\n// const HOT_TRACK_TAG = 0xB027;\n// const FALL_TRACK_TAG = 0xB028;\n// const HIDE_TRACK_TAG = 0xB029;\n// const POLY_2D = 0x5000;\n// const SHAPE_OK = 0x5010;\n// const SHAPE_NOT_OK = 0x5011;\n// const SHAPE_HOOK = 0x5020;\n// const PATH_3D = 0x6000;\n// const PATH_MATRIX = 0x6005;\n// const SHAPE_2D = 0x6010;\n// const M_SCALE = 0x6020;\n// const M_TWIST = 0x6030;\n// const M_TEETER = 0x6040;\n// const M_FIT = 0x6050;\n// const M_BEVEL = 0x6060;\n// const XZ_CURVE = 0x6070;\n// const YZ_CURVE = 0x6080;\n// const INTERPCT = 0x6090;\n// const DEFORM_LIMIT = 0x60A0;\n// const USE_CONTOUR = 0x6100;\n// const USE_TWEEN = 0x6110;\n// const USE_SCALE = 0x6120;\n// const USE_TWIST = 0x6130;\n// const USE_TEETER = 0x6140;\n// const USE_FIT = 0x6150;\n// const USE_BEVEL = 0x6160;\n// const DEFAULT_VIEW = 0x3000;\n// const VIEW_TOP = 0x3010;\n// const VIEW_BOTTOM = 0x3020;\n// const VIEW_LEFT = 0x3030;\n// const VIEW_RIGHT = 0x3040;\n// const VIEW_FRONT = 0x3050;\n// const VIEW_BACK = 0x3060;\n// const VIEW_USER = 0x3070;\n// const VIEW_CAMERA = 0x3080;\n// const VIEW_WINDOW = 0x3090;\n// const VIEWPORT_LAYOUT_OLD = 0x7000;\n// const VIEWPORT_DATA_OLD = 0x7010;\n// const VIEWPORT_LAYOUT = 0x7001;\n// const VIEWPORT_DATA = 0x7011;\n// const VIEWPORT_DATA_3 = 0x7012;\n// const VIEWPORT_SIZE = 0x7020;\n// const NETWORK_VIEW = 0x7030;\n\nexport { TDSLoader };","map":{"version":3,"names":["AdditiveBlending","BufferGeometry","Color","DoubleSide","FileLoader","Float32BufferAttribute","Group","Loader","LoaderUtils","Matrix4","Mesh","MeshPhongMaterial","TextureLoader","TDSLoader","constructor","manager","debug","group","materials","meshes","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","data","parse","e","console","error","itemError","arraybuffer","readFile","i","length","add","DataView","chunk","Chunk","debugMessage","id","MLIBMAGIC","CMAGIC","M3DMAGIC","next","readChunk","M3D_VERSION","version","readDWord","MDATA","readMeshData","hexId","MESH_VERSION","MASTER_SCALE","scale","readFloat","set","NAMED_OBJECT","readNamedObject","MAT_ENTRY","readMaterialEntry","name","readString","N_TRI_OBJECT","mesh","readMesh","push","material","MAT_NAME","MAT_WIRE","wireframe","MAT_WIRE_SIZE","value","readByte","wireframeLinewidth","MAT_TWO_SIDE","side","MAT_ADDITIVE","blending","MAT_DIFFUSE","color","readColor","MAT_SPECULAR","specular","MAT_AMBIENT","MAT_SHININESS","shininess","readPercentage","MAT_TRANSPARENCY","transparency","opacity","transparent","MAT_TEXMAP","map","readMap","MAT_BUMPMAP","bumpMap","MAT_OPACMAP","alphaMap","MAT_SPECMAP","specularMap","geometry","POINT_ARRAY","points","readWord","vertices","setAttribute","FACE_ARRAY","readFaceArray","TEX_VERTS","texels","uvs","MESH_MATRIX","values","matrix","elements","transpose","inverse","copy","invert","applyMatrix4","decompose","position","quaternion","computeVertexNormals","faces","index","setIndex","materialIndex","start","endOfChunk","subchunk","MSH_MAT_GROUP","readMaterialGroup","count","addGroup","Array","isArray","undefined","texture","resourcePath","setCrossOrigin","crossOrigin","MAT_MAPNAME","MAT_MAP_UOFFSET","offset","x","MAT_MAP_VOFFSET","y","MAT_MAP_USCALE","repeat","MAT_MAP_VSCALE","numFaces","subChunk","COLOR_24","LIN_COLOR_24","r","g","b","setRGB","COLOR_F","LIN_COLOR_F","INT_PERCENTAGE","readShort","FLOAT_PERCENTAGE","message","log","Function","size","end","byteLength","toString","v","getUint8","getFloat32","readInt","getInt32","getInt16","getUint32","getUint16","s","c","String","fromCharCode"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/loaders/TDSLoader.js"],"sourcesContent":["import {\n\tAdditiveBlending,\n\tBufferGeometry,\n\tColor,\n\tDoubleSide,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tGroup,\n\tLoader,\n\tLoaderUtils,\n\tMatrix4,\n\tMesh,\n\tMeshPhongMaterial,\n\tTextureLoader\n} from 'three';\n\n/**\n * A loader for the 3DS format, based on lib3ds.\n *\n * Loads geometry with uv and materials basic properties with texture support.\n *\n * ```js\n * const loader = new TDSLoader();\n * loader.setResourcePath( 'models/3ds/portalgun/textures/' );\n * const object = await loader.loadAsync( 'models/3ds/portalgun/portalgun.3ds' );\n * scene.add( object );\n *\n * @augments Loader\n * @three_import import { TDSLoader } from 'three/addons/loaders/TDSLoader.js';\n */\nclass TDSLoader extends Loader {\n\n\t/**\n\t * Constructs a new 3DS loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * Whether debug mode should be enabled or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.debug = false;\n\n\t\t// internals\n\n\t\tthis.group = null;\n\n\t\tthis.materials = [];\n\t\tthis.meshes = [];\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded 3DS asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(Group)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( data, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given 3DS data and returns the resulting data.\n\t *\n\t * @param {ArrayBuffer} arraybuffer - The raw 3DS data as an array buffer.\n\t * @param {string} path - The asset path.\n\t * @return {Group} The parsed asset represented as a group.\n\t */\n\tparse( arraybuffer, path ) {\n\n\t\tthis.group = new Group();\n\t\tthis.materials = [];\n\t\tthis.meshes = [];\n\n\t\tthis.readFile( arraybuffer, path );\n\n\t\tfor ( let i = 0; i < this.meshes.length; i ++ ) {\n\n\t\t\tthis.group.add( this.meshes[ i ] );\n\n\t\t}\n\n\t\treturn this.group;\n\n\t}\n\n\t/**\n\t * Decode file content to read 3ds data.\n\t *\n\t * @private\n\t * @param {ArrayBuffer} arraybuffer - Arraybuffer data to be loaded.\n\t * @param {string} path - Path for external resources.\n\t */\n\treadFile( arraybuffer, path ) {\n\n\t\tconst data = new DataView( arraybuffer );\n\t\tconst chunk = new Chunk( data, 0, this.debugMessage );\n\n\t\tif ( chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC ) {\n\n\t\t\tlet next = chunk.readChunk();\n\n\t\t\twhile ( next ) {\n\n\t\t\t\tif ( next.id === M3D_VERSION ) {\n\n\t\t\t\t\tconst version = next.readDWord();\n\t\t\t\t\tthis.debugMessage( '3DS file version: ' + version );\n\n\t\t\t\t} else if ( next.id === MDATA ) {\n\n\t\t\t\t\tthis.readMeshData( next, path );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.debugMessage( 'Unknown main chunk: ' + next.hexId );\n\n\t\t\t\t}\n\n\t\t\t\tnext = chunk.readChunk();\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.debugMessage( 'Parsed ' + this.meshes.length + ' meshes' );\n\n\t}\n\n\t/**\n\t * Read mesh data chunk.\n\t *\n\t * @private\n\t * @param {Chunk} chunk - to read mesh from\n\t * @param {string} path - Path for external resources.\n\t */\n\treadMeshData( chunk, path ) {\n\n\t\tlet next = chunk.readChunk();\n\n\t\twhile ( next ) {\n\n\t\t\tif ( next.id === MESH_VERSION ) {\n\n\t\t\t\tconst version = + next.readDWord();\n\t\t\t\tthis.debugMessage( 'Mesh Version: ' + version );\n\n\t\t\t} else if ( next.id === MASTER_SCALE ) {\n\n\t\t\t\tconst scale = next.readFloat();\n\t\t\t\tthis.debugMessage( 'Master scale: ' + scale );\n\t\t\t\tthis.group.scale.set( scale, scale, scale );\n\n\t\t\t} else if ( next.id === NAMED_OBJECT ) {\n\n\t\t\t\tthis.debugMessage( 'Named Object' );\n\t\t\t\tthis.readNamedObject( next );\n\n\t\t\t} else if ( next.id === MAT_ENTRY ) {\n\n\t\t\t\tthis.debugMessage( 'Material' );\n\t\t\t\tthis.readMaterialEntry( next, path );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( 'Unknown MDATA chunk: ' + next.hexId );\n\n\t\t\t}\n\n\t\t\tnext = chunk.readChunk();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Read named object chunk.\n\t *\n\t * @private\n\t * @param {Chunk} chunk - Chunk in use.\n\t */\n\treadNamedObject( chunk ) {\n\n\t\tconst name = chunk.readString();\n\n\t\tlet next = chunk.readChunk();\n\t\twhile ( next ) {\n\n\t\t\tif ( next.id === N_TRI_OBJECT ) {\n\n\t\t\t\tconst mesh = this.readMesh( next );\n\t\t\t\tmesh.name = name;\n\t\t\t\tthis.meshes.push( mesh );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( 'Unknown named object chunk: ' + next.hexId );\n\n\t\t\t}\n\n\t\t\tnext = chunk.readChunk( );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Read material data chunk and add it to the material list.\n\t *\n\t * @private\n\t * @param {Chunk} chunk - Chunk in use.\n\t * @param {string} path - Path for external resources.\n\t */\n\treadMaterialEntry( chunk, path ) {\n\n\t\tlet next = chunk.readChunk();\n\t\tconst material = new MeshPhongMaterial();\n\n\t\twhile ( next ) {\n\n\t\t\tif ( next.id === MAT_NAME ) {\n\n\t\t\t\tmaterial.name = next.readString();\n\t\t\t\tthis.debugMessage( '   Name: ' + material.name );\n\n\t\t\t} else if ( next.id === MAT_WIRE ) {\n\n\t\t\t\tthis.debugMessage( '   Wireframe' );\n\t\t\t\tmaterial.wireframe = true;\n\n\t\t\t} else if ( next.id === MAT_WIRE_SIZE ) {\n\n\t\t\t\tconst value = next.readByte();\n\t\t\t\tmaterial.wireframeLinewidth = value;\n\t\t\t\tthis.debugMessage( '   Wireframe Thickness: ' + value );\n\n\t\t\t} else if ( next.id === MAT_TWO_SIDE ) {\n\n\t\t\t\tmaterial.side = DoubleSide;\n\t\t\t\tthis.debugMessage( '   DoubleSided' );\n\n\t\t\t} else if ( next.id === MAT_ADDITIVE ) {\n\n\t\t\t\tthis.debugMessage( '   Additive Blending' );\n\t\t\t\tmaterial.blending = AdditiveBlending;\n\n\t\t\t} else if ( next.id === MAT_DIFFUSE ) {\n\n\t\t\t\tthis.debugMessage( '   Diffuse Color' );\n\t\t\t\tmaterial.color = this.readColor( next );\n\n\t\t\t} else if ( next.id === MAT_SPECULAR ) {\n\n\t\t\t\tthis.debugMessage( '   Specular Color' );\n\t\t\t\tmaterial.specular = this.readColor( next );\n\n\t\t\t} else if ( next.id === MAT_AMBIENT ) {\n\n\t\t\t\tthis.debugMessage( '   Ambient color' );\n\t\t\t\tmaterial.color = this.readColor( next );\n\n\t\t\t} else if ( next.id === MAT_SHININESS ) {\n\n\t\t\t\tconst shininess = this.readPercentage( next );\n\t\t\t\tmaterial.shininess = shininess * 100;\n\t\t\t\tthis.debugMessage( '   Shininess : ' + shininess );\n\n\t\t\t} else if ( next.id === MAT_TRANSPARENCY ) {\n\n\t\t\t\tconst transparency = this.readPercentage( next );\n\t\t\t\tmaterial.opacity = 1 - transparency;\n\t\t\t\tthis.debugMessage( '  Transparency : ' + transparency );\n\t\t\t\tmaterial.transparent = material.opacity < 1 ? true : false;\n\n\t\t\t} else if ( next.id === MAT_TEXMAP ) {\n\n\t\t\t\tthis.debugMessage( '   ColorMap' );\n\t\t\t\tmaterial.map = this.readMap( next, path );\n\n\t\t\t} else if ( next.id === MAT_BUMPMAP ) {\n\n\t\t\t\tthis.debugMessage( '   BumpMap' );\n\t\t\t\tmaterial.bumpMap = this.readMap( next, path );\n\n\t\t\t} else if ( next.id === MAT_OPACMAP ) {\n\n\t\t\t\tthis.debugMessage( '   OpacityMap' );\n\t\t\t\tmaterial.alphaMap = this.readMap( next, path );\n\n\t\t\t} else if ( next.id === MAT_SPECMAP ) {\n\n\t\t\t\tthis.debugMessage( '   SpecularMap' );\n\t\t\t\tmaterial.specularMap = this.readMap( next, path );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( '   Unknown material chunk: ' + next.hexId );\n\n\t\t\t}\n\n\t\t\tnext = chunk.readChunk();\n\n\t\t}\n\n\t\tthis.materials[ material.name ] = material;\n\n\t}\n\n\t/**\n\t * Read mesh data chunk.\n\t *\n\t * @private\n\t * @param {Chunk} chunk - Chunk in use.\n\t * @return {Mesh} - The parsed mesh.\n\t */\n\treadMesh( chunk ) {\n\n\t\tlet next = chunk.readChunk( );\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst material = new MeshPhongMaterial();\n\t\tconst mesh = new Mesh( geometry, material );\n\t\tmesh.name = 'mesh';\n\n\t\twhile ( next ) {\n\n\t\t\tif ( next.id === POINT_ARRAY ) {\n\n\t\t\t\tconst points = next.readWord( );\n\n\t\t\t\tthis.debugMessage( '   Vertex: ' + points );\n\n\t\t\t\t//BufferGeometry\n\n\t\t\t\tconst vertices = [];\n\n\t\t\t\tfor ( let i = 0; i < points; i ++ )\t\t{\n\n\t\t\t\t\tvertices.push( next.readFloat( ) );\n\t\t\t\t\tvertices.push( next.readFloat( ) );\n\t\t\t\t\tvertices.push( next.readFloat( ) );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t\t\t} else if ( next.id === FACE_ARRAY ) {\n\n\t\t\t\tthis.readFaceArray( next, mesh );\n\n\t\t\t} else if ( next.id === TEX_VERTS ) {\n\n\t\t\t\tconst texels = next.readWord( );\n\n\t\t\t\tthis.debugMessage( '   UV: ' + texels );\n\n\t\t\t\t//BufferGeometry\n\n\t\t\t\tconst uvs = [];\n\n\t\t\t\tfor ( let i = 0; i < texels; i ++ ) {\n\n\t\t\t\t\tuvs.push( next.readFloat( ) );\n\t\t\t\t\tuvs.push( next.readFloat( ) );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\n\t\t\t} else if ( next.id === MESH_MATRIX ) {\n\n\t\t\t\tthis.debugMessage( '   Transformation Matrix (TODO)' );\n\n\t\t\t\tconst values = [];\n\t\t\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\t\t\tvalues[ i ] = next.readFloat( );\n\n\t\t\t\t}\n\n\t\t\t\tconst matrix = new Matrix4();\n\n\t\t\t\t//X Line\n\t\t\t\tmatrix.elements[ 0 ] = values[ 0 ];\n\t\t\t\tmatrix.elements[ 1 ] = values[ 6 ];\n\t\t\t\tmatrix.elements[ 2 ] = values[ 3 ];\n\t\t\t\tmatrix.elements[ 3 ] = values[ 9 ];\n\n\t\t\t\t//Y Line\n\t\t\t\tmatrix.elements[ 4 ] = values[ 2 ];\n\t\t\t\tmatrix.elements[ 5 ] = values[ 8 ];\n\t\t\t\tmatrix.elements[ 6 ] = values[ 5 ];\n\t\t\t\tmatrix.elements[ 7 ] = values[ 11 ];\n\n\t\t\t\t//Z Line\n\t\t\t\tmatrix.elements[ 8 ] = values[ 1 ];\n\t\t\t\tmatrix.elements[ 9 ] = values[ 7 ];\n\t\t\t\tmatrix.elements[ 10 ] = values[ 4 ];\n\t\t\t\tmatrix.elements[ 11 ] = values[ 10 ];\n\n\t\t\t\t//W Line\n\t\t\t\tmatrix.elements[ 12 ] = 0;\n\t\t\t\tmatrix.elements[ 13 ] = 0;\n\t\t\t\tmatrix.elements[ 14 ] = 0;\n\t\t\t\tmatrix.elements[ 15 ] = 1;\n\n\t\t\t\tmatrix.transpose();\n\n\t\t\t\tconst inverse = new Matrix4();\n\t\t\t\tinverse.copy( matrix ).invert();\n\t\t\t\tgeometry.applyMatrix4( inverse );\n\n\t\t\t\tmatrix.decompose( mesh.position, mesh.quaternion, mesh.scale );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( '   Unknown mesh chunk: ' + next.hexId );\n\n\t\t\t}\n\n\t\t\tnext = chunk.readChunk( );\n\n\t\t}\n\n\t\tgeometry.computeVertexNormals();\n\n\t\treturn mesh;\n\n\t}\n\n\t/**\n\t * Read face array data chunk.\n\t *\n\t * @private\n\t * @param {Chunk} chunk - Chunk in use.\n\t * @param {Mesh} mesh - Mesh to be filled with the data read.\n\t */\n\treadFaceArray( chunk, mesh ) {\n\n\t\tconst faces = chunk.readWord( );\n\n\t\tthis.debugMessage( '   Faces: ' + faces );\n\n\t\tconst index = [];\n\n\t\tfor ( let i = 0; i < faces; ++ i ) {\n\n\t\t\tindex.push( chunk.readWord( ), chunk.readWord( ), chunk.readWord( ) );\n\n\t\t\tchunk.readWord( ); // visibility\n\n\t\t}\n\n\t\tmesh.geometry.setIndex( index );\n\n\t\t//The rest of the FACE_ARRAY chunk is subchunks\n\n\t\tlet materialIndex = 0;\n\t\tlet start = 0;\n\n\t\twhile ( ! chunk.endOfChunk ) {\n\n\t\t\tconst subchunk = chunk.readChunk( );\n\n\t\t\tif ( subchunk.id === MSH_MAT_GROUP ) {\n\n\t\t\t\tthis.debugMessage( '      Material Group' );\n\n\t\t\t\tconst group = this.readMaterialGroup( subchunk );\n\t\t\t\tconst count = group.index.length * 3; // assuming successive indices\n\n\t\t\t\tmesh.geometry.addGroup( start, count, materialIndex );\n\n\t\t\t\tstart += count;\n\t\t\t\tmaterialIndex ++;\n\n\t\t\t\tconst material = this.materials[ group.name ];\n\n\t\t\t\tif ( Array.isArray( mesh.material ) === false ) mesh.material = [];\n\n\t\t\t\tif ( material !== undefined )\t{\n\n\t\t\t\t\tmesh.material.push( material );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( '      Unknown face array chunk: ' + subchunk.hexId );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( mesh.material.length === 1 ) mesh.material = mesh.material[ 0 ]; // for backwards compatibility\n\n\t}\n\n\t/**\n\t * Read texture map data chunk.\n\t *\n\t * @private\n\t * @param {Chunk} chunk - Chunk in use.\n\t * @param {string} path - Path for external resources.\n\t * @return {Texture} Texture read from this data chunk.\n\t */\n\treadMap( chunk, path ) {\n\n\t\tlet next = chunk.readChunk( );\n\t\tlet texture = {};\n\n\t\tconst loader = new TextureLoader( this.manager );\n\t\tloader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\twhile ( next ) {\n\n\t\t\tif ( next.id === MAT_MAPNAME ) {\n\n\t\t\t\tconst name = next.readString();\n\t\t\t\ttexture = loader.load( name );\n\n\t\t\t\tthis.debugMessage( '      File: ' + path + name );\n\n\t\t\t} else if ( next.id === MAT_MAP_UOFFSET ) {\n\n\t\t\t\ttexture.offset.x = next.readFloat( );\n\t\t\t\tthis.debugMessage( '      OffsetX: ' + texture.offset.x );\n\n\t\t\t} else if ( next.id === MAT_MAP_VOFFSET ) {\n\n\t\t\t\ttexture.offset.y = next.readFloat( );\n\t\t\t\tthis.debugMessage( '      OffsetY: ' + texture.offset.y );\n\n\t\t\t} else if ( next.id === MAT_MAP_USCALE ) {\n\n\t\t\t\ttexture.repeat.x = next.readFloat( );\n\t\t\t\tthis.debugMessage( '      RepeatX: ' + texture.repeat.x );\n\n\t\t\t} else if ( next.id === MAT_MAP_VSCALE ) {\n\n\t\t\t\ttexture.repeat.y = next.readFloat( );\n\t\t\t\tthis.debugMessage( '      RepeatY: ' + texture.repeat.y );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( '      Unknown map chunk: ' + next.hexId );\n\n\t\t\t}\n\n\t\t\tnext = chunk.readChunk( );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\t/**\n\t * Read material group data chunk.\n\t *\n\t * @private\n\t * @param {Chunk} chunk - Chunk in use.\n\t * @return {Object} Object with name and index of the object.\n\t */\n\treadMaterialGroup( chunk ) {\n\n\t\tconst name = chunk.readString();\n\t\tconst numFaces = chunk.readWord();\n\n\t\tthis.debugMessage( '         Name: ' + name );\n\t\tthis.debugMessage( '         Faces: ' + numFaces );\n\n\t\tconst index = [];\n\t\tfor ( let i = 0; i < numFaces; ++ i ) {\n\n\t\t\tindex.push( chunk.readWord( ) );\n\n\t\t}\n\n\t\treturn { name: name, index: index };\n\n\t}\n\n\t/**\n\t * Read a color value.\n\t *\n\t * @private\n\t * @param {Chunk} chunk - Chunk.\n\t * @return {Color} Color value read.\n\t */\n\treadColor( chunk ) {\n\n\t\tconst subChunk = chunk.readChunk( );\n\t\tconst color = new Color();\n\n\t\tif ( subChunk.id === COLOR_24 || subChunk.id === LIN_COLOR_24 ) {\n\n\t\t\tconst r = subChunk.readByte( );\n\t\t\tconst g = subChunk.readByte( );\n\t\t\tconst b = subChunk.readByte( );\n\n\t\t\tcolor.setRGB( r / 255, g / 255, b / 255 );\n\n\t\t\tthis.debugMessage( '      Color: ' + color.r + ', ' + color.g + ', ' + color.b );\n\n\t\t}\telse if ( subChunk.id === COLOR_F || subChunk.id === LIN_COLOR_F ) {\n\n\t\t\tconst r = subChunk.readFloat( );\n\t\t\tconst g = subChunk.readFloat( );\n\t\t\tconst b = subChunk.readFloat( );\n\n\t\t\tcolor.setRGB( r, g, b );\n\n\t\t\tthis.debugMessage( '      Color: ' + color.r + ', ' + color.g + ', ' + color.b );\n\n\t\t}\telse {\n\n\t\t\tthis.debugMessage( '      Unknown color chunk: ' + subChunk.hexId );\n\n\t\t}\n\n\t\treturn color;\n\n\t}\n\n\t/**\n\t * Read percentage value.\n\t *\n\t * @private\n\t * @param {Chunk} chunk - Chunk to read data from.\n\t * @return {number} Data read from the dataview.\n\t */\n\treadPercentage( chunk ) {\n\n\t\tconst subChunk = chunk.readChunk( );\n\n\t\tswitch ( subChunk.id ) {\n\n\t\t\tcase INT_PERCENTAGE:\n\t\t\t\treturn ( subChunk.readShort( ) / 100 );\n\t\t\t\tbreak;\n\n\t\t\tcase FLOAT_PERCENTAGE:\n\t\t\t\treturn subChunk.readFloat( );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthis.debugMessage( '      Unknown percentage chunk: ' + subChunk.hexId );\n\t\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Print debug message to the console.\n\t *\n\t * Is controlled by a flag to show or hide debug messages.\n\t *\n\t * @private\n\t * @param {Object} message - Debug message to print to the console.\n\t */\n\tdebugMessage( message ) {\n\n\t\tif ( this.debug ) {\n\n\t\t\tconsole.log( message );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Read data/sub-chunks from chunk.\n *\n * @private\n */\nclass Chunk {\n\n\t/**\n\t * Create a new chunk\n\t *\n\t * @private\n\t * @param {DataView} data - DataView to read from.\n\t * @param {number} position - In data.\n\t * @param {Function} debugMessage - Logging callback.\n\t */\n\tconstructor( data, position, debugMessage ) {\n\n\t\tthis.data = data;\n\t\t// the offset to the begin of this chunk\n\t\tthis.offset = position;\n\t\t// the current reading position\n\t\tthis.position = position;\n\t\tthis.debugMessage = debugMessage;\n\n\t\tif ( this.debugMessage instanceof Function ) {\n\n\t\t\tthis.debugMessage = function () {};\n\n\t\t}\n\n\t\tthis.id = this.readWord();\n\t\tthis.size = this.readDWord();\n\t\tthis.end = this.offset + this.size;\n\n\t\tif ( this.end > data.byteLength ) {\n\n\t\t\tthis.debugMessage( 'Bad chunk size for chunk at ' + position );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Reads a sub cchunk.\n\t *\n\t * @private\n\t * @return {Chunk | null} next sub chunk.\n\t */\n\treadChunk() {\n\n\t\tif ( this.endOfChunk ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\ttry {\n\n\t\t\tconst next = new Chunk( this.data, this.position, this.debugMessage );\n\t\t\tthis.position += next.size;\n\t\t\treturn next;\n\n\t\t}\tcatch ( e ) {\n\n\t\t\tthis.debugMessage( 'Unable to read chunk at ' + this.position );\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the ID of this chunk as Hex\n\t *\n\t * @private\n\t * @return {string} hex-string of id\n\t */\n\tget hexId() {\n\n\t\treturn this.id.toString( 16 );\n\n\t}\n\n\tget endOfChunk() {\n\n\t\treturn this.position >= this.end;\n\n\t}\n\n\t/**\n\t * Read byte value.\n\t *\n\t * @private\n\t * @return {number} Data read from the dataview.\n\t */\n\treadByte() {\n\n\t\tconst v = this.data.getUint8( this.position, true );\n\t\tthis.position += 1;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read 32 bit float value.\n\t *\n\t * @private\n\t * @return {number} Data read from the dataview.\n\t */\n\treadFloat() {\n\n\t\ttry {\n\n\t\t\tconst v = this.data.getFloat32( this.position, true );\n\t\t\tthis.position += 4;\n\t\t\treturn v;\n\n\t\t}\tcatch ( e ) {\n\n\t\t\tthis.debugMessage( e + ' ' + this.position + ' ' + this.data.byteLength );\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Read 32 bit signed integer value.\n\t *\n\t * @private\n\t * @return {number} Data read from the dataview.\n\t */\n\treadInt() {\n\n\t\tconst v = this.data.getInt32( this.position, true );\n\t\tthis.position += 4;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read 16 bit signed integer value.\n\t *\n\t * @private\n\t * @return {number} Data read from the dataview.\n\t */\n\treadShort() {\n\n\t\tconst v = this.data.getInt16( this.position, true );\n\t\tthis.position += 2;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read 64 bit unsigned integer value.\n\t *\n\t * @private\n\t * @return {number} Data read from the dataview.\n\t */\n\treadDWord() {\n\n\t\tconst v = this.data.getUint32( this.position, true );\n\t\tthis.position += 4;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read 32 bit unsigned integer value.\n\t *\n\t * @private\n\t * @return {number} Data read from the dataview.\n\t */\n\treadWord() {\n\n\t\tconst v = this.data.getUint16( this.position, true );\n\t\tthis.position += 2;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read NULL terminated ASCII string value from chunk-pos.\n\t *\n\t * @private\n\t * @return {string} Data read from the dataview.\n\t */\n\treadString() {\n\n\t\tlet s = '';\n\t\tlet c = this.readByte();\n\t\twhile ( c ) {\n\n\t\t\ts += String.fromCharCode( c );\n\t\t\tc = this.readByte();\n\n\t\t}\n\n\t\treturn s;\n\n\t}\n\n}\n\n// const NULL_CHUNK = 0x0000;\nconst M3DMAGIC = 0x4D4D;\n// const SMAGIC = 0x2D2D;\n// const LMAGIC = 0x2D3D;\nconst MLIBMAGIC = 0x3DAA;\n// const MATMAGIC = 0x3DFF;\nconst CMAGIC = 0xC23D;\nconst M3D_VERSION = 0x0002;\n// const M3D_KFVERSION = 0x0005;\nconst COLOR_F = 0x0010;\nconst COLOR_24 = 0x0011;\nconst LIN_COLOR_24 = 0x0012;\nconst LIN_COLOR_F = 0x0013;\nconst INT_PERCENTAGE = 0x0030;\nconst FLOAT_PERCENTAGE = 0x0031;\nconst MDATA = 0x3D3D;\nconst MESH_VERSION = 0x3D3E;\nconst MASTER_SCALE = 0x0100;\n// const LO_SHADOW_BIAS = 0x1400;\n// const HI_SHADOW_BIAS = 0x1410;\n// const SHADOW_MAP_SIZE = 0x1420;\n// const SHADOW_SAMPLES = 0x1430;\n// const SHADOW_RANGE = 0x1440;\n// const SHADOW_FILTER = 0x1450;\n// const RAY_BIAS = 0x1460;\n// const O_CONSTS = 0x1500;\n// const AMBIENT_LIGHT = 0x2100;\n// const BIT_MAP = 0x1100;\n// const SOLID_BGND = 0x1200;\n// const V_GRADIENT = 0x1300;\n// const USE_BIT_MAP = 0x1101;\n// const USE_SOLID_BGND = 0x1201;\n// const USE_V_GRADIENT = 0x1301;\n// const FOG = 0x2200;\n// const FOG_BGND = 0x2210;\n// const LAYER_FOG = 0x2302;\n// const DISTANCE_CUE = 0x2300;\n// const DCUE_BGND = 0x2310;\n// const USE_FOG = 0x2201;\n// const USE_LAYER_FOG = 0x2303;\n// const USE_DISTANCE_CUE = 0x2301;\nconst MAT_ENTRY = 0xAFFF;\nconst MAT_NAME = 0xA000;\nconst MAT_AMBIENT = 0xA010;\nconst MAT_DIFFUSE = 0xA020;\nconst MAT_SPECULAR = 0xA030;\nconst MAT_SHININESS = 0xA040;\n// const MAT_SHIN2PCT = 0xA041;\nconst MAT_TRANSPARENCY = 0xA050;\n// const MAT_XPFALL = 0xA052;\n// const MAT_USE_XPFALL = 0xA240;\n// const MAT_REFBLUR = 0xA053;\n// const MAT_SHADING = 0xA100;\n// const MAT_USE_REFBLUR = 0xA250;\n// const MAT_SELF_ILLUM = 0xA084;\nconst MAT_TWO_SIDE = 0xA081;\n// const MAT_DECAL = 0xA082;\nconst MAT_ADDITIVE = 0xA083;\nconst MAT_WIRE = 0xA085;\n// const MAT_FACEMAP = 0xA088;\n// const MAT_TRANSFALLOFF_IN = 0xA08A;\n// const MAT_PHONGSOFT = 0xA08C;\n// const MAT_WIREABS = 0xA08E;\nconst MAT_WIRE_SIZE = 0xA087;\nconst MAT_TEXMAP = 0xA200;\n// const MAT_SXP_TEXT_DATA = 0xA320;\n// const MAT_TEXMASK = 0xA33E;\n// const MAT_SXP_TEXTMASK_DATA = 0xA32A;\n// const MAT_TEX2MAP = 0xA33A;\n// const MAT_SXP_TEXT2_DATA = 0xA321;\n// const MAT_TEX2MASK = 0xA340;\n// const MAT_SXP_TEXT2MASK_DATA = 0xA32C;\nconst MAT_OPACMAP = 0xA210;\n// const MAT_SXP_OPAC_DATA = 0xA322;\n// const MAT_OPACMASK = 0xA342;\n// const MAT_SXP_OPACMASK_DATA = 0xA32E;\nconst MAT_BUMPMAP = 0xA230;\n// const MAT_SXP_BUMP_DATA = 0xA324;\n// const MAT_BUMPMASK = 0xA344;\n// const MAT_SXP_BUMPMASK_DATA = 0xA330;\nconst MAT_SPECMAP = 0xA204;\n// const MAT_SXP_SPEC_DATA = 0xA325;\n// const MAT_SPECMASK = 0xA348;\n// const MAT_SXP_SPECMASK_DATA = 0xA332;\n// const MAT_SHINMAP = 0xA33C;\n// const MAT_SXP_SHIN_DATA = 0xA326;\n// const MAT_SHINMASK = 0xA346;\n// const MAT_SXP_SHINMASK_DATA = 0xA334;\n// const MAT_SELFIMAP = 0xA33D;\n// const MAT_SXP_SELFI_DATA = 0xA328;\n// const MAT_SELFIMASK = 0xA34A;\n// const MAT_SXP_SELFIMASK_DATA = 0xA336;\n// const MAT_REFLMAP = 0xA220;\n// const MAT_REFLMASK = 0xA34C;\n// const MAT_SXP_REFLMASK_DATA = 0xA338;\n// const MAT_ACUBIC = 0xA310;\nconst MAT_MAPNAME = 0xA300;\n// const MAT_MAP_TILING = 0xA351;\n// const MAT_MAP_TEXBLUR = 0xA353;\nconst MAT_MAP_USCALE = 0xA354;\nconst MAT_MAP_VSCALE = 0xA356;\nconst MAT_MAP_UOFFSET = 0xA358;\nconst MAT_MAP_VOFFSET = 0xA35A;\n// const MAT_MAP_ANG = 0xA35C;\n// const MAT_MAP_COL1 = 0xA360;\n// const MAT_MAP_COL2 = 0xA362;\n// const MAT_MAP_RCOL = 0xA364;\n// const MAT_MAP_GCOL = 0xA366;\n// const MAT_MAP_BCOL = 0xA368;\nconst NAMED_OBJECT = 0x4000;\n// const N_DIRECT_LIGHT = 0x4600;\n// const DL_OFF = 0x4620;\n// const DL_OUTER_RANGE = 0x465A;\n// const DL_INNER_RANGE = 0x4659;\n// const DL_MULTIPLIER = 0x465B;\n// const DL_EXCLUDE = 0x4654;\n// const DL_ATTENUATE = 0x4625;\n// const DL_SPOTLIGHT = 0x4610;\n// const DL_SPOT_ROLL = 0x4656;\n// const DL_SHADOWED = 0x4630;\n// const DL_LOCAL_SHADOW2 = 0x4641;\n// const DL_SEE_CONE = 0x4650;\n// const DL_SPOT_RECTANGULAR = 0x4651;\n// const DL_SPOT_ASPECT = 0x4657;\n// const DL_SPOT_PROJECTOR = 0x4653;\n// const DL_SPOT_OVERSHOOT = 0x4652;\n// const DL_RAY_BIAS = 0x4658;\n// const DL_RAYSHAD = 0x4627;\n// const N_CAMERA = 0x4700;\n// const CAM_SEE_CONE = 0x4710;\n// const CAM_RANGES = 0x4720;\n// const OBJ_HIDDEN = 0x4010;\n// const OBJ_VIS_LOFTER = 0x4011;\n// const OBJ_DOESNT_CAST = 0x4012;\n// const OBJ_DONT_RECVSHADOW = 0x4017;\n// const OBJ_MATTE = 0x4013;\n// const OBJ_FAST = 0x4014;\n// const OBJ_PROCEDURAL = 0x4015;\n// const OBJ_FROZEN = 0x4016;\nconst N_TRI_OBJECT = 0x4100;\nconst POINT_ARRAY = 0x4110;\n// const POINT_FLAG_ARRAY = 0x4111;\nconst FACE_ARRAY = 0x4120;\nconst MSH_MAT_GROUP = 0x4130;\n// const SMOOTH_GROUP = 0x4150;\n// const MSH_BOXMAP = 0x4190;\nconst TEX_VERTS = 0x4140;\nconst MESH_MATRIX = 0x4160;\n// const MESH_COLOR = 0x4165;\n// const MESH_TEXTURE_INFO = 0x4170;\n// const KFDATA = 0xB000;\n// const KFHDR = 0xB00A;\n// const KFSEG = 0xB008;\n// const KFCURTIME = 0xB009;\n// const AMBIENT_NODE_TAG = 0xB001;\n// const OBJECT_NODE_TAG = 0xB002;\n// const CAMERA_NODE_TAG = 0xB003;\n// const TARGET_NODE_TAG = 0xB004;\n// const LIGHT_NODE_TAG = 0xB005;\n// const L_TARGET_NODE_TAG = 0xB006;\n// const SPOTLIGHT_NODE_TAG = 0xB007;\n// const NODE_ID = 0xB030;\n// const NODE_HDR = 0xB010;\n// const PIVOT = 0xB013;\n// const INSTANCE_NAME = 0xB011;\n// const MORPH_SMOOTH = 0xB015;\n// const BOUNDBOX = 0xB014;\n// const POS_TRACK_TAG = 0xB020;\n// const COL_TRACK_TAG = 0xB025;\n// const ROT_TRACK_TAG = 0xB021;\n// const SCL_TRACK_TAG = 0xB022;\n// const MORPH_TRACK_TAG = 0xB026;\n// const FOV_TRACK_TAG = 0xB023;\n// const ROLL_TRACK_TAG = 0xB024;\n// const HOT_TRACK_TAG = 0xB027;\n// const FALL_TRACK_TAG = 0xB028;\n// const HIDE_TRACK_TAG = 0xB029;\n// const POLY_2D = 0x5000;\n// const SHAPE_OK = 0x5010;\n// const SHAPE_NOT_OK = 0x5011;\n// const SHAPE_HOOK = 0x5020;\n// const PATH_3D = 0x6000;\n// const PATH_MATRIX = 0x6005;\n// const SHAPE_2D = 0x6010;\n// const M_SCALE = 0x6020;\n// const M_TWIST = 0x6030;\n// const M_TEETER = 0x6040;\n// const M_FIT = 0x6050;\n// const M_BEVEL = 0x6060;\n// const XZ_CURVE = 0x6070;\n// const YZ_CURVE = 0x6080;\n// const INTERPCT = 0x6090;\n// const DEFORM_LIMIT = 0x60A0;\n// const USE_CONTOUR = 0x6100;\n// const USE_TWEEN = 0x6110;\n// const USE_SCALE = 0x6120;\n// const USE_TWIST = 0x6130;\n// const USE_TEETER = 0x6140;\n// const USE_FIT = 0x6150;\n// const USE_BEVEL = 0x6160;\n// const DEFAULT_VIEW = 0x3000;\n// const VIEW_TOP = 0x3010;\n// const VIEW_BOTTOM = 0x3020;\n// const VIEW_LEFT = 0x3030;\n// const VIEW_RIGHT = 0x3040;\n// const VIEW_FRONT = 0x3050;\n// const VIEW_BACK = 0x3060;\n// const VIEW_USER = 0x3070;\n// const VIEW_CAMERA = 0x3080;\n// const VIEW_WINDOW = 0x3090;\n// const VIEWPORT_LAYOUT_OLD = 0x7000;\n// const VIEWPORT_DATA_OLD = 0x7010;\n// const VIEWPORT_LAYOUT = 0x7001;\n// const VIEWPORT_DATA = 0x7011;\n// const VIEWPORT_DATA_3 = 0x7012;\n// const VIEWPORT_SIZE = 0x7020;\n// const NETWORK_VIEW = 0x7030;\n\nexport { TDSLoader };\n"],"mappings":"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AW,GAAG,MAAM;AAC1B;AACA;AACA;AACA,MAAMF,WAAW,GAAG,MAAM;AAC1B;AACA;AACA;AACA,MAAMI,WAAW,GAAG,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM4C,WAAW,GAAG,MAAM;AAC1B;AACA;AACA,MAAMM,cAAc,GAAG,MAAM;AAC7B,MAAME,cAAc,GAAG,MAAM;AAC7B,MAAMP,eAAe,GAAG,MAAM;AAC9B,MAAMG,eAAe,GAAG,MAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,MAAM1F,YAAY,GAAG,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMM,YAAY,GAAG,MAAM;AAC3B,MAAMuC,WAAW,GAAG,MAAM;AAC1B;AACA,MAAMK,UAAU,GAAG,MAAM;AACzB,MAAMyB,aAAa,GAAG,MAAM;AAC5B;AACA;AACA,MAAMvB,SAAS,GAAG,MAAM;AACxB,MAAMG,WAAW,GAAG,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS7G,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}