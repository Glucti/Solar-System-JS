{"ast":null,"code":"import { Vector2, Vector3, DirectionalLight, MathUtils, ShaderChunk, Matrix4, Box3 } from 'three';\nimport { CSMFrustum } from './CSMFrustum.js';\nimport { CSMShader } from './CSMShader.js';\nconst _cameraToLightMatrix = new Matrix4();\nconst _lightSpaceFrustum = new CSMFrustum({\n  webGL: true\n});\nconst _center = new Vector3();\nconst _bbox = new Box3();\nconst _uniformArray = [];\nconst _logArray = [];\nconst _lightOrientationMatrix = new Matrix4();\nconst _lightOrientationMatrixInverse = new Matrix4();\nconst _up = new Vector3(0, 1, 0);\n\n/**\n * An implementation of Cascade Shadow Maps (CSM).\n *\n * This module can only be used with {@link WebGLRenderer}. When using {@link WebGPURenderer},\n * use {@link CSMShadowNode} instead.\n *\n * @three_import import { CSM } from 'three/addons/csm/CSM.js';\n */\nexport class CSM {\n  /**\n   * Constructs a new CSM instance.\n   *\n   * @param {CSM~Data} data - The CSM data.\n   */\n  constructor(data) {\n    /**\n     * The scene's camera.\n     *\n     * @type {Camera}\n     */\n    this.camera = data.camera;\n\n    /**\n     * The parent object, usually the scene.\n     *\n     * @type {Object3D}\n     */\n    this.parent = data.parent;\n\n    /**\n     * The number of cascades.\n     *\n     * @type {number}\n     * @default 3\n     */\n    this.cascades = data.cascades || 3;\n\n    /**\n     * The maximum far value.\n     *\n     * @type {number}\n     * @default 100000\n     */\n    this.maxFar = data.maxFar || 100000;\n\n    /**\n     * The frustum split mode.\n     *\n     * @type {('practical'|'uniform'|'logarithmic'|'custom')}\n     * @default 'practical'\n     */\n    this.mode = data.mode || 'practical';\n\n    /**\n     * The shadow map size.\n     *\n     * @type {number}\n     * @default 2048\n     */\n    this.shadowMapSize = data.shadowMapSize || 2048;\n\n    /**\n     * The shadow bias.\n     *\n     * @type {number}\n     * @default 0.000001\n     */\n    this.shadowBias = data.shadowBias || 0.000001;\n\n    /**\n     * The light direction.\n     *\n     * @type {Vector3}\n     */\n    this.lightDirection = data.lightDirection || new Vector3(1, -1, 1).normalize();\n\n    /**\n     * The light intensity.\n     *\n     * @type {number}\n     * @default 3\n     */\n    this.lightIntensity = data.lightIntensity || 3;\n\n    /**\n     * The light near value.\n     *\n     * @type {number}\n     * @default 1\n     */\n    this.lightNear = data.lightNear || 1;\n\n    /**\n     * The light far value.\n     *\n     * @type {number}\n     * @default 2000\n     */\n    this.lightFar = data.lightFar || 2000;\n\n    /**\n     * The light margin.\n     *\n     * @type {number}\n     * @default 200\n     */\n    this.lightMargin = data.lightMargin || 200;\n\n    /**\n     * Custom split callback when using `mode='custom'`.\n     *\n     * @type {Function}\n     */\n    this.customSplitsCallback = data.customSplitsCallback;\n\n    /**\n     * Whether to fade between cascades or not.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    this.fade = false;\n\n    /**\n     * The main frustum.\n     *\n     * @type {CSMFrustum}\n     */\n    this.mainFrustum = new CSMFrustum({\n      webGL: true\n    });\n\n    /**\n     * An array of frustums representing the cascades.\n     *\n     * @type {Array<CSMFrustum>}\n     */\n    this.frustums = [];\n\n    /**\n     * An array of numbers in the range `[0,1]` the defines how the\n     * mainCSM frustum should be split up.\n     *\n     * @type {Array<number>}\n     */\n    this.breaks = [];\n\n    /**\n     * An array of directional lights which cast the shadows for\n     * the different cascades. There is one directional light for each\n     * cascade.\n     *\n     * @type {Array<DirectionalLight>}\n     */\n    this.lights = [];\n\n    /**\n     * A Map holding enhanced material shaders.\n     *\n     * @type {Map<Material,Object>}\n     */\n    this.shaders = new Map();\n    this._createLights();\n    this.updateFrustums();\n    this._injectInclude();\n  }\n\n  /**\n   * Creates the directional lights of this CSM instance.\n   *\n   * @private\n   */\n  _createLights() {\n    for (let i = 0; i < this.cascades; i++) {\n      const light = new DirectionalLight(0xffffff, this.lightIntensity);\n      light.castShadow = true;\n      light.shadow.mapSize.width = this.shadowMapSize;\n      light.shadow.mapSize.height = this.shadowMapSize;\n      light.shadow.camera.near = this.lightNear;\n      light.shadow.camera.far = this.lightFar;\n      light.shadow.bias = this.shadowBias;\n      this.parent.add(light);\n      this.parent.add(light.target);\n      this.lights.push(light);\n    }\n  }\n\n  /**\n   * Inits the cascades according to the scene's camera and breaks configuration.\n   *\n   * @private\n   */\n  _initCascades() {\n    const camera = this.camera;\n    camera.updateProjectionMatrix();\n    this.mainFrustum.setFromProjectionMatrix(camera.projectionMatrix, this.maxFar);\n    this.mainFrustum.split(this.breaks, this.frustums);\n  }\n\n  /**\n   * Updates the shadow bounds of this CSM instance.\n   *\n   * @private\n   */\n  _updateShadowBounds() {\n    const frustums = this.frustums;\n    for (let i = 0; i < frustums.length; i++) {\n      const light = this.lights[i];\n      const shadowCam = light.shadow.camera;\n      const frustum = this.frustums[i];\n\n      // Get the two points that represent that furthest points on the frustum assuming\n      // that's either the diagonal across the far plane or the diagonal across the whole\n      // frustum itself.\n      const nearVerts = frustum.vertices.near;\n      const farVerts = frustum.vertices.far;\n      const point1 = farVerts[0];\n      let point2;\n      if (point1.distanceTo(farVerts[2]) > point1.distanceTo(nearVerts[2])) {\n        point2 = farVerts[2];\n      } else {\n        point2 = nearVerts[2];\n      }\n      let squaredBBWidth = point1.distanceTo(point2);\n      if (this.fade) {\n        // expand the shadow extents by the fade margin if fade is enabled.\n        const camera = this.camera;\n        const far = Math.max(camera.far, this.maxFar);\n        const linearDepth = frustum.vertices.far[0].z / (far - camera.near);\n        const margin = 0.25 * Math.pow(linearDepth, 2.0) * (far - camera.near);\n        squaredBBWidth += margin;\n      }\n      shadowCam.left = -squaredBBWidth / 2;\n      shadowCam.right = squaredBBWidth / 2;\n      shadowCam.top = squaredBBWidth / 2;\n      shadowCam.bottom = -squaredBBWidth / 2;\n      shadowCam.updateProjectionMatrix();\n    }\n  }\n\n  /**\n   * Computes the breaks of this CSM instance based on the scene's camera, number of cascades\n   * and the selected split mode.\n   *\n   * @private\n   */\n  _getBreaks() {\n    const camera = this.camera;\n    const far = Math.min(camera.far, this.maxFar);\n    this.breaks.length = 0;\n    switch (this.mode) {\n      case 'uniform':\n        uniformSplit(this.cascades, camera.near, far, this.breaks);\n        break;\n      case 'logarithmic':\n        logarithmicSplit(this.cascades, camera.near, far, this.breaks);\n        break;\n      case 'practical':\n        practicalSplit(this.cascades, camera.near, far, 0.5, this.breaks);\n        break;\n      case 'custom':\n        if (this.customSplitsCallback === undefined) console.error('CSM: Custom split scheme callback not defined.');\n        this.customSplitsCallback(this.cascades, camera.near, far, this.breaks);\n        break;\n    }\n    function uniformSplit(amount, near, far, target) {\n      for (let i = 1; i < amount; i++) {\n        target.push((near + (far - near) * i / amount) / far);\n      }\n      target.push(1);\n    }\n    function logarithmicSplit(amount, near, far, target) {\n      for (let i = 1; i < amount; i++) {\n        target.push(near * (far / near) ** (i / amount) / far);\n      }\n      target.push(1);\n    }\n    function practicalSplit(amount, near, far, lambda, target) {\n      _uniformArray.length = 0;\n      _logArray.length = 0;\n      logarithmicSplit(amount, near, far, _logArray);\n      uniformSplit(amount, near, far, _uniformArray);\n      for (let i = 1; i < amount; i++) {\n        target.push(MathUtils.lerp(_uniformArray[i - 1], _logArray[i - 1], lambda));\n      }\n      target.push(1);\n    }\n  }\n\n  /**\n   * Updates the CSM. This method must be called in your animation loop before\n   * calling `renderer.render()`.\n   */\n  update() {\n    const camera = this.camera;\n    const frustums = this.frustums;\n\n    // for each frustum we need to find its min-max box aligned with the light orientation\n    // the position in _lightOrientationMatrix does not matter, as we transform there and back\n    _lightOrientationMatrix.lookAt(new Vector3(), this.lightDirection, _up);\n    _lightOrientationMatrixInverse.copy(_lightOrientationMatrix).invert();\n    for (let i = 0; i < frustums.length; i++) {\n      const light = this.lights[i];\n      const shadowCam = light.shadow.camera;\n      const texelWidth = (shadowCam.right - shadowCam.left) / this.shadowMapSize;\n      const texelHeight = (shadowCam.top - shadowCam.bottom) / this.shadowMapSize;\n      _cameraToLightMatrix.multiplyMatrices(_lightOrientationMatrixInverse, camera.matrixWorld);\n      frustums[i].toSpace(_cameraToLightMatrix, _lightSpaceFrustum);\n      const nearVerts = _lightSpaceFrustum.vertices.near;\n      const farVerts = _lightSpaceFrustum.vertices.far;\n      _bbox.makeEmpty();\n      for (let j = 0; j < 4; j++) {\n        _bbox.expandByPoint(nearVerts[j]);\n        _bbox.expandByPoint(farVerts[j]);\n      }\n      _bbox.getCenter(_center);\n      _center.z = _bbox.max.z + this.lightMargin;\n      _center.x = Math.floor(_center.x / texelWidth) * texelWidth;\n      _center.y = Math.floor(_center.y / texelHeight) * texelHeight;\n      _center.applyMatrix4(_lightOrientationMatrix);\n      light.position.copy(_center);\n      light.target.position.copy(_center);\n      light.target.position.x += this.lightDirection.x;\n      light.target.position.y += this.lightDirection.y;\n      light.target.position.z += this.lightDirection.z;\n    }\n  }\n\n  /**\n   * Injects the CSM shader enhancements into the built-in materials.\n   *\n   * @private\n   */\n  _injectInclude() {\n    ShaderChunk.lights_fragment_begin = CSMShader.lights_fragment_begin;\n    ShaderChunk.lights_pars_begin = CSMShader.lights_pars_begin;\n  }\n\n  /**\n   * Applications must call this method for all materials that should be affected by CSM.\n   *\n   * @param {Material} material - The material to setup for CSM support.\n   */\n  setupMaterial(material) {\n    material.defines = material.defines || {};\n    material.defines.USE_CSM = 1;\n    material.defines.CSM_CASCADES = this.cascades;\n    if (this.fade) {\n      material.defines.CSM_FADE = '';\n    }\n    const breaksVec2 = [];\n    const scope = this;\n    const shaders = this.shaders;\n    material.onBeforeCompile = function (shader) {\n      const far = Math.min(scope.camera.far, scope.maxFar);\n      scope._getExtendedBreaks(breaksVec2);\n      shader.uniforms.CSM_cascades = {\n        value: breaksVec2\n      };\n      shader.uniforms.cameraNear = {\n        value: scope.camera.near\n      };\n      shader.uniforms.shadowFar = {\n        value: far\n      };\n      shaders.set(material, shader);\n    };\n    shaders.set(material, null);\n  }\n\n  /**\n   * Updates the CSM uniforms.\n   *\n   * @private\n   */\n  _updateUniforms() {\n    const far = Math.min(this.camera.far, this.maxFar);\n    const shaders = this.shaders;\n    shaders.forEach(function (shader, material) {\n      if (shader !== null) {\n        const uniforms = shader.uniforms;\n        this._getExtendedBreaks(uniforms.CSM_cascades.value);\n        uniforms.cameraNear.value = this.camera.near;\n        uniforms.shadowFar.value = far;\n      }\n      if (!this.fade && 'CSM_FADE' in material.defines) {\n        delete material.defines.CSM_FADE;\n        material.needsUpdate = true;\n      } else if (this.fade && !('CSM_FADE' in material.defines)) {\n        material.defines.CSM_FADE = '';\n        material.needsUpdate = true;\n      }\n    }, this);\n  }\n\n  /**\n   * Computes the extended breaks for the CSM uniforms.\n   *\n   * @private\n   * @param {Array<Vector2>} target - The target array that holds the extended breaks.\n   */\n  _getExtendedBreaks(target) {\n    while (target.length < this.breaks.length) {\n      target.push(new Vector2());\n    }\n    target.length = this.breaks.length;\n    for (let i = 0; i < this.cascades; i++) {\n      const amount = this.breaks[i];\n      const prev = this.breaks[i - 1] || 0;\n      target[i].x = prev;\n      target[i].y = amount;\n    }\n  }\n\n  /**\n   * Applications must call this method every time they change camera or CSM settings.\n   */\n  updateFrustums() {\n    this._getBreaks();\n    this._initCascades();\n    this._updateShadowBounds();\n    this._updateUniforms();\n  }\n\n  /**\n   * Applications must call this method when they remove the CSM usage from their scene.\n   */\n  remove() {\n    for (let i = 0; i < this.lights.length; i++) {\n      this.parent.remove(this.lights[i].target);\n      this.parent.remove(this.lights[i]);\n    }\n  }\n\n  /**\n   * Frees the GPU-related resources allocated by this instance. Call this\n   * method whenever this instance is no longer used in your app.\n   */\n  dispose() {\n    const shaders = this.shaders;\n    shaders.forEach(function (shader, material) {\n      delete material.onBeforeCompile;\n      delete material.defines.USE_CSM;\n      delete material.defines.CSM_CASCADES;\n      delete material.defines.CSM_FADE;\n      if (shader !== null) {\n        delete shader.uniforms.CSM_cascades;\n        delete shader.uniforms.cameraNear;\n        delete shader.uniforms.shadowFar;\n      }\n      material.needsUpdate = true;\n    });\n    shaders.clear();\n  }\n}\n\n/**\n * Constructor data of `CSM`.\n *\n * @typedef {Object} CSM~Data\n * @property {Camera} camera - The scene's camera.\n * @property {Object3D} parent - The parent object, usually the scene.\n * @property {number} [cascades=3] - The number of cascades.\n * @property {number} [maxFar=100000] - The maximum far value.\n * @property {('practical'|'uniform'|'logarithmic'|'custom')} [mode='practical'] - The frustum split mode.\n * @property {Function} [customSplitsCallback] - Custom split callback when using `mode='custom'`.\n * @property {number} [shadowMapSize=2048] - The shadow map size.\n * @property {number} [shadowBias=0.000001] - The shadow bias.\n * @property {Vector3} [lightDirection] - The light direction.\n * @property {number} [lightIntensity=3] - The light intensity.\n * @property {number} [lightNear=1] - The light near value.\n * @property {number} [lightNear=2000] - The light far value.\n * @property {number} [lightMargin=200] - The light margin.\n **/","map":{"version":3,"names":["Vector2","Vector3","DirectionalLight","MathUtils","ShaderChunk","Matrix4","Box3","CSMFrustum","CSMShader","_cameraToLightMatrix","_lightSpaceFrustum","webGL","_center","_bbox","_uniformArray","_logArray","_lightOrientationMatrix","_lightOrientationMatrixInverse","_up","CSM","constructor","data","camera","parent","cascades","maxFar","mode","shadowMapSize","shadowBias","lightDirection","normalize","lightIntensity","lightNear","lightFar","lightMargin","customSplitsCallback","fade","mainFrustum","frustums","breaks","lights","shaders","Map","_createLights","updateFrustums","_injectInclude","i","light","castShadow","shadow","mapSize","width","height","near","far","bias","add","target","push","_initCascades","updateProjectionMatrix","setFromProjectionMatrix","projectionMatrix","split","_updateShadowBounds","length","shadowCam","frustum","nearVerts","vertices","farVerts","point1","point2","distanceTo","squaredBBWidth","Math","max","linearDepth","z","margin","pow","left","right","top","bottom","_getBreaks","min","uniformSplit","logarithmicSplit","practicalSplit","undefined","console","error","amount","lambda","lerp","update","lookAt","copy","invert","texelWidth","texelHeight","multiplyMatrices","matrixWorld","toSpace","makeEmpty","j","expandByPoint","getCenter","x","floor","y","applyMatrix4","position","lights_fragment_begin","lights_pars_begin","setupMaterial","material","defines","USE_CSM","CSM_CASCADES","CSM_FADE","breaksVec2","scope","onBeforeCompile","shader","_getExtendedBreaks","uniforms","CSM_cascades","value","cameraNear","shadowFar","set","_updateUniforms","forEach","needsUpdate","prev","remove","dispose","clear"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/csm/CSM.js"],"sourcesContent":["import {\n\tVector2,\n\tVector3,\n\tDirectionalLight,\n\tMathUtils,\n\tShaderChunk,\n\tMatrix4,\n\tBox3\n} from 'three';\nimport { CSMFrustum } from './CSMFrustum.js';\nimport { CSMShader } from './CSMShader.js';\n\nconst _cameraToLightMatrix = new Matrix4();\nconst _lightSpaceFrustum = new CSMFrustum( { webGL: true } );\nconst _center = new Vector3();\nconst _bbox = new Box3();\nconst _uniformArray = [];\nconst _logArray = [];\nconst _lightOrientationMatrix = new Matrix4();\nconst _lightOrientationMatrixInverse = new Matrix4();\nconst _up = new Vector3( 0, 1, 0 );\n\n/**\n * An implementation of Cascade Shadow Maps (CSM).\n *\n * This module can only be used with {@link WebGLRenderer}. When using {@link WebGPURenderer},\n * use {@link CSMShadowNode} instead.\n *\n * @three_import import { CSM } from 'three/addons/csm/CSM.js';\n */\nexport class CSM {\n\n\t/**\n\t * Constructs a new CSM instance.\n\t *\n\t * @param {CSM~Data} data - The CSM data.\n\t */\n\tconstructor( data ) {\n\n\t\t/**\n\t\t * The scene's camera.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = data.camera;\n\n\t\t/**\n\t\t * The parent object, usually the scene.\n\t\t *\n\t\t * @type {Object3D}\n\t\t */\n\t\tthis.parent = data.parent;\n\n\t\t/**\n\t\t * The number of cascades.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 3\n\t\t */\n\t\tthis.cascades = data.cascades || 3;\n\n\t\t/**\n\t\t * The maximum far value.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 100000\n\t\t */\n\t\tthis.maxFar = data.maxFar || 100000;\n\n\t\t/**\n\t\t * The frustum split mode.\n\t\t *\n\t\t * @type {('practical'|'uniform'|'logarithmic'|'custom')}\n\t\t * @default 'practical'\n\t\t */\n\t\tthis.mode = data.mode || 'practical';\n\n\t\t/**\n\t\t * The shadow map size.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 2048\n\t\t */\n\t\tthis.shadowMapSize = data.shadowMapSize || 2048;\n\n\t\t/**\n\t\t * The shadow bias.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0.000001\n\t\t */\n\t\tthis.shadowBias = data.shadowBias || 0.000001;\n\n\t\t/**\n\t\t * The light direction.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.lightDirection = data.lightDirection || new Vector3( 1, - 1, 1 ).normalize();\n\n\t\t/**\n\t\t * The light intensity.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 3\n\t\t */\n\t\tthis.lightIntensity = data.lightIntensity || 3;\n\n\t\t/**\n\t\t * The light near value.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.lightNear = data.lightNear || 1;\n\n\t\t/**\n\t\t * The light far value.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 2000\n\t\t */\n\t\tthis.lightFar = data.lightFar || 2000;\n\n\t\t/**\n\t\t * The light margin.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 200\n\t\t */\n\t\tthis.lightMargin = data.lightMargin || 200;\n\n\t\t/**\n\t\t * Custom split callback when using `mode='custom'`.\n\t\t *\n\t\t * @type {Function}\n\t\t */\n\t\tthis.customSplitsCallback = data.customSplitsCallback;\n\n\t\t/**\n\t\t * Whether to fade between cascades or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.fade = false;\n\n\t\t/**\n\t\t * The main frustum.\n\t\t *\n\t\t * @type {CSMFrustum}\n\t\t */\n\t\tthis.mainFrustum = new CSMFrustum( { webGL: true } );\n\n\t\t/**\n\t\t * An array of frustums representing the cascades.\n\t\t *\n\t\t * @type {Array<CSMFrustum>}\n\t\t */\n\t\tthis.frustums = [];\n\n\t\t/**\n\t\t * An array of numbers in the range `[0,1]` the defines how the\n\t\t * mainCSM frustum should be split up.\n\t\t *\n\t\t * @type {Array<number>}\n\t\t */\n\t\tthis.breaks = [];\n\n\t\t/**\n\t\t * An array of directional lights which cast the shadows for\n\t\t * the different cascades. There is one directional light for each\n\t\t * cascade.\n\t\t *\n\t\t * @type {Array<DirectionalLight>}\n\t\t */\n\t\tthis.lights = [];\n\n\t\t/**\n\t\t * A Map holding enhanced material shaders.\n\t\t *\n\t\t * @type {Map<Material,Object>}\n\t\t */\n\t\tthis.shaders = new Map();\n\n\t\tthis._createLights();\n\t\tthis.updateFrustums();\n\t\tthis._injectInclude();\n\n\t}\n\n\t/**\n\t * Creates the directional lights of this CSM instance.\n\t *\n\t * @private\n\t */\n\t_createLights() {\n\n\t\tfor ( let i = 0; i < this.cascades; i ++ ) {\n\n\t\t\tconst light = new DirectionalLight( 0xffffff, this.lightIntensity );\n\t\t\tlight.castShadow = true;\n\t\t\tlight.shadow.mapSize.width = this.shadowMapSize;\n\t\t\tlight.shadow.mapSize.height = this.shadowMapSize;\n\n\t\t\tlight.shadow.camera.near = this.lightNear;\n\t\t\tlight.shadow.camera.far = this.lightFar;\n\t\t\tlight.shadow.bias = this.shadowBias;\n\n\t\t\tthis.parent.add( light );\n\t\t\tthis.parent.add( light.target );\n\t\t\tthis.lights.push( light );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Inits the cascades according to the scene's camera and breaks configuration.\n\t *\n\t * @private\n\t */\n\t_initCascades() {\n\n\t\tconst camera = this.camera;\n\t\tcamera.updateProjectionMatrix();\n\t\tthis.mainFrustum.setFromProjectionMatrix( camera.projectionMatrix, this.maxFar );\n\t\tthis.mainFrustum.split( this.breaks, this.frustums );\n\n\t}\n\n\t/**\n\t * Updates the shadow bounds of this CSM instance.\n\t *\n\t * @private\n\t */\n\t_updateShadowBounds() {\n\n\t\tconst frustums = this.frustums;\n\t\tfor ( let i = 0; i < frustums.length; i ++ ) {\n\n\t\t\tconst light = this.lights[ i ];\n\t\t\tconst shadowCam = light.shadow.camera;\n\t\t\tconst frustum = this.frustums[ i ];\n\n\t\t\t// Get the two points that represent that furthest points on the frustum assuming\n\t\t\t// that's either the diagonal across the far plane or the diagonal across the whole\n\t\t\t// frustum itself.\n\t\t\tconst nearVerts = frustum.vertices.near;\n\t\t\tconst farVerts = frustum.vertices.far;\n\t\t\tconst point1 = farVerts[ 0 ];\n\t\t\tlet point2;\n\t\t\tif ( point1.distanceTo( farVerts[ 2 ] ) > point1.distanceTo( nearVerts[ 2 ] ) ) {\n\n\t\t\t\tpoint2 = farVerts[ 2 ];\n\n\t\t\t} else {\n\n\t\t\t\tpoint2 = nearVerts[ 2 ];\n\n\t\t\t}\n\n\t\t\tlet squaredBBWidth = point1.distanceTo( point2 );\n\t\t\tif ( this.fade ) {\n\n\t\t\t\t// expand the shadow extents by the fade margin if fade is enabled.\n\t\t\t\tconst camera = this.camera;\n\t\t\t\tconst far = Math.max( camera.far, this.maxFar );\n\t\t\t\tconst linearDepth = frustum.vertices.far[ 0 ].z / ( far - camera.near );\n\t\t\t\tconst margin = 0.25 * Math.pow( linearDepth, 2.0 ) * ( far - camera.near );\n\n\t\t\t\tsquaredBBWidth += margin;\n\n\t\t\t}\n\n\t\t\tshadowCam.left = - squaredBBWidth / 2;\n\t\t\tshadowCam.right = squaredBBWidth / 2;\n\t\t\tshadowCam.top = squaredBBWidth / 2;\n\t\t\tshadowCam.bottom = - squaredBBWidth / 2;\n\t\t\tshadowCam.updateProjectionMatrix();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Computes the breaks of this CSM instance based on the scene's camera, number of cascades\n\t * and the selected split mode.\n\t *\n\t * @private\n\t */\n\t_getBreaks() {\n\n\t\tconst camera = this.camera;\n\t\tconst far = Math.min( camera.far, this.maxFar );\n\t\tthis.breaks.length = 0;\n\n\t\tswitch ( this.mode ) {\n\n\t\t\tcase 'uniform':\n\t\t\t\tuniformSplit( this.cascades, camera.near, far, this.breaks );\n\t\t\t\tbreak;\n\t\t\tcase 'logarithmic':\n\t\t\t\tlogarithmicSplit( this.cascades, camera.near, far, this.breaks );\n\t\t\t\tbreak;\n\t\t\tcase 'practical':\n\t\t\t\tpracticalSplit( this.cascades, camera.near, far, 0.5, this.breaks );\n\t\t\t\tbreak;\n\t\t\tcase 'custom':\n\t\t\t\tif ( this.customSplitsCallback === undefined ) console.error( 'CSM: Custom split scheme callback not defined.' );\n\t\t\t\tthis.customSplitsCallback( this.cascades, camera.near, far, this.breaks );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tfunction uniformSplit( amount, near, far, target ) {\n\n\t\t\tfor ( let i = 1; i < amount; i ++ ) {\n\n\t\t\t\ttarget.push( ( near + ( far - near ) * i / amount ) / far );\n\n\t\t\t}\n\n\t\t\ttarget.push( 1 );\n\n\t\t}\n\n\t\tfunction logarithmicSplit( amount, near, far, target ) {\n\n\t\t\tfor ( let i = 1; i < amount; i ++ ) {\n\n\t\t\t\ttarget.push( ( near * ( far / near ) ** ( i / amount ) ) / far );\n\n\t\t\t}\n\n\t\t\ttarget.push( 1 );\n\n\t\t}\n\n\t\tfunction practicalSplit( amount, near, far, lambda, target ) {\n\n\t\t\t_uniformArray.length = 0;\n\t\t\t_logArray.length = 0;\n\t\t\tlogarithmicSplit( amount, near, far, _logArray );\n\t\t\tuniformSplit( amount, near, far, _uniformArray );\n\n\t\t\tfor ( let i = 1; i < amount; i ++ ) {\n\n\t\t\t\ttarget.push( MathUtils.lerp( _uniformArray[ i - 1 ], _logArray[ i - 1 ], lambda ) );\n\n\t\t\t}\n\n\t\t\ttarget.push( 1 );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the CSM. This method must be called in your animation loop before\n\t * calling `renderer.render()`.\n\t */\n\tupdate() {\n\n\t\tconst camera = this.camera;\n\t\tconst frustums = this.frustums;\n\n\t\t// for each frustum we need to find its min-max box aligned with the light orientation\n\t\t// the position in _lightOrientationMatrix does not matter, as we transform there and back\n\t\t_lightOrientationMatrix.lookAt( new Vector3(), this.lightDirection, _up );\n\t\t_lightOrientationMatrixInverse.copy( _lightOrientationMatrix ).invert();\n\n\t\tfor ( let i = 0; i < frustums.length; i ++ ) {\n\n\t\t\tconst light = this.lights[ i ];\n\t\t\tconst shadowCam = light.shadow.camera;\n\t\t\tconst texelWidth = ( shadowCam.right - shadowCam.left ) / this.shadowMapSize;\n\t\t\tconst texelHeight = ( shadowCam.top - shadowCam.bottom ) / this.shadowMapSize;\n\t\t\t_cameraToLightMatrix.multiplyMatrices( _lightOrientationMatrixInverse, camera.matrixWorld );\n\t\t\tfrustums[ i ].toSpace( _cameraToLightMatrix, _lightSpaceFrustum );\n\n\t\t\tconst nearVerts = _lightSpaceFrustum.vertices.near;\n\t\t\tconst farVerts = _lightSpaceFrustum.vertices.far;\n\t\t\t_bbox.makeEmpty();\n\t\t\tfor ( let j = 0; j < 4; j ++ ) {\n\n\t\t\t\t_bbox.expandByPoint( nearVerts[ j ] );\n\t\t\t\t_bbox.expandByPoint( farVerts[ j ] );\n\n\t\t\t}\n\n\t\t\t_bbox.getCenter( _center );\n\t\t\t_center.z = _bbox.max.z + this.lightMargin;\n\t\t\t_center.x = Math.floor( _center.x / texelWidth ) * texelWidth;\n\t\t\t_center.y = Math.floor( _center.y / texelHeight ) * texelHeight;\n\t\t\t_center.applyMatrix4( _lightOrientationMatrix );\n\n\t\t\tlight.position.copy( _center );\n\t\t\tlight.target.position.copy( _center );\n\n\t\t\tlight.target.position.x += this.lightDirection.x;\n\t\t\tlight.target.position.y += this.lightDirection.y;\n\t\t\tlight.target.position.z += this.lightDirection.z;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Injects the CSM shader enhancements into the built-in materials.\n\t *\n\t * @private\n\t */\n\t_injectInclude() {\n\n\t\tShaderChunk.lights_fragment_begin = CSMShader.lights_fragment_begin;\n\t\tShaderChunk.lights_pars_begin = CSMShader.lights_pars_begin;\n\n\t}\n\n\t/**\n\t * Applications must call this method for all materials that should be affected by CSM.\n\t *\n\t * @param {Material} material - The material to setup for CSM support.\n\t */\n\tsetupMaterial( material ) {\n\n\t\tmaterial.defines = material.defines || {};\n\t\tmaterial.defines.USE_CSM = 1;\n\t\tmaterial.defines.CSM_CASCADES = this.cascades;\n\n\t\tif ( this.fade ) {\n\n\t\t\tmaterial.defines.CSM_FADE = '';\n\n\t\t}\n\n\t\tconst breaksVec2 = [];\n\t\tconst scope = this;\n\t\tconst shaders = this.shaders;\n\n\t\tmaterial.onBeforeCompile = function ( shader ) {\n\n\t\t\tconst far = Math.min( scope.camera.far, scope.maxFar );\n\t\t\tscope._getExtendedBreaks( breaksVec2 );\n\n\t\t\tshader.uniforms.CSM_cascades = { value: breaksVec2 };\n\t\t\tshader.uniforms.cameraNear = { value: scope.camera.near };\n\t\t\tshader.uniforms.shadowFar = { value: far };\n\n\t\t\tshaders.set( material, shader );\n\n\t\t};\n\n\t\tshaders.set( material, null );\n\n\t}\n\n\t/**\n\t * Updates the CSM uniforms.\n\t *\n\t * @private\n\t */\n\t_updateUniforms() {\n\n\t\tconst far = Math.min( this.camera.far, this.maxFar );\n\t\tconst shaders = this.shaders;\n\n\t\tshaders.forEach( function ( shader, material ) {\n\n\t\t\tif ( shader !== null ) {\n\n\t\t\t\tconst uniforms = shader.uniforms;\n\t\t\t\tthis._getExtendedBreaks( uniforms.CSM_cascades.value );\n\t\t\t\tuniforms.cameraNear.value = this.camera.near;\n\t\t\t\tuniforms.shadowFar.value = far;\n\n\t\t\t}\n\n\t\t\tif ( ! this.fade && 'CSM_FADE' in material.defines ) {\n\n\t\t\t\tdelete material.defines.CSM_FADE;\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t} else if ( this.fade && ! ( 'CSM_FADE' in material.defines ) ) {\n\n\t\t\t\tmaterial.defines.CSM_FADE = '';\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}, this );\n\n\t}\n\n\t/**\n\t * Computes the extended breaks for the CSM uniforms.\n\t *\n\t * @private\n\t * @param {Array<Vector2>} target - The target array that holds the extended breaks.\n\t */\n\t_getExtendedBreaks( target ) {\n\n\t\twhile ( target.length < this.breaks.length ) {\n\n\t\t\ttarget.push( new Vector2() );\n\n\t\t}\n\n\t\ttarget.length = this.breaks.length;\n\n\t\tfor ( let i = 0; i < this.cascades; i ++ ) {\n\n\t\t\tconst amount = this.breaks[ i ];\n\t\t\tconst prev = this.breaks[ i - 1 ] || 0;\n\t\t\ttarget[ i ].x = prev;\n\t\t\ttarget[ i ].y = amount;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Applications must call this method every time they change camera or CSM settings.\n\t */\n\tupdateFrustums() {\n\n\t\tthis._getBreaks();\n\t\tthis._initCascades();\n\t\tthis._updateShadowBounds();\n\t\tthis._updateUniforms();\n\n\t}\n\n\t/**\n\t * Applications must call this method when they remove the CSM usage from their scene.\n\t */\n\tremove() {\n\n\t\tfor ( let i = 0; i < this.lights.length; i ++ ) {\n\n\t\t\tthis.parent.remove( this.lights[ i ].target );\n\t\t\tthis.parent.remove( this.lights[ i ] );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever this instance is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tconst shaders = this.shaders;\n\t\tshaders.forEach( function ( shader, material ) {\n\n\t\t\tdelete material.onBeforeCompile;\n\t\t\tdelete material.defines.USE_CSM;\n\t\t\tdelete material.defines.CSM_CASCADES;\n\t\t\tdelete material.defines.CSM_FADE;\n\n\t\t\tif ( shader !== null ) {\n\n\t\t\t\tdelete shader.uniforms.CSM_cascades;\n\t\t\t\tdelete shader.uniforms.cameraNear;\n\t\t\t\tdelete shader.uniforms.shadowFar;\n\n\t\t\t}\n\n\t\t\tmaterial.needsUpdate = true;\n\n\t\t} );\n\t\tshaders.clear();\n\n\t}\n\n}\n\n/**\n * Constructor data of `CSM`.\n *\n * @typedef {Object} CSM~Data\n * @property {Camera} camera - The scene's camera.\n * @property {Object3D} parent - The parent object, usually the scene.\n * @property {number} [cascades=3] - The number of cascades.\n * @property {number} [maxFar=100000] - The maximum far value.\n * @property {('practical'|'uniform'|'logarithmic'|'custom')} [mode='practical'] - The frustum split mode.\n * @property {Function} [customSplitsCallback] - Custom split callback when using `mode='custom'`.\n * @property {number} [shadowMapSize=2048] - The shadow map size.\n * @property {number} [shadowBias=0.000001] - The shadow bias.\n * @property {Vector3} [lightDirection] - The light direction.\n * @property {number} [lightIntensity=3] - The light intensity.\n * @property {number} [lightNear=1] - The light near value.\n * @property {number} [lightNear=2000] - The light far value.\n * @property {number} [lightMargin=200] - The light margin.\n **/\n"],"mappings":"AAAA,SACCA,OAAO,EACPC,OAAO,EACPC,gBAAgB,EAChBC,SAAS,EACTC,WAAW,EACXC,OAAO,EACPC,IAAI,QACE,OAAO;AACd,SAASC,UAAU,QAAQ,iBAAiB;AAC5C,SAASC,SAAS,QAAQ,gBAAgB;AAE1C,MAAMC,oBAAoB,GAAG,IAAIJ,OAAO,CAAC,CAAC;AAC1C,MAAMK,kBAAkB,GAAG,IAAIH,UAAU,CAAE;EAAEI,KAAK,EAAE;AAAK,CAAE,CAAC;AAC5D,MAAMC,OAAO,GAAG,IAAIX,OAAO,CAAC,CAAC;AAC7B,MAAMY,KAAK,GAAG,IAAIP,IAAI,CAAC,CAAC;AACxB,MAAMQ,aAAa,GAAG,EAAE;AACxB,MAAMC,SAAS,GAAG,EAAE;AACpB,MAAMC,uBAAuB,GAAG,IAAIX,OAAO,CAAC,CAAC;AAC7C,MAAMY,8BAA8B,GAAG,IAAIZ,OAAO,CAAC,CAAC;AACpD,MAAMa,GAAG,GAAG,IAAIjB,OAAO,CAAE,CAAC,EAAE,CAAC,EAAE,CAAE,CAAC;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMkB,GAAG,CAAC;EAEhB;AACD;AACA;AACA;AACA;EACCC,WAAWA,CAAEC,IAAI,EAAG;IAEnB;AACF;AACA;AACA;AACA;IACE,IAAI,CAACC,MAAM,GAAGD,IAAI,CAACC,MAAM;;IAEzB;AACF;AACA;AACA;AACA;IACE,IAAI,CAACC,MAAM,GAAGF,IAAI,CAACE,MAAM;;IAEzB;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,QAAQ,GAAGH,IAAI,CAACG,QAAQ,IAAI,CAAC;;IAElC;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,MAAM,GAAGJ,IAAI,CAACI,MAAM,IAAI,MAAM;;IAEnC;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,IAAI,GAAGL,IAAI,CAACK,IAAI,IAAI,WAAW;;IAEpC;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,aAAa,GAAGN,IAAI,CAACM,aAAa,IAAI,IAAI;;IAE/C;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,UAAU,GAAGP,IAAI,CAACO,UAAU,IAAI,QAAQ;;IAE7C;AACF;AACA;AACA;AACA;IACE,IAAI,CAACC,cAAc,GAAGR,IAAI,CAACQ,cAAc,IAAI,IAAI5B,OAAO,CAAE,CAAC,EAAE,CAAE,CAAC,EAAE,CAAE,CAAC,CAAC6B,SAAS,CAAC,CAAC;;IAEjF;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,cAAc,GAAGV,IAAI,CAACU,cAAc,IAAI,CAAC;;IAE9C;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,SAAS,GAAGX,IAAI,CAACW,SAAS,IAAI,CAAC;;IAEpC;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,QAAQ,GAAGZ,IAAI,CAACY,QAAQ,IAAI,IAAI;;IAErC;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,WAAW,GAAGb,IAAI,CAACa,WAAW,IAAI,GAAG;;IAE1C;AACF;AACA;AACA;AACA;IACE,IAAI,CAACC,oBAAoB,GAAGd,IAAI,CAACc,oBAAoB;;IAErD;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,IAAI,GAAG,KAAK;;IAEjB;AACF;AACA;AACA;AACA;IACE,IAAI,CAACC,WAAW,GAAG,IAAI9B,UAAU,CAAE;MAAEI,KAAK,EAAE;IAAK,CAAE,CAAC;;IAEpD;AACF;AACA;AACA;AACA;IACE,IAAI,CAAC2B,QAAQ,GAAG,EAAE;;IAElB;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,MAAM,GAAG,EAAE;;IAEhB;AACF;AACA;AACA;AACA;AACA;AACA;IACE,IAAI,CAACC,MAAM,GAAG,EAAE;;IAEhB;AACF;AACA;AACA;AACA;IACE,IAAI,CAACC,OAAO,GAAG,IAAIC,GAAG,CAAC,CAAC;IAExB,IAAI,CAACC,aAAa,CAAC,CAAC;IACpB,IAAI,CAACC,cAAc,CAAC,CAAC;IACrB,IAAI,CAACC,cAAc,CAAC,CAAC;EAEtB;;EAEA;AACD;AACA;AACA;AACA;EACCF,aAAaA,CAAA,EAAG;IAEf,KAAM,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACtB,QAAQ,EAAEsB,CAAC,EAAG,EAAG;MAE1C,MAAMC,KAAK,GAAG,IAAI7C,gBAAgB,CAAE,QAAQ,EAAE,IAAI,CAAC6B,cAAe,CAAC;MACnEgB,KAAK,CAACC,UAAU,GAAG,IAAI;MACvBD,KAAK,CAACE,MAAM,CAACC,OAAO,CAACC,KAAK,GAAG,IAAI,CAACxB,aAAa;MAC/CoB,KAAK,CAACE,MAAM,CAACC,OAAO,CAACE,MAAM,GAAG,IAAI,CAACzB,aAAa;MAEhDoB,KAAK,CAACE,MAAM,CAAC3B,MAAM,CAAC+B,IAAI,GAAG,IAAI,CAACrB,SAAS;MACzCe,KAAK,CAACE,MAAM,CAAC3B,MAAM,CAACgC,GAAG,GAAG,IAAI,CAACrB,QAAQ;MACvCc,KAAK,CAACE,MAAM,CAACM,IAAI,GAAG,IAAI,CAAC3B,UAAU;MAEnC,IAAI,CAACL,MAAM,CAACiC,GAAG,CAAET,KAAM,CAAC;MACxB,IAAI,CAACxB,MAAM,CAACiC,GAAG,CAAET,KAAK,CAACU,MAAO,CAAC;MAC/B,IAAI,CAACjB,MAAM,CAACkB,IAAI,CAAEX,KAAM,CAAC;IAE1B;EAED;;EAEA;AACD;AACA;AACA;AACA;EACCY,aAAaA,CAAA,EAAG;IAEf,MAAMrC,MAAM,GAAG,IAAI,CAACA,MAAM;IAC1BA,MAAM,CAACsC,sBAAsB,CAAC,CAAC;IAC/B,IAAI,CAACvB,WAAW,CAACwB,uBAAuB,CAAEvC,MAAM,CAACwC,gBAAgB,EAAE,IAAI,CAACrC,MAAO,CAAC;IAChF,IAAI,CAACY,WAAW,CAAC0B,KAAK,CAAE,IAAI,CAACxB,MAAM,EAAE,IAAI,CAACD,QAAS,CAAC;EAErD;;EAEA;AACD;AACA;AACA;AACA;EACC0B,mBAAmBA,CAAA,EAAG;IAErB,MAAM1B,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC9B,KAAM,IAAIQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,QAAQ,CAAC2B,MAAM,EAAEnB,CAAC,EAAG,EAAG;MAE5C,MAAMC,KAAK,GAAG,IAAI,CAACP,MAAM,CAAEM,CAAC,CAAE;MAC9B,MAAMoB,SAAS,GAAGnB,KAAK,CAACE,MAAM,CAAC3B,MAAM;MACrC,MAAM6C,OAAO,GAAG,IAAI,CAAC7B,QAAQ,CAAEQ,CAAC,CAAE;;MAElC;MACA;MACA;MACA,MAAMsB,SAAS,GAAGD,OAAO,CAACE,QAAQ,CAAChB,IAAI;MACvC,MAAMiB,QAAQ,GAAGH,OAAO,CAACE,QAAQ,CAACf,GAAG;MACrC,MAAMiB,MAAM,GAAGD,QAAQ,CAAE,CAAC,CAAE;MAC5B,IAAIE,MAAM;MACV,IAAKD,MAAM,CAACE,UAAU,CAAEH,QAAQ,CAAE,CAAC,CAAG,CAAC,GAAGC,MAAM,CAACE,UAAU,CAAEL,SAAS,CAAE,CAAC,CAAG,CAAC,EAAG;QAE/EI,MAAM,GAAGF,QAAQ,CAAE,CAAC,CAAE;MAEvB,CAAC,MAAM;QAENE,MAAM,GAAGJ,SAAS,CAAE,CAAC,CAAE;MAExB;MAEA,IAAIM,cAAc,GAAGH,MAAM,CAACE,UAAU,CAAED,MAAO,CAAC;MAChD,IAAK,IAAI,CAACpC,IAAI,EAAG;QAEhB;QACA,MAAMd,MAAM,GAAG,IAAI,CAACA,MAAM;QAC1B,MAAMgC,GAAG,GAAGqB,IAAI,CAACC,GAAG,CAAEtD,MAAM,CAACgC,GAAG,EAAE,IAAI,CAAC7B,MAAO,CAAC;QAC/C,MAAMoD,WAAW,GAAGV,OAAO,CAACE,QAAQ,CAACf,GAAG,CAAE,CAAC,CAAE,CAACwB,CAAC,IAAKxB,GAAG,GAAGhC,MAAM,CAAC+B,IAAI,CAAE;QACvE,MAAM0B,MAAM,GAAG,IAAI,GAAGJ,IAAI,CAACK,GAAG,CAAEH,WAAW,EAAE,GAAI,CAAC,IAAKvB,GAAG,GAAGhC,MAAM,CAAC+B,IAAI,CAAE;QAE1EqB,cAAc,IAAIK,MAAM;MAEzB;MAEAb,SAAS,CAACe,IAAI,GAAG,CAAEP,cAAc,GAAG,CAAC;MACrCR,SAAS,CAACgB,KAAK,GAAGR,cAAc,GAAG,CAAC;MACpCR,SAAS,CAACiB,GAAG,GAAGT,cAAc,GAAG,CAAC;MAClCR,SAAS,CAACkB,MAAM,GAAG,CAAEV,cAAc,GAAG,CAAC;MACvCR,SAAS,CAACN,sBAAsB,CAAC,CAAC;IAEnC;EAED;;EAEA;AACD;AACA;AACA;AACA;AACA;EACCyB,UAAUA,CAAA,EAAG;IAEZ,MAAM/D,MAAM,GAAG,IAAI,CAACA,MAAM;IAC1B,MAAMgC,GAAG,GAAGqB,IAAI,CAACW,GAAG,CAAEhE,MAAM,CAACgC,GAAG,EAAE,IAAI,CAAC7B,MAAO,CAAC;IAC/C,IAAI,CAACc,MAAM,CAAC0B,MAAM,GAAG,CAAC;IAEtB,QAAS,IAAI,CAACvC,IAAI;MAEjB,KAAK,SAAS;QACb6D,YAAY,CAAE,IAAI,CAAC/D,QAAQ,EAAEF,MAAM,CAAC+B,IAAI,EAAEC,GAAG,EAAE,IAAI,CAACf,MAAO,CAAC;QAC5D;MACD,KAAK,aAAa;QACjBiD,gBAAgB,CAAE,IAAI,CAAChE,QAAQ,EAAEF,MAAM,CAAC+B,IAAI,EAAEC,GAAG,EAAE,IAAI,CAACf,MAAO,CAAC;QAChE;MACD,KAAK,WAAW;QACfkD,cAAc,CAAE,IAAI,CAACjE,QAAQ,EAAEF,MAAM,CAAC+B,IAAI,EAAEC,GAAG,EAAE,GAAG,EAAE,IAAI,CAACf,MAAO,CAAC;QACnE;MACD,KAAK,QAAQ;QACZ,IAAK,IAAI,CAACJ,oBAAoB,KAAKuD,SAAS,EAAGC,OAAO,CAACC,KAAK,CAAE,gDAAiD,CAAC;QAChH,IAAI,CAACzD,oBAAoB,CAAE,IAAI,CAACX,QAAQ,EAAEF,MAAM,CAAC+B,IAAI,EAAEC,GAAG,EAAE,IAAI,CAACf,MAAO,CAAC;QACzE;IAEF;IAEA,SAASgD,YAAYA,CAAEM,MAAM,EAAExC,IAAI,EAAEC,GAAG,EAAEG,MAAM,EAAG;MAElD,KAAM,IAAIX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+C,MAAM,EAAE/C,CAAC,EAAG,EAAG;QAEnCW,MAAM,CAACC,IAAI,CAAE,CAAEL,IAAI,GAAG,CAAEC,GAAG,GAAGD,IAAI,IAAKP,CAAC,GAAG+C,MAAM,IAAKvC,GAAI,CAAC;MAE5D;MAEAG,MAAM,CAACC,IAAI,CAAE,CAAE,CAAC;IAEjB;IAEA,SAAS8B,gBAAgBA,CAAEK,MAAM,EAAExC,IAAI,EAAEC,GAAG,EAAEG,MAAM,EAAG;MAEtD,KAAM,IAAIX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+C,MAAM,EAAE/C,CAAC,EAAG,EAAG;QAEnCW,MAAM,CAACC,IAAI,CAAIL,IAAI,GAAG,CAAEC,GAAG,GAAGD,IAAI,MAAQP,CAAC,GAAG+C,MAAM,CAAE,GAAKvC,GAAI,CAAC;MAEjE;MAEAG,MAAM,CAACC,IAAI,CAAE,CAAE,CAAC;IAEjB;IAEA,SAAS+B,cAAcA,CAAEI,MAAM,EAAExC,IAAI,EAAEC,GAAG,EAAEwC,MAAM,EAAErC,MAAM,EAAG;MAE5D3C,aAAa,CAACmD,MAAM,GAAG,CAAC;MACxBlD,SAAS,CAACkD,MAAM,GAAG,CAAC;MACpBuB,gBAAgB,CAAEK,MAAM,EAAExC,IAAI,EAAEC,GAAG,EAAEvC,SAAU,CAAC;MAChDwE,YAAY,CAAEM,MAAM,EAAExC,IAAI,EAAEC,GAAG,EAAExC,aAAc,CAAC;MAEhD,KAAM,IAAIgC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+C,MAAM,EAAE/C,CAAC,EAAG,EAAG;QAEnCW,MAAM,CAACC,IAAI,CAAEvD,SAAS,CAAC4F,IAAI,CAAEjF,aAAa,CAAEgC,CAAC,GAAG,CAAC,CAAE,EAAE/B,SAAS,CAAE+B,CAAC,GAAG,CAAC,CAAE,EAAEgD,MAAO,CAAE,CAAC;MAEpF;MAEArC,MAAM,CAACC,IAAI,CAAE,CAAE,CAAC;IAEjB;EAED;;EAEA;AACD;AACA;AACA;EACCsC,MAAMA,CAAA,EAAG;IAER,MAAM1E,MAAM,GAAG,IAAI,CAACA,MAAM;IAC1B,MAAMgB,QAAQ,GAAG,IAAI,CAACA,QAAQ;;IAE9B;IACA;IACAtB,uBAAuB,CAACiF,MAAM,CAAE,IAAIhG,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC4B,cAAc,EAAEX,GAAI,CAAC;IACzED,8BAA8B,CAACiF,IAAI,CAAElF,uBAAwB,CAAC,CAACmF,MAAM,CAAC,CAAC;IAEvE,KAAM,IAAIrD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,QAAQ,CAAC2B,MAAM,EAAEnB,CAAC,EAAG,EAAG;MAE5C,MAAMC,KAAK,GAAG,IAAI,CAACP,MAAM,CAAEM,CAAC,CAAE;MAC9B,MAAMoB,SAAS,GAAGnB,KAAK,CAACE,MAAM,CAAC3B,MAAM;MACrC,MAAM8E,UAAU,GAAG,CAAElC,SAAS,CAACgB,KAAK,GAAGhB,SAAS,CAACe,IAAI,IAAK,IAAI,CAACtD,aAAa;MAC5E,MAAM0E,WAAW,GAAG,CAAEnC,SAAS,CAACiB,GAAG,GAAGjB,SAAS,CAACkB,MAAM,IAAK,IAAI,CAACzD,aAAa;MAC7ElB,oBAAoB,CAAC6F,gBAAgB,CAAErF,8BAA8B,EAAEK,MAAM,CAACiF,WAAY,CAAC;MAC3FjE,QAAQ,CAAEQ,CAAC,CAAE,CAAC0D,OAAO,CAAE/F,oBAAoB,EAAEC,kBAAmB,CAAC;MAEjE,MAAM0D,SAAS,GAAG1D,kBAAkB,CAAC2D,QAAQ,CAAChB,IAAI;MAClD,MAAMiB,QAAQ,GAAG5D,kBAAkB,CAAC2D,QAAQ,CAACf,GAAG;MAChDzC,KAAK,CAAC4F,SAAS,CAAC,CAAC;MACjB,KAAM,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAG,EAAG;QAE9B7F,KAAK,CAAC8F,aAAa,CAAEvC,SAAS,CAAEsC,CAAC,CAAG,CAAC;QACrC7F,KAAK,CAAC8F,aAAa,CAAErC,QAAQ,CAAEoC,CAAC,CAAG,CAAC;MAErC;MAEA7F,KAAK,CAAC+F,SAAS,CAAEhG,OAAQ,CAAC;MAC1BA,OAAO,CAACkE,CAAC,GAAGjE,KAAK,CAAC+D,GAAG,CAACE,CAAC,GAAG,IAAI,CAAC5C,WAAW;MAC1CtB,OAAO,CAACiG,CAAC,GAAGlC,IAAI,CAACmC,KAAK,CAAElG,OAAO,CAACiG,CAAC,GAAGT,UAAW,CAAC,GAAGA,UAAU;MAC7DxF,OAAO,CAACmG,CAAC,GAAGpC,IAAI,CAACmC,KAAK,CAAElG,OAAO,CAACmG,CAAC,GAAGV,WAAY,CAAC,GAAGA,WAAW;MAC/DzF,OAAO,CAACoG,YAAY,CAAEhG,uBAAwB,CAAC;MAE/C+B,KAAK,CAACkE,QAAQ,CAACf,IAAI,CAAEtF,OAAQ,CAAC;MAC9BmC,KAAK,CAACU,MAAM,CAACwD,QAAQ,CAACf,IAAI,CAAEtF,OAAQ,CAAC;MAErCmC,KAAK,CAACU,MAAM,CAACwD,QAAQ,CAACJ,CAAC,IAAI,IAAI,CAAChF,cAAc,CAACgF,CAAC;MAChD9D,KAAK,CAACU,MAAM,CAACwD,QAAQ,CAACF,CAAC,IAAI,IAAI,CAAClF,cAAc,CAACkF,CAAC;MAChDhE,KAAK,CAACU,MAAM,CAACwD,QAAQ,CAACnC,CAAC,IAAI,IAAI,CAACjD,cAAc,CAACiD,CAAC;IAEjD;EAED;;EAEA;AACD;AACA;AACA;AACA;EACCjC,cAAcA,CAAA,EAAG;IAEhBzC,WAAW,CAAC8G,qBAAqB,GAAG1G,SAAS,CAAC0G,qBAAqB;IACnE9G,WAAW,CAAC+G,iBAAiB,GAAG3G,SAAS,CAAC2G,iBAAiB;EAE5D;;EAEA;AACD;AACA;AACA;AACA;EACCC,aAAaA,CAAEC,QAAQ,EAAG;IAEzBA,QAAQ,CAACC,OAAO,GAAGD,QAAQ,CAACC,OAAO,IAAI,CAAC,CAAC;IACzCD,QAAQ,CAACC,OAAO,CAACC,OAAO,GAAG,CAAC;IAC5BF,QAAQ,CAACC,OAAO,CAACE,YAAY,GAAG,IAAI,CAAChG,QAAQ;IAE7C,IAAK,IAAI,CAACY,IAAI,EAAG;MAEhBiF,QAAQ,CAACC,OAAO,CAACG,QAAQ,GAAG,EAAE;IAE/B;IAEA,MAAMC,UAAU,GAAG,EAAE;IACrB,MAAMC,KAAK,GAAG,IAAI;IAClB,MAAMlF,OAAO,GAAG,IAAI,CAACA,OAAO;IAE5B4E,QAAQ,CAACO,eAAe,GAAG,UAAWC,MAAM,EAAG;MAE9C,MAAMvE,GAAG,GAAGqB,IAAI,CAACW,GAAG,CAAEqC,KAAK,CAACrG,MAAM,CAACgC,GAAG,EAAEqE,KAAK,CAAClG,MAAO,CAAC;MACtDkG,KAAK,CAACG,kBAAkB,CAAEJ,UAAW,CAAC;MAEtCG,MAAM,CAACE,QAAQ,CAACC,YAAY,GAAG;QAAEC,KAAK,EAAEP;MAAW,CAAC;MACpDG,MAAM,CAACE,QAAQ,CAACG,UAAU,GAAG;QAAED,KAAK,EAAEN,KAAK,CAACrG,MAAM,CAAC+B;MAAK,CAAC;MACzDwE,MAAM,CAACE,QAAQ,CAACI,SAAS,GAAG;QAAEF,KAAK,EAAE3E;MAAI,CAAC;MAE1Cb,OAAO,CAAC2F,GAAG,CAAEf,QAAQ,EAAEQ,MAAO,CAAC;IAEhC,CAAC;IAEDpF,OAAO,CAAC2F,GAAG,CAAEf,QAAQ,EAAE,IAAK,CAAC;EAE9B;;EAEA;AACD;AACA;AACA;AACA;EACCgB,eAAeA,CAAA,EAAG;IAEjB,MAAM/E,GAAG,GAAGqB,IAAI,CAACW,GAAG,CAAE,IAAI,CAAChE,MAAM,CAACgC,GAAG,EAAE,IAAI,CAAC7B,MAAO,CAAC;IACpD,MAAMgB,OAAO,GAAG,IAAI,CAACA,OAAO;IAE5BA,OAAO,CAAC6F,OAAO,CAAE,UAAWT,MAAM,EAAER,QAAQ,EAAG;MAE9C,IAAKQ,MAAM,KAAK,IAAI,EAAG;QAEtB,MAAME,QAAQ,GAAGF,MAAM,CAACE,QAAQ;QAChC,IAAI,CAACD,kBAAkB,CAAEC,QAAQ,CAACC,YAAY,CAACC,KAAM,CAAC;QACtDF,QAAQ,CAACG,UAAU,CAACD,KAAK,GAAG,IAAI,CAAC3G,MAAM,CAAC+B,IAAI;QAC5C0E,QAAQ,CAACI,SAAS,CAACF,KAAK,GAAG3E,GAAG;MAE/B;MAEA,IAAK,CAAE,IAAI,CAAClB,IAAI,IAAI,UAAU,IAAIiF,QAAQ,CAACC,OAAO,EAAG;QAEpD,OAAOD,QAAQ,CAACC,OAAO,CAACG,QAAQ;QAChCJ,QAAQ,CAACkB,WAAW,GAAG,IAAI;MAE5B,CAAC,MAAM,IAAK,IAAI,CAACnG,IAAI,IAAI,EAAI,UAAU,IAAIiF,QAAQ,CAACC,OAAO,CAAE,EAAG;QAE/DD,QAAQ,CAACC,OAAO,CAACG,QAAQ,GAAG,EAAE;QAC9BJ,QAAQ,CAACkB,WAAW,GAAG,IAAI;MAE5B;IAED,CAAC,EAAE,IAAK,CAAC;EAEV;;EAEA;AACD;AACA;AACA;AACA;AACA;EACCT,kBAAkBA,CAAErE,MAAM,EAAG;IAE5B,OAAQA,MAAM,CAACQ,MAAM,GAAG,IAAI,CAAC1B,MAAM,CAAC0B,MAAM,EAAG;MAE5CR,MAAM,CAACC,IAAI,CAAE,IAAI1D,OAAO,CAAC,CAAE,CAAC;IAE7B;IAEAyD,MAAM,CAACQ,MAAM,GAAG,IAAI,CAAC1B,MAAM,CAAC0B,MAAM;IAElC,KAAM,IAAInB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACtB,QAAQ,EAAEsB,CAAC,EAAG,EAAG;MAE1C,MAAM+C,MAAM,GAAG,IAAI,CAACtD,MAAM,CAAEO,CAAC,CAAE;MAC/B,MAAM0F,IAAI,GAAG,IAAI,CAACjG,MAAM,CAAEO,CAAC,GAAG,CAAC,CAAE,IAAI,CAAC;MACtCW,MAAM,CAAEX,CAAC,CAAE,CAAC+D,CAAC,GAAG2B,IAAI;MACpB/E,MAAM,CAAEX,CAAC,CAAE,CAACiE,CAAC,GAAGlB,MAAM;IAEvB;EAED;;EAEA;AACD;AACA;EACCjD,cAAcA,CAAA,EAAG;IAEhB,IAAI,CAACyC,UAAU,CAAC,CAAC;IACjB,IAAI,CAAC1B,aAAa,CAAC,CAAC;IACpB,IAAI,CAACK,mBAAmB,CAAC,CAAC;IAC1B,IAAI,CAACqE,eAAe,CAAC,CAAC;EAEvB;;EAEA;AACD;AACA;EACCI,MAAMA,CAAA,EAAG;IAER,KAAM,IAAI3F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACN,MAAM,CAACyB,MAAM,EAAEnB,CAAC,EAAG,EAAG;MAE/C,IAAI,CAACvB,MAAM,CAACkH,MAAM,CAAE,IAAI,CAACjG,MAAM,CAAEM,CAAC,CAAE,CAACW,MAAO,CAAC;MAC7C,IAAI,CAAClC,MAAM,CAACkH,MAAM,CAAE,IAAI,CAACjG,MAAM,CAAEM,CAAC,CAAG,CAAC;IAEvC;EAED;;EAEA;AACD;AACA;AACA;EACC4F,OAAOA,CAAA,EAAG;IAET,MAAMjG,OAAO,GAAG,IAAI,CAACA,OAAO;IAC5BA,OAAO,CAAC6F,OAAO,CAAE,UAAWT,MAAM,EAAER,QAAQ,EAAG;MAE9C,OAAOA,QAAQ,CAACO,eAAe;MAC/B,OAAOP,QAAQ,CAACC,OAAO,CAACC,OAAO;MAC/B,OAAOF,QAAQ,CAACC,OAAO,CAACE,YAAY;MACpC,OAAOH,QAAQ,CAACC,OAAO,CAACG,QAAQ;MAEhC,IAAKI,MAAM,KAAK,IAAI,EAAG;QAEtB,OAAOA,MAAM,CAACE,QAAQ,CAACC,YAAY;QACnC,OAAOH,MAAM,CAACE,QAAQ,CAACG,UAAU;QACjC,OAAOL,MAAM,CAACE,QAAQ,CAACI,SAAS;MAEjC;MAEAd,QAAQ,CAACkB,WAAW,GAAG,IAAI;IAE5B,CAAE,CAAC;IACH9F,OAAO,CAACkG,KAAK,CAAC,CAAC;EAEhB;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}