{"ast":null,"code":"import { Matrix4, Vector2 } from 'three';\n\n/**\n * @module SAOShader\n * @three_import import { SAOShader } from 'three/addons/shaders/SAOShader.js';\n */\n\n/**\n * SAO shader.\n *\n * Used by {@link SAOPass}.\n *\n * @constant\n * @type {ShaderMaterial~Shader}\n */\nconst SAOShader = {\n  name: 'SAOShader',\n  defines: {\n    'NUM_SAMPLES': 7,\n    'NUM_RINGS': 4,\n    'DIFFUSE_TEXTURE': 0,\n    'PERSPECTIVE_CAMERA': 1\n  },\n  uniforms: {\n    'tDepth': {\n      value: null\n    },\n    'tDiffuse': {\n      value: null\n    },\n    'tNormal': {\n      value: null\n    },\n    'size': {\n      value: new Vector2(512, 512)\n    },\n    'cameraNear': {\n      value: 1\n    },\n    'cameraFar': {\n      value: 100\n    },\n    'cameraProjectionMatrix': {\n      value: new Matrix4()\n    },\n    'cameraInverseProjectionMatrix': {\n      value: new Matrix4()\n    },\n    'scale': {\n      value: 1.0\n    },\n    'intensity': {\n      value: 0.1\n    },\n    'bias': {\n      value: 0.5\n    },\n    'minResolution': {\n      value: 0.0\n    },\n    'kernelRadius': {\n      value: 100.0\n    },\n    'randomSeed': {\n      value: 0.0\n    }\n  },\n  vertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}`,\n  fragmentShader: /* glsl */`\n\t\t#include <common>\n\n\t\tvarying vec2 vUv;\n\n\t\t#if DIFFUSE_TEXTURE == 1\n\t\tuniform sampler2D tDiffuse;\n\t\t#endif\n\n\t\tuniform highp sampler2D tDepth;\n\t\tuniform highp sampler2D tNormal;\n\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tuniform mat4 cameraProjectionMatrix;\n\t\tuniform mat4 cameraInverseProjectionMatrix;\n\n\t\tuniform float scale;\n\t\tuniform float intensity;\n\t\tuniform float bias;\n\t\tuniform float kernelRadius;\n\t\tuniform float minResolution;\n\t\tuniform vec2 size;\n\t\tuniform float randomSeed;\n\n\t\t// RGBA depth\n\n\t\t#include <packing>\n\n\t\tvec4 getDefaultColor( const in vec2 screenPosition ) {\n\t\t\t#if DIFFUSE_TEXTURE == 1\n\t\t\treturn texture2D( tDiffuse, vUv );\n\t\t\t#else\n\t\t\treturn vec4( 1.0 );\n\t\t\t#endif\n\t\t}\n\n\t\tfloat getDepth( const in vec2 screenPosition ) {\n\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\t\t}\n\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#else\n\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#endif\n\t\t}\n\n\t\tvec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\n\t\t\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n\t\t\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\n\t\t\tclipPosition *= clipW; // unprojection.\n\n\t\t\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\n\t\t}\n\n\t\tvec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {\n\t\t\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\n\t\t}\n\n\t\tfloat scaleDividedByCameraFar;\n\t\tfloat minResolutionMultipliedByCameraFar;\n\n\t\tfloat getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {\n\t\t\tvec3 viewDelta = sampleViewPosition - centerViewPosition;\n\t\t\tfloat viewDistance = length( viewDelta );\n\t\t\tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;\n\n\t\t\treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );\n\t\t}\n\n\t\t// moving costly divides into consts\n\t\tconst float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\n\t\tconst float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\n\n\t\tfloat getAmbientOcclusion( const in vec3 centerViewPosition ) {\n\t\t\t// precompute some variables require in getOcclusion.\n\t\t\tscaleDividedByCameraFar = scale / cameraFar;\n\t\t\tminResolutionMultipliedByCameraFar = minResolution * cameraFar;\n\t\t\tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );\n\n\t\t\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\n\t\t\tfloat angle = rand( vUv + randomSeed ) * PI2;\n\t\t\tvec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;\n\t\t\tvec2 radiusStep = radius;\n\n\t\t\tfloat occlusionSum = 0.0;\n\t\t\tfloat weightSum = 0.0;\n\n\t\t\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\n\t\t\t\tvec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;\n\t\t\t\tradius += radiusStep;\n\t\t\t\tangle += ANGLE_STEP;\n\n\t\t\t\tfloat sampleDepth = getDepth( sampleUv );\n\t\t\t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfloat sampleViewZ = getViewZ( sampleDepth );\n\t\t\t\tvec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );\n\t\t\t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );\n\t\t\t\tweightSum += 1.0;\n\t\t\t}\n\n\t\t\tif( weightSum == 0.0 ) discard;\n\n\t\t\treturn occlusionSum * ( intensity / weightSum );\n\t\t}\n\n\t\tvoid main() {\n\t\t\tfloat centerDepth = getDepth( vUv );\n\t\t\tif( centerDepth >= ( 1.0 - EPSILON ) ) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t\tfloat centerViewZ = getViewZ( centerDepth );\n\t\t\tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );\n\n\t\t\tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );\n\n\t\t\tgl_FragColor = getDefaultColor( vUv );\n\t\t\tgl_FragColor.xyz *=  1.0 - ambientOcclusion;\n\t\t}`\n};\nexport { SAOShader };","map":{"version":3,"names":["Matrix4","Vector2","SAOShader","name","defines","uniforms","value","vertexShader","fragmentShader"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/shaders/SAOShader.js"],"sourcesContent":["import {\n\tMatrix4,\n\tVector2\n} from 'three';\n\n/**\n * @module SAOShader\n * @three_import import { SAOShader } from 'three/addons/shaders/SAOShader.js';\n */\n\n/**\n * SAO shader.\n *\n * Used by {@link SAOPass}.\n *\n * @constant\n * @type {ShaderMaterial~Shader}\n */\nconst SAOShader = {\n\n\tname: 'SAOShader',\n\n\tdefines: {\n\t\t'NUM_SAMPLES': 7,\n\t\t'NUM_RINGS': 4,\n\t\t'DIFFUSE_TEXTURE': 0,\n\t\t'PERSPECTIVE_CAMERA': 1\n\t},\n\n\tuniforms: {\n\n\t\t'tDepth': { value: null },\n\t\t'tDiffuse': { value: null },\n\t\t'tNormal': { value: null },\n\t\t'size': { value: new Vector2( 512, 512 ) },\n\n\t\t'cameraNear': { value: 1 },\n\t\t'cameraFar': { value: 100 },\n\t\t'cameraProjectionMatrix': { value: new Matrix4() },\n\t\t'cameraInverseProjectionMatrix': { value: new Matrix4() },\n\n\t\t'scale': { value: 1.0 },\n\t\t'intensity': { value: 0.1 },\n\t\t'bias': { value: 0.5 },\n\n\t\t'minResolution': { value: 0.0 },\n\t\t'kernelRadius': { value: 100.0 },\n\t\t'randomSeed': { value: 0.0 }\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\t\t#include <common>\n\n\t\tvarying vec2 vUv;\n\n\t\t#if DIFFUSE_TEXTURE == 1\n\t\tuniform sampler2D tDiffuse;\n\t\t#endif\n\n\t\tuniform highp sampler2D tDepth;\n\t\tuniform highp sampler2D tNormal;\n\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tuniform mat4 cameraProjectionMatrix;\n\t\tuniform mat4 cameraInverseProjectionMatrix;\n\n\t\tuniform float scale;\n\t\tuniform float intensity;\n\t\tuniform float bias;\n\t\tuniform float kernelRadius;\n\t\tuniform float minResolution;\n\t\tuniform vec2 size;\n\t\tuniform float randomSeed;\n\n\t\t// RGBA depth\n\n\t\t#include <packing>\n\n\t\tvec4 getDefaultColor( const in vec2 screenPosition ) {\n\t\t\t#if DIFFUSE_TEXTURE == 1\n\t\t\treturn texture2D( tDiffuse, vUv );\n\t\t\t#else\n\t\t\treturn vec4( 1.0 );\n\t\t\t#endif\n\t\t}\n\n\t\tfloat getDepth( const in vec2 screenPosition ) {\n\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\t\t}\n\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#else\n\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#endif\n\t\t}\n\n\t\tvec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\n\t\t\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n\t\t\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\n\t\t\tclipPosition *= clipW; // unprojection.\n\n\t\t\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\n\t\t}\n\n\t\tvec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {\n\t\t\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\n\t\t}\n\n\t\tfloat scaleDividedByCameraFar;\n\t\tfloat minResolutionMultipliedByCameraFar;\n\n\t\tfloat getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {\n\t\t\tvec3 viewDelta = sampleViewPosition - centerViewPosition;\n\t\t\tfloat viewDistance = length( viewDelta );\n\t\t\tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;\n\n\t\t\treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );\n\t\t}\n\n\t\t// moving costly divides into consts\n\t\tconst float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\n\t\tconst float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\n\n\t\tfloat getAmbientOcclusion( const in vec3 centerViewPosition ) {\n\t\t\t// precompute some variables require in getOcclusion.\n\t\t\tscaleDividedByCameraFar = scale / cameraFar;\n\t\t\tminResolutionMultipliedByCameraFar = minResolution * cameraFar;\n\t\t\tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );\n\n\t\t\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\n\t\t\tfloat angle = rand( vUv + randomSeed ) * PI2;\n\t\t\tvec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;\n\t\t\tvec2 radiusStep = radius;\n\n\t\t\tfloat occlusionSum = 0.0;\n\t\t\tfloat weightSum = 0.0;\n\n\t\t\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\n\t\t\t\tvec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;\n\t\t\t\tradius += radiusStep;\n\t\t\t\tangle += ANGLE_STEP;\n\n\t\t\t\tfloat sampleDepth = getDepth( sampleUv );\n\t\t\t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfloat sampleViewZ = getViewZ( sampleDepth );\n\t\t\t\tvec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );\n\t\t\t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );\n\t\t\t\tweightSum += 1.0;\n\t\t\t}\n\n\t\t\tif( weightSum == 0.0 ) discard;\n\n\t\t\treturn occlusionSum * ( intensity / weightSum );\n\t\t}\n\n\t\tvoid main() {\n\t\t\tfloat centerDepth = getDepth( vUv );\n\t\t\tif( centerDepth >= ( 1.0 - EPSILON ) ) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t\tfloat centerViewZ = getViewZ( centerDepth );\n\t\t\tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );\n\n\t\t\tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );\n\n\t\t\tgl_FragColor = getDefaultColor( vUv );\n\t\t\tgl_FragColor.xyz *=  1.0 - ambientOcclusion;\n\t\t}`\n\n};\n\nexport { SAOShader };\n"],"mappings":"AAAA,SACCA,OAAO,EACPC,OAAO,QACD,OAAO;;AAEd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,SAAS,GAAG;EAEjBC,IAAI,EAAE,WAAW;EAEjBC,OAAO,EAAE;IACR,aAAa,EAAE,CAAC;IAChB,WAAW,EAAE,CAAC;IACd,iBAAiB,EAAE,CAAC;IACpB,oBAAoB,EAAE;EACvB,CAAC;EAEDC,QAAQ,EAAE;IAET,QAAQ,EAAE;MAAEC,KAAK,EAAE;IAAK,CAAC;IACzB,UAAU,EAAE;MAAEA,KAAK,EAAE;IAAK,CAAC;IAC3B,SAAS,EAAE;MAAEA,KAAK,EAAE;IAAK,CAAC;IAC1B,MAAM,EAAE;MAAEA,KAAK,EAAE,IAAIL,OAAO,CAAE,GAAG,EAAE,GAAI;IAAE,CAAC;IAE1C,YAAY,EAAE;MAAEK,KAAK,EAAE;IAAE,CAAC;IAC1B,WAAW,EAAE;MAAEA,KAAK,EAAE;IAAI,CAAC;IAC3B,wBAAwB,EAAE;MAAEA,KAAK,EAAE,IAAIN,OAAO,CAAC;IAAE,CAAC;IAClD,+BAA+B,EAAE;MAAEM,KAAK,EAAE,IAAIN,OAAO,CAAC;IAAE,CAAC;IAEzD,OAAO,EAAE;MAAEM,KAAK,EAAE;IAAI,CAAC;IACvB,WAAW,EAAE;MAAEA,KAAK,EAAE;IAAI,CAAC;IAC3B,MAAM,EAAE;MAAEA,KAAK,EAAE;IAAI,CAAC;IAEtB,eAAe,EAAE;MAAEA,KAAK,EAAE;IAAI,CAAC;IAC/B,cAAc,EAAE;MAAEA,KAAK,EAAE;IAAM,CAAC;IAChC,YAAY,EAAE;MAAEA,KAAK,EAAE;IAAI;EAC5B,CAAC;EAEDC,YAAY,EAAE,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;EAEHC,cAAc,EAAE,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,CAAC;AAED,SAASN,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}