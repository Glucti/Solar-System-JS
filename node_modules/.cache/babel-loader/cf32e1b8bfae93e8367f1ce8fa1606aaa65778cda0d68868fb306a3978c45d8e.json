{"ast":null,"code":"import { ClampToEdgeWrapping, DataTexture, DataUtils, FileLoader, HalfFloatType, LinearFilter, LinearMipMapLinearFilter, LinearSRGBColorSpace, Loader, RGBAFormat, UVMapping } from 'three';\n\n/**\n * UltraHDR Image Format - https://developer.android.com/media/platform/hdr-image-format\n *\n * Short format brief:\n *\n *  [JPEG headers]\n *  [XMP metadata describing the MPF container and *both* SDR and gainmap images]\n *  [Optional metadata] [EXIF] [ICC Profile]\n *  [SDR image]\n *  [XMP metadata describing only the gainmap image]\n *  [Gainmap image]\n *\n * Each section is separated by a 0xFFXX byte followed by a descriptor byte (0xFFE0, 0xFFE1, 0xFFE2.)\n * Binary image storages are prefixed with a unique 0xFFD8 16-bit descriptor.\n */\n\n// Calculating this SRGB powers is extremely slow for 4K images and can be sufficiently precalculated for a 3-4x speed boost\nconst SRGB_TO_LINEAR = Array(1024).fill(0).map((_, value) => Math.pow(value / 255 * 0.9478672986 + 0.0521327014, 2.4));\n\n/**\n * A loader for the Ultra HDR Image Format.\n *\n * Existing HDR or EXR textures can be converted to Ultra HDR with this [tool]{@link https://gainmap-creator.monogrid.com/}.\n *\n * Current feature set:\n * - JPEG headers (required)\n * - XMP metadata (required)\n * - XMP validation (not implemented)\n * - EXIF profile (not implemented)\n * - ICC profile (not implemented)\n * - Binary storage for SDR & HDR images (required)\n * - Gainmap metadata (required)\n * - Non-JPEG image formats (not implemented)\n * - Primary image as an HDR image (not implemented)\n *\n * ```js\n * const loader = new UltraHDRLoader();\n * const texture = await loader.loadAsync( 'textures/equirectangular/ice_planet_close.jpg' );\n * texture.mapping = THREE.EquirectangularReflectionMapping;\n *\n * scene.background = texture;\n * scene.environment = texture;\n * ```\n *\n * @augments Loader\n * @three_import import { UltraHDRLoader } from 'three/addons/loaders/UltraHDRLoader.js';\n */\nclass UltraHDRLoader extends Loader {\n  /**\n   * Constructs a new Ultra HDR loader.\n   *\n   * @param {LoadingManager} [manager] - The loading manager.\n   */\n  constructor(manager) {\n    super(manager);\n\n    /**\n     * The texture type.\n     *\n     * @type {(HalfFloatType|FloatType)}\n     * @default HalfFloatType\n     */\n    this.type = HalfFloatType;\n  }\n\n  /**\n   * Sets the texture type.\n   *\n   * @param {(HalfFloatType|FloatType)} value - The texture type to set.\n   * @return {RGBELoader} A reference to this loader.\n   */\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n\n  /**\n   * Parses the given Ultra HDR texture data.\n   *\n   * @param {ArrayBuffer} buffer - The raw texture data.\n   * @param {Function} onLoad - The `onLoad` callback.\n   */\n  parse(buffer, onLoad) {\n    const xmpMetadata = {\n      version: null,\n      baseRenditionIsHDR: null,\n      gainMapMin: null,\n      gainMapMax: null,\n      gamma: null,\n      offsetSDR: null,\n      offsetHDR: null,\n      hdrCapacityMin: null,\n      hdrCapacityMax: null\n    };\n    const textDecoder = new TextDecoder();\n    const data = new DataView(buffer);\n    let byteOffset = 0;\n    const sections = [];\n    while (byteOffset < data.byteLength) {\n      const byte = data.getUint8(byteOffset);\n      if (byte === 0xff) {\n        const leadingByte = data.getUint8(byteOffset + 1);\n        if ([/* Valid section headers */\n        0xd8,\n        // SOI\n        0xe0,\n        // APP0\n        0xe1,\n        // APP1\n        0xe2 // APP2\n        ].includes(leadingByte)) {\n          sections.push({\n            sectionType: leadingByte,\n            section: [byte, leadingByte],\n            sectionOffset: byteOffset + 2\n          });\n          byteOffset += 2;\n        } else {\n          sections[sections.length - 1].section.push(byte, leadingByte);\n          byteOffset += 2;\n        }\n      } else {\n        sections[sections.length - 1].section.push(byte);\n        byteOffset++;\n      }\n    }\n    let primaryImage, gainmapImage;\n    for (let i = 0; i < sections.length; i++) {\n      const {\n        sectionType,\n        section,\n        sectionOffset\n      } = sections[i];\n      if (sectionType === 0xe0) {\n        /* JPEG Header - no useful information */\n      } else if (sectionType === 0xe1) {\n        /* XMP Metadata */\n\n        this._parseXMPMetadata(textDecoder.decode(new Uint8Array(section)), xmpMetadata);\n      } else if (sectionType === 0xe2) {\n        /* Data Sections - MPF / EXIF / ICC Profile */\n\n        const sectionData = new DataView(new Uint8Array(section.slice(2)).buffer);\n        const sectionHeader = sectionData.getUint32(2, false);\n        if (sectionHeader === 0x4d504600) {\n          /* MPF Section */\n\n          /* Section contains a list of static bytes and ends with offsets indicating location of SDR and gainmap images */\n          /* First bytes after header indicate little / big endian ordering (0x49492A00 - LE / 0x4D4D002A - BE) */\n          /*\n          ... 60 bytes indicating tags, versions, etc. ...\n          \tbytes | bits | description\n          \t4       32     primary image size\n          4       32     primary image offset\n          2       16     0x0000\n          2       16     0x0000\n          \t4       32     0x00000000\n          4       32     gainmap image size\n          4       32     gainmap image offset\n          2       16     0x0000\n          2       16     0x0000\n          */\n\n          const mpfLittleEndian = sectionData.getUint32(6) === 0x49492a00;\n          const mpfBytesOffset = 60;\n\n          /* SDR size includes the metadata length, SDR offset is always 0 */\n\n          const primaryImageSize = sectionData.getUint32(mpfBytesOffset, mpfLittleEndian);\n          const primaryImageOffset = sectionData.getUint32(mpfBytesOffset + 4, mpfLittleEndian);\n\n          /* Gainmap size is an absolute value starting from its offset, gainmap offset needs 6 bytes padding to take into account 0x00 bytes at the end of XMP */\n          const gainmapImageSize = sectionData.getUint32(mpfBytesOffset + 16, mpfLittleEndian);\n          const gainmapImageOffset = sectionData.getUint32(mpfBytesOffset + 20, mpfLittleEndian) + sectionOffset + 6;\n          primaryImage = new Uint8Array(data.buffer, primaryImageOffset, primaryImageSize);\n          gainmapImage = new Uint8Array(data.buffer, gainmapImageOffset, gainmapImageSize);\n        }\n      }\n    }\n\n    /* Minimal sufficient validation - https://developer.android.com/media/platform/hdr-image-format#signal_of_the_format */\n    if (!xmpMetadata.version) {\n      throw new Error('THREE.UltraHDRLoader: Not a valid UltraHDR image');\n    }\n    if (primaryImage && gainmapImage) {\n      this._applyGainmapToSDR(xmpMetadata, primaryImage, gainmapImage, (hdrBuffer, width, height) => {\n        onLoad({\n          width,\n          height,\n          data: hdrBuffer,\n          format: RGBAFormat,\n          type: this.type\n        });\n      }, error => {\n        throw new Error(error);\n      });\n    } else {\n      throw new Error('THREE.UltraHDRLoader: Could not parse UltraHDR images');\n    }\n  }\n\n  /**\n   * Starts loading from the given URL and passes the loaded Ultra HDR texture\n   * to the `onLoad()` callback.\n   *\n   * @param {string} url - The path/URL of the files to be loaded. This can also be a data URI.\n   * @param {function(DataTexture, Object)} onLoad - Executed when the loading process has been finished.\n   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n   * @param {onErrorCallback} onError - Executed when errors occur.\n   * @return {DataTexture} The Ultra HDR texture.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const texture = new DataTexture(this.type === HalfFloatType ? new Uint16Array() : new Float32Array(), 0, 0, RGBAFormat, this.type, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, 1, LinearSRGBColorSpace);\n    texture.generateMipmaps = true;\n    texture.flipY = true;\n    const loader = new FileLoader(this.manager);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setPath(this.path);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, buffer => {\n      try {\n        this.parse(buffer, texData => {\n          texture.image = {\n            data: texData.data,\n            width: texData.width,\n            height: texData.height\n          };\n          texture.needsUpdate = true;\n          if (onLoad) onLoad(texture, texData);\n        });\n      } catch (error) {\n        if (onError) onError(error);\n        console.error(error);\n      }\n    }, onProgress, onError);\n    return texture;\n  }\n  _parseXMPMetadata(xmpDataString, xmpMetadata) {\n    const domParser = new DOMParser();\n    const xmpXml = domParser.parseFromString(xmpDataString.substring(xmpDataString.indexOf('<'), xmpDataString.lastIndexOf('>') + 1), 'text/xml');\n\n    /* Determine if given XMP metadata is the primary GContainer descriptor or a gainmap descriptor */\n    const [hasHDRContainerDescriptor] = xmpXml.getElementsByTagName('Container:Directory');\n    if (hasHDRContainerDescriptor) {\n      /* There's not much useful information in the container descriptor besides memory-validation */\n    } else {\n      /* Gainmap descriptor - defaults from https://developer.android.com/media/platform/hdr-image-format#HDR_gain_map_metadata */\n\n      const [gainmapNode] = xmpXml.getElementsByTagName('rdf:Description');\n      xmpMetadata.version = gainmapNode.getAttribute('hdrgm:Version');\n      xmpMetadata.baseRenditionIsHDR = gainmapNode.getAttribute('hdrgm:BaseRenditionIsHDR') === 'True';\n      xmpMetadata.gainMapMin = parseFloat(gainmapNode.getAttribute('hdrgm:GainMapMin') || 0.0);\n      xmpMetadata.gainMapMax = parseFloat(gainmapNode.getAttribute('hdrgm:GainMapMax') || 1.0);\n      xmpMetadata.gamma = parseFloat(gainmapNode.getAttribute('hdrgm:Gamma') || 1.0);\n      xmpMetadata.offsetSDR = parseFloat(gainmapNode.getAttribute('hdrgm:OffsetSDR') / (1 / 64));\n      xmpMetadata.offsetHDR = parseFloat(gainmapNode.getAttribute('hdrgm:OffsetHDR') / (1 / 64));\n      xmpMetadata.hdrCapacityMin = parseFloat(gainmapNode.getAttribute('hdrgm:HDRCapacityMin') || 0.0);\n      xmpMetadata.hdrCapacityMax = parseFloat(gainmapNode.getAttribute('hdrgm:HDRCapacityMax') || 1.0);\n    }\n  }\n  _srgbToLinear(value) {\n    if (value / 255 < 0.04045) {\n      return value / 255 * 0.0773993808;\n    }\n    if (value < 1024) {\n      return SRGB_TO_LINEAR[~~value];\n    }\n    return Math.pow(value / 255 * 0.9478672986 + 0.0521327014, 2.4);\n  }\n  _applyGainmapToSDR(xmpMetadata, sdrBuffer, gainmapBuffer, onSuccess, onError) {\n    const getImageDataFromBuffer = buffer => new Promise((resolve, reject) => {\n      const imageLoader = document.createElement('img');\n      imageLoader.onload = () => {\n        const image = {\n          width: imageLoader.naturalWidth,\n          height: imageLoader.naturalHeight,\n          source: imageLoader\n        };\n        URL.revokeObjectURL(imageLoader.src);\n        resolve(image);\n      };\n      imageLoader.onerror = () => {\n        URL.revokeObjectURL(imageLoader.src);\n        reject();\n      };\n      imageLoader.src = URL.createObjectURL(new Blob([buffer], {\n        type: 'image/jpeg'\n      }));\n    });\n    Promise.all([getImageDataFromBuffer(sdrBuffer), getImageDataFromBuffer(gainmapBuffer)]).then(([sdrImage, gainmapImage]) => {\n      const sdrImageAspect = sdrImage.width / sdrImage.height;\n      const gainmapImageAspect = gainmapImage.width / gainmapImage.height;\n      if (sdrImageAspect !== gainmapImageAspect) {\n        onError('THREE.UltraHDRLoader Error: Aspect ratio mismatch between SDR and Gainmap images');\n        return;\n      }\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d', {\n        willReadFrequently: true,\n        colorSpace: 'srgb'\n      });\n      canvas.width = sdrImage.width;\n      canvas.height = sdrImage.height;\n\n      /* Use out-of-the-box interpolation of Canvas API to scale gainmap to fit the SDR resolution */\n      ctx.drawImage(gainmapImage.source, 0, 0, gainmapImage.width, gainmapImage.height, 0, 0, sdrImage.width, sdrImage.height);\n      const gainmapImageData = ctx.getImageData(0, 0, sdrImage.width, sdrImage.height, {\n        colorSpace: 'srgb'\n      });\n      ctx.drawImage(sdrImage.source, 0, 0);\n      const sdrImageData = ctx.getImageData(0, 0, sdrImage.width, sdrImage.height, {\n        colorSpace: 'srgb'\n      });\n\n      /* HDR Recovery formula - https://developer.android.com/media/platform/hdr-image-format#use_the_gain_map_to_create_adapted_HDR_rendition */\n      let hdrBuffer;\n      if (this.type === HalfFloatType) {\n        hdrBuffer = new Uint16Array(sdrImageData.data.length).fill(23544);\n      } else {\n        hdrBuffer = new Float32Array(sdrImageData.data.length).fill(255);\n      }\n      const maxDisplayBoost = Math.sqrt(Math.pow(/* 1.8 instead of 2 near-perfectly rectifies approximations introduced by precalculated SRGB_TO_LINEAR values */\n      1.8, xmpMetadata.hdrCapacityMax));\n      const unclampedWeightFactor = (Math.log2(maxDisplayBoost) - xmpMetadata.hdrCapacityMin) / (xmpMetadata.hdrCapacityMax - xmpMetadata.hdrCapacityMin);\n      const weightFactor = Math.min(Math.max(unclampedWeightFactor, 0.0), 1.0);\n      const useGammaOne = xmpMetadata.gamma === 1.0;\n      for (let pixelIndex = 0; pixelIndex < sdrImageData.data.length; pixelIndex += 4) {\n        const x = pixelIndex / 4 % sdrImage.width;\n        const y = Math.floor(pixelIndex / 4 / sdrImage.width);\n        for (let channelIndex = 0; channelIndex < 3; channelIndex++) {\n          const sdrValue = sdrImageData.data[pixelIndex + channelIndex];\n          const gainmapIndex = (y * sdrImage.width + x) * 4 + channelIndex;\n          const gainmapValue = gainmapImageData.data[gainmapIndex] / 255.0;\n\n          /* Gamma is 1.0 by default */\n          const logRecovery = useGammaOne ? gainmapValue : Math.pow(gainmapValue, 1.0 / xmpMetadata.gamma);\n          const logBoost = xmpMetadata.gainMapMin * (1.0 - logRecovery) + xmpMetadata.gainMapMax * logRecovery;\n          const hdrValue = (sdrValue + xmpMetadata.offsetSDR) * (logBoost * weightFactor === 0.0 ? 1.0 : Math.pow(2, logBoost * weightFactor)) - xmpMetadata.offsetHDR;\n          const linearHDRValue = Math.min(Math.max(this._srgbToLinear(hdrValue), 0), 65504);\n          hdrBuffer[pixelIndex + channelIndex] = this.type === HalfFloatType ? DataUtils.toHalfFloat(linearHDRValue) : linearHDRValue;\n        }\n      }\n      onSuccess(hdrBuffer, sdrImage.width, sdrImage.height);\n    }).catch(() => {\n      throw new Error('THREE.UltraHDRLoader Error: Could not parse UltraHDR images');\n    });\n  }\n}\nexport { UltraHDRLoader };","map":{"version":3,"names":["ClampToEdgeWrapping","DataTexture","DataUtils","FileLoader","HalfFloatType","LinearFilter","LinearMipMapLinearFilter","LinearSRGBColorSpace","Loader","RGBAFormat","UVMapping","SRGB_TO_LINEAR","Array","fill","map","_","value","Math","pow","UltraHDRLoader","constructor","manager","type","setDataType","parse","buffer","onLoad","xmpMetadata","version","baseRenditionIsHDR","gainMapMin","gainMapMax","gamma","offsetSDR","offsetHDR","hdrCapacityMin","hdrCapacityMax","textDecoder","TextDecoder","data","DataView","byteOffset","sections","byteLength","byte","getUint8","leadingByte","includes","push","sectionType","section","sectionOffset","length","primaryImage","gainmapImage","i","_parseXMPMetadata","decode","Uint8Array","sectionData","slice","sectionHeader","getUint32","mpfLittleEndian","mpfBytesOffset","primaryImageSize","primaryImageOffset","gainmapImageSize","gainmapImageOffset","Error","_applyGainmapToSDR","hdrBuffer","width","height","format","error","load","url","onProgress","onError","texture","Uint16Array","Float32Array","generateMipmaps","flipY","loader","setResponseType","setRequestHeader","requestHeader","setPath","path","setWithCredentials","withCredentials","texData","image","needsUpdate","console","xmpDataString","domParser","DOMParser","xmpXml","parseFromString","substring","indexOf","lastIndexOf","hasHDRContainerDescriptor","getElementsByTagName","gainmapNode","getAttribute","parseFloat","_srgbToLinear","sdrBuffer","gainmapBuffer","onSuccess","getImageDataFromBuffer","Promise","resolve","reject","imageLoader","document","createElement","onload","naturalWidth","naturalHeight","source","URL","revokeObjectURL","src","onerror","createObjectURL","Blob","all","then","sdrImage","sdrImageAspect","gainmapImageAspect","canvas","ctx","getContext","willReadFrequently","colorSpace","drawImage","gainmapImageData","getImageData","sdrImageData","maxDisplayBoost","sqrt","unclampedWeightFactor","log2","weightFactor","min","max","useGammaOne","pixelIndex","x","y","floor","channelIndex","sdrValue","gainmapIndex","gainmapValue","logRecovery","logBoost","hdrValue","linearHDRValue","toHalfFloat","catch"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/loaders/UltraHDRLoader.js"],"sourcesContent":["import {\n\tClampToEdgeWrapping,\n\tDataTexture,\n\tDataUtils,\n\tFileLoader,\n\tHalfFloatType,\n\tLinearFilter,\n\tLinearMipMapLinearFilter,\n\tLinearSRGBColorSpace,\n\tLoader,\n\tRGBAFormat,\n\tUVMapping,\n} from 'three';\n\n/**\n * UltraHDR Image Format - https://developer.android.com/media/platform/hdr-image-format\n *\n * Short format brief:\n *\n *  [JPEG headers]\n *  [XMP metadata describing the MPF container and *both* SDR and gainmap images]\n *  [Optional metadata] [EXIF] [ICC Profile]\n *  [SDR image]\n *  [XMP metadata describing only the gainmap image]\n *  [Gainmap image]\n *\n * Each section is separated by a 0xFFXX byte followed by a descriptor byte (0xFFE0, 0xFFE1, 0xFFE2.)\n * Binary image storages are prefixed with a unique 0xFFD8 16-bit descriptor.\n */\n\n\n// Calculating this SRGB powers is extremely slow for 4K images and can be sufficiently precalculated for a 3-4x speed boost\nconst SRGB_TO_LINEAR = Array( 1024 )\n\t.fill( 0 )\n\t.map( ( _, value ) =>\n\t\tMath.pow( ( value / 255 ) * 0.9478672986 + 0.0521327014, 2.4 )\n\t);\n\n/**\n * A loader for the Ultra HDR Image Format.\n *\n * Existing HDR or EXR textures can be converted to Ultra HDR with this [tool]{@link https://gainmap-creator.monogrid.com/}.\n *\n * Current feature set:\n * - JPEG headers (required)\n * - XMP metadata (required)\n * - XMP validation (not implemented)\n * - EXIF profile (not implemented)\n * - ICC profile (not implemented)\n * - Binary storage for SDR & HDR images (required)\n * - Gainmap metadata (required)\n * - Non-JPEG image formats (not implemented)\n * - Primary image as an HDR image (not implemented)\n *\n * ```js\n * const loader = new UltraHDRLoader();\n * const texture = await loader.loadAsync( 'textures/equirectangular/ice_planet_close.jpg' );\n * texture.mapping = THREE.EquirectangularReflectionMapping;\n *\n * scene.background = texture;\n * scene.environment = texture;\n * ```\n *\n * @augments Loader\n * @three_import import { UltraHDRLoader } from 'three/addons/loaders/UltraHDRLoader.js';\n */\nclass UltraHDRLoader extends Loader {\n\n\t/**\n\t * Constructs a new Ultra HDR loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * The texture type.\n\t\t *\n\t\t * @type {(HalfFloatType|FloatType)}\n\t\t * @default HalfFloatType\n\t\t */\n\t\tthis.type = HalfFloatType;\n\n\t}\n\n\t/**\n\t * Sets the texture type.\n\t *\n\t * @param {(HalfFloatType|FloatType)} value - The texture type to set.\n\t * @return {RGBELoader} A reference to this loader.\n\t */\n\tsetDataType( value ) {\n\n\t\tthis.type = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Parses the given Ultra HDR texture data.\n\t *\n\t * @param {ArrayBuffer} buffer - The raw texture data.\n\t * @param {Function} onLoad - The `onLoad` callback.\n\t */\n\tparse( buffer, onLoad ) {\n\n\t\tconst xmpMetadata = {\n\t\t\tversion: null,\n\t\t\tbaseRenditionIsHDR: null,\n\t\t\tgainMapMin: null,\n\t\t\tgainMapMax: null,\n\t\t\tgamma: null,\n\t\t\toffsetSDR: null,\n\t\t\toffsetHDR: null,\n\t\t\thdrCapacityMin: null,\n\t\t\thdrCapacityMax: null,\n\t\t};\n\t\tconst textDecoder = new TextDecoder();\n\n\t\tconst data = new DataView( buffer );\n\n\t\tlet byteOffset = 0;\n\t\tconst sections = [];\n\n\t\twhile ( byteOffset < data.byteLength ) {\n\n\t\t\tconst byte = data.getUint8( byteOffset );\n\n\t\t\tif ( byte === 0xff ) {\n\n\t\t\t\tconst leadingByte = data.getUint8( byteOffset + 1 );\n\n\t\t\t\tif (\n\t\t\t\t\t[\n\t\t\t\t\t\t/* Valid section headers */\n\t\t\t\t\t\t0xd8, // SOI\n\t\t\t\t\t\t0xe0, // APP0\n\t\t\t\t\t\t0xe1, // APP1\n\t\t\t\t\t\t0xe2, // APP2\n\t\t\t\t\t].includes( leadingByte )\n\t\t\t\t) {\n\n\t\t\t\t\tsections.push( {\n\t\t\t\t\t\tsectionType: leadingByte,\n\t\t\t\t\t\tsection: [ byte, leadingByte ],\n\t\t\t\t\t\tsectionOffset: byteOffset + 2,\n\t\t\t\t\t} );\n\n\t\t\t\t\tbyteOffset += 2;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsections[ sections.length - 1 ].section.push( byte, leadingByte );\n\n\t\t\t\t\tbyteOffset += 2;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tsections[ sections.length - 1 ].section.push( byte );\n\n\t\t\t\tbyteOffset ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet primaryImage, gainmapImage;\n\n\t\tfor ( let i = 0; i < sections.length; i ++ ) {\n\n\t\t\tconst { sectionType, section, sectionOffset } = sections[ i ];\n\n\t\t\tif ( sectionType === 0xe0 ) {\n\t\t\t\t/* JPEG Header - no useful information */\n\t\t\t} else if ( sectionType === 0xe1 ) {\n\n\t\t\t\t/* XMP Metadata */\n\n\t\t\t\tthis._parseXMPMetadata(\n\t\t\t\t\ttextDecoder.decode( new Uint8Array( section ) ),\n\t\t\t\t\txmpMetadata\n\t\t\t\t);\n\n\t\t\t} else if ( sectionType === 0xe2 ) {\n\n\t\t\t\t/* Data Sections - MPF / EXIF / ICC Profile */\n\n\t\t\t\tconst sectionData = new DataView(\n\t\t\t\t\tnew Uint8Array( section.slice( 2 ) ).buffer\n\t\t\t\t);\n\t\t\t\tconst sectionHeader = sectionData.getUint32( 2, false );\n\n\t\t\t\tif ( sectionHeader === 0x4d504600 ) {\n\n\t\t\t\t\t/* MPF Section */\n\n\t\t\t\t\t/* Section contains a list of static bytes and ends with offsets indicating location of SDR and gainmap images */\n\t\t\t\t\t/* First bytes after header indicate little / big endian ordering (0x49492A00 - LE / 0x4D4D002A - BE) */\n\t\t\t\t\t/*\n\t\t\t\t\t... 60 bytes indicating tags, versions, etc. ...\n\n\t\t\t\t\tbytes | bits | description\n\n\t\t\t\t\t4       32     primary image size\n\t\t\t\t\t4       32     primary image offset\n\t\t\t\t\t2       16     0x0000\n\t\t\t\t\t2       16     0x0000\n\n\t\t\t\t\t4       32     0x00000000\n\t\t\t\t\t4       32     gainmap image size\n\t\t\t\t\t4       32     gainmap image offset\n\t\t\t\t\t2       16     0x0000\n\t\t\t\t\t2       16     0x0000\n\t\t\t\t\t*/\n\n\t\t\t\t\tconst mpfLittleEndian = sectionData.getUint32( 6 ) === 0x49492a00;\n\t\t\t\t\tconst mpfBytesOffset = 60;\n\n\t\t\t\t\t/* SDR size includes the metadata length, SDR offset is always 0 */\n\n\t\t\t\t\tconst primaryImageSize = sectionData.getUint32(\n\t\t\t\t\t\tmpfBytesOffset,\n\t\t\t\t\t\tmpfLittleEndian\n\t\t\t\t\t);\n\t\t\t\t\tconst primaryImageOffset = sectionData.getUint32(\n\t\t\t\t\t\tmpfBytesOffset + 4,\n\t\t\t\t\t\tmpfLittleEndian\n\t\t\t\t\t);\n\n\t\t\t\t\t/* Gainmap size is an absolute value starting from its offset, gainmap offset needs 6 bytes padding to take into account 0x00 bytes at the end of XMP */\n\t\t\t\t\tconst gainmapImageSize = sectionData.getUint32(\n\t\t\t\t\t\tmpfBytesOffset + 16,\n\t\t\t\t\t\tmpfLittleEndian\n\t\t\t\t\t);\n\t\t\t\t\tconst gainmapImageOffset =\n\t\t\t\t\t\tsectionData.getUint32( mpfBytesOffset + 20, mpfLittleEndian ) +\n\t\t\t\t\t\tsectionOffset +\n\t\t\t\t\t\t6;\n\n\t\t\t\t\tprimaryImage = new Uint8Array(\n\t\t\t\t\t\tdata.buffer,\n\t\t\t\t\t\tprimaryImageOffset,\n\t\t\t\t\t\tprimaryImageSize\n\t\t\t\t\t);\n\n\t\t\t\t\tgainmapImage = new Uint8Array(\n\t\t\t\t\t\tdata.buffer,\n\t\t\t\t\t\tgainmapImageOffset,\n\t\t\t\t\t\tgainmapImageSize\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/* Minimal sufficient validation - https://developer.android.com/media/platform/hdr-image-format#signal_of_the_format */\n\t\tif ( ! xmpMetadata.version ) {\n\n\t\t\tthrow new Error( 'THREE.UltraHDRLoader: Not a valid UltraHDR image' );\n\n\t\t}\n\n\t\tif ( primaryImage && gainmapImage ) {\n\n\t\t\tthis._applyGainmapToSDR(\n\t\t\t\txmpMetadata,\n\t\t\t\tprimaryImage,\n\t\t\t\tgainmapImage,\n\t\t\t\t( hdrBuffer, width, height ) => {\n\n\t\t\t\t\tonLoad( {\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\theight,\n\t\t\t\t\t\tdata: hdrBuffer,\n\t\t\t\t\t\tformat: RGBAFormat,\n\t\t\t\t\t\ttype: this.type,\n\t\t\t\t\t} );\n\n\t\t\t\t},\n\t\t\t\t( error ) => {\n\n\t\t\t\t\tthrow new Error( error );\n\n\t\t\t\t}\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.UltraHDRLoader: Could not parse UltraHDR images' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded Ultra HDR texture\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the files to be loaded. This can also be a data URI.\n\t * @param {function(DataTexture, Object)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t * @return {DataTexture} The Ultra HDR texture.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst texture = new DataTexture(\n\t\t\tthis.type === HalfFloatType ? new Uint16Array() : new Float32Array(),\n\t\t\t0,\n\t\t\t0,\n\t\t\tRGBAFormat,\n\t\t\tthis.type,\n\t\t\tUVMapping,\n\t\t\tClampToEdgeWrapping,\n\t\t\tClampToEdgeWrapping,\n\t\t\tLinearFilter,\n\t\t\tLinearMipMapLinearFilter,\n\t\t\t1,\n\t\t\tLinearSRGBColorSpace\n\t\t);\n\t\ttexture.generateMipmaps = true;\n\t\ttexture.flipY = true;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setPath( this.path );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, ( buffer ) => {\n\n\t\t\ttry {\n\n\t\t\t\tthis.parse(\n\t\t\t\t\tbuffer,\n\t\t\t\t\t( texData ) => {\n\n\t\t\t\t\t\ttexture.image = {\n\t\t\t\t\t\t\tdata: texData.data,\n\t\t\t\t\t\t\twidth: texData.width,\n\t\t\t\t\t\t\theight: texData.height,\n\t\t\t\t\t\t};\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( onError ) onError( error );\n\n\t\t\t\tconsole.error( error );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t}\n\n\t_parseXMPMetadata( xmpDataString, xmpMetadata ) {\n\n\t\tconst domParser = new DOMParser();\n\n\t\tconst xmpXml = domParser.parseFromString(\n\t\t\txmpDataString.substring(\n\t\t\t\txmpDataString.indexOf( '<' ),\n\t\t\t\txmpDataString.lastIndexOf( '>' ) + 1\n\t\t\t),\n\t\t\t'text/xml'\n\t\t);\n\n\t\t/* Determine if given XMP metadata is the primary GContainer descriptor or a gainmap descriptor */\n\t\tconst [ hasHDRContainerDescriptor ] = xmpXml.getElementsByTagName(\n\t\t\t'Container:Directory'\n\t\t);\n\n\t\tif ( hasHDRContainerDescriptor ) {\n\t\t\t/* There's not much useful information in the container descriptor besides memory-validation */\n\t\t} else {\n\n\t\t\t/* Gainmap descriptor - defaults from https://developer.android.com/media/platform/hdr-image-format#HDR_gain_map_metadata */\n\n\t\t\tconst [ gainmapNode ] = xmpXml.getElementsByTagName( 'rdf:Description' );\n\n\t\t\txmpMetadata.version = gainmapNode.getAttribute( 'hdrgm:Version' );\n\t\t\txmpMetadata.baseRenditionIsHDR =\n\t\t\t\tgainmapNode.getAttribute( 'hdrgm:BaseRenditionIsHDR' ) === 'True';\n\t\t\txmpMetadata.gainMapMin = parseFloat(\n\t\t\t\tgainmapNode.getAttribute( 'hdrgm:GainMapMin' ) || 0.0\n\t\t\t);\n\t\t\txmpMetadata.gainMapMax = parseFloat(\n\t\t\t\tgainmapNode.getAttribute( 'hdrgm:GainMapMax' ) || 1.0\n\t\t\t);\n\t\t\txmpMetadata.gamma = parseFloat(\n\t\t\t\tgainmapNode.getAttribute( 'hdrgm:Gamma' ) || 1.0\n\t\t\t);\n\t\t\txmpMetadata.offsetSDR = parseFloat(\n\t\t\t\tgainmapNode.getAttribute( 'hdrgm:OffsetSDR' ) / ( 1 / 64 )\n\t\t\t);\n\t\t\txmpMetadata.offsetHDR = parseFloat(\n\t\t\t\tgainmapNode.getAttribute( 'hdrgm:OffsetHDR' ) / ( 1 / 64 )\n\t\t\t);\n\t\t\txmpMetadata.hdrCapacityMin = parseFloat(\n\t\t\t\tgainmapNode.getAttribute( 'hdrgm:HDRCapacityMin' ) || 0.0\n\t\t\t);\n\t\t\txmpMetadata.hdrCapacityMax = parseFloat(\n\t\t\t\tgainmapNode.getAttribute( 'hdrgm:HDRCapacityMax' ) || 1.0\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t_srgbToLinear( value ) {\n\n\t\tif ( value / 255 < 0.04045 ) {\n\n\t\t\treturn ( value / 255 ) * 0.0773993808;\n\n\t\t}\n\n\t\tif ( value < 1024 ) {\n\n\t\t\treturn SRGB_TO_LINEAR[ ~ ~ value ];\n\n\t\t}\n\n\t\treturn Math.pow( ( value / 255 ) * 0.9478672986 + 0.0521327014, 2.4 );\n\n\t}\n\n\t_applyGainmapToSDR(\n\t\txmpMetadata,\n\t\tsdrBuffer,\n\t\tgainmapBuffer,\n\t\tonSuccess,\n\t\tonError\n\t) {\n\n\t\tconst getImageDataFromBuffer = ( buffer ) =>\n\t\t\tnew Promise( ( resolve, reject ) => {\n\n\t\t\t\tconst imageLoader = document.createElement( 'img' );\n\n\t\t\t\timageLoader.onload = () => {\n\n\t\t\t\t\tconst image = {\n\t\t\t\t\t\twidth: imageLoader.naturalWidth,\n\t\t\t\t\t\theight: imageLoader.naturalHeight,\n\t\t\t\t\t\tsource: imageLoader,\n\t\t\t\t\t};\n\n\t\t\t\t\tURL.revokeObjectURL( imageLoader.src );\n\n\t\t\t\t\tresolve( image );\n\n\t\t\t\t};\n\n\t\t\t\timageLoader.onerror = () => {\n\n\t\t\t\t\tURL.revokeObjectURL( imageLoader.src );\n\n\t\t\t\t\treject();\n\n\t\t\t\t};\n\n\t\t\t\timageLoader.src = URL.createObjectURL(\n\t\t\t\t\tnew Blob( [ buffer ], { type: 'image/jpeg' } )\n\t\t\t\t);\n\n\t\t\t} );\n\n\t\tPromise.all( [\n\t\t\tgetImageDataFromBuffer( sdrBuffer ),\n\t\t\tgetImageDataFromBuffer( gainmapBuffer ),\n\t\t] )\n\t\t\t.then( ( [ sdrImage, gainmapImage ] ) => {\n\n\t\t\t\tconst sdrImageAspect = sdrImage.width / sdrImage.height;\n\t\t\t\tconst gainmapImageAspect = gainmapImage.width / gainmapImage.height;\n\n\t\t\t\tif ( sdrImageAspect !== gainmapImageAspect ) {\n\n\t\t\t\t\tonError(\n\t\t\t\t\t\t'THREE.UltraHDRLoader Error: Aspect ratio mismatch between SDR and Gainmap images'\n\t\t\t\t\t);\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\tconst ctx = canvas.getContext( '2d', {\n\t\t\t\t\twillReadFrequently: true,\n\t\t\t\t\tcolorSpace: 'srgb',\n\t\t\t\t} );\n\n\t\t\t\tcanvas.width = sdrImage.width;\n\t\t\t\tcanvas.height = sdrImage.height;\n\n\t\t\t\t/* Use out-of-the-box interpolation of Canvas API to scale gainmap to fit the SDR resolution */\n\t\t\t\tctx.drawImage(\n\t\t\t\t\tgainmapImage.source,\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tgainmapImage.width,\n\t\t\t\t\tgainmapImage.height,\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tsdrImage.width,\n\t\t\t\t\tsdrImage.height\n\t\t\t\t);\n\t\t\t\tconst gainmapImageData = ctx.getImageData(\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tsdrImage.width,\n\t\t\t\t\tsdrImage.height,\n\t\t\t\t\t{ colorSpace: 'srgb' }\n\t\t\t\t);\n\n\t\t\t\tctx.drawImage( sdrImage.source, 0, 0 );\n\t\t\t\tconst sdrImageData = ctx.getImageData(\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tsdrImage.width,\n\t\t\t\t\tsdrImage.height,\n\t\t\t\t\t{ colorSpace: 'srgb' }\n\t\t\t\t);\n\n\t\t\t\t/* HDR Recovery formula - https://developer.android.com/media/platform/hdr-image-format#use_the_gain_map_to_create_adapted_HDR_rendition */\n\t\t\t\tlet hdrBuffer;\n\n\t\t\t\tif ( this.type === HalfFloatType ) {\n\n\t\t\t\t\thdrBuffer = new Uint16Array( sdrImageData.data.length ).fill( 23544 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\thdrBuffer = new Float32Array( sdrImageData.data.length ).fill( 255 );\n\n\t\t\t\t}\n\n\t\t\t\tconst maxDisplayBoost = Math.sqrt(\n\t\t\t\t\tMath.pow(\n\t\t\t\t\t\t/* 1.8 instead of 2 near-perfectly rectifies approximations introduced by precalculated SRGB_TO_LINEAR values */\n\t\t\t\t\t\t1.8,\n\t\t\t\t\t\txmpMetadata.hdrCapacityMax\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\tconst unclampedWeightFactor =\n\t\t\t\t\t( Math.log2( maxDisplayBoost ) - xmpMetadata.hdrCapacityMin ) /\n\t\t\t\t\t( xmpMetadata.hdrCapacityMax - xmpMetadata.hdrCapacityMin );\n\t\t\t\tconst weightFactor = Math.min(\n\t\t\t\t\tMath.max( unclampedWeightFactor, 0.0 ),\n\t\t\t\t\t1.0\n\t\t\t\t);\n\t\t\t\tconst useGammaOne = xmpMetadata.gamma === 1.0;\n\n\t\t\t\tfor (\n\t\t\t\t\tlet pixelIndex = 0;\n\t\t\t\t\tpixelIndex < sdrImageData.data.length;\n\t\t\t\t\tpixelIndex += 4\n\t\t\t\t) {\n\n\t\t\t\t\tconst x = ( pixelIndex / 4 ) % sdrImage.width;\n\t\t\t\t\tconst y = Math.floor( pixelIndex / 4 / sdrImage.width );\n\n\t\t\t\t\tfor ( let channelIndex = 0; channelIndex < 3; channelIndex ++ ) {\n\n\t\t\t\t\t\tconst sdrValue = sdrImageData.data[ pixelIndex + channelIndex ];\n\n\t\t\t\t\t\tconst gainmapIndex = ( y * sdrImage.width + x ) * 4 + channelIndex;\n\t\t\t\t\t\tconst gainmapValue = gainmapImageData.data[ gainmapIndex ] / 255.0;\n\n\t\t\t\t\t\t/* Gamma is 1.0 by default */\n\t\t\t\t\t\tconst logRecovery = useGammaOne\n\t\t\t\t\t\t\t? gainmapValue\n\t\t\t\t\t\t\t: Math.pow( gainmapValue, 1.0 / xmpMetadata.gamma );\n\n\t\t\t\t\t\tconst logBoost =\n\t\t\t\t\t\t\txmpMetadata.gainMapMin * ( 1.0 - logRecovery ) +\n\t\t\t\t\t\t\txmpMetadata.gainMapMax * logRecovery;\n\n\t\t\t\t\t\tconst hdrValue =\n\t\t\t\t\t\t\t( sdrValue + xmpMetadata.offsetSDR ) *\n\t\t\t\t\t\t\t\t( logBoost * weightFactor === 0.0\n\t\t\t\t\t\t\t\t\t? 1.0\n\t\t\t\t\t\t\t\t\t: Math.pow( 2, logBoost * weightFactor ) ) -\n\t\t\t\t\t\t\txmpMetadata.offsetHDR;\n\n\t\t\t\t\t\tconst linearHDRValue = Math.min(\n\t\t\t\t\t\t\tMath.max( this._srgbToLinear( hdrValue ), 0 ),\n\t\t\t\t\t\t\t65504\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\thdrBuffer[ pixelIndex + channelIndex ] =\n\t\t\t\t\t\t\tthis.type === HalfFloatType\n\t\t\t\t\t\t\t\t? DataUtils.toHalfFloat( linearHDRValue )\n\t\t\t\t\t\t\t\t: linearHDRValue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tonSuccess( hdrBuffer, sdrImage.width, sdrImage.height );\n\n\t\t\t} )\n\t\t\t.catch( () => {\n\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'THREE.UltraHDRLoader Error: Could not parse UltraHDR images'\n\t\t\t\t);\n\n\t\t\t} );\n\n\t}\n\n}\n\nexport { UltraHDRLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}