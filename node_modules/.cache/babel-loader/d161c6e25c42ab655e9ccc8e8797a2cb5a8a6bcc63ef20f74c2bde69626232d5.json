{"ast":null,"code":"/**\n * === IFFParser ===\n * - Parses data from the IFF buffer.\n * - LWO3 files are in IFF format and can contain the following data types, referred to by shorthand codes\n *\n * ATOMIC DATA TYPES\n *  ID Tag - 4x 7 bit uppercase ASCII chars: ID4\n *  signed integer, 1, 2, or 4 byte length: I1, I2, I4\n *  unsigned integer, 1, 2, or 4 byte length: U1, U2, U4\n *  float, 4 byte length: F4\n *  string, series of ASCII chars followed by null byte (If the length of the string including the null terminating byte is odd, an extra null is added so that the data that follows will begin on an even byte boundary): S0\n *\n * COMPOUND DATA TYPES\n *  Variable-length Index (index into an array or collection): U2 or U4 : VX\n *  Color (RGB): F4 + F4 + F4: COL12\n *  Coordinate (x, y, z): F4 + F4 + F4: VEC12\n *  Percentage F4 data type from 0->1 with 1 = 100%: FP4\n *  Angle in radian F4: ANG4\n *  Filename (string) S0: FNAM0\n *  XValue F4 + index (VX) + optional envelope( ENVL ): XVAL\n *  XValue vector VEC12 + index (VX) + optional envelope( ENVL ): XVAL3\n *\n *  The IFF file is arranged in chunks:\n *  CHUNK = ID4 + length (U4) + length X bytes of data + optional 0 pad byte\n *  optional 0 pad byte is there to ensure chunk ends on even boundary, not counted in size\n *\n * COMPOUND DATA TYPES\n * - Chunks are combined in Forms (collections of chunks)\n * - FORM = string 'FORM' (ID4) + length (U4) + type (ID4) + optional ( CHUNK | FORM )\n * - CHUNKS and FORMS are collectively referred to as blocks\n * - The entire file is contained in one top level FORM\n *\n **/\n\nimport { LWO2Parser } from './LWO2Parser.js';\nimport { LWO3Parser } from './LWO3Parser.js';\nclass IFFParser {\n  constructor() {\n    this.debugger = new Debugger();\n    // this.debugger.enable(); // un-comment to log IFF hierarchy.\n  }\n  parse(buffer) {\n    this.reader = new DataViewReader(buffer);\n    this.tree = {\n      materials: {},\n      layers: [],\n      tags: [],\n      textures: []\n    };\n\n    // start out at the top level to add any data before first layer is encountered\n    this.currentLayer = this.tree;\n    this.currentForm = this.tree;\n    this.parseTopForm();\n    if (this.tree.format === undefined) return;\n    if (this.tree.format === 'LWO2') {\n      this.parser = new LWO2Parser(this);\n      while (!this.reader.endOfFile()) this.parser.parseBlock();\n    } else if (this.tree.format === 'LWO3') {\n      this.parser = new LWO3Parser(this);\n      while (!this.reader.endOfFile()) this.parser.parseBlock();\n    }\n    this.debugger.offset = this.reader.offset;\n    this.debugger.closeForms();\n    return this.tree;\n  }\n  parseTopForm() {\n    this.debugger.offset = this.reader.offset;\n    const topForm = this.reader.getIDTag();\n    if (topForm !== 'FORM') {\n      console.warn('LWOLoader: Top-level FORM missing.');\n      return;\n    }\n    const length = this.reader.getUint32();\n    this.debugger.dataOffset = this.reader.offset;\n    this.debugger.length = length;\n    const type = this.reader.getIDTag();\n    if (type === 'LWO2') {\n      this.tree.format = type;\n    } else if (type === 'LWO3') {\n      this.tree.format = type;\n    }\n    this.debugger.node = 0;\n    this.debugger.nodeID = type;\n    this.debugger.log();\n    return;\n  }\n\n  ///\n  // FORM PARSING METHODS\n  ///\n\n  // Forms are organisational and can contain any number of sub chunks and sub forms\n  // FORM ::= 'FORM'[ID4], length[U4], type[ID4], ( chunk[CHUNK] | form[FORM] ) * }\n  parseForm(length) {\n    const type = this.reader.getIDTag();\n    switch (type) {\n      // SKIPPED FORMS\n      // if skipForm( length ) is called, the entire form and any sub forms and chunks are skipped\n\n      case 'ISEQ': // Image sequence\n      case 'ANIM': // plug in animation\n      case 'STCC': // Color-cycling Still\n      case 'VPVL':\n      case 'VPRM':\n      case 'NROT':\n      case 'WRPW': // image wrap w ( for cylindrical and spherical projections)\n      case 'WRPH': // image wrap h\n      case 'FUNC':\n      case 'FALL':\n      case 'OPAC':\n      case 'GRAD': // gradient texture\n      case 'ENVS':\n      case 'VMOP':\n      case 'VMBG':\n\n      // Car Material FORMS\n      case 'OMAX':\n      case 'STEX':\n      case 'CKBG':\n      case 'CKEY':\n      case 'VMLA':\n      case 'VMLB':\n        this.debugger.skipped = true;\n        this.skipForm(length); // not currently supported\n        break;\n\n      // if break; is called directly, the position in the lwoTree is not created\n      // any sub chunks and forms are added to the parent form instead\n      case 'META':\n      case 'NNDS':\n      case 'NODS':\n      case 'NDTA':\n      case 'ADAT':\n      case 'AOVS':\n      case 'BLOK':\n\n      // used by texture nodes\n      case 'IBGC': // imageBackgroundColor\n      case 'IOPC': // imageOpacity\n      case 'IIMG': // hold reference to image path\n      case 'TXTR':\n        // this.setupForm( type, length );\n        this.debugger.length = 4;\n        this.debugger.skipped = true;\n        break;\n      case 'IFAL': // imageFallof\n      case 'ISCL': // imageScale\n      case 'IPOS': // imagePosition\n      case 'IROT': // imageRotation\n      case 'IBMP':\n      case 'IUTD':\n      case 'IVTD':\n        this.parseTextureNodeAttribute(type);\n        break;\n      case 'ENVL':\n        this.parseEnvelope(length);\n        break;\n\n      // CLIP FORM AND SUB FORMS\n\n      case 'CLIP':\n        if (this.tree.format === 'LWO2') {\n          this.parseForm(length);\n        } else {\n          this.parseClip(length);\n        }\n        break;\n      case 'STIL':\n        this.parseImage();\n        break;\n      case 'XREF':\n        // clone of another STIL\n        this.reader.skip(8); // unknown\n        this.currentForm.referenceTexture = {\n          index: this.reader.getUint32(),\n          refName: this.reader.getString() // internal unique ref\n        };\n        break;\n\n      // Not in spec, used by texture nodes\n\n      case 'IMST':\n        this.parseImageStateForm(length);\n        break;\n\n      // SURF FORM AND SUB FORMS\n\n      case 'SURF':\n        this.parseSurfaceForm(length);\n        break;\n      case 'VALU':\n        // Not in spec\n        this.parseValueForm(length);\n        break;\n      case 'NTAG':\n        this.parseSubNode(length);\n        break;\n      case 'ATTR': // BSDF Node Attributes\n      case 'SATR':\n        // Standard Node Attributes\n        this.setupForm('attributes', length);\n        break;\n      case 'NCON':\n        this.parseConnections(length);\n        break;\n      case 'SSHA':\n        this.parentForm = this.currentForm;\n        this.currentForm = this.currentSurface;\n        this.setupForm('surfaceShader', length);\n        break;\n      case 'SSHD':\n        this.setupForm('surfaceShaderData', length);\n        break;\n      case 'ENTR':\n        // Not in spec\n        this.parseEntryForm(length);\n        break;\n\n      // Image Map Layer\n\n      case 'IMAP':\n        this.parseImageMap(length);\n        break;\n      case 'TAMP':\n        this.parseXVAL('amplitude', length);\n        break;\n\n      //Texture Mapping Form\n\n      case 'TMAP':\n        this.setupForm('textureMap', length);\n        break;\n      case 'CNTR':\n        this.parseXVAL3('center', length);\n        break;\n      case 'SIZE':\n        this.parseXVAL3('scale', length);\n        break;\n      case 'ROTA':\n        this.parseXVAL3('rotation', length);\n        break;\n      default:\n        this.parseUnknownForm(type, length);\n    }\n    this.debugger.node = 0;\n    this.debugger.nodeID = type;\n    this.debugger.log();\n  }\n  setupForm(type, length) {\n    if (!this.currentForm) this.currentForm = this.currentNode;\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    if (!this.currentForm[type]) {\n      this.currentForm[type] = {};\n      this.currentForm = this.currentForm[type];\n    } else {\n      // should never see this unless there's a bug in the reader\n      console.warn('LWOLoader: form already exists on parent: ', type, this.currentForm);\n      this.currentForm = this.currentForm[type];\n    }\n  }\n  skipForm(length) {\n    this.reader.skip(length - 4);\n  }\n  parseUnknownForm(type, length) {\n    console.warn('LWOLoader: unknown FORM encountered: ' + type, length);\n    printBuffer(this.reader.dv.buffer, this.reader.offset, length - 4);\n    this.reader.skip(length - 4);\n  }\n  parseSurfaceForm(length) {\n    this.reader.skip(8); // unknown Uint32 x2\n\n    const name = this.reader.getString();\n    const surface = {\n      attributes: {},\n      // LWO2 style non-node attributes will go here\n      connections: {},\n      name: name,\n      inputName: name,\n      nodes: {},\n      source: this.reader.getString()\n    };\n    this.tree.materials[name] = surface;\n    this.currentSurface = surface;\n    this.parentForm = this.tree.materials;\n    this.currentForm = surface;\n    this.currentFormEnd = this.reader.offset + length;\n  }\n  parseSurfaceLwo2(length) {\n    const name = this.reader.getString();\n    const surface = {\n      attributes: {},\n      // LWO2 style non-node attributes will go here\n      connections: {},\n      name: name,\n      nodes: {},\n      source: this.reader.getString()\n    };\n    this.tree.materials[name] = surface;\n    this.currentSurface = surface;\n    this.parentForm = this.tree.materials;\n    this.currentForm = surface;\n    this.currentFormEnd = this.reader.offset + length;\n  }\n  parseSubNode(length) {\n    // parse the NRNM CHUNK of the subnode FORM to get\n    // a meaningful name for the subNode\n    // some subnodes can be renamed, but Input and Surface cannot\n\n    this.reader.skip(8); // NRNM + length\n    const name = this.reader.getString();\n    const node = {\n      name: name\n    };\n    this.currentForm = node;\n    this.currentNode = node;\n    this.currentFormEnd = this.reader.offset + length;\n  }\n\n  // collect attributes from all nodes at the top level of a surface\n  parseConnections(length) {\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    this.currentForm = this.currentSurface.connections;\n  }\n\n  // surface node attribute data, e.g. specular, roughness etc\n  parseEntryForm(length) {\n    this.reader.skip(8); // NAME + length\n    const name = this.reader.getString();\n    this.currentForm = this.currentNode.attributes;\n    this.setupForm(name, length);\n  }\n\n  // parse values from material - doesn't match up to other LWO3 data types\n  // sub form of entry form\n  parseValueForm() {\n    this.reader.skip(8); // unknown + length\n\n    const valueType = this.reader.getString();\n    if (valueType === 'double') {\n      this.currentForm.value = this.reader.getUint64();\n    } else if (valueType === 'int') {\n      this.currentForm.value = this.reader.getUint32();\n    } else if (valueType === 'vparam') {\n      this.reader.skip(24);\n      this.currentForm.value = this.reader.getFloat64();\n    } else if (valueType === 'vparam3') {\n      this.reader.skip(24);\n      this.currentForm.value = this.reader.getFloat64Array(3);\n    }\n  }\n\n  // holds various data about texture node image state\n  // Data other than mipMapLevel unknown\n  parseImageStateForm() {\n    this.reader.skip(8); // unknown\n\n    this.currentForm.mipMapLevel = this.reader.getFloat32();\n  }\n\n  // LWO2 style image data node OR LWO3 textures defined at top level in editor (not as SURF node)\n  parseImageMap(length) {\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    if (!this.currentForm.maps) this.currentForm.maps = [];\n    const map = {};\n    this.currentForm.maps.push(map);\n    this.currentForm = map;\n    this.reader.skip(10); // unknown, could be an issue if it contains a VX\n  }\n  parseTextureNodeAttribute(type) {\n    this.reader.skip(28); // FORM + length + VPRM + unknown + Uint32 x2 + float32\n\n    this.reader.skip(20); // FORM + length + VPVL + float32 + Uint32\n\n    switch (type) {\n      case 'ISCL':\n        this.currentNode.scale = this.reader.getFloat32Array(3);\n        break;\n      case 'IPOS':\n        this.currentNode.position = this.reader.getFloat32Array(3);\n        break;\n      case 'IROT':\n        this.currentNode.rotation = this.reader.getFloat32Array(3);\n        break;\n      case 'IFAL':\n        this.currentNode.falloff = this.reader.getFloat32Array(3);\n        break;\n      case 'IBMP':\n        this.currentNode.amplitude = this.reader.getFloat32();\n        break;\n      case 'IUTD':\n        this.currentNode.uTiles = this.reader.getFloat32();\n        break;\n      case 'IVTD':\n        this.currentNode.vTiles = this.reader.getFloat32();\n        break;\n    }\n    this.reader.skip(2); // unknown\n  }\n\n  // ENVL forms are currently ignored\n  parseEnvelope(length) {\n    this.reader.skip(length - 4); // skipping  entirely for now\n  }\n\n  ///\n  // CHUNK PARSING METHODS\n  ///\n\n  // clips can either be defined inside a surface node, or at the top\n  // level and they have a different format in each case\n  parseClip(length) {\n    const tag = this.reader.getIDTag();\n\n    // inside surface node\n    if (tag === 'FORM') {\n      this.reader.skip(16);\n      this.currentNode.fileName = this.reader.getString();\n      return;\n    }\n\n    // otherwise top level\n    this.reader.setOffset(this.reader.offset - 4);\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    this.reader.skip(8); // unknown\n\n    const texture = {\n      index: this.reader.getUint32()\n    };\n    this.tree.textures.push(texture);\n    this.currentForm = texture;\n  }\n  parseClipLwo2(length) {\n    const texture = {\n      index: this.reader.getUint32(),\n      fileName: ''\n    };\n\n    // search STIL block\n    while (true) {\n      const tag = this.reader.getIDTag();\n      const n_length = this.reader.getUint16();\n      if (tag === 'STIL') {\n        texture.fileName = this.reader.getString();\n        break;\n      }\n      if (n_length >= length) {\n        break;\n      }\n    }\n    this.tree.textures.push(texture);\n    this.currentForm = texture;\n  }\n  parseImage() {\n    this.reader.skip(8); // unknown\n    this.currentForm.fileName = this.reader.getString();\n  }\n  parseXVAL(type, length) {\n    const endOffset = this.reader.offset + length - 4;\n    this.reader.skip(8);\n    this.currentForm[type] = this.reader.getFloat32();\n    this.reader.setOffset(endOffset); // set end offset directly to skip optional envelope\n  }\n  parseXVAL3(type, length) {\n    const endOffset = this.reader.offset + length - 4;\n    this.reader.skip(8);\n    this.currentForm[type] = {\n      x: this.reader.getFloat32(),\n      y: this.reader.getFloat32(),\n      z: this.reader.getFloat32()\n    };\n    this.reader.setOffset(endOffset);\n  }\n\n  // Tags associated with an object\n  // OTAG { type[ID4], tag-string[S0] }\n  parseObjectTag() {\n    if (!this.tree.objectTags) this.tree.objectTags = {};\n    this.tree.objectTags[this.reader.getIDTag()] = {\n      tagString: this.reader.getString()\n    };\n  }\n\n  // Signals the start of a new layer. All the data chunks which follow will be included in this layer until another layer chunk is encountered.\n  // LAYR: number[U2], flags[U2], pivot[VEC12], name[S0], parent[U2]\n  parseLayer(length) {\n    const number = this.reader.getUint16();\n    const flags = this.reader.getUint16(); // If the least significant bit of flags is set, the layer is hidden.\n    const pivot = this.reader.getFloat32Array(3); // Note: this seems to be superfluous, as the geometry is translated when pivot is present\n    const layer = {\n      number: number,\n      flags: flags,\n      // If the least significant bit of flags is set, the layer is hidden.\n      pivot: [-pivot[0], pivot[1], pivot[2]],\n      // Note: this seems to be superfluous, as the geometry is translated when pivot is present\n      name: this.reader.getString()\n    };\n    this.tree.layers.push(layer);\n    this.currentLayer = layer;\n    const parsedLength = 16 + stringOffset(this.currentLayer.name); // index ( 2 ) + flags( 2 ) + pivot( 12 ) + stringlength\n\n    // if we have not reached then end of the layer block, there must be a parent defined\n    this.currentLayer.parent = parsedLength < length ? this.reader.getUint16() : -1; // omitted or -1 for no parent\n  }\n\n  // VEC12 * ( F4 + F4 + F4 ) array of x,y,z vectors\n  // Converting from left to right handed coordinate system:\n  // x -> -x and switch material FrontSide -> BackSide\n  parsePoints(length) {\n    this.currentPoints = [];\n    for (let i = 0; i < length / 4; i += 3) {\n      // x -> -x to match three.js right handed coords\n      this.currentPoints.push(-this.reader.getFloat32(), this.reader.getFloat32(), this.reader.getFloat32());\n    }\n  }\n\n  // parse VMAP or VMAD\n  // Associates a set of floating-point vectors with a set of points.\n  // VMAP: { type[ID4], dimension[U2], name[S0], ( vert[VX], value[F4] # dimension ) * }\n\n  // VMAD Associates a set of floating-point vectors with the vertices of specific polygons.\n  // Similar to VMAP UVs, but associates with polygon vertices rather than points\n  // to solve to problem of UV seams:  VMAD chunks are paired with VMAPs of the same name,\n  // if they exist. The vector values in the VMAD will then replace those in the\n  // corresponding VMAP, but only for calculations involving the specified polygons.\n  // VMAD { type[ID4], dimension[U2], name[S0], ( vert[VX], poly[VX], value[F4] # dimension ) * }\n  parseVertexMapping(length, discontinuous) {\n    const finalOffset = this.reader.offset + length;\n    const channelName = this.reader.getString();\n    if (this.reader.offset === finalOffset) {\n      // then we are in a texture node and the VMAP chunk is just a reference to a UV channel name\n      this.currentForm.UVChannel = channelName;\n      return;\n    }\n\n    // otherwise reset to initial length and parse normal VMAP CHUNK\n    this.reader.setOffset(this.reader.offset - stringOffset(channelName));\n    const type = this.reader.getIDTag();\n    this.reader.getUint16(); // dimension\n    const name = this.reader.getString();\n    const remainingLength = length - 6 - stringOffset(name);\n    switch (type) {\n      case 'TXUV':\n        this.parseUVMapping(name, finalOffset, discontinuous);\n        break;\n      case 'MORF':\n      case 'SPOT':\n        this.parseMorphTargets(name, finalOffset, type); // can't be discontinuous\n        break;\n      // unsupported VMAPs\n      case 'APSL':\n      case 'NORM':\n      case 'WGHT':\n      case 'MNVW':\n      case 'PICK':\n      case 'RGB ':\n      case 'RGBA':\n        this.reader.skip(remainingLength);\n        break;\n      default:\n        console.warn('LWOLoader: unknown vertex map type: ' + type);\n        this.reader.skip(remainingLength);\n    }\n  }\n  parseUVMapping(name, finalOffset, discontinuous) {\n    const uvIndices = [];\n    const polyIndices = [];\n    const uvs = [];\n    while (this.reader.offset < finalOffset) {\n      uvIndices.push(this.reader.getVariableLengthIndex());\n      if (discontinuous) polyIndices.push(this.reader.getVariableLengthIndex());\n      uvs.push(this.reader.getFloat32(), this.reader.getFloat32());\n    }\n    if (discontinuous) {\n      if (!this.currentLayer.discontinuousUVs) this.currentLayer.discontinuousUVs = {};\n      this.currentLayer.discontinuousUVs[name] = {\n        uvIndices: uvIndices,\n        polyIndices: polyIndices,\n        uvs: uvs\n      };\n    } else {\n      if (!this.currentLayer.uvs) this.currentLayer.uvs = {};\n      this.currentLayer.uvs[name] = {\n        uvIndices: uvIndices,\n        uvs: uvs\n      };\n    }\n  }\n  parseMorphTargets(name, finalOffset, type) {\n    const indices = [];\n    const points = [];\n    type = type === 'MORF' ? 'relative' : 'absolute';\n    while (this.reader.offset < finalOffset) {\n      indices.push(this.reader.getVariableLengthIndex());\n      // z -> -z to match three.js right handed coords\n      points.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\n    }\n    if (!this.currentLayer.morphTargets) this.currentLayer.morphTargets = {};\n    this.currentLayer.morphTargets[name] = {\n      indices: indices,\n      points: points,\n      type: type\n    };\n  }\n\n  // A list of polygons for the current layer.\n  // POLS { type[ID4], ( numvert+flags[U2], vert[VX] # numvert ) * }\n  parsePolygonList(length) {\n    const finalOffset = this.reader.offset + length;\n    const type = this.reader.getIDTag();\n    const indices = [];\n\n    // hold a list of polygon sizes, to be split up later\n    const polygonDimensions = [];\n    while (this.reader.offset < finalOffset) {\n      let numverts = this.reader.getUint16();\n\n      //const flags = numverts & 64512; // 6 high order bits are flags - ignoring for now\n      numverts = numverts & 1023; // remaining ten low order bits are vertex num\n      polygonDimensions.push(numverts);\n      for (let j = 0; j < numverts; j++) indices.push(this.reader.getVariableLengthIndex());\n    }\n    const geometryData = {\n      type: type,\n      vertexIndices: indices,\n      polygonDimensions: polygonDimensions,\n      points: this.currentPoints\n    };\n\n    // Note: assuming that all polys will be lines or points if the first is\n    if (polygonDimensions[0] === 1) geometryData.type = 'points';else if (polygonDimensions[0] === 2) geometryData.type = 'lines';\n    this.currentLayer.geometry = geometryData;\n  }\n\n  // Lists the tag strings that can be associated with polygons by the PTAG chunk.\n  // TAGS { tag-string[S0] * }\n  parseTagStrings(length) {\n    this.tree.tags = this.reader.getStringArray(length);\n  }\n\n  // Associates tags of a given type with polygons in the most recent POLS chunk.\n  // PTAG { type[ID4], ( poly[VX], tag[U2] ) * }\n  parsePolygonTagMapping(length) {\n    const finalOffset = this.reader.offset + length;\n    const type = this.reader.getIDTag();\n    if (type === 'SURF') this.parseMaterialIndices(finalOffset);else {\n      //PART, SMGP, COLR not supported\n\n      this.reader.skip(length - 4);\n    }\n  }\n  parseMaterialIndices(finalOffset) {\n    // array holds polygon index followed by material index\n    this.currentLayer.geometry.materialIndices = [];\n    while (this.reader.offset < finalOffset) {\n      const polygonIndex = this.reader.getVariableLengthIndex();\n      const materialIndex = this.reader.getUint16();\n      this.currentLayer.geometry.materialIndices.push(polygonIndex, materialIndex);\n    }\n  }\n  parseUnknownCHUNK(blockID, length) {\n    console.warn('LWOLoader: unknown chunk type: ' + blockID + ' length: ' + length);\n\n    // print the chunk plus some bytes padding either side\n    // printBuffer( this.reader.dv.buffer, this.reader.offset - 20, length + 40 );\n\n    const data = this.reader.getString(length);\n    this.currentForm[blockID] = data;\n  }\n}\nclass DataViewReader {\n  constructor(buffer) {\n    this.dv = new DataView(buffer);\n    this.offset = 0;\n    this._textDecoder = new TextDecoder();\n    this._bytes = new Uint8Array(buffer);\n  }\n  size() {\n    return this.dv.buffer.byteLength;\n  }\n  setOffset(offset) {\n    if (offset > 0 && offset < this.dv.buffer.byteLength) {\n      this.offset = offset;\n    } else {\n      console.error('LWOLoader: invalid buffer offset');\n    }\n  }\n  endOfFile() {\n    if (this.offset >= this.size()) return true;\n    return false;\n  }\n  skip(length) {\n    this.offset += length;\n  }\n  getUint8() {\n    const value = this.dv.getUint8(this.offset);\n    this.offset += 1;\n    return value;\n  }\n  getUint16() {\n    const value = this.dv.getUint16(this.offset);\n    this.offset += 2;\n    return value;\n  }\n  getInt32() {\n    const value = this.dv.getInt32(this.offset, false);\n    this.offset += 4;\n    return value;\n  }\n  getUint32() {\n    const value = this.dv.getUint32(this.offset, false);\n    this.offset += 4;\n    return value;\n  }\n  getUint64() {\n    const low = this.getUint32();\n    const high = this.getUint32();\n    return high * 0x100000000 + low;\n  }\n  getFloat32() {\n    const value = this.dv.getFloat32(this.offset, false);\n    this.offset += 4;\n    return value;\n  }\n  getFloat32Array(size) {\n    const a = [];\n    for (let i = 0; i < size; i++) {\n      a.push(this.getFloat32());\n    }\n    return a;\n  }\n  getFloat64() {\n    const value = this.dv.getFloat64(this.offset, this.littleEndian);\n    this.offset += 8;\n    return value;\n  }\n  getFloat64Array(size) {\n    const a = [];\n    for (let i = 0; i < size; i++) {\n      a.push(this.getFloat64());\n    }\n    return a;\n  }\n\n  // get variable-length index data type\n  // VX ::= index[U2] | (index + 0xFF000000)[U4]\n  // If the index value is less than 65,280 (0xFF00),then VX === U2\n  // otherwise VX === U4 with bits 24-31 set\n  // When reading an index, if the first byte encountered is 255 (0xFF), then\n  // the four-byte form is being used and the first byte should be discarded or masked out.\n  getVariableLengthIndex() {\n    const firstByte = this.getUint8();\n    if (firstByte === 255) {\n      return this.getUint8() * 65536 + this.getUint8() * 256 + this.getUint8();\n    }\n    return firstByte * 256 + this.getUint8();\n  }\n\n  // An ID tag is a sequence of 4 bytes containing 7-bit ASCII values\n  getIDTag() {\n    return this.getString(4);\n  }\n  getString(size) {\n    if (size === 0) return;\n    const start = this.offset;\n    let result;\n    let length;\n    if (size) {\n      length = size;\n      result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, size));\n    } else {\n      // use 1:1 mapping of buffer to avoid redundant new array creation.\n      length = this._bytes.indexOf(0, start) - start;\n      result = this._textDecoder.decode(new Uint8Array(this.dv.buffer, start, length));\n\n      // account for null byte in length\n      length++;\n\n      // if string with terminating nullbyte is uneven, extra nullbyte is added, skip that too\n      length += length % 2;\n    }\n    this.skip(length);\n    return result;\n  }\n  getStringArray(size) {\n    let a = this.getString(size);\n    a = a.split('\\0');\n    return a.filter(Boolean); // return array with any empty strings removed\n  }\n}\n\n// ************** DEBUGGER  **************\n\nclass Debugger {\n  constructor() {\n    this.active = false;\n    this.depth = 0;\n    this.formList = [];\n    this.offset = 0;\n    this.node = 0; // 0 = FORM, 1 = CHUNK, 2 = SUBNODE\n    this.nodeID = 'FORM';\n    this.dataOffset = 0;\n    this.length = 0;\n    this.skipped = false;\n  }\n  enable() {\n    this.active = true;\n  }\n  log() {\n    if (!this.active) return;\n    let nodeType;\n    switch (this.node) {\n      case 0:\n        nodeType = 'FORM';\n        break;\n      case 1:\n        nodeType = 'CHK';\n        break;\n      case 2:\n        nodeType = 'S-CHK';\n        break;\n    }\n    console.log('| '.repeat(this.depth) + nodeType, this.nodeID, `( ${this.offset} ) -> ( ${this.dataOffset + this.length} )`, this.node == 0 ? ' {' : '', this.skipped ? 'SKIPPED' : '', this.node == 0 && this.skipped ? '}' : '');\n    if (this.node == 0 && !this.skipped) {\n      this.depth += 1;\n      this.formList.push(this.dataOffset + this.length);\n    }\n    this.skipped = false;\n  }\n  closeForms() {\n    if (!this.active) return;\n    for (let i = this.formList.length - 1; i >= 0; i--) {\n      if (this.offset >= this.formList[i]) {\n        this.depth -= 1;\n        console.log('| '.repeat(this.depth) + '}');\n        this.formList.splice(-1, 1);\n      }\n    }\n  }\n}\n\n// ************** UTILITY FUNCTIONS **************\n\n// calculate the length of the string in the buffer\n// this will be string.length + nullbyte + optional padbyte to make the length even\nfunction stringOffset(string) {\n  return string.length + 1 + (string.length + 1) % 2;\n}\n\n// for testing purposes, dump buffer to console\n// printBuffer( this.reader.dv.buffer, this.reader.offset, length );\nfunction printBuffer(buffer, from, to) {\n  console.log(new TextDecoder().decode(new Uint8Array(buffer, from, to)));\n}\nexport { IFFParser };","map":{"version":3,"names":["LWO2Parser","LWO3Parser","IFFParser","constructor","debugger","Debugger","parse","buffer","reader","DataViewReader","tree","materials","layers","tags","textures","currentLayer","currentForm","parseTopForm","format","undefined","parser","endOfFile","parseBlock","offset","closeForms","topForm","getIDTag","console","warn","length","getUint32","dataOffset","type","node","nodeID","log","parseForm","skipped","skipForm","parseTextureNodeAttribute","parseEnvelope","parseClip","parseImage","skip","referenceTexture","index","refName","getString","parseImageStateForm","parseSurfaceForm","parseValueForm","parseSubNode","setupForm","parseConnections","parentForm","currentSurface","parseEntryForm","parseImageMap","parseXVAL","parseXVAL3","parseUnknownForm","currentNode","currentFormEnd","printBuffer","dv","name","surface","attributes","connections","inputName","nodes","source","parseSurfaceLwo2","valueType","value","getUint64","getFloat64","getFloat64Array","mipMapLevel","getFloat32","maps","map","push","scale","getFloat32Array","position","rotation","falloff","amplitude","uTiles","vTiles","tag","fileName","setOffset","texture","parseClipLwo2","n_length","getUint16","endOffset","x","y","z","parseObjectTag","objectTags","tagString","parseLayer","number","flags","pivot","layer","parsedLength","stringOffset","parent","parsePoints","currentPoints","i","parseVertexMapping","discontinuous","finalOffset","channelName","UVChannel","remainingLength","parseUVMapping","parseMorphTargets","uvIndices","polyIndices","uvs","getVariableLengthIndex","discontinuousUVs","indices","points","morphTargets","parsePolygonList","polygonDimensions","numverts","j","geometryData","vertexIndices","geometry","parseTagStrings","getStringArray","parsePolygonTagMapping","parseMaterialIndices","materialIndices","polygonIndex","materialIndex","parseUnknownCHUNK","blockID","data","DataView","_textDecoder","TextDecoder","_bytes","Uint8Array","size","byteLength","error","getUint8","getInt32","low","high","a","littleEndian","firstByte","start","result","decode","indexOf","split","filter","Boolean","active","depth","formList","enable","nodeType","repeat","splice","string","from","to"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/loaders/lwo/IFFParser.js"],"sourcesContent":["/**\n * === IFFParser ===\n * - Parses data from the IFF buffer.\n * - LWO3 files are in IFF format and can contain the following data types, referred to by shorthand codes\n *\n * ATOMIC DATA TYPES\n *  ID Tag - 4x 7 bit uppercase ASCII chars: ID4\n *  signed integer, 1, 2, or 4 byte length: I1, I2, I4\n *  unsigned integer, 1, 2, or 4 byte length: U1, U2, U4\n *  float, 4 byte length: F4\n *  string, series of ASCII chars followed by null byte (If the length of the string including the null terminating byte is odd, an extra null is added so that the data that follows will begin on an even byte boundary): S0\n *\n * COMPOUND DATA TYPES\n *  Variable-length Index (index into an array or collection): U2 or U4 : VX\n *  Color (RGB): F4 + F4 + F4: COL12\n *  Coordinate (x, y, z): F4 + F4 + F4: VEC12\n *  Percentage F4 data type from 0->1 with 1 = 100%: FP4\n *  Angle in radian F4: ANG4\n *  Filename (string) S0: FNAM0\n *  XValue F4 + index (VX) + optional envelope( ENVL ): XVAL\n *  XValue vector VEC12 + index (VX) + optional envelope( ENVL ): XVAL3\n *\n *  The IFF file is arranged in chunks:\n *  CHUNK = ID4 + length (U4) + length X bytes of data + optional 0 pad byte\n *  optional 0 pad byte is there to ensure chunk ends on even boundary, not counted in size\n *\n * COMPOUND DATA TYPES\n * - Chunks are combined in Forms (collections of chunks)\n * - FORM = string 'FORM' (ID4) + length (U4) + type (ID4) + optional ( CHUNK | FORM )\n * - CHUNKS and FORMS are collectively referred to as blocks\n * - The entire file is contained in one top level FORM\n *\n **/\n\nimport { LWO2Parser } from './LWO2Parser.js';\nimport { LWO3Parser } from './LWO3Parser.js';\n\nclass IFFParser {\n\n\tconstructor() {\n\n\t\tthis.debugger = new Debugger();\n\t\t// this.debugger.enable(); // un-comment to log IFF hierarchy.\n\n\t}\n\n\tparse( buffer ) {\n\n\t\tthis.reader = new DataViewReader( buffer );\n\n\t\tthis.tree = {\n\t\t\tmaterials: {},\n\t\t\tlayers: [],\n\t\t\ttags: [],\n\t\t\ttextures: [],\n\t\t};\n\n\t\t// start out at the top level to add any data before first layer is encountered\n\t\tthis.currentLayer = this.tree;\n\t\tthis.currentForm = this.tree;\n\n\t\tthis.parseTopForm();\n\n\t\tif ( this.tree.format === undefined ) return;\n\n\t\tif ( this.tree.format === 'LWO2' ) {\n\n\t\t\tthis.parser = new LWO2Parser( this );\n\t\t\twhile ( ! this.reader.endOfFile() ) this.parser.parseBlock();\n\n\t\t} else if ( this.tree.format === 'LWO3' ) {\n\n\t\t\tthis.parser = new LWO3Parser( this );\n\t\t\twhile ( ! this.reader.endOfFile() ) this.parser.parseBlock();\n\n\t\t}\n\n\t\tthis.debugger.offset = this.reader.offset;\n\t\tthis.debugger.closeForms();\n\n\t\treturn this.tree;\n\n\t}\n\n\tparseTopForm() {\n\n\t\tthis.debugger.offset = this.reader.offset;\n\n\t\tconst topForm = this.reader.getIDTag();\n\n\t\tif ( topForm !== 'FORM' ) {\n\n\t\t\tconsole.warn( 'LWOLoader: Top-level FORM missing.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst length = this.reader.getUint32();\n\n\t\tthis.debugger.dataOffset = this.reader.offset;\n\t\tthis.debugger.length = length;\n\n\t\tconst type = this.reader.getIDTag();\n\n\t\tif ( type === 'LWO2' ) {\n\n\t\t\tthis.tree.format = type;\n\n\t\t} else if ( type === 'LWO3' ) {\n\n\t\t\tthis.tree.format = type;\n\n\t\t}\n\n\t\tthis.debugger.node = 0;\n\t\tthis.debugger.nodeID = type;\n\t\tthis.debugger.log();\n\n\t\treturn;\n\n\t}\n\n\n\t///\n\t// FORM PARSING METHODS\n\t///\n\n\t// Forms are organisational and can contain any number of sub chunks and sub forms\n\t// FORM ::= 'FORM'[ID4], length[U4], type[ID4], ( chunk[CHUNK] | form[FORM] ) * }\n\tparseForm( length ) {\n\n\t\tconst type = this.reader.getIDTag();\n\n\t\tswitch ( type ) {\n\n\t\t\t// SKIPPED FORMS\n\t\t\t// if skipForm( length ) is called, the entire form and any sub forms and chunks are skipped\n\n\t\t\tcase 'ISEQ': // Image sequence\n\t\t\tcase 'ANIM': // plug in animation\n\t\t\tcase 'STCC': // Color-cycling Still\n\t\t\tcase 'VPVL':\n\t\t\tcase 'VPRM':\n\t\t\tcase 'NROT':\n\t\t\tcase 'WRPW': // image wrap w ( for cylindrical and spherical projections)\n\t\t\tcase 'WRPH': // image wrap h\n\t\t\tcase 'FUNC':\n\t\t\tcase 'FALL':\n\t\t\tcase 'OPAC':\n\t\t\tcase 'GRAD': // gradient texture\n\t\t\tcase 'ENVS':\n\t\t\tcase 'VMOP':\n\t\t\tcase 'VMBG':\n\n\t\t\t// Car Material FORMS\n\t\t\tcase 'OMAX':\n\t\t\tcase 'STEX':\n\t\t\tcase 'CKBG':\n\t\t\tcase 'CKEY':\n\t\t\tcase 'VMLA':\n\t\t\tcase 'VMLB':\n\t\t\t\tthis.debugger.skipped = true;\n\t\t\t\tthis.skipForm( length ); // not currently supported\n\t\t\t\tbreak;\n\n\t\t\t// if break; is called directly, the position in the lwoTree is not created\n\t\t\t// any sub chunks and forms are added to the parent form instead\n\t\t\tcase 'META':\n\t\t\tcase 'NNDS':\n\t\t\tcase 'NODS':\n\t\t\tcase 'NDTA':\n\t\t\tcase 'ADAT':\n\t\t\tcase 'AOVS':\n\t\t\tcase 'BLOK':\n\n\t\t\t// used by texture nodes\n\t\t\tcase 'IBGC': // imageBackgroundColor\n\t\t\tcase 'IOPC': // imageOpacity\n\t\t\tcase 'IIMG': // hold reference to image path\n\t\t\tcase 'TXTR':\n\t\t\t\t// this.setupForm( type, length );\n\t\t\t\tthis.debugger.length = 4;\n\t\t\t\tthis.debugger.skipped = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 'IFAL': // imageFallof\n\t\t\tcase 'ISCL': // imageScale\n\t\t\tcase 'IPOS': // imagePosition\n\t\t\tcase 'IROT': // imageRotation\n\t\t\tcase 'IBMP':\n\t\t\tcase 'IUTD':\n\t\t\tcase 'IVTD':\n\t\t\t\tthis.parseTextureNodeAttribute( type );\n\t\t\t\tbreak;\n\n\t\t\tcase 'ENVL':\n\t\t\t\tthis.parseEnvelope( length );\n\t\t\t\tbreak;\n\n\t\t\t\t// CLIP FORM AND SUB FORMS\n\n\t\t\tcase 'CLIP':\n\t\t\t\tif ( this.tree.format === 'LWO2' ) {\n\n\t\t\t\t\tthis.parseForm( length );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.parseClip( length );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'STIL':\n\t\t\t\tthis.parseImage();\n\t\t\t\tbreak;\n\n\t\t\tcase 'XREF': // clone of another STIL\n\t\t\t\tthis.reader.skip( 8 ); // unknown\n\t\t\t\tthis.currentForm.referenceTexture = {\n\t\t\t\t\tindex: this.reader.getUint32(),\n\t\t\t\t\trefName: this.reader.getString() // internal unique ref\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\t\t// Not in spec, used by texture nodes\n\n\t\t\tcase 'IMST':\n\t\t\t\tthis.parseImageStateForm( length );\n\t\t\t\tbreak;\n\n\t\t\t\t// SURF FORM AND SUB FORMS\n\n\t\t\tcase 'SURF':\n\t\t\t\tthis.parseSurfaceForm( length );\n\t\t\t\tbreak;\n\n\t\t\tcase 'VALU': // Not in spec\n\t\t\t\tthis.parseValueForm( length );\n\t\t\t\tbreak;\n\n\t\t\tcase 'NTAG':\n\t\t\t\tthis.parseSubNode( length );\n\t\t\t\tbreak;\n\n\t\t\tcase 'ATTR': // BSDF Node Attributes\n\t\t\tcase 'SATR': // Standard Node Attributes\n\t\t\t\tthis.setupForm( 'attributes', length );\n\t\t\t\tbreak;\n\n\t\t\tcase 'NCON':\n\t\t\t\tthis.parseConnections( length );\n\t\t\t\tbreak;\n\n\t\t\tcase 'SSHA':\n\t\t\t\tthis.parentForm = this.currentForm;\n\t\t\t\tthis.currentForm = this.currentSurface;\n\t\t\t\tthis.setupForm( 'surfaceShader', length );\n\t\t\t\tbreak;\n\n\t\t\tcase 'SSHD':\n\t\t\t\tthis.setupForm( 'surfaceShaderData', length );\n\t\t\t\tbreak;\n\n\t\t\tcase 'ENTR': // Not in spec\n\t\t\t\tthis.parseEntryForm( length );\n\t\t\t\tbreak;\n\n\t\t\t\t// Image Map Layer\n\n\t\t\tcase 'IMAP':\n\t\t\t\tthis.parseImageMap( length );\n\t\t\t\tbreak;\n\n\t\t\tcase 'TAMP':\n\t\t\t\tthis.parseXVAL( 'amplitude', length );\n\t\t\t\tbreak;\n\n\t\t\t\t//Texture Mapping Form\n\n\t\t\tcase 'TMAP':\n\t\t\t\tthis.setupForm( 'textureMap', length );\n\t\t\t\tbreak;\n\n\t\t\tcase 'CNTR':\n\t\t\t\tthis.parseXVAL3( 'center', length );\n\t\t\t\tbreak;\n\n\t\t\tcase 'SIZE':\n\t\t\t\tthis.parseXVAL3( 'scale', length );\n\t\t\t\tbreak;\n\n\t\t\tcase 'ROTA':\n\t\t\t\tthis.parseXVAL3( 'rotation', length );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthis.parseUnknownForm( type, length );\n\n\t\t}\n\n\t\tthis.debugger.node = 0;\n\t\tthis.debugger.nodeID = type;\n\t\tthis.debugger.log();\n\n\t}\n\n\tsetupForm( type, length ) {\n\n\t\tif ( ! this.currentForm ) this.currentForm = this.currentNode;\n\n\t\tthis.currentFormEnd = this.reader.offset + length;\n\t\tthis.parentForm = this.currentForm;\n\n\t\tif ( ! this.currentForm[ type ] ) {\n\n\t\t\tthis.currentForm[ type ] = {};\n\t\t\tthis.currentForm = this.currentForm[ type ];\n\n\n\t\t} else {\n\n\t\t\t// should never see this unless there's a bug in the reader\n\t\t\tconsole.warn( 'LWOLoader: form already exists on parent: ', type, this.currentForm );\n\n\t\t\tthis.currentForm = this.currentForm[ type ];\n\n\t\t}\n\n\n\t}\n\n\tskipForm( length ) {\n\n\t\tthis.reader.skip( length - 4 );\n\n\t}\n\n\tparseUnknownForm( type, length ) {\n\n\t\tconsole.warn( 'LWOLoader: unknown FORM encountered: ' + type, length );\n\n\t\tprintBuffer( this.reader.dv.buffer, this.reader.offset, length - 4 );\n\t\tthis.reader.skip( length - 4 );\n\n\t}\n\n\tparseSurfaceForm( length ) {\n\n\t\tthis.reader.skip( 8 ); // unknown Uint32 x2\n\n\t\tconst name = this.reader.getString();\n\n\t\tconst surface = {\n\t\t\tattributes: {}, // LWO2 style non-node attributes will go here\n\t\t\tconnections: {},\n\t\t\tname: name,\n\t\t\tinputName: name,\n\t\t\tnodes: {},\n\t\t\tsource: this.reader.getString(),\n\t\t};\n\n\t\tthis.tree.materials[ name ] = surface;\n\t\tthis.currentSurface = surface;\n\n\t\tthis.parentForm = this.tree.materials;\n\t\tthis.currentForm = surface;\n\t\tthis.currentFormEnd = this.reader.offset + length;\n\n\t}\n\n\tparseSurfaceLwo2( length ) {\n\n\t\tconst name = this.reader.getString();\n\n\t\tconst surface = {\n\t\t\tattributes: {}, // LWO2 style non-node attributes will go here\n\t\t\tconnections: {},\n\t\t\tname: name,\n\t\t\tnodes: {},\n\t\t\tsource: this.reader.getString(),\n\t\t};\n\n\t\tthis.tree.materials[ name ] = surface;\n\t\tthis.currentSurface = surface;\n\n\t\tthis.parentForm = this.tree.materials;\n\t\tthis.currentForm = surface;\n\t\tthis.currentFormEnd = this.reader.offset + length;\n\n\t}\n\n\tparseSubNode( length ) {\n\n\t\t// parse the NRNM CHUNK of the subnode FORM to get\n\t\t// a meaningful name for the subNode\n\t\t// some subnodes can be renamed, but Input and Surface cannot\n\n\t\tthis.reader.skip( 8 ); // NRNM + length\n\t\tconst name = this.reader.getString();\n\n\t\tconst node = {\n\t\t\tname: name\n\t\t};\n\t\tthis.currentForm = node;\n\t\tthis.currentNode = node;\n\n\t\tthis.currentFormEnd = this.reader.offset + length;\n\n\n\t}\n\n\t// collect attributes from all nodes at the top level of a surface\n\tparseConnections( length ) {\n\n\t\tthis.currentFormEnd = this.reader.offset + length;\n\t\tthis.parentForm = this.currentForm;\n\n\t\tthis.currentForm = this.currentSurface.connections;\n\n\t}\n\n\t// surface node attribute data, e.g. specular, roughness etc\n\tparseEntryForm( length ) {\n\n\t\tthis.reader.skip( 8 ); // NAME + length\n\t\tconst name = this.reader.getString();\n\t\tthis.currentForm = this.currentNode.attributes;\n\n\t\tthis.setupForm( name, length );\n\n\t}\n\n\t// parse values from material - doesn't match up to other LWO3 data types\n\t// sub form of entry form\n\tparseValueForm() {\n\n\t\tthis.reader.skip( 8 ); // unknown + length\n\n\t\tconst valueType = this.reader.getString();\n\n\t\tif ( valueType === 'double' ) {\n\n\t\t\tthis.currentForm.value = this.reader.getUint64();\n\n\t\t} else if ( valueType === 'int' ) {\n\n\t\t\tthis.currentForm.value = this.reader.getUint32();\n\n\t\t} else if ( valueType === 'vparam' ) {\n\n\t\t\tthis.reader.skip( 24 );\n\t\t\tthis.currentForm.value = this.reader.getFloat64();\n\n\t\t} else if ( valueType === 'vparam3' ) {\n\n\t\t\tthis.reader.skip( 24 );\n\t\t\tthis.currentForm.value = this.reader.getFloat64Array( 3 );\n\n\t\t}\n\n\t}\n\n\t// holds various data about texture node image state\n\t// Data other than mipMapLevel unknown\n\tparseImageStateForm() {\n\n\t\tthis.reader.skip( 8 ); // unknown\n\n\t\tthis.currentForm.mipMapLevel = this.reader.getFloat32();\n\n\t}\n\n\t// LWO2 style image data node OR LWO3 textures defined at top level in editor (not as SURF node)\n\tparseImageMap( length ) {\n\n\t\tthis.currentFormEnd = this.reader.offset + length;\n\t\tthis.parentForm = this.currentForm;\n\n\t\tif ( ! this.currentForm.maps ) this.currentForm.maps = [];\n\n\t\tconst map = {};\n\t\tthis.currentForm.maps.push( map );\n\t\tthis.currentForm = map;\n\n\t\tthis.reader.skip( 10 ); // unknown, could be an issue if it contains a VX\n\n\t}\n\n\tparseTextureNodeAttribute( type ) {\n\n\t\tthis.reader.skip( 28 ); // FORM + length + VPRM + unknown + Uint32 x2 + float32\n\n\t\tthis.reader.skip( 20 ); // FORM + length + VPVL + float32 + Uint32\n\n\t\tswitch ( type ) {\n\n\t\t\tcase 'ISCL':\n\t\t\t\tthis.currentNode.scale = this.reader.getFloat32Array( 3 );\n\t\t\t\tbreak;\n\t\t\tcase 'IPOS':\n\t\t\t\tthis.currentNode.position = this.reader.getFloat32Array( 3 );\n\t\t\t\tbreak;\n\t\t\tcase 'IROT':\n\t\t\t\tthis.currentNode.rotation = this.reader.getFloat32Array( 3 );\n\t\t\t\tbreak;\n\t\t\tcase 'IFAL':\n\t\t\t\tthis.currentNode.falloff = this.reader.getFloat32Array( 3 );\n\t\t\t\tbreak;\n\n\t\t\tcase 'IBMP':\n\t\t\t\tthis.currentNode.amplitude = this.reader.getFloat32();\n\t\t\t\tbreak;\n\t\t\tcase 'IUTD':\n\t\t\t\tthis.currentNode.uTiles = this.reader.getFloat32();\n\t\t\t\tbreak;\n\t\t\tcase 'IVTD':\n\t\t\t\tthis.currentNode.vTiles = this.reader.getFloat32();\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tthis.reader.skip( 2 ); // unknown\n\n\n\t}\n\n\t// ENVL forms are currently ignored\n\tparseEnvelope( length ) {\n\n\t\tthis.reader.skip( length - 4 ); // skipping  entirely for now\n\n\t}\n\n\t///\n\t// CHUNK PARSING METHODS\n\t///\n\n\t// clips can either be defined inside a surface node, or at the top\n\t// level and they have a different format in each case\n\tparseClip( length ) {\n\n\t\tconst tag = this.reader.getIDTag();\n\n\t\t// inside surface node\n\t\tif ( tag === 'FORM' ) {\n\n\t\t\tthis.reader.skip( 16 );\n\n\t\t\tthis.currentNode.fileName = this.reader.getString();\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// otherwise top level\n\t\tthis.reader.setOffset( this.reader.offset - 4 );\n\n\t\tthis.currentFormEnd = this.reader.offset + length;\n\t\tthis.parentForm = this.currentForm;\n\n\t\tthis.reader.skip( 8 ); // unknown\n\n\t\tconst texture = {\n\t\t\tindex: this.reader.getUint32()\n\t\t};\n\t\tthis.tree.textures.push( texture );\n\t\tthis.currentForm = texture;\n\n\t}\n\n\tparseClipLwo2( length ) {\n\n\t\tconst texture = {\n\t\t\tindex: this.reader.getUint32(),\n\t\t\tfileName: ''\n\t\t};\n\n\t\t// search STIL block\n\t\twhile ( true ) {\n\n\t\t\tconst tag = this.reader.getIDTag();\n\t\t\tconst n_length = this.reader.getUint16();\n\t\t\tif ( tag === 'STIL' ) {\n\n\t\t\t\ttexture.fileName = this.reader.getString();\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( n_length >= length ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.tree.textures.push( texture );\n\t\tthis.currentForm = texture;\n\n\t}\n\n\tparseImage() {\n\n\t\tthis.reader.skip( 8 ); // unknown\n\t\tthis.currentForm.fileName = this.reader.getString();\n\n\t}\n\n\tparseXVAL( type, length ) {\n\n\t\tconst endOffset = this.reader.offset + length - 4;\n\t\tthis.reader.skip( 8 );\n\n\t\tthis.currentForm[ type ] = this.reader.getFloat32();\n\n\t\tthis.reader.setOffset( endOffset ); // set end offset directly to skip optional envelope\n\n\t}\n\n\tparseXVAL3( type, length ) {\n\n\t\tconst endOffset = this.reader.offset + length - 4;\n\t\tthis.reader.skip( 8 );\n\n\t\tthis.currentForm[ type ] = {\n\t\t\tx: this.reader.getFloat32(),\n\t\t\ty: this.reader.getFloat32(),\n\t\t\tz: this.reader.getFloat32(),\n\t\t};\n\n\t\tthis.reader.setOffset( endOffset );\n\n\t}\n\n\t// Tags associated with an object\n\t// OTAG { type[ID4], tag-string[S0] }\n\tparseObjectTag() {\n\n\t\tif ( ! this.tree.objectTags ) this.tree.objectTags = {};\n\n\t\tthis.tree.objectTags[ this.reader.getIDTag() ] = {\n\t\t\ttagString: this.reader.getString()\n\t\t};\n\n\t}\n\n\t// Signals the start of a new layer. All the data chunks which follow will be included in this layer until another layer chunk is encountered.\n\t// LAYR: number[U2], flags[U2], pivot[VEC12], name[S0], parent[U2]\n\tparseLayer( length ) {\n\n\t\tconst number = this.reader.getUint16();\n\t\tconst flags = this.reader.getUint16(); // If the least significant bit of flags is set, the layer is hidden.\n\t\tconst pivot = this.reader.getFloat32Array( 3 ); // Note: this seems to be superfluous, as the geometry is translated when pivot is present\n\t\tconst layer = {\n\t\t\tnumber: number,\n\t\t\tflags: flags, // If the least significant bit of flags is set, the layer is hidden.\n\t\t\tpivot: [ - pivot[ 0 ], pivot[ 1 ], pivot[ 2 ] ], // Note: this seems to be superfluous, as the geometry is translated when pivot is present\n\t\t\tname: this.reader.getString(),\n\t\t};\n\n\t\tthis.tree.layers.push( layer );\n\t\tthis.currentLayer = layer;\n\n\t\tconst parsedLength = 16 + stringOffset( this.currentLayer.name ); // index ( 2 ) + flags( 2 ) + pivot( 12 ) + stringlength\n\n\t\t// if we have not reached then end of the layer block, there must be a parent defined\n\t\tthis.currentLayer.parent = ( parsedLength < length ) ? this.reader.getUint16() : - 1; // omitted or -1 for no parent\n\n\t}\n\n\t// VEC12 * ( F4 + F4 + F4 ) array of x,y,z vectors\n\t// Converting from left to right handed coordinate system:\n\t// x -> -x and switch material FrontSide -> BackSide\n\tparsePoints( length ) {\n\n\t\tthis.currentPoints = [];\n\t\tfor ( let i = 0; i < length / 4; i += 3 ) {\n\n\t\t\t// x -> -x to match three.js right handed coords\n\t\t\tthis.currentPoints.push( - this.reader.getFloat32(), this.reader.getFloat32(), this.reader.getFloat32() );\n\n\t\t}\n\n\t}\n\n\t// parse VMAP or VMAD\n\t// Associates a set of floating-point vectors with a set of points.\n\t// VMAP: { type[ID4], dimension[U2], name[S0], ( vert[VX], value[F4] # dimension ) * }\n\n\t// VMAD Associates a set of floating-point vectors with the vertices of specific polygons.\n\t// Similar to VMAP UVs, but associates with polygon vertices rather than points\n\t// to solve to problem of UV seams:  VMAD chunks are paired with VMAPs of the same name,\n\t// if they exist. The vector values in the VMAD will then replace those in the\n\t// corresponding VMAP, but only for calculations involving the specified polygons.\n\t// VMAD { type[ID4], dimension[U2], name[S0], ( vert[VX], poly[VX], value[F4] # dimension ) * }\n\tparseVertexMapping( length, discontinuous ) {\n\n\t\tconst finalOffset = this.reader.offset + length;\n\n\t\tconst channelName = this.reader.getString();\n\n\t\tif ( this.reader.offset === finalOffset ) {\n\n\t\t\t// then we are in a texture node and the VMAP chunk is just a reference to a UV channel name\n\t\t\tthis.currentForm.UVChannel = channelName;\n\t\t\treturn;\n\n\t\t}\n\n\t\t// otherwise reset to initial length and parse normal VMAP CHUNK\n\t\tthis.reader.setOffset( this.reader.offset - stringOffset( channelName ) );\n\n\t\tconst type = this.reader.getIDTag();\n\n\t\tthis.reader.getUint16(); // dimension\n\t\tconst name = this.reader.getString();\n\n\t\tconst remainingLength = length - 6 - stringOffset( name );\n\n\t\tswitch ( type ) {\n\n\t\t\tcase 'TXUV':\n\t\t\t\tthis.parseUVMapping( name, finalOffset, discontinuous );\n\t\t\t\tbreak;\n\t\t\tcase 'MORF':\n\t\t\tcase 'SPOT':\n\t\t\t\tthis.parseMorphTargets( name, finalOffset, type ); // can't be discontinuous\n\t\t\t\tbreak;\n\t\t\t// unsupported VMAPs\n\t\t\tcase 'APSL':\n\t\t\tcase 'NORM':\n\t\t\tcase 'WGHT':\n\t\t\tcase 'MNVW':\n\t\t\tcase 'PICK':\n\t\t\tcase 'RGB ':\n\t\t\tcase 'RGBA':\n\t\t\t\tthis.reader.skip( remainingLength );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.warn( 'LWOLoader: unknown vertex map type: ' + type );\n\t\t\t\tthis.reader.skip( remainingLength );\n\n\t\t}\n\n\t}\n\n\tparseUVMapping( name, finalOffset, discontinuous ) {\n\n\t\tconst uvIndices = [];\n\t\tconst polyIndices = [];\n\t\tconst uvs = [];\n\n\t\twhile ( this.reader.offset < finalOffset ) {\n\n\t\t\tuvIndices.push( this.reader.getVariableLengthIndex() );\n\n\t\t\tif ( discontinuous ) polyIndices.push( this.reader.getVariableLengthIndex() );\n\n\t\t\tuvs.push( this.reader.getFloat32(), this.reader.getFloat32() );\n\n\t\t}\n\n\t\tif ( discontinuous ) {\n\n\t\t\tif ( ! this.currentLayer.discontinuousUVs ) this.currentLayer.discontinuousUVs = {};\n\n\t\t\tthis.currentLayer.discontinuousUVs[ name ] = {\n\t\t\t\tuvIndices: uvIndices,\n\t\t\t\tpolyIndices: polyIndices,\n\t\t\t\tuvs: uvs,\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tif ( ! this.currentLayer.uvs ) this.currentLayer.uvs = {};\n\n\t\t\tthis.currentLayer.uvs[ name ] = {\n\t\t\t\tuvIndices: uvIndices,\n\t\t\t\tuvs: uvs,\n\t\t\t};\n\n\t\t}\n\n\t}\n\n\tparseMorphTargets( name, finalOffset, type ) {\n\n\t\tconst indices = [];\n\t\tconst points = [];\n\n\t\ttype = ( type === 'MORF' ) ? 'relative' : 'absolute';\n\n\t\twhile ( this.reader.offset < finalOffset ) {\n\n\t\t\tindices.push( this.reader.getVariableLengthIndex() );\n\t\t\t// z -> -z to match three.js right handed coords\n\t\t\tpoints.push( this.reader.getFloat32(), this.reader.getFloat32(), - this.reader.getFloat32() );\n\n\t\t}\n\n\t\tif ( ! this.currentLayer.morphTargets ) this.currentLayer.morphTargets = {};\n\n\t\tthis.currentLayer.morphTargets[ name ] = {\n\t\t\tindices: indices,\n\t\t\tpoints: points,\n\t\t\ttype: type,\n\t\t};\n\n\t}\n\n\t// A list of polygons for the current layer.\n\t// POLS { type[ID4], ( numvert+flags[U2], vert[VX] # numvert ) * }\n\tparsePolygonList( length ) {\n\n\t\tconst finalOffset = this.reader.offset + length;\n\t\tconst type = this.reader.getIDTag();\n\n\t\tconst indices = [];\n\n\t\t// hold a list of polygon sizes, to be split up later\n\t\tconst polygonDimensions = [];\n\n\t\twhile ( this.reader.offset < finalOffset ) {\n\n\t\t\tlet numverts = this.reader.getUint16();\n\n\t\t\t//const flags = numverts & 64512; // 6 high order bits are flags - ignoring for now\n\t\t\tnumverts = numverts & 1023; // remaining ten low order bits are vertex num\n\t\t\tpolygonDimensions.push( numverts );\n\n\t\t\tfor ( let j = 0; j < numverts; j ++ ) indices.push( this.reader.getVariableLengthIndex() );\n\n\t\t}\n\n\t\tconst geometryData = {\n\t\t\ttype: type,\n\t\t\tvertexIndices: indices,\n\t\t\tpolygonDimensions: polygonDimensions,\n\t\t\tpoints: this.currentPoints\n\t\t};\n\n\t\t// Note: assuming that all polys will be lines or points if the first is\n\t\tif ( polygonDimensions[ 0 ] === 1 ) geometryData.type = 'points';\n\t\telse if ( polygonDimensions[ 0 ] === 2 ) geometryData.type = 'lines';\n\n\t\tthis.currentLayer.geometry = geometryData;\n\n\t}\n\n\t// Lists the tag strings that can be associated with polygons by the PTAG chunk.\n\t// TAGS { tag-string[S0] * }\n\tparseTagStrings( length ) {\n\n\t\tthis.tree.tags = this.reader.getStringArray( length );\n\n\t}\n\n\t// Associates tags of a given type with polygons in the most recent POLS chunk.\n\t// PTAG { type[ID4], ( poly[VX], tag[U2] ) * }\n\tparsePolygonTagMapping( length ) {\n\n\t\tconst finalOffset = this.reader.offset + length;\n\t\tconst type = this.reader.getIDTag();\n\t\tif ( type === 'SURF' ) this.parseMaterialIndices( finalOffset );\n\t\telse { //PART, SMGP, COLR not supported\n\n\t\t\tthis.reader.skip( length - 4 );\n\n\t\t}\n\n\t}\n\n\tparseMaterialIndices( finalOffset ) {\n\n\t\t// array holds polygon index followed by material index\n\t\tthis.currentLayer.geometry.materialIndices = [];\n\n\t\twhile ( this.reader.offset < finalOffset ) {\n\n\t\t\tconst polygonIndex = this.reader.getVariableLengthIndex();\n\t\t\tconst materialIndex = this.reader.getUint16();\n\n\t\t\tthis.currentLayer.geometry.materialIndices.push( polygonIndex, materialIndex );\n\n\t\t}\n\n\t}\n\n\tparseUnknownCHUNK( blockID, length ) {\n\n\t\tconsole.warn( 'LWOLoader: unknown chunk type: ' + blockID + ' length: ' + length );\n\n\t\t// print the chunk plus some bytes padding either side\n\t\t// printBuffer( this.reader.dv.buffer, this.reader.offset - 20, length + 40 );\n\n\t\tconst data = this.reader.getString( length );\n\n\t\tthis.currentForm[ blockID ] = data;\n\n\t}\n\n}\n\n\nclass DataViewReader {\n\n\tconstructor( buffer ) {\n\n\t\tthis.dv = new DataView( buffer );\n\t\tthis.offset = 0;\n\t\tthis._textDecoder = new TextDecoder();\n\t\tthis._bytes = new Uint8Array( buffer );\n\n\t}\n\n\tsize() {\n\n\t\treturn this.dv.buffer.byteLength;\n\n\t}\n\n\tsetOffset( offset ) {\n\n\t\tif ( offset > 0 && offset < this.dv.buffer.byteLength ) {\n\n\t\t\tthis.offset = offset;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'LWOLoader: invalid buffer offset' );\n\n\t\t}\n\n\t}\n\n\tendOfFile() {\n\n\t\tif ( this.offset >= this.size() ) return true;\n\t\treturn false;\n\n\t}\n\n\tskip( length ) {\n\n\t\tthis.offset += length;\n\n\t}\n\n\tgetUint8() {\n\n\t\tconst value = this.dv.getUint8( this.offset );\n\t\tthis.offset += 1;\n\t\treturn value;\n\n\t}\n\n\tgetUint16() {\n\n\t\tconst value = this.dv.getUint16( this.offset );\n\t\tthis.offset += 2;\n\t\treturn value;\n\n\t}\n\n\tgetInt32() {\n\n\t\tconst value = this.dv.getInt32( this.offset, false );\n\t\tthis.offset += 4;\n\t\treturn value;\n\n\t}\n\n\tgetUint32() {\n\n\t\tconst value = this.dv.getUint32( this.offset, false );\n\t\tthis.offset += 4;\n\t\treturn value;\n\n\t}\n\n\tgetUint64() {\n\n\t\tconst low = this.getUint32();\n\t\tconst high = this.getUint32();\n\t\treturn high * 0x100000000 + low;\n\n\t}\n\n\tgetFloat32() {\n\n\t\tconst value = this.dv.getFloat32( this.offset, false );\n\t\tthis.offset += 4;\n\t\treturn value;\n\n\t}\n\n\tgetFloat32Array( size ) {\n\n\t\tconst a = [];\n\n\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\ta.push( this.getFloat32() );\n\n\t\t}\n\n\t\treturn a;\n\n\t}\n\n\tgetFloat64() {\n\n\t\tconst value = this.dv.getFloat64( this.offset, this.littleEndian );\n\t\tthis.offset += 8;\n\t\treturn value;\n\n\t}\n\n\tgetFloat64Array( size ) {\n\n\t\tconst a = [];\n\n\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\ta.push( this.getFloat64() );\n\n\t\t}\n\n\t\treturn a;\n\n\t}\n\n\t// get variable-length index data type\n\t// VX ::= index[U2] | (index + 0xFF000000)[U4]\n\t// If the index value is less than 65,280 (0xFF00),then VX === U2\n\t// otherwise VX === U4 with bits 24-31 set\n\t// When reading an index, if the first byte encountered is 255 (0xFF), then\n\t// the four-byte form is being used and the first byte should be discarded or masked out.\n\tgetVariableLengthIndex() {\n\n\t\tconst firstByte = this.getUint8();\n\n\t\tif ( firstByte === 255 ) {\n\n\t\t\treturn this.getUint8() * 65536 + this.getUint8() * 256 + this.getUint8();\n\n\t\t}\n\n\t\treturn firstByte * 256 + this.getUint8();\n\n\t}\n\n\t// An ID tag is a sequence of 4 bytes containing 7-bit ASCII values\n\tgetIDTag() {\n\n\t\treturn this.getString( 4 );\n\n\t}\n\n\tgetString( size ) {\n\n\t\tif ( size === 0 ) return;\n\n\t\tconst start = this.offset;\n\n\t\tlet result;\n\t\tlet length;\n\n\t\tif ( size ) {\n\n\t\t\tlength = size;\n\t\t\tresult = this._textDecoder.decode( new Uint8Array( this.dv.buffer, start, size ) );\n\n\t\t} else {\n\n\t\t\t// use 1:1 mapping of buffer to avoid redundant new array creation.\n\t\t\tlength = this._bytes.indexOf( 0, start ) - start;\n\n\t\t\tresult = this._textDecoder.decode( new Uint8Array( this.dv.buffer, start, length ) );\n\n\t\t\t// account for null byte in length\n\t\t\tlength ++;\n\n\t\t\t// if string with terminating nullbyte is uneven, extra nullbyte is added, skip that too\n\t\t\tlength += length % 2;\n\n\t\t}\n\n\t\tthis.skip( length );\n\n\t\treturn result;\n\n\t}\n\n\tgetStringArray( size ) {\n\n\t\tlet a = this.getString( size );\n\t\ta = a.split( '\\0' );\n\n\t\treturn a.filter( Boolean ); // return array with any empty strings removed\n\n\t}\n\n}\n\n\n// ************** DEBUGGER  **************\n\nclass Debugger {\n\n\tconstructor() {\n\n\t\tthis.active = false;\n\t\tthis.depth = 0;\n\t\tthis.formList = [];\n\t\tthis.offset = 0;\n\n\t\tthis.node = 0; // 0 = FORM, 1 = CHUNK, 2 = SUBNODE\n\t\tthis.nodeID = 'FORM';\n\n\t\tthis.dataOffset = 0;\n\t\tthis.length = 0;\n\t\tthis.skipped = false;\n\n\t}\n\n\tenable() {\n\n\t\tthis.active = true;\n\n\t}\n\n\tlog() {\n\n\t\tif ( ! this.active ) return;\n\n\t\tlet nodeType;\n\n\t\tswitch ( this.node ) {\n\n\t\t\tcase 0:\n\t\t\t\tnodeType = 'FORM';\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tnodeType = 'CHK';\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tnodeType = 'S-CHK';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tconsole.log(\n\t\t\t'| '.repeat( this.depth ) +\n\t\t\tnodeType,\n\t\t\tthis.nodeID,\n\t\t\t`( ${this.offset} ) -> ( ${this.dataOffset + this.length} )`,\n\t\t\t( ( this.node == 0 ) ? ' {' : '' ),\n\t\t\t( ( this.skipped ) ? 'SKIPPED' : '' ),\n\t\t\t( ( this.node == 0 && this.skipped ) ? '}' : '' )\n\t\t);\n\n\t\tif ( this.node == 0 && ! this.skipped ) {\n\n\t\t\tthis.depth += 1;\n\t\t\tthis.formList.push( this.dataOffset + this.length );\n\n\t\t}\n\n\t\tthis.skipped = false;\n\n\t}\n\n\tcloseForms() {\n\n\t\tif ( ! this.active ) return;\n\n\t\tfor ( let i = this.formList.length - 1; i >= 0; i -- ) {\n\n\t\t\tif ( this.offset >= this.formList[ i ] ) {\n\n\t\t\t\tthis.depth -= 1;\n\t\t\t\tconsole.log( '| '.repeat( this.depth ) + '}' );\n\t\t\t\tthis.formList.splice( - 1, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n// ************** UTILITY FUNCTIONS **************\n\n// calculate the length of the string in the buffer\n// this will be string.length + nullbyte + optional padbyte to make the length even\nfunction stringOffset( string ) {\n\n\treturn string.length + 1 + ( ( string.length + 1 ) % 2 );\n\n}\n\n// for testing purposes, dump buffer to console\n// printBuffer( this.reader.dv.buffer, this.reader.offset, length );\nfunction printBuffer( buffer, from, to ) {\n\n\tconsole.log( new TextDecoder().decode( new Uint8Array( buffer, from, to ) ) );\n\n}\n\nexport { IFFParser };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}