{"ast":null,"code":"import { Mesh, MeshBasicMaterial, SphereGeometry, Vector3 } from 'three';\n\n/**\n * A ground-projected skybox.\n *\n * By default the object is centered at the camera, so it is often helpful to set\n * `skybox.position.y = height` to put the ground at the origin.\n *\n * ```js\n * const height = 15, radius = 100;\n *\n * const skybox = new GroundedSkybox( envMap, height, radius );\n * skybox.position.y = height;\n * scene.add( skybox );\n * ```\n *\n * @augments Mesh\n * @three_import import { GroundedSkybox } from 'three/addons/objects/GroundedSkybox.js';\n */\nclass GroundedSkybox extends Mesh {\n  /**\n   * Constructs a new ground-projected skybox.\n   *\n   * @param {Texture} map - The environment map to use.\n   * @param {number} height - The height is how far the camera that took the photo was above the ground.\n   * A larger value will magnify the downward part of the image.\n   * @param {number} radius - The radius of the skybox. Must be large enough to ensure the scene's camera stays inside.\n   * @param {number} [resolution=128] - The geometry resolution of the skybox.\n   */\n  constructor(map, height, radius, resolution = 128) {\n    if (height <= 0 || radius <= 0 || resolution <= 0) {\n      throw new Error('GroundedSkybox height, radius, and resolution must be positive.');\n    }\n    const geometry = new SphereGeometry(radius, 2 * resolution, resolution);\n    geometry.scale(1, 1, -1);\n    const pos = geometry.getAttribute('position');\n    const tmp = new Vector3();\n    for (let i = 0; i < pos.count; ++i) {\n      tmp.fromBufferAttribute(pos, i);\n      if (tmp.y < 0) {\n        // Smooth out the transition from flat floor to sphere:\n        const y1 = -height * 3 / 2;\n        const f = tmp.y < y1 ? -height / tmp.y : 1 - tmp.y * tmp.y / (3 * y1 * y1);\n        tmp.multiplyScalar(f);\n        tmp.toArray(pos.array, 3 * i);\n      }\n    }\n    pos.needsUpdate = true;\n    super(geometry, new MeshBasicMaterial({\n      map,\n      depthWrite: false\n    }));\n  }\n}\nexport { GroundedSkybox };","map":{"version":3,"names":["Mesh","MeshBasicMaterial","SphereGeometry","Vector3","GroundedSkybox","constructor","map","height","radius","resolution","Error","geometry","scale","pos","getAttribute","tmp","i","count","fromBufferAttribute","y","y1","f","multiplyScalar","toArray","array","needsUpdate","depthWrite"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/objects/GroundedSkybox.js"],"sourcesContent":["import { Mesh, MeshBasicMaterial, SphereGeometry, Vector3 } from 'three';\n\n/**\n * A ground-projected skybox.\n *\n * By default the object is centered at the camera, so it is often helpful to set\n * `skybox.position.y = height` to put the ground at the origin.\n *\n * ```js\n * const height = 15, radius = 100;\n *\n * const skybox = new GroundedSkybox( envMap, height, radius );\n * skybox.position.y = height;\n * scene.add( skybox );\n * ```\n *\n * @augments Mesh\n * @three_import import { GroundedSkybox } from 'three/addons/objects/GroundedSkybox.js';\n */\nclass GroundedSkybox extends Mesh {\n\n\t/**\n\t * Constructs a new ground-projected skybox.\n\t *\n\t * @param {Texture} map - The environment map to use.\n\t * @param {number} height - The height is how far the camera that took the photo was above the ground.\n\t * A larger value will magnify the downward part of the image.\n\t * @param {number} radius - The radius of the skybox. Must be large enough to ensure the scene's camera stays inside.\n\t * @param {number} [resolution=128] - The geometry resolution of the skybox.\n\t */\n\tconstructor( map, height, radius, resolution = 128 ) {\n\n\t\tif ( height <= 0 || radius <= 0 || resolution <= 0 ) {\n\n\t\t\tthrow new Error( 'GroundedSkybox height, radius, and resolution must be positive.' );\n\n\t\t}\n\n\t\tconst geometry = new SphereGeometry( radius, 2 * resolution, resolution );\n\t\tgeometry.scale( 1, 1, - 1 );\n\n\t\tconst pos = geometry.getAttribute( 'position' );\n\t\tconst tmp = new Vector3();\n\n\t\tfor ( let i = 0; i < pos.count; ++ i ) {\n\n\t\t\ttmp.fromBufferAttribute( pos, i );\n\t\t\tif ( tmp.y < 0 ) {\n\n\t\t\t\t// Smooth out the transition from flat floor to sphere:\n\t\t\t\tconst y1 = - height * 3 / 2;\n\t\t\t\tconst f =\n\t\t\t\t\t\ttmp.y < y1 ? - height / tmp.y : ( 1 - tmp.y * tmp.y / ( 3 * y1 * y1 ) );\n\t\t\t\ttmp.multiplyScalar( f );\n\t\t\t\ttmp.toArray( pos.array, 3 * i );\n\n\t\t\t}\n\n\t\t}\n\n\t\tpos.needsUpdate = true;\n\n\t\tsuper( geometry, new MeshBasicMaterial( { map, depthWrite: false } ) );\n\n\t}\n\n}\n\nexport { GroundedSkybox };\n"],"mappings":"AAAA,SAASA,IAAI,EAAEC,iBAAiB,EAAEC,cAAc,EAAEC,OAAO,QAAQ,OAAO;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,cAAc,SAASJ,IAAI,CAAC;EAEjC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCK,WAAWA,CAAEC,GAAG,EAAEC,MAAM,EAAEC,MAAM,EAAEC,UAAU,GAAG,GAAG,EAAG;IAEpD,IAAKF,MAAM,IAAI,CAAC,IAAIC,MAAM,IAAI,CAAC,IAAIC,UAAU,IAAI,CAAC,EAAG;MAEpD,MAAM,IAAIC,KAAK,CAAE,iEAAkE,CAAC;IAErF;IAEA,MAAMC,QAAQ,GAAG,IAAIT,cAAc,CAAEM,MAAM,EAAE,CAAC,GAAGC,UAAU,EAAEA,UAAW,CAAC;IACzEE,QAAQ,CAACC,KAAK,CAAE,CAAC,EAAE,CAAC,EAAE,CAAE,CAAE,CAAC;IAE3B,MAAMC,GAAG,GAAGF,QAAQ,CAACG,YAAY,CAAE,UAAW,CAAC;IAC/C,MAAMC,GAAG,GAAG,IAAIZ,OAAO,CAAC,CAAC;IAEzB,KAAM,IAAIa,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,GAAG,CAACI,KAAK,EAAE,EAAGD,CAAC,EAAG;MAEtCD,GAAG,CAACG,mBAAmB,CAAEL,GAAG,EAAEG,CAAE,CAAC;MACjC,IAAKD,GAAG,CAACI,CAAC,GAAG,CAAC,EAAG;QAEhB;QACA,MAAMC,EAAE,GAAG,CAAEb,MAAM,GAAG,CAAC,GAAG,CAAC;QAC3B,MAAMc,CAAC,GACLN,GAAG,CAACI,CAAC,GAAGC,EAAE,GAAG,CAAEb,MAAM,GAAGQ,GAAG,CAACI,CAAC,GAAK,CAAC,GAAGJ,GAAG,CAACI,CAAC,GAAGJ,GAAG,CAACI,CAAC,IAAK,CAAC,GAAGC,EAAE,GAAGA,EAAE,CAAI;QACzEL,GAAG,CAACO,cAAc,CAAED,CAAE,CAAC;QACvBN,GAAG,CAACQ,OAAO,CAAEV,GAAG,CAACW,KAAK,EAAE,CAAC,GAAGR,CAAE,CAAC;MAEhC;IAED;IAEAH,GAAG,CAACY,WAAW,GAAG,IAAI;IAEtB,KAAK,CAAEd,QAAQ,EAAE,IAAIV,iBAAiB,CAAE;MAAEK,GAAG;MAAEoB,UAAU,EAAE;IAAM,CAAE,CAAE,CAAC;EAEvE;AAED;AAEA,SAAStB,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}