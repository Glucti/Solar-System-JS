{"ast":null,"code":"import { Triangle, Vector2, Vector3 } from 'three';\nconst _face = new Triangle();\nconst _color = new Vector3();\nconst _uva = new Vector2(),\n  _uvb = new Vector2(),\n  _uvc = new Vector2();\n\n/**\n * Utility class for sampling weighted random points on the surface of a mesh.\n *\n * Building the sampler is a one-time O(n) operation. Once built, any number of\n * random samples may be selected in O(logn) time. Memory usage is O(n).\n *\n * References:\n * - {@link http://www.joesfer.com/?p=84}\n * - {@link https://stackoverflow.com/a/4322940/1314762}\n *\n * ```js\n * const sampler = new MeshSurfaceSampler( surfaceMesh )\n * \t.setWeightAttribute( 'color' )\n * \t.build();\n *\n * const mesh = new THREE.InstancedMesh( sampleGeometry, sampleMaterial, 100 );\n *\n * const position = new THREE.Vector3();\n * const matrix = new THREE.Matrix4();\n *\n * // Sample randomly from the surface, creating an instance of the sample geometry at each sample point.\n *\n * for ( let i = 0; i < 100; i ++ ) {\n *\n * \tsampler.sample( position );\n * \tmatrix.makeTranslation( position.x, position.y, position.z );\n * \tmesh.setMatrixAt( i, matrix );\n *\n * }\n *\n * scene.add( mesh );\n * ```\n *\n * @three_import import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';\n */\nclass MeshSurfaceSampler {\n  /**\n   * Constructs a mesh surface sampler.\n   *\n   * @param {Mesh} mesh - Surface mesh from which to sample.\n   */\n  constructor(mesh) {\n    this.geometry = mesh.geometry;\n    this.randomFunction = Math.random;\n    this.indexAttribute = this.geometry.index;\n    this.positionAttribute = this.geometry.getAttribute('position');\n    this.normalAttribute = this.geometry.getAttribute('normal');\n    this.colorAttribute = this.geometry.getAttribute('color');\n    this.uvAttribute = this.geometry.getAttribute('uv');\n    this.weightAttribute = null;\n    this.distribution = null;\n  }\n\n  /**\n   * Specifies a vertex attribute to be used as a weight when sampling from the surface.\n   * Faces with higher weights are more likely to be sampled, and those with weights of\n   * zero will not be sampled at all. For vector attributes, only .x is used in sampling.\n   *\n   * If no weight attribute is selected, sampling is randomly distributed by area.\n   *\n   * @param {string} name - The attribute name.\n   * @return {MeshSurfaceSampler} A reference to this sampler.\n   */\n  setWeightAttribute(name) {\n    this.weightAttribute = name ? this.geometry.getAttribute(name) : null;\n    return this;\n  }\n\n  /**\n   * Processes the input geometry and prepares to return samples. Any configuration of the\n   * geometry or sampler must occur before this method is called. Time complexity is O(n)\n   * for a surface with n faces.\n   *\n   * @return {MeshSurfaceSampler} A reference to this sampler.\n   */\n  build() {\n    const indexAttribute = this.indexAttribute;\n    const positionAttribute = this.positionAttribute;\n    const weightAttribute = this.weightAttribute;\n    const totalFaces = indexAttribute ? indexAttribute.count / 3 : positionAttribute.count / 3;\n    const faceWeights = new Float32Array(totalFaces);\n\n    // Accumulate weights for each mesh face.\n\n    for (let i = 0; i < totalFaces; i++) {\n      let faceWeight = 1;\n      let i0 = 3 * i;\n      let i1 = 3 * i + 1;\n      let i2 = 3 * i + 2;\n      if (indexAttribute) {\n        i0 = indexAttribute.getX(i0);\n        i1 = indexAttribute.getX(i1);\n        i2 = indexAttribute.getX(i2);\n      }\n      if (weightAttribute) {\n        faceWeight = weightAttribute.getX(i0) + weightAttribute.getX(i1) + weightAttribute.getX(i2);\n      }\n      _face.a.fromBufferAttribute(positionAttribute, i0);\n      _face.b.fromBufferAttribute(positionAttribute, i1);\n      _face.c.fromBufferAttribute(positionAttribute, i2);\n      faceWeight *= _face.getArea();\n      faceWeights[i] = faceWeight;\n    }\n\n    // Store cumulative total face weights in an array, where weight index\n    // corresponds to face index.\n\n    const distribution = new Float32Array(totalFaces);\n    let cumulativeTotal = 0;\n    for (let i = 0; i < totalFaces; i++) {\n      cumulativeTotal += faceWeights[i];\n      distribution[i] = cumulativeTotal;\n    }\n    this.distribution = distribution;\n    return this;\n  }\n\n  /**\n   * Allows to set a custom random number generator. Default is `Math.random()`.\n   *\n   * @param {Function} randomFunction - A random number generator.\n   * @return {MeshSurfaceSampler} A reference to this sampler.\n   */\n  setRandomGenerator(randomFunction) {\n    this.randomFunction = randomFunction;\n    return this;\n  }\n\n  /**\n   * Selects a random point on the surface of the input geometry, returning the\n   * position and optionally the normal vector, color and UV Coordinate at that point.\n   * Time complexity is O(log n) for a surface with n faces.\n   *\n   * @param {Vector3} targetPosition - The target object holding the sampled position.\n   * @param {Vector3} targetNormal - The target object holding the sampled normal.\n   * @param {Color} targetColor - The target object holding the sampled color.\n   * @param {Vector2} targetUV -  The target object holding the sampled uv coordinates.\n   * @return {MeshSurfaceSampler} A reference to this sampler.\n   */\n  sample(targetPosition, targetNormal, targetColor, targetUV) {\n    const faceIndex = this._sampleFaceIndex();\n    return this._sampleFace(faceIndex, targetPosition, targetNormal, targetColor, targetUV);\n  }\n\n  // private\n\n  _sampleFaceIndex() {\n    const cumulativeTotal = this.distribution[this.distribution.length - 1];\n    return this._binarySearch(this.randomFunction() * cumulativeTotal);\n  }\n  _binarySearch(x) {\n    const dist = this.distribution;\n    let start = 0;\n    let end = dist.length - 1;\n    let index = -1;\n    while (start <= end) {\n      const mid = Math.ceil((start + end) / 2);\n      if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {\n        index = mid;\n        break;\n      } else if (x < dist[mid]) {\n        end = mid - 1;\n      } else {\n        start = mid + 1;\n      }\n    }\n    return index;\n  }\n  _sampleFace(faceIndex, targetPosition, targetNormal, targetColor, targetUV) {\n    let u = this.randomFunction();\n    let v = this.randomFunction();\n    if (u + v > 1) {\n      u = 1 - u;\n      v = 1 - v;\n    }\n\n    // get the vertex attribute indices\n    const indexAttribute = this.indexAttribute;\n    let i0 = faceIndex * 3;\n    let i1 = faceIndex * 3 + 1;\n    let i2 = faceIndex * 3 + 2;\n    if (indexAttribute) {\n      i0 = indexAttribute.getX(i0);\n      i1 = indexAttribute.getX(i1);\n      i2 = indexAttribute.getX(i2);\n    }\n    _face.a.fromBufferAttribute(this.positionAttribute, i0);\n    _face.b.fromBufferAttribute(this.positionAttribute, i1);\n    _face.c.fromBufferAttribute(this.positionAttribute, i2);\n    targetPosition.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n    if (targetNormal !== undefined) {\n      if (this.normalAttribute !== undefined) {\n        _face.a.fromBufferAttribute(this.normalAttribute, i0);\n        _face.b.fromBufferAttribute(this.normalAttribute, i1);\n        _face.c.fromBufferAttribute(this.normalAttribute, i2);\n        targetNormal.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v)).normalize();\n      } else {\n        _face.getNormal(targetNormal);\n      }\n    }\n    if (targetColor !== undefined && this.colorAttribute !== undefined) {\n      _face.a.fromBufferAttribute(this.colorAttribute, i0);\n      _face.b.fromBufferAttribute(this.colorAttribute, i1);\n      _face.c.fromBufferAttribute(this.colorAttribute, i2);\n      _color.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n      targetColor.r = _color.x;\n      targetColor.g = _color.y;\n      targetColor.b = _color.z;\n    }\n    if (targetUV !== undefined && this.uvAttribute !== undefined) {\n      _uva.fromBufferAttribute(this.uvAttribute, i0);\n      _uvb.fromBufferAttribute(this.uvAttribute, i1);\n      _uvc.fromBufferAttribute(this.uvAttribute, i2);\n      targetUV.set(0, 0).addScaledVector(_uva, u).addScaledVector(_uvb, v).addScaledVector(_uvc, 1 - (u + v));\n    }\n    return this;\n  }\n}\nexport { MeshSurfaceSampler };","map":{"version":3,"names":["Triangle","Vector2","Vector3","_face","_color","_uva","_uvb","_uvc","MeshSurfaceSampler","constructor","mesh","geometry","randomFunction","Math","random","indexAttribute","index","positionAttribute","getAttribute","normalAttribute","colorAttribute","uvAttribute","weightAttribute","distribution","setWeightAttribute","name","build","totalFaces","count","faceWeights","Float32Array","i","faceWeight","i0","i1","i2","getX","a","fromBufferAttribute","b","c","getArea","cumulativeTotal","setRandomGenerator","sample","targetPosition","targetNormal","targetColor","targetUV","faceIndex","_sampleFaceIndex","_sampleFace","length","_binarySearch","x","dist","start","end","mid","ceil","u","v","set","addScaledVector","undefined","normalize","getNormal","r","g","y","z"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/math/MeshSurfaceSampler.js"],"sourcesContent":["import {\n\tTriangle,\n\tVector2,\n\tVector3\n} from 'three';\n\nconst _face = new Triangle();\nconst _color = new Vector3();\nconst _uva = new Vector2(), _uvb = new Vector2(), _uvc = new Vector2();\n\n/**\n * Utility class for sampling weighted random points on the surface of a mesh.\n *\n * Building the sampler is a one-time O(n) operation. Once built, any number of\n * random samples may be selected in O(logn) time. Memory usage is O(n).\n *\n * References:\n * - {@link http://www.joesfer.com/?p=84}\n * - {@link https://stackoverflow.com/a/4322940/1314762}\n *\n * ```js\n * const sampler = new MeshSurfaceSampler( surfaceMesh )\n * \t.setWeightAttribute( 'color' )\n * \t.build();\n *\n * const mesh = new THREE.InstancedMesh( sampleGeometry, sampleMaterial, 100 );\n *\n * const position = new THREE.Vector3();\n * const matrix = new THREE.Matrix4();\n *\n * // Sample randomly from the surface, creating an instance of the sample geometry at each sample point.\n *\n * for ( let i = 0; i < 100; i ++ ) {\n *\n * \tsampler.sample( position );\n * \tmatrix.makeTranslation( position.x, position.y, position.z );\n * \tmesh.setMatrixAt( i, matrix );\n *\n * }\n *\n * scene.add( mesh );\n * ```\n *\n * @three_import import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';\n */\nclass MeshSurfaceSampler {\n\n\t/**\n\t * Constructs a mesh surface sampler.\n\t *\n\t * @param {Mesh} mesh - Surface mesh from which to sample.\n\t */\n\tconstructor( mesh ) {\n\n\t\tthis.geometry = mesh.geometry;\n\t\tthis.randomFunction = Math.random;\n\n\t\tthis.indexAttribute = this.geometry.index;\n\t\tthis.positionAttribute = this.geometry.getAttribute( 'position' );\n\t\tthis.normalAttribute = this.geometry.getAttribute( 'normal' );\n\t\tthis.colorAttribute = this.geometry.getAttribute( 'color' );\n\t\tthis.uvAttribute = this.geometry.getAttribute( 'uv' );\n\t\tthis.weightAttribute = null;\n\n\t\tthis.distribution = null;\n\n\t}\n\n\t/**\n\t * Specifies a vertex attribute to be used as a weight when sampling from the surface.\n\t * Faces with higher weights are more likely to be sampled, and those with weights of\n\t * zero will not be sampled at all. For vector attributes, only .x is used in sampling.\n\t *\n\t * If no weight attribute is selected, sampling is randomly distributed by area.\n\t *\n\t * @param {string} name - The attribute name.\n\t * @return {MeshSurfaceSampler} A reference to this sampler.\n\t */\n\tsetWeightAttribute( name ) {\n\n\t\tthis.weightAttribute = name ? this.geometry.getAttribute( name ) : null;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Processes the input geometry and prepares to return samples. Any configuration of the\n\t * geometry or sampler must occur before this method is called. Time complexity is O(n)\n\t * for a surface with n faces.\n\t *\n\t * @return {MeshSurfaceSampler} A reference to this sampler.\n\t */\n\tbuild() {\n\n\t\tconst indexAttribute = this.indexAttribute;\n\t\tconst positionAttribute = this.positionAttribute;\n\t\tconst weightAttribute = this.weightAttribute;\n\n\t\tconst totalFaces = indexAttribute ? ( indexAttribute.count / 3 ) : ( positionAttribute.count / 3 );\n\t\tconst faceWeights = new Float32Array( totalFaces );\n\n\t\t// Accumulate weights for each mesh face.\n\n\t\tfor ( let i = 0; i < totalFaces; i ++ ) {\n\n\t\t\tlet faceWeight = 1;\n\n\t\t\tlet i0 = 3 * i;\n\t\t\tlet i1 = 3 * i + 1;\n\t\t\tlet i2 = 3 * i + 2;\n\n\t\t\tif ( indexAttribute ) {\n\n\t\t\t\ti0 = indexAttribute.getX( i0 );\n\t\t\t\ti1 = indexAttribute.getX( i1 );\n\t\t\t\ti2 = indexAttribute.getX( i2 );\n\n\t\t\t}\n\n\t\t\tif ( weightAttribute ) {\n\n\t\t\t\tfaceWeight = weightAttribute.getX( i0 )\n\t\t\t\t\t+ weightAttribute.getX( i1 )\n\t\t\t\t\t+ weightAttribute.getX( i2 );\n\n\t\t\t}\n\n\t\t\t_face.a.fromBufferAttribute( positionAttribute, i0 );\n\t\t\t_face.b.fromBufferAttribute( positionAttribute, i1 );\n\t\t\t_face.c.fromBufferAttribute( positionAttribute, i2 );\n\t\t\tfaceWeight *= _face.getArea();\n\n\t\t\tfaceWeights[ i ] = faceWeight;\n\n\t\t}\n\n\t\t// Store cumulative total face weights in an array, where weight index\n\t\t// corresponds to face index.\n\n\t\tconst distribution = new Float32Array( totalFaces );\n\t\tlet cumulativeTotal = 0;\n\n\t\tfor ( let i = 0; i < totalFaces; i ++ ) {\n\n\t\t\tcumulativeTotal += faceWeights[ i ];\n\t\t\tdistribution[ i ] = cumulativeTotal;\n\n\t\t}\n\n\t\tthis.distribution = distribution;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Allows to set a custom random number generator. Default is `Math.random()`.\n\t *\n\t * @param {Function} randomFunction - A random number generator.\n\t * @return {MeshSurfaceSampler} A reference to this sampler.\n\t */\n\tsetRandomGenerator( randomFunction ) {\n\n\t\tthis.randomFunction = randomFunction;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Selects a random point on the surface of the input geometry, returning the\n\t * position and optionally the normal vector, color and UV Coordinate at that point.\n\t * Time complexity is O(log n) for a surface with n faces.\n\t *\n\t * @param {Vector3} targetPosition - The target object holding the sampled position.\n\t * @param {Vector3} targetNormal - The target object holding the sampled normal.\n\t * @param {Color} targetColor - The target object holding the sampled color.\n\t * @param {Vector2} targetUV -  The target object holding the sampled uv coordinates.\n\t * @return {MeshSurfaceSampler} A reference to this sampler.\n\t */\n\tsample( targetPosition, targetNormal, targetColor, targetUV ) {\n\n\t\tconst faceIndex = this._sampleFaceIndex();\n\t\treturn this._sampleFace( faceIndex, targetPosition, targetNormal, targetColor, targetUV );\n\n\t}\n\n\t// private\n\n\t_sampleFaceIndex() {\n\n\t\tconst cumulativeTotal = this.distribution[ this.distribution.length - 1 ];\n\t\treturn this._binarySearch( this.randomFunction() * cumulativeTotal );\n\n\t}\n\n\t_binarySearch( x ) {\n\n\t\tconst dist = this.distribution;\n\t\tlet start = 0;\n\t\tlet end = dist.length - 1;\n\n\t\tlet index = - 1;\n\n\t\twhile ( start <= end ) {\n\n\t\t\tconst mid = Math.ceil( ( start + end ) / 2 );\n\n\t\t\tif ( mid === 0 || dist[ mid - 1 ] <= x && dist[ mid ] > x ) {\n\n\t\t\t\tindex = mid;\n\n\t\t\t\tbreak;\n\n\t\t\t} else if ( x < dist[ mid ] ) {\n\n\t\t\t\tend = mid - 1;\n\n\t\t\t} else {\n\n\t\t\t\tstart = mid + 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn index;\n\n\t}\n\n\t_sampleFace( faceIndex, targetPosition, targetNormal, targetColor, targetUV ) {\n\n\t\tlet u = this.randomFunction();\n\t\tlet v = this.randomFunction();\n\n\t\tif ( u + v > 1 ) {\n\n\t\t\tu = 1 - u;\n\t\t\tv = 1 - v;\n\n\t\t}\n\n\t\t// get the vertex attribute indices\n\t\tconst indexAttribute = this.indexAttribute;\n\t\tlet i0 = faceIndex * 3;\n\t\tlet i1 = faceIndex * 3 + 1;\n\t\tlet i2 = faceIndex * 3 + 2;\n\t\tif ( indexAttribute ) {\n\n\t\t\ti0 = indexAttribute.getX( i0 );\n\t\t\ti1 = indexAttribute.getX( i1 );\n\t\t\ti2 = indexAttribute.getX( i2 );\n\n\t\t}\n\n\t\t_face.a.fromBufferAttribute( this.positionAttribute, i0 );\n\t\t_face.b.fromBufferAttribute( this.positionAttribute, i1 );\n\t\t_face.c.fromBufferAttribute( this.positionAttribute, i2 );\n\n\t\ttargetPosition\n\t\t\t.set( 0, 0, 0 )\n\t\t\t.addScaledVector( _face.a, u )\n\t\t\t.addScaledVector( _face.b, v )\n\t\t\t.addScaledVector( _face.c, 1 - ( u + v ) );\n\n\t\tif ( targetNormal !== undefined ) {\n\n\t\t\tif ( this.normalAttribute !== undefined ) {\n\n\t\t\t\t_face.a.fromBufferAttribute( this.normalAttribute, i0 );\n\t\t\t\t_face.b.fromBufferAttribute( this.normalAttribute, i1 );\n\t\t\t\t_face.c.fromBufferAttribute( this.normalAttribute, i2 );\n\t\t\t\ttargetNormal.set( 0, 0, 0 ).addScaledVector( _face.a, u ).addScaledVector( _face.b, v ).addScaledVector( _face.c, 1 - ( u + v ) ).normalize();\n\n\t\t\t} else {\n\n\t\t\t\t_face.getNormal( targetNormal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( targetColor !== undefined && this.colorAttribute !== undefined ) {\n\n\t\t\t_face.a.fromBufferAttribute( this.colorAttribute, i0 );\n\t\t\t_face.b.fromBufferAttribute( this.colorAttribute, i1 );\n\t\t\t_face.c.fromBufferAttribute( this.colorAttribute, i2 );\n\n\t\t\t_color\n\t\t\t\t.set( 0, 0, 0 )\n\t\t\t\t.addScaledVector( _face.a, u )\n\t\t\t\t.addScaledVector( _face.b, v )\n\t\t\t\t.addScaledVector( _face.c, 1 - ( u + v ) );\n\n\t\t\ttargetColor.r = _color.x;\n\t\t\ttargetColor.g = _color.y;\n\t\t\ttargetColor.b = _color.z;\n\n\t\t}\n\n\t\tif ( targetUV !== undefined && this.uvAttribute !== undefined ) {\n\n\t\t\t_uva.fromBufferAttribute( this.uvAttribute, i0 );\n\t\t\t_uvb.fromBufferAttribute( this.uvAttribute, i1 );\n\t\t\t_uvc.fromBufferAttribute( this.uvAttribute, i2 );\n\t\t\ttargetUV.set( 0, 0 ).addScaledVector( _uva, u ).addScaledVector( _uvb, v ).addScaledVector( _uvc, 1 - ( u + v ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { MeshSurfaceSampler };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}