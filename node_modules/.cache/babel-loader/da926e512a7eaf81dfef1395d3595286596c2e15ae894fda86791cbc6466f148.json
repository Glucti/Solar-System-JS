{"ast":null,"code":"import { MathUtils, Mesh } from 'three';\n\n/**\n * A special type of an animated mesh with a more advanced interface\n * for animation playback. Unlike {@link MorphAnimMesh}. It allows to\n * playback more than one morph animation at the same time but without\n * fading options.\n *\n * @augments Mesh\n * @three_import import { MorphBlendMesh } from 'three/addons/misc/MorphBlendMesh.js';\n */\nclass MorphBlendMesh extends Mesh {\n  /**\n   * Constructs a new morph blend mesh.\n   *\n   * @param {BufferGeometry} [geometry] - The mesh geometry.\n   * @param {Material|Array<Material>} [material] - The mesh material.\n   */\n  constructor(geometry, material) {\n    super(geometry, material);\n\n    /**\n     * A dictionary of animations.\n     *\n     * @type {Object<string,Object>}\n     */\n    this.animationsMap = {};\n\n    /**\n     * A list of animations.\n     *\n     * @type {Array<Object>}\n     */\n    this.animationsList = [];\n\n    // prepare default animation\n    // (all frames played together in 1 second)\n\n    const numFrames = Object.keys(this.morphTargetDictionary).length;\n    const name = '__default';\n    const startFrame = 0;\n    const endFrame = numFrames - 1;\n    const fps = numFrames / 1;\n    this.createAnimation(name, startFrame, endFrame, fps);\n    this.setAnimationWeight(name, 1);\n  }\n\n  /**\n   * Creates a new animation.\n   *\n   * @param {string} name - The animation name.\n   * @param {number} start - The start time.\n   * @param {number} end - The end time.\n   * @param {number} fps - The FPS.\n   */\n  createAnimation(name, start, end, fps) {\n    const animation = {\n      start: start,\n      end: end,\n      length: end - start + 1,\n      fps: fps,\n      duration: (end - start) / fps,\n      lastFrame: 0,\n      currentFrame: 0,\n      active: false,\n      time: 0,\n      direction: 1,\n      weight: 1,\n      directionBackwards: false,\n      mirroredLoop: false\n    };\n    this.animationsMap[name] = animation;\n    this.animationsList.push(animation);\n  }\n\n  /**\n   * Automatically creates animations based on the values in\n   * {@link Mesh#morphTargetDictionary}.\n   *\n   * @param {number} fps - The FPS of all animations.\n   */\n  autoCreateAnimations(fps) {\n    const pattern = /([a-z]+)_?(\\d+)/i;\n    let firstAnimation;\n    const frameRanges = {};\n    let i = 0;\n    for (const key in this.morphTargetDictionary) {\n      const chunks = key.match(pattern);\n      if (chunks && chunks.length > 1) {\n        const name = chunks[1];\n        if (!frameRanges[name]) frameRanges[name] = {\n          start: Infinity,\n          end: -Infinity\n        };\n        const range = frameRanges[name];\n        if (i < range.start) range.start = i;\n        if (i > range.end) range.end = i;\n        if (!firstAnimation) firstAnimation = name;\n      }\n      i++;\n    }\n    for (const name in frameRanges) {\n      const range = frameRanges[name];\n      this.createAnimation(name, range.start, range.end, fps);\n    }\n    this.firstAnimation = firstAnimation;\n  }\n\n  /**\n   * Sets the animation playback direction to \"forward\" for the\n   * defined animation.\n   *\n   * @param {string} name - The animation name.\n   */\n  setAnimationDirectionForward(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.direction = 1;\n      animation.directionBackwards = false;\n    }\n  }\n\n  /**\n   * Sets the animation playback direction to \"backward\" for the\n   * defined animation.\n   *\n   * @param {string} name - The animation name.\n   */\n  setAnimationDirectionBackward(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.direction = -1;\n      animation.directionBackwards = true;\n    }\n  }\n\n  /**\n   * Sets the FPS to the given value for the defined animation.\n   *\n   * @param {string} name - The animation name.\n   * @param {number} fps - The FPS to set.\n   */\n  setAnimationFPS(name, fps) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.fps = fps;\n      animation.duration = (animation.end - animation.start) / animation.fps;\n    }\n  }\n\n  /**\n   * Sets the duration to the given value for the defined animation.\n   *\n   * @param {string} name - The animation name.\n   * @param {number} duration - The duration to set.\n   */\n  setAnimationDuration(name, duration) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.duration = duration;\n      animation.fps = (animation.end - animation.start) / animation.duration;\n    }\n  }\n\n  /**\n   * Sets the weight to the given value for the defined animation.\n   *\n   * @param {string} name - The animation name.\n   * @param {number} weight - The weight to set.\n   */\n  setAnimationWeight(name, weight) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.weight = weight;\n    }\n  }\n\n  /**\n   * Sets the time to the given value for the defined animation.\n   *\n   * @param {string} name - The animation name.\n   * @param {number} time - The time to set.\n   */\n  setAnimationTime(name, time) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.time = time;\n    }\n  }\n\n  /**\n   * Returns the time for the defined animation.\n   *\n   * @param {string} name - The animation name.\n   * @return {number} The time.\n   */\n  getAnimationTime(name) {\n    let time = 0;\n    const animation = this.animationsMap[name];\n    if (animation) {\n      time = animation.time;\n    }\n    return time;\n  }\n\n  /**\n   * Returns the duration for the defined animation.\n   *\n   * @param {string} name - The animation name.\n   * @return {number} The duration.\n   */\n  getAnimationDuration(name) {\n    let duration = -1;\n    const animation = this.animationsMap[name];\n    if (animation) {\n      duration = animation.duration;\n    }\n    return duration;\n  }\n\n  /**\n   * Plays the defined animation.\n   *\n   * @param {string} name - The animation name.\n   */\n  playAnimation(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.time = 0;\n      animation.active = true;\n    } else {\n      console.warn('THREE.MorphBlendMesh: animation[' + name + '] undefined in .playAnimation()');\n    }\n  }\n\n  /**\n   * Stops the defined animation.\n   *\n   * @param {string} name - The animation name.\n   */\n  stopAnimation(name) {\n    const animation = this.animationsMap[name];\n    if (animation) {\n      animation.active = false;\n    }\n  }\n\n  /**\n   * Updates the animations of the mesh.\n   *\n   * @param {number} delta - The delta time in seconds.\n   */\n  update(delta) {\n    for (let i = 0, il = this.animationsList.length; i < il; i++) {\n      const animation = this.animationsList[i];\n      if (!animation.active) continue;\n      const frameTime = animation.duration / animation.length;\n      animation.time += animation.direction * delta;\n      if (animation.mirroredLoop) {\n        if (animation.time > animation.duration || animation.time < 0) {\n          animation.direction *= -1;\n          if (animation.time > animation.duration) {\n            animation.time = animation.duration;\n            animation.directionBackwards = true;\n          }\n          if (animation.time < 0) {\n            animation.time = 0;\n            animation.directionBackwards = false;\n          }\n        }\n      } else {\n        animation.time = animation.time % animation.duration;\n        if (animation.time < 0) animation.time += animation.duration;\n      }\n      const keyframe = animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\n      const weight = animation.weight;\n      if (keyframe !== animation.currentFrame) {\n        this.morphTargetInfluences[animation.lastFrame] = 0;\n        this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\n        this.morphTargetInfluences[keyframe] = 0;\n        animation.lastFrame = animation.currentFrame;\n        animation.currentFrame = keyframe;\n      }\n      let mix = animation.time % frameTime / frameTime;\n      if (animation.directionBackwards) mix = 1 - mix;\n      if (animation.currentFrame !== animation.lastFrame) {\n        this.morphTargetInfluences[animation.currentFrame] = mix * weight;\n        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\n      } else {\n        this.morphTargetInfluences[animation.currentFrame] = weight;\n      }\n    }\n  }\n}\nexport { MorphBlendMesh };","map":{"version":3,"names":["MathUtils","Mesh","MorphBlendMesh","constructor","geometry","material","animationsMap","animationsList","numFrames","Object","keys","morphTargetDictionary","length","name","startFrame","endFrame","fps","createAnimation","setAnimationWeight","start","end","animation","duration","lastFrame","currentFrame","active","time","direction","weight","directionBackwards","mirroredLoop","push","autoCreateAnimations","pattern","firstAnimation","frameRanges","i","key","chunks","match","Infinity","range","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","playAnimation","console","warn","stopAnimation","update","delta","il","frameTime","keyframe","clamp","Math","floor","morphTargetInfluences","mix"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/misc/MorphBlendMesh.js"],"sourcesContent":["import {\n\tMathUtils,\n\tMesh\n} from 'three';\n\n/**\n * A special type of an animated mesh with a more advanced interface\n * for animation playback. Unlike {@link MorphAnimMesh}. It allows to\n * playback more than one morph animation at the same time but without\n * fading options.\n *\n * @augments Mesh\n * @three_import import { MorphBlendMesh } from 'three/addons/misc/MorphBlendMesh.js';\n */\nclass MorphBlendMesh extends Mesh {\n\n\t/**\n\t * Constructs a new morph blend mesh.\n\t *\n\t * @param {BufferGeometry} [geometry] - The mesh geometry.\n\t * @param {Material|Array<Material>} [material] - The mesh material.\n\t */\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\n\t\t/**\n\t\t * A dictionary of animations.\n\t\t *\n\t\t * @type {Object<string,Object>}\n\t\t */\n\t\tthis.animationsMap = {};\n\n\t\t/**\n\t\t * A list of animations.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.animationsList = [];\n\n\t\t// prepare default animation\n\t\t// (all frames played together in 1 second)\n\n\t\tconst numFrames = Object.keys( this.morphTargetDictionary ).length;\n\n\t\tconst name = '__default';\n\n\t\tconst startFrame = 0;\n\t\tconst endFrame = numFrames - 1;\n\n\t\tconst fps = numFrames / 1;\n\n\t\tthis.createAnimation( name, startFrame, endFrame, fps );\n\t\tthis.setAnimationWeight( name, 1 );\n\n\t}\n\n\t/**\n\t * Creates a new animation.\n\t *\n\t * @param {string} name - The animation name.\n\t * @param {number} start - The start time.\n\t * @param {number} end - The end time.\n\t * @param {number} fps - The FPS.\n\t */\n\tcreateAnimation( name, start, end, fps ) {\n\n\t\tconst animation = {\n\n\t\t\tstart: start,\n\t\t\tend: end,\n\n\t\t\tlength: end - start + 1,\n\n\t\t\tfps: fps,\n\t\t\tduration: ( end - start ) / fps,\n\n\t\t\tlastFrame: 0,\n\t\t\tcurrentFrame: 0,\n\n\t\t\tactive: false,\n\n\t\t\ttime: 0,\n\t\t\tdirection: 1,\n\t\t\tweight: 1,\n\n\t\t\tdirectionBackwards: false,\n\t\t\tmirroredLoop: false\n\n\t\t};\n\n\t\tthis.animationsMap[ name ] = animation;\n\t\tthis.animationsList.push( animation );\n\n\t}\n\n\t/**\n\t * Automatically creates animations based on the values in\n\t * {@link Mesh#morphTargetDictionary}.\n\t *\n\t * @param {number} fps - The FPS of all animations.\n\t */\n\tautoCreateAnimations( fps ) {\n\n\t\tconst pattern = /([a-z]+)_?(\\d+)/i;\n\n\t\tlet firstAnimation;\n\n\t\tconst frameRanges = {};\n\n\t\tlet i = 0;\n\n\t\tfor ( const key in this.morphTargetDictionary ) {\n\n\t\t\tconst chunks = key.match( pattern );\n\n\t\t\tif ( chunks && chunks.length > 1 ) {\n\n\t\t\t\tconst name = chunks[ 1 ];\n\n\t\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\n\n\t\t\t\tconst range = frameRanges[ name ];\n\n\t\t\t\tif ( i < range.start ) range.start = i;\n\t\t\t\tif ( i > range.end ) range.end = i;\n\n\t\t\t\tif ( ! firstAnimation ) firstAnimation = name;\n\n\t\t\t}\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\tfor ( const name in frameRanges ) {\n\n\t\t\tconst range = frameRanges[ name ];\n\t\t\tthis.createAnimation( name, range.start, range.end, fps );\n\n\t\t}\n\n\t\tthis.firstAnimation = firstAnimation;\n\n\t}\n\n\t/**\n\t * Sets the animation playback direction to \"forward\" for the\n\t * defined animation.\n\t *\n\t * @param {string} name - The animation name.\n\t */\n\tsetAnimationDirectionForward( name ) {\n\n\t\tconst animation = this.animationsMap[ name ];\n\n\t\tif ( animation ) {\n\n\t\t\tanimation.direction = 1;\n\t\t\tanimation.directionBackwards = false;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets the animation playback direction to \"backward\" for the\n\t * defined animation.\n\t *\n\t * @param {string} name - The animation name.\n\t */\n\tsetAnimationDirectionBackward( name ) {\n\n\t\tconst animation = this.animationsMap[ name ];\n\n\t\tif ( animation ) {\n\n\t\t\tanimation.direction = - 1;\n\t\t\tanimation.directionBackwards = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets the FPS to the given value for the defined animation.\n\t *\n\t * @param {string} name - The animation name.\n\t * @param {number} fps - The FPS to set.\n\t */\n\tsetAnimationFPS( name, fps ) {\n\n\t\tconst animation = this.animationsMap[ name ];\n\n\t\tif ( animation ) {\n\n\t\t\tanimation.fps = fps;\n\t\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets the duration to the given value for the defined animation.\n\t *\n\t * @param {string} name - The animation name.\n\t * @param {number} duration - The duration to set.\n\t */\n\tsetAnimationDuration( name, duration ) {\n\n\t\tconst animation = this.animationsMap[ name ];\n\n\t\tif ( animation ) {\n\n\t\t\tanimation.duration = duration;\n\t\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets the weight to the given value for the defined animation.\n\t *\n\t * @param {string} name - The animation name.\n\t * @param {number} weight - The weight to set.\n\t */\n\tsetAnimationWeight( name, weight ) {\n\n\t\tconst animation = this.animationsMap[ name ];\n\n\t\tif ( animation ) {\n\n\t\t\tanimation.weight = weight;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets the time to the given value for the defined animation.\n\t *\n\t * @param {string} name - The animation name.\n\t * @param {number} time - The time to set.\n\t */\n\tsetAnimationTime( name, time ) {\n\n\t\tconst animation = this.animationsMap[ name ];\n\n\t\tif ( animation ) {\n\n\t\t\tanimation.time = time;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the time for the defined animation.\n\t *\n\t * @param {string} name - The animation name.\n\t * @return {number} The time.\n\t */\n\tgetAnimationTime( name ) {\n\n\t\tlet time = 0;\n\n\t\tconst animation = this.animationsMap[ name ];\n\n\t\tif ( animation ) {\n\n\t\t\ttime = animation.time;\n\n\t\t}\n\n\t\treturn time;\n\n\t}\n\n\t/**\n\t * Returns the duration for the defined animation.\n\t *\n\t * @param {string} name - The animation name.\n\t * @return {number} The duration.\n\t */\n\tgetAnimationDuration( name ) {\n\n\t\tlet duration = - 1;\n\n\t\tconst animation = this.animationsMap[ name ];\n\n\t\tif ( animation ) {\n\n\t\t\tduration = animation.duration;\n\n\t\t}\n\n\t\treturn duration;\n\n\t}\n\n\t/**\n\t * Plays the defined animation.\n\t *\n\t * @param {string} name - The animation name.\n\t */\n\tplayAnimation( name ) {\n\n\t\tconst animation = this.animationsMap[ name ];\n\n\t\tif ( animation ) {\n\n\t\t\tanimation.time = 0;\n\t\t\tanimation.active = true;\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.MorphBlendMesh: animation[' + name + '] undefined in .playAnimation()' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Stops the defined animation.\n\t *\n\t * @param {string} name - The animation name.\n\t */\n\tstopAnimation( name ) {\n\n\t\tconst animation = this.animationsMap[ name ];\n\n\t\tif ( animation ) {\n\n\t\t\tanimation.active = false;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the animations of the mesh.\n\t *\n\t * @param {number} delta - The delta time in seconds.\n\t */\n\tupdate( delta ) {\n\n\t\tfor ( let i = 0, il = this.animationsList.length; i < il; i ++ ) {\n\n\t\t\tconst animation = this.animationsList[ i ];\n\n\t\t\tif ( ! animation.active ) continue;\n\n\t\t\tconst frameTime = animation.duration / animation.length;\n\n\t\t\tanimation.time += animation.direction * delta;\n\n\t\t\tif ( animation.mirroredLoop ) {\n\n\t\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\n\n\t\t\t\t\tanimation.direction *= - 1;\n\n\t\t\t\t\tif ( animation.time > animation.duration ) {\n\n\t\t\t\t\t\tanimation.time = animation.duration;\n\t\t\t\t\t\tanimation.directionBackwards = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( animation.time < 0 ) {\n\n\t\t\t\t\t\tanimation.time = 0;\n\t\t\t\t\t\tanimation.directionBackwards = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tanimation.time = animation.time % animation.duration;\n\n\t\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\n\n\t\t\t}\n\n\t\t\tconst keyframe = animation.start + MathUtils.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\n\t\t\tconst weight = animation.weight;\n\n\t\t\tif ( keyframe !== animation.currentFrame ) {\n\n\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\n\n\t\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\n\n\t\t\t\tanimation.lastFrame = animation.currentFrame;\n\t\t\t\tanimation.currentFrame = keyframe;\n\n\t\t\t}\n\n\t\t\tlet mix = ( animation.time % frameTime ) / frameTime;\n\n\t\t\tif ( animation.directionBackwards ) mix = 1 - mix;\n\n\t\t\tif ( animation.currentFrame !== animation.lastFrame ) {\n\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\n\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\n\n\t\t\t} else {\n\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = weight;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexport { MorphBlendMesh };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}