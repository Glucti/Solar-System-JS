{"ast":null,"code":"import { Frustum, Vector3, Matrix4, Quaternion } from 'three';\nconst _frustum = new Frustum();\nconst _center = new Vector3();\nconst _tmpPoint = new Vector3();\nconst _vecNear = new Vector3();\nconst _vecTopLeft = new Vector3();\nconst _vecTopRight = new Vector3();\nconst _vecDownRight = new Vector3();\nconst _vecDownLeft = new Vector3();\nconst _vecFarTopLeft = new Vector3();\nconst _vecFarTopRight = new Vector3();\nconst _vecFarDownRight = new Vector3();\nconst _vecFarDownLeft = new Vector3();\nconst _vectemp1 = new Vector3();\nconst _vectemp2 = new Vector3();\nconst _vectemp3 = new Vector3();\nconst _matrix = new Matrix4();\nconst _quaternion = new Quaternion();\nconst _scale = new Vector3();\n\n/**\n * This class can be used to select 3D objects in a scene with a selection box.\n * It is recommended to visualize the selected area with the help of {@link SelectionHelper}.\n *\n * ```js\n * const selectionBox = new SelectionBox( camera, scene );\n * const selectedObjects = selectionBox.select( startPoint, endPoint );\n * ```\n *\n * @three_import import { SelectionBox } from 'three/addons/interactive/SelectionBox.js';\n */\nclass SelectionBox {\n  /**\n   * Constructs a new selection box.\n   *\n   * @param {Camera} camera - The camera the scene is rendered with.\n   * @param {Scene} scene - The scene.\n   * @param {number} [deep=Number.MAX_VALUE] - How deep the selection frustum of perspective cameras should extend.\n   */\n  constructor(camera, scene, deep = Number.MAX_VALUE) {\n    /**\n     * The camera the scene is rendered with.\n     *\n     * @type {Camera}\n     */\n    this.camera = camera;\n\n    /**\n     * The camera the scene is rendered with.\n     *\n     * @type {Scene}\n     */\n    this.scene = scene;\n\n    /**\n     * The start point of the selection.\n     *\n     * @type {Vector3}\n     */\n    this.startPoint = new Vector3();\n\n    /**\n     * The end point of the selection.\n     *\n     * @type {Vector3}\n     */\n    this.endPoint = new Vector3();\n\n    /**\n     * The selected 3D objects.\n     *\n     * @type {Array<Object3D>}\n     */\n    this.collection = [];\n\n    /**\n     * The selected instance IDs of instanced meshes.\n     *\n     * @type {Object}\n     */\n    this.instances = {};\n\n    /**\n     * How deep the selection frustum of perspective cameras should extend.\n     *\n     * @type {number}\n     * @default Number.MAX_VALUE\n     */\n    this.deep = deep;\n  }\n\n  /**\n   * This method selects 3D objects in the scene based on the given start\n   * and end point. If no parameters are provided, the method uses the start\n   * and end values of the respective members.\n   *\n   * @param {Vector3} [startPoint] - The start point.\n   * @param {Vector3} [endPoint] - The end point.\n   * @return {Array<Object3D>} The selected 3D objects.\n   */\n  select(startPoint, endPoint) {\n    this.startPoint = startPoint || this.startPoint;\n    this.endPoint = endPoint || this.endPoint;\n    this.collection = [];\n    this._updateFrustum(this.startPoint, this.endPoint);\n    this._searchChildInFrustum(_frustum, this.scene);\n    return this.collection;\n  }\n\n  // private\n\n  _updateFrustum(startPoint, endPoint) {\n    startPoint = startPoint || this.startPoint;\n    endPoint = endPoint || this.endPoint;\n\n    // Avoid invalid frustum\n\n    if (startPoint.x === endPoint.x) {\n      endPoint.x += Number.EPSILON;\n    }\n    if (startPoint.y === endPoint.y) {\n      endPoint.y += Number.EPSILON;\n    }\n    this.camera.updateProjectionMatrix();\n    this.camera.updateMatrixWorld();\n    if (this.camera.isPerspectiveCamera) {\n      _tmpPoint.copy(startPoint);\n      _tmpPoint.x = Math.min(startPoint.x, endPoint.x);\n      _tmpPoint.y = Math.max(startPoint.y, endPoint.y);\n      endPoint.x = Math.max(startPoint.x, endPoint.x);\n      endPoint.y = Math.min(startPoint.y, endPoint.y);\n      _vecNear.setFromMatrixPosition(this.camera.matrixWorld);\n      _vecTopLeft.copy(_tmpPoint);\n      _vecTopRight.set(endPoint.x, _tmpPoint.y, 0);\n      _vecDownRight.copy(endPoint);\n      _vecDownLeft.set(_tmpPoint.x, endPoint.y, 0);\n      _vecTopLeft.unproject(this.camera);\n      _vecTopRight.unproject(this.camera);\n      _vecDownRight.unproject(this.camera);\n      _vecDownLeft.unproject(this.camera);\n      _vectemp1.copy(_vecTopLeft).sub(_vecNear);\n      _vectemp2.copy(_vecTopRight).sub(_vecNear);\n      _vectemp3.copy(_vecDownRight).sub(_vecNear);\n      _vectemp1.normalize();\n      _vectemp2.normalize();\n      _vectemp3.normalize();\n      _vectemp1.multiplyScalar(this.deep);\n      _vectemp2.multiplyScalar(this.deep);\n      _vectemp3.multiplyScalar(this.deep);\n      _vectemp1.add(_vecNear);\n      _vectemp2.add(_vecNear);\n      _vectemp3.add(_vecNear);\n      const planes = _frustum.planes;\n      planes[0].setFromCoplanarPoints(_vecNear, _vecTopLeft, _vecTopRight);\n      planes[1].setFromCoplanarPoints(_vecNear, _vecTopRight, _vecDownRight);\n      planes[2].setFromCoplanarPoints(_vecDownRight, _vecDownLeft, _vecNear);\n      planes[3].setFromCoplanarPoints(_vecDownLeft, _vecTopLeft, _vecNear);\n      planes[4].setFromCoplanarPoints(_vecTopRight, _vecDownRight, _vecDownLeft);\n      planes[5].setFromCoplanarPoints(_vectemp3, _vectemp2, _vectemp1);\n      planes[5].normal.multiplyScalar(-1);\n    } else if (this.camera.isOrthographicCamera) {\n      const left = Math.min(startPoint.x, endPoint.x);\n      const top = Math.max(startPoint.y, endPoint.y);\n      const right = Math.max(startPoint.x, endPoint.x);\n      const down = Math.min(startPoint.y, endPoint.y);\n      _vecTopLeft.set(left, top, -1);\n      _vecTopRight.set(right, top, -1);\n      _vecDownRight.set(right, down, -1);\n      _vecDownLeft.set(left, down, -1);\n      _vecFarTopLeft.set(left, top, 1);\n      _vecFarTopRight.set(right, top, 1);\n      _vecFarDownRight.set(right, down, 1);\n      _vecFarDownLeft.set(left, down, 1);\n      _vecTopLeft.unproject(this.camera);\n      _vecTopRight.unproject(this.camera);\n      _vecDownRight.unproject(this.camera);\n      _vecDownLeft.unproject(this.camera);\n      _vecFarTopLeft.unproject(this.camera);\n      _vecFarTopRight.unproject(this.camera);\n      _vecFarDownRight.unproject(this.camera);\n      _vecFarDownLeft.unproject(this.camera);\n      const planes = _frustum.planes;\n      planes[0].setFromCoplanarPoints(_vecTopLeft, _vecFarTopLeft, _vecFarTopRight);\n      planes[1].setFromCoplanarPoints(_vecTopRight, _vecFarTopRight, _vecFarDownRight);\n      planes[2].setFromCoplanarPoints(_vecFarDownRight, _vecFarDownLeft, _vecDownLeft);\n      planes[3].setFromCoplanarPoints(_vecFarDownLeft, _vecFarTopLeft, _vecTopLeft);\n      planes[4].setFromCoplanarPoints(_vecTopRight, _vecDownRight, _vecDownLeft);\n      planes[5].setFromCoplanarPoints(_vecFarDownRight, _vecFarTopRight, _vecFarTopLeft);\n      planes[5].normal.multiplyScalar(-1);\n    } else {\n      console.error('THREE.SelectionBox: Unsupported camera type.');\n    }\n  }\n  _searchChildInFrustum(frustum, object) {\n    if (object.isMesh || object.isLine || object.isPoints) {\n      if (object.isInstancedMesh) {\n        this.instances[object.uuid] = [];\n        for (let instanceId = 0; instanceId < object.count; instanceId++) {\n          object.getMatrixAt(instanceId, _matrix);\n          _matrix.decompose(_center, _quaternion, _scale);\n          _center.applyMatrix4(object.matrixWorld);\n          if (frustum.containsPoint(_center)) {\n            this.instances[object.uuid].push(instanceId);\n          }\n        }\n      } else {\n        if (object.geometry.boundingSphere === null) object.geometry.computeBoundingSphere();\n        _center.copy(object.geometry.boundingSphere.center);\n        _center.applyMatrix4(object.matrixWorld);\n        if (frustum.containsPoint(_center)) {\n          this.collection.push(object);\n        }\n      }\n    }\n    if (object.children.length > 0) {\n      for (let x = 0; x < object.children.length; x++) {\n        this._searchChildInFrustum(frustum, object.children[x]);\n      }\n    }\n  }\n}\nexport { SelectionBox };","map":{"version":3,"names":["Frustum","Vector3","Matrix4","Quaternion","_frustum","_center","_tmpPoint","_vecNear","_vecTopLeft","_vecTopRight","_vecDownRight","_vecDownLeft","_vecFarTopLeft","_vecFarTopRight","_vecFarDownRight","_vecFarDownLeft","_vectemp1","_vectemp2","_vectemp3","_matrix","_quaternion","_scale","SelectionBox","constructor","camera","scene","deep","Number","MAX_VALUE","startPoint","endPoint","collection","instances","select","_updateFrustum","_searchChildInFrustum","x","EPSILON","y","updateProjectionMatrix","updateMatrixWorld","isPerspectiveCamera","copy","Math","min","max","setFromMatrixPosition","matrixWorld","set","unproject","sub","normalize","multiplyScalar","add","planes","setFromCoplanarPoints","normal","isOrthographicCamera","left","top","right","down","console","error","frustum","object","isMesh","isLine","isPoints","isInstancedMesh","uuid","instanceId","count","getMatrixAt","decompose","applyMatrix4","containsPoint","push","geometry","boundingSphere","computeBoundingSphere","center","children","length"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/interactive/SelectionBox.js"],"sourcesContent":["import {\n\tFrustum,\n\tVector3,\n\tMatrix4,\n\tQuaternion,\n} from 'three';\n\nconst _frustum = new Frustum();\nconst _center = new Vector3();\n\nconst _tmpPoint = new Vector3();\n\nconst _vecNear = new Vector3();\nconst _vecTopLeft = new Vector3();\nconst _vecTopRight = new Vector3();\nconst _vecDownRight = new Vector3();\nconst _vecDownLeft = new Vector3();\n\nconst _vecFarTopLeft = new Vector3();\nconst _vecFarTopRight = new Vector3();\nconst _vecFarDownRight = new Vector3();\nconst _vecFarDownLeft = new Vector3();\n\nconst _vectemp1 = new Vector3();\nconst _vectemp2 = new Vector3();\nconst _vectemp3 = new Vector3();\n\nconst _matrix = new Matrix4();\nconst _quaternion = new Quaternion();\nconst _scale = new Vector3();\n\n/**\n * This class can be used to select 3D objects in a scene with a selection box.\n * It is recommended to visualize the selected area with the help of {@link SelectionHelper}.\n *\n * ```js\n * const selectionBox = new SelectionBox( camera, scene );\n * const selectedObjects = selectionBox.select( startPoint, endPoint );\n * ```\n *\n * @three_import import { SelectionBox } from 'three/addons/interactive/SelectionBox.js';\n */\nclass SelectionBox {\n\n\t/**\n\t * Constructs a new selection box.\n\t *\n\t * @param {Camera} camera - The camera the scene is rendered with.\n\t * @param {Scene} scene - The scene.\n\t * @param {number} [deep=Number.MAX_VALUE] - How deep the selection frustum of perspective cameras should extend.\n\t */\n\tconstructor( camera, scene, deep = Number.MAX_VALUE ) {\n\n\t\t/**\n\t\t * The camera the scene is rendered with.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * The camera the scene is rendered with.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * The start point of the selection.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.startPoint = new Vector3();\n\n\t\t/**\n\t\t * The end point of the selection.\n\t\t *\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.endPoint = new Vector3();\n\n\t\t/**\n\t\t * The selected 3D objects.\n\t\t *\n\t\t * @type {Array<Object3D>}\n\t\t */\n\t\tthis.collection = [];\n\n\t\t/**\n\t\t * The selected instance IDs of instanced meshes.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.instances = {};\n\n\t\t/**\n\t\t * How deep the selection frustum of perspective cameras should extend.\n\t\t *\n\t\t * @type {number}\n\t\t * @default Number.MAX_VALUE\n\t\t */\n\t\tthis.deep = deep;\n\n\t}\n\n\t/**\n\t * This method selects 3D objects in the scene based on the given start\n\t * and end point. If no parameters are provided, the method uses the start\n\t * and end values of the respective members.\n\t *\n\t * @param {Vector3} [startPoint] - The start point.\n\t * @param {Vector3} [endPoint] - The end point.\n\t * @return {Array<Object3D>} The selected 3D objects.\n\t */\n\tselect( startPoint, endPoint ) {\n\n\t\tthis.startPoint = startPoint || this.startPoint;\n\t\tthis.endPoint = endPoint || this.endPoint;\n\t\tthis.collection = [];\n\n\t\tthis._updateFrustum( this.startPoint, this.endPoint );\n\t\tthis._searchChildInFrustum( _frustum, this.scene );\n\n\t\treturn this.collection;\n\n\t}\n\n\t// private\n\n\t_updateFrustum( startPoint, endPoint ) {\n\n\t\tstartPoint = startPoint || this.startPoint;\n\t\tendPoint = endPoint || this.endPoint;\n\n\t\t// Avoid invalid frustum\n\n\t\tif ( startPoint.x === endPoint.x ) {\n\n\t\t\tendPoint.x += Number.EPSILON;\n\n\t\t}\n\n\t\tif ( startPoint.y === endPoint.y ) {\n\n\t\t\tendPoint.y += Number.EPSILON;\n\n\t\t}\n\n\t\tthis.camera.updateProjectionMatrix();\n\t\tthis.camera.updateMatrixWorld();\n\n\t\tif ( this.camera.isPerspectiveCamera ) {\n\n\t\t\t_tmpPoint.copy( startPoint );\n\t\t\t_tmpPoint.x = Math.min( startPoint.x, endPoint.x );\n\t\t\t_tmpPoint.y = Math.max( startPoint.y, endPoint.y );\n\t\t\tendPoint.x = Math.max( startPoint.x, endPoint.x );\n\t\t\tendPoint.y = Math.min( startPoint.y, endPoint.y );\n\n\t\t\t_vecNear.setFromMatrixPosition( this.camera.matrixWorld );\n\t\t\t_vecTopLeft.copy( _tmpPoint );\n\t\t\t_vecTopRight.set( endPoint.x, _tmpPoint.y, 0 );\n\t\t\t_vecDownRight.copy( endPoint );\n\t\t\t_vecDownLeft.set( _tmpPoint.x, endPoint.y, 0 );\n\n\t\t\t_vecTopLeft.unproject( this.camera );\n\t\t\t_vecTopRight.unproject( this.camera );\n\t\t\t_vecDownRight.unproject( this.camera );\n\t\t\t_vecDownLeft.unproject( this.camera );\n\n\t\t\t_vectemp1.copy( _vecTopLeft ).sub( _vecNear );\n\t\t\t_vectemp2.copy( _vecTopRight ).sub( _vecNear );\n\t\t\t_vectemp3.copy( _vecDownRight ).sub( _vecNear );\n\t\t\t_vectemp1.normalize();\n\t\t\t_vectemp2.normalize();\n\t\t\t_vectemp3.normalize();\n\n\t\t\t_vectemp1.multiplyScalar( this.deep );\n\t\t\t_vectemp2.multiplyScalar( this.deep );\n\t\t\t_vectemp3.multiplyScalar( this.deep );\n\t\t\t_vectemp1.add( _vecNear );\n\t\t\t_vectemp2.add( _vecNear );\n\t\t\t_vectemp3.add( _vecNear );\n\n\t\t\tconst planes = _frustum.planes;\n\n\t\t\tplanes[ 0 ].setFromCoplanarPoints( _vecNear, _vecTopLeft, _vecTopRight );\n\t\t\tplanes[ 1 ].setFromCoplanarPoints( _vecNear, _vecTopRight, _vecDownRight );\n\t\t\tplanes[ 2 ].setFromCoplanarPoints( _vecDownRight, _vecDownLeft, _vecNear );\n\t\t\tplanes[ 3 ].setFromCoplanarPoints( _vecDownLeft, _vecTopLeft, _vecNear );\n\t\t\tplanes[ 4 ].setFromCoplanarPoints( _vecTopRight, _vecDownRight, _vecDownLeft );\n\t\t\tplanes[ 5 ].setFromCoplanarPoints( _vectemp3, _vectemp2, _vectemp1 );\n\t\t\tplanes[ 5 ].normal.multiplyScalar( - 1 );\n\n\t\t} else if ( this.camera.isOrthographicCamera ) {\n\n\t\t\tconst left = Math.min( startPoint.x, endPoint.x );\n\t\t\tconst top = Math.max( startPoint.y, endPoint.y );\n\t\t\tconst right = Math.max( startPoint.x, endPoint.x );\n\t\t\tconst down = Math.min( startPoint.y, endPoint.y );\n\n\t\t\t_vecTopLeft.set( left, top, - 1 );\n\t\t\t_vecTopRight.set( right, top, - 1 );\n\t\t\t_vecDownRight.set( right, down, - 1 );\n\t\t\t_vecDownLeft.set( left, down, - 1 );\n\n\t\t\t_vecFarTopLeft.set( left, top, 1 );\n\t\t\t_vecFarTopRight.set( right, top, 1 );\n\t\t\t_vecFarDownRight.set( right, down, 1 );\n\t\t\t_vecFarDownLeft.set( left, down, 1 );\n\n\t\t\t_vecTopLeft.unproject( this.camera );\n\t\t\t_vecTopRight.unproject( this.camera );\n\t\t\t_vecDownRight.unproject( this.camera );\n\t\t\t_vecDownLeft.unproject( this.camera );\n\n\t\t\t_vecFarTopLeft.unproject( this.camera );\n\t\t\t_vecFarTopRight.unproject( this.camera );\n\t\t\t_vecFarDownRight.unproject( this.camera );\n\t\t\t_vecFarDownLeft.unproject( this.camera );\n\n\t\t\tconst planes = _frustum.planes;\n\n\t\t\tplanes[ 0 ].setFromCoplanarPoints( _vecTopLeft, _vecFarTopLeft, _vecFarTopRight );\n\t\t\tplanes[ 1 ].setFromCoplanarPoints( _vecTopRight, _vecFarTopRight, _vecFarDownRight );\n\t\t\tplanes[ 2 ].setFromCoplanarPoints( _vecFarDownRight, _vecFarDownLeft, _vecDownLeft );\n\t\t\tplanes[ 3 ].setFromCoplanarPoints( _vecFarDownLeft, _vecFarTopLeft, _vecTopLeft );\n\t\t\tplanes[ 4 ].setFromCoplanarPoints( _vecTopRight, _vecDownRight, _vecDownLeft );\n\t\t\tplanes[ 5 ].setFromCoplanarPoints( _vecFarDownRight, _vecFarTopRight, _vecFarTopLeft );\n\t\t\tplanes[ 5 ].normal.multiplyScalar( - 1 );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.SelectionBox: Unsupported camera type.' );\n\n\t\t}\n\n\t}\n\n\t_searchChildInFrustum( frustum, object ) {\n\n\t\tif ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\tif ( object.isInstancedMesh ) {\n\n\t\t\t\tthis.instances[ object.uuid ] = [];\n\n\t\t\t\tfor ( let instanceId = 0; instanceId < object.count; instanceId ++ ) {\n\n\t\t\t\t\tobject.getMatrixAt( instanceId, _matrix );\n\t\t\t\t\t_matrix.decompose( _center, _quaternion, _scale );\n\t\t\t\t\t_center.applyMatrix4( object.matrixWorld );\n\n\t\t\t\t\tif ( frustum.containsPoint( _center ) ) {\n\n\t\t\t\t\t\tthis.instances[ object.uuid ].push( instanceId );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( object.geometry.boundingSphere === null ) object.geometry.computeBoundingSphere();\n\n\t\t\t\t_center.copy( object.geometry.boundingSphere.center );\n\n\t\t\t\t_center.applyMatrix4( object.matrixWorld );\n\n\t\t\t\tif ( frustum.containsPoint( _center ) ) {\n\n\t\t\t\t\tthis.collection.push( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.children.length > 0 ) {\n\n\t\t\tfor ( let x = 0; x < object.children.length; x ++ ) {\n\n\t\t\t\tthis._searchChildInFrustum( frustum, object.children[ x ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexport { SelectionBox };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}