{"ast":null,"code":"import { Box3, Line3, Plane, Sphere, Triangle, Vector3, Layers } from 'three';\nimport { Capsule } from '../math/Capsule.js';\nconst _v1 = new Vector3();\nconst _v2 = new Vector3();\nconst _point1 = new Vector3();\nconst _point2 = new Vector3();\nconst _plane = new Plane();\nconst _line1 = new Line3();\nconst _line2 = new Line3();\nconst _sphere = new Sphere();\nconst _capsule = new Capsule();\nconst _temp1 = new Vector3();\nconst _temp2 = new Vector3();\nconst _temp3 = new Vector3();\nconst EPS = 1e-10;\nfunction lineToLineClosestPoints(line1, line2, target1 = null, target2 = null) {\n  const r = _temp1.copy(line1.end).sub(line1.start);\n  const s = _temp2.copy(line2.end).sub(line2.start);\n  const w = _temp3.copy(line2.start).sub(line1.start);\n  const a = r.dot(s),\n    b = r.dot(r),\n    c = s.dot(s),\n    d = s.dot(w),\n    e = r.dot(w);\n  let t1, t2;\n  const divisor = b * c - a * a;\n  if (Math.abs(divisor) < EPS) {\n    const d1 = -d / c;\n    const d2 = (a - d) / c;\n    if (Math.abs(d1 - 0.5) < Math.abs(d2 - 0.5)) {\n      t1 = 0;\n      t2 = d1;\n    } else {\n      t1 = 1;\n      t2 = d2;\n    }\n  } else {\n    t1 = (d * a + e * c) / divisor;\n    t2 = (t1 * a - d) / c;\n  }\n  t2 = Math.max(0, Math.min(1, t2));\n  t1 = Math.max(0, Math.min(1, t1));\n  if (target1) {\n    target1.copy(r).multiplyScalar(t1).add(line1.start);\n  }\n  if (target2) {\n    target2.copy(s).multiplyScalar(t2).add(line2.start);\n  }\n}\n\n/**\n * An octree is a hierarchical tree data structure used to partition a three-dimensional\n * space by recursively subdividing it into eight octants.\n *\n * This particular implementation can have up to sixteen levels and stores up to eight triangles\n * in leaf nodes.\n *\n * `Octree` can be used in games to compute collision between the game world and colliders from\n * the player or other dynamic 3D objects.\n *\n *\n * ```js\n * const octree = new Octree().fromGraphNode( scene );\n * const result = octree.capsuleIntersect( playerCollider ); // collision detection\n * ```\n *\n * @three_import import { Octree } from 'three/addons/math/Octree.js';\n */\nclass Octree {\n  /**\n   * Constructs a new Octree.\n   *\n   * @param {Box3} [box] - The base box with enclose the entire Octree.\n   */\n  constructor(box) {\n    /**\n     * The base box with enclose the entire Octree.\n     *\n     * @type {Box3}\n     */\n    this.box = box;\n\n    /**\n     * The bounds of the Octree. Compared to {@link Octree#box}, no\n     * margin is applied.\n     *\n     * @type {Box3}\n     */\n    this.bounds = new Box3();\n\n    /**\n     * Can by used for layers configuration for refine testing.\n     *\n     * @type {Layers}\n     */\n    this.layers = new Layers();\n\n    /**\n     * The number of triangles a leaf can store before it is split.\n     *\n     * @type {number}\n     * @default 8\n     */\n    this.trianglesPerLeaf = 8;\n\n    /**\n     * The maximum level of the Octree. It defines the maximum\n     * hierarchical depth of the data structure.\n     *\n     * @type {number}\n     * @default 16\n     */\n    this.maxLevel = 16;\n\n    // private\n\n    this.subTrees = [];\n    this.triangles = [];\n  }\n\n  /**\n   * Adds the given triangle to the Octree. The triangle vertices are clamped if they exceed\n   * the bounds of the Octree.\n   *\n   * @param {Triangle} triangle - The triangle to add.\n   * @return {Octree} A reference to this Octree.\n   */\n  addTriangle(triangle) {\n    this.bounds.min.x = Math.min(this.bounds.min.x, triangle.a.x, triangle.b.x, triangle.c.x);\n    this.bounds.min.y = Math.min(this.bounds.min.y, triangle.a.y, triangle.b.y, triangle.c.y);\n    this.bounds.min.z = Math.min(this.bounds.min.z, triangle.a.z, triangle.b.z, triangle.c.z);\n    this.bounds.max.x = Math.max(this.bounds.max.x, triangle.a.x, triangle.b.x, triangle.c.x);\n    this.bounds.max.y = Math.max(this.bounds.max.y, triangle.a.y, triangle.b.y, triangle.c.y);\n    this.bounds.max.z = Math.max(this.bounds.max.z, triangle.a.z, triangle.b.z, triangle.c.z);\n    this.triangles.push(triangle);\n    return this;\n  }\n\n  /**\n   * Prepares {@link Octree#box} for the build.\n   *\n   * @return {Octree} A reference to this Octree.\n   */\n  calcBox() {\n    this.box = this.bounds.clone();\n\n    // offset small amount to account for regular grid\n    this.box.min.x -= 0.01;\n    this.box.min.y -= 0.01;\n    this.box.min.z -= 0.01;\n    return this;\n  }\n\n  /**\n   * Splits the Octree. This method is used recursively when\n   * building the Octree.\n   *\n   * @param {number} level - The current level.\n   * @return {Octree} A reference to this Octree.\n   */\n  split(level) {\n    if (!this.box) return;\n    const subTrees = [];\n    const halfsize = _v2.copy(this.box.max).sub(this.box.min).multiplyScalar(0.5);\n    for (let x = 0; x < 2; x++) {\n      for (let y = 0; y < 2; y++) {\n        for (let z = 0; z < 2; z++) {\n          const box = new Box3();\n          const v = _v1.set(x, y, z);\n          box.min.copy(this.box.min).add(v.multiply(halfsize));\n          box.max.copy(box.min).add(halfsize);\n          subTrees.push(new Octree(box));\n        }\n      }\n    }\n    let triangle;\n    while (triangle = this.triangles.pop()) {\n      for (let i = 0; i < subTrees.length; i++) {\n        if (subTrees[i].box.intersectsTriangle(triangle)) {\n          subTrees[i].triangles.push(triangle);\n        }\n      }\n    }\n    for (let i = 0; i < subTrees.length; i++) {\n      const len = subTrees[i].triangles.length;\n      if (len > this.trianglesPerLeaf && level < this.maxLevel) {\n        subTrees[i].split(level + 1);\n      }\n      if (len !== 0) {\n        this.subTrees.push(subTrees[i]);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Builds the Octree.\n   *\n   * @return {Octree} A reference to this Octree.\n   */\n  build() {\n    this.calcBox();\n    this.split(0);\n    return this;\n  }\n\n  /**\n   * Computes the triangles that potentially intersect with the given ray.\n   *\n   * @param {Ray} ray - The ray to test.\n   * @param {Array<Triangle>} triangles - The target array that holds the triangles.\n   */\n  getRayTriangles(ray, triangles) {\n    for (let i = 0; i < this.subTrees.length; i++) {\n      const subTree = this.subTrees[i];\n      if (!ray.intersectsBox(subTree.box)) continue;\n      if (subTree.triangles.length > 0) {\n        for (let j = 0; j < subTree.triangles.length; j++) {\n          if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j]);\n        }\n      } else {\n        subTree.getRayTriangles(ray, triangles);\n      }\n    }\n  }\n\n  /**\n   * Computes the intersection between the given capsule and triangle.\n   *\n   * @param {Capsule} capsule - The capsule to test.\n   * @param {Triangle} triangle - The triangle to test.\n   * @return {Object|false} The intersection object. If no intersection\n   * is detected, the method returns `false`.\n   */\n  triangleCapsuleIntersect(capsule, triangle) {\n    triangle.getPlane(_plane);\n    const d1 = _plane.distanceToPoint(capsule.start) - capsule.radius;\n    const d2 = _plane.distanceToPoint(capsule.end) - capsule.radius;\n    if (d1 > 0 && d2 > 0 || d1 < -capsule.radius && d2 < -capsule.radius) {\n      return false;\n    }\n    const delta = Math.abs(d1 / (Math.abs(d1) + Math.abs(d2)));\n    const intersectPoint = _v1.copy(capsule.start).lerp(capsule.end, delta);\n    if (triangle.containsPoint(intersectPoint)) {\n      return {\n        normal: _plane.normal.clone(),\n        point: intersectPoint.clone(),\n        depth: Math.abs(Math.min(d1, d2))\n      };\n    }\n    const r2 = capsule.radius * capsule.radius;\n    const line1 = _line1.set(capsule.start, capsule.end);\n    const lines = [[triangle.a, triangle.b], [triangle.b, triangle.c], [triangle.c, triangle.a]];\n    for (let i = 0; i < lines.length; i++) {\n      const line2 = _line2.set(lines[i][0], lines[i][1]);\n      lineToLineClosestPoints(line1, line2, _point1, _point2);\n      if (_point1.distanceToSquared(_point2) < r2) {\n        return {\n          normal: _point1.clone().sub(_point2).normalize(),\n          point: _point2.clone(),\n          depth: capsule.radius - _point1.distanceTo(_point2)\n        };\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Computes the intersection between the given sphere and triangle.\n   *\n   * @param {Sphere} sphere - The sphere to test.\n   * @param {Triangle} triangle - The triangle to test.\n   * @return {Object|false} The intersection object. If no intersection\n   * is detected, the method returns `false`.\n   */\n  triangleSphereIntersect(sphere, triangle) {\n    triangle.getPlane(_plane);\n    if (!sphere.intersectsPlane(_plane)) return false;\n    const depth = Math.abs(_plane.distanceToSphere(sphere));\n    const r2 = sphere.radius * sphere.radius - depth * depth;\n    const plainPoint = _plane.projectPoint(sphere.center, _v1);\n    if (triangle.containsPoint(sphere.center)) {\n      return {\n        normal: _plane.normal.clone(),\n        point: plainPoint.clone(),\n        depth: Math.abs(_plane.distanceToSphere(sphere))\n      };\n    }\n    const lines = [[triangle.a, triangle.b], [triangle.b, triangle.c], [triangle.c, triangle.a]];\n    for (let i = 0; i < lines.length; i++) {\n      _line1.set(lines[i][0], lines[i][1]);\n      _line1.closestPointToPoint(plainPoint, true, _v2);\n      const d = _v2.distanceToSquared(sphere.center);\n      if (d < r2) {\n        return {\n          normal: sphere.center.clone().sub(_v2).normalize(),\n          point: _v2.clone(),\n          depth: sphere.radius - Math.sqrt(d)\n        };\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Computes the triangles that potentially intersect with the given bounding sphere.\n   *\n   * @param {Sphere} sphere - The sphere to test.\n   * @param {Array<Triangle>} triangles - The target array that holds the triangles.\n   */\n  getSphereTriangles(sphere, triangles) {\n    for (let i = 0; i < this.subTrees.length; i++) {\n      const subTree = this.subTrees[i];\n      if (!sphere.intersectsBox(subTree.box)) continue;\n      if (subTree.triangles.length > 0) {\n        for (let j = 0; j < subTree.triangles.length; j++) {\n          if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j]);\n        }\n      } else {\n        subTree.getSphereTriangles(sphere, triangles);\n      }\n    }\n  }\n\n  /**\n   * Computes the triangles that potentially intersect with the given capsule.\n   *\n   * @param {Capsule} capsule - The capsule to test.\n   * @param {Array<Triangle>} triangles - The target array that holds the triangles.\n   */\n  getCapsuleTriangles(capsule, triangles) {\n    for (let i = 0; i < this.subTrees.length; i++) {\n      const subTree = this.subTrees[i];\n      if (!capsule.intersectsBox(subTree.box)) continue;\n      if (subTree.triangles.length > 0) {\n        for (let j = 0; j < subTree.triangles.length; j++) {\n          if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j]);\n        }\n      } else {\n        subTree.getCapsuleTriangles(capsule, triangles);\n      }\n    }\n  }\n\n  /**\n   * Performs a bounding sphere intersection test with this Octree.\n   *\n   * @param {Sphere} sphere - The bounding sphere to test.\n   * @return {Object|boolean} The intersection object. If no intersection\n   * is detected, the method returns `false`.\n   */\n  sphereIntersect(sphere) {\n    _sphere.copy(sphere);\n    const triangles = [];\n    let result,\n      hit = false;\n    this.getSphereTriangles(sphere, triangles);\n    for (let i = 0; i < triangles.length; i++) {\n      if (result = this.triangleSphereIntersect(_sphere, triangles[i])) {\n        hit = true;\n        _sphere.center.add(result.normal.multiplyScalar(result.depth));\n      }\n    }\n    if (hit) {\n      const collisionVector = _sphere.center.clone().sub(sphere.center);\n      const depth = collisionVector.length();\n      return {\n        normal: collisionVector.normalize(),\n        depth: depth\n      };\n    }\n    return false;\n  }\n\n  /**\n   * Performs a capsule intersection test with this Octree.\n   *\n   * @param {Capsule} capsule - The capsule to test.\n   * @return {Object|boolean} The intersection object. If no intersection\n   * is detected, the method returns `false`.\n   */\n  capsuleIntersect(capsule) {\n    _capsule.copy(capsule);\n    const triangles = [];\n    let result,\n      hit = false;\n    this.getCapsuleTriangles(_capsule, triangles);\n    for (let i = 0; i < triangles.length; i++) {\n      if (result = this.triangleCapsuleIntersect(_capsule, triangles[i])) {\n        hit = true;\n        _capsule.translate(result.normal.multiplyScalar(result.depth));\n      }\n    }\n    if (hit) {\n      const collisionVector = _capsule.getCenter(new Vector3()).sub(capsule.getCenter(_v1));\n      const depth = collisionVector.length();\n      return {\n        normal: collisionVector.normalize(),\n        depth: depth\n      };\n    }\n    return false;\n  }\n\n  /**\n   * Performs a ray intersection test with this Octree.\n   *\n   * @param {Ray} ray - The ray to test.\n   * @return {Object|boolean} The nearest intersection object. If no intersection\n   * is detected, the method returns `false`.\n   */\n  rayIntersect(ray) {\n    const triangles = [];\n    let triangle,\n      position,\n      distance = 1e100;\n    this.getRayTriangles(ray, triangles);\n    for (let i = 0; i < triangles.length; i++) {\n      const result = ray.intersectTriangle(triangles[i].a, triangles[i].b, triangles[i].c, true, _v1);\n      if (result) {\n        const newdistance = result.sub(ray.origin).length();\n        if (distance > newdistance) {\n          position = result.clone().add(ray.origin);\n          distance = newdistance;\n          triangle = triangles[i];\n        }\n      }\n    }\n    return distance < 1e100 ? {\n      distance: distance,\n      triangle: triangle,\n      position: position\n    } : false;\n  }\n\n  /**\n   * Constructs the Octree from the given 3D object.\n   *\n   * @param {Object3D} group - The scene graph node.\n   * @return {Octree} A reference to this Octree.\n   */\n  fromGraphNode(group) {\n    group.updateWorldMatrix(true, true);\n    group.traverse(obj => {\n      if (obj.isMesh === true) {\n        if (this.layers.test(obj.layers)) {\n          let geometry,\n            isTemp = false;\n          if (obj.geometry.index !== null) {\n            isTemp = true;\n            geometry = obj.geometry.toNonIndexed();\n          } else {\n            geometry = obj.geometry;\n          }\n          const positionAttribute = geometry.getAttribute('position');\n          for (let i = 0; i < positionAttribute.count; i += 3) {\n            const v1 = new Vector3().fromBufferAttribute(positionAttribute, i);\n            const v2 = new Vector3().fromBufferAttribute(positionAttribute, i + 1);\n            const v3 = new Vector3().fromBufferAttribute(positionAttribute, i + 2);\n            v1.applyMatrix4(obj.matrixWorld);\n            v2.applyMatrix4(obj.matrixWorld);\n            v3.applyMatrix4(obj.matrixWorld);\n            this.addTriangle(new Triangle(v1, v2, v3));\n          }\n          if (isTemp) {\n            geometry.dispose();\n          }\n        }\n      }\n    });\n    this.build();\n    return this;\n  }\n\n  /**\n   * Clears the Octree by making it empty.\n   *\n   * @return {Octree} A reference to this Octree.\n   */\n  clear() {\n    this.box = null;\n    this.bounds.makeEmpty();\n    this.subTrees.length = 0;\n    this.triangles.length = 0;\n    return this;\n  }\n}\nexport { Octree };","map":{"version":3,"names":["Box3","Line3","Plane","Sphere","Triangle","Vector3","Layers","Capsule","_v1","_v2","_point1","_point2","_plane","_line1","_line2","_sphere","_capsule","_temp1","_temp2","_temp3","EPS","lineToLineClosestPoints","line1","line2","target1","target2","r","copy","end","sub","start","s","w","a","dot","b","c","d","e","t1","t2","divisor","Math","abs","d1","d2","max","min","multiplyScalar","add","Octree","constructor","box","bounds","layers","trianglesPerLeaf","maxLevel","subTrees","triangles","addTriangle","triangle","x","y","z","push","calcBox","clone","split","level","halfsize","v","set","multiply","pop","i","length","intersectsTriangle","len","build","getRayTriangles","ray","subTree","intersectsBox","j","indexOf","triangleCapsuleIntersect","capsule","getPlane","distanceToPoint","radius","delta","intersectPoint","lerp","containsPoint","normal","point","depth","r2","lines","distanceToSquared","normalize","distanceTo","triangleSphereIntersect","sphere","intersectsPlane","distanceToSphere","plainPoint","projectPoint","center","closestPointToPoint","sqrt","getSphereTriangles","getCapsuleTriangles","sphereIntersect","result","hit","collisionVector","capsuleIntersect","translate","getCenter","rayIntersect","position","distance","intersectTriangle","newdistance","origin","fromGraphNode","group","updateWorldMatrix","traverse","obj","isMesh","test","geometry","isTemp","index","toNonIndexed","positionAttribute","getAttribute","count","v1","fromBufferAttribute","v2","v3","applyMatrix4","matrixWorld","dispose","clear","makeEmpty"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/math/Octree.js"],"sourcesContent":["import {\n\tBox3,\n\tLine3,\n\tPlane,\n\tSphere,\n\tTriangle,\n\tVector3,\n\tLayers\n} from 'three';\nimport { Capsule } from '../math/Capsule.js';\n\n\nconst _v1 = new Vector3();\nconst _v2 = new Vector3();\nconst _point1 = new Vector3();\nconst _point2 = new Vector3();\nconst _plane = new Plane();\nconst _line1 = new Line3();\nconst _line2 = new Line3();\nconst _sphere = new Sphere();\nconst _capsule = new Capsule();\n\nconst _temp1 = new Vector3();\nconst _temp2 = new Vector3();\nconst _temp3 = new Vector3();\nconst EPS = 1e-10;\n\nfunction lineToLineClosestPoints( line1, line2, target1 = null, target2 = null ) {\n\n\tconst r = _temp1.copy( line1.end ).sub( line1.start );\n\tconst s = _temp2.copy( line2.end ).sub( line2.start );\n\tconst w = _temp3.copy( line2.start ).sub( line1.start );\n\n\tconst a = r.dot( s ),\n\t\tb = r.dot( r ),\n\t\tc = s.dot( s ),\n\t\td = s.dot( w ),\n\t\te = r.dot( w );\n\n\tlet t1, t2;\n\tconst divisor = b * c - a * a;\n\n\tif ( Math.abs( divisor ) < EPS ) {\n\n\t\tconst d1 = - d / c;\n\t\tconst d2 = ( a - d ) / c;\n\n\t\tif ( Math.abs( d1 - 0.5 ) < Math.abs( d2 - 0.5 ) ) {\n\n\t\t\tt1 = 0;\n\t\t\tt2 = d1;\n\n\t\t} else {\n\n\t\t\tt1 = 1;\n\t\t\tt2 = d2;\n\n\t\t}\n\n\t} else {\n\n\t\tt1 = ( d * a + e * c ) / divisor;\n\t\tt2 = ( t1 * a - d ) / c;\n\n\t}\n\n\tt2 = Math.max( 0, Math.min( 1, t2 ) );\n\tt1 = Math.max( 0, Math.min( 1, t1 ) );\n\n\tif ( target1 ) {\n\n\t\ttarget1.copy( r ).multiplyScalar( t1 ).add( line1.start );\n\n\t}\n\n\tif ( target2 ) {\n\n\t\ttarget2.copy( s ).multiplyScalar( t2 ).add( line2.start );\n\n\t}\n\n}\n\n/**\n * An octree is a hierarchical tree data structure used to partition a three-dimensional\n * space by recursively subdividing it into eight octants.\n *\n * This particular implementation can have up to sixteen levels and stores up to eight triangles\n * in leaf nodes.\n *\n * `Octree` can be used in games to compute collision between the game world and colliders from\n * the player or other dynamic 3D objects.\n *\n *\n * ```js\n * const octree = new Octree().fromGraphNode( scene );\n * const result = octree.capsuleIntersect( playerCollider ); // collision detection\n * ```\n *\n * @three_import import { Octree } from 'three/addons/math/Octree.js';\n */\nclass Octree {\n\n\t/**\n\t * Constructs a new Octree.\n\t *\n\t * @param {Box3} [box] - The base box with enclose the entire Octree.\n\t */\n\tconstructor( box ) {\n\n\t\t/**\n\t\t * The base box with enclose the entire Octree.\n\t\t *\n\t\t * @type {Box3}\n\t\t */\n\t\tthis.box = box;\n\n\t\t/**\n\t\t * The bounds of the Octree. Compared to {@link Octree#box}, no\n\t\t * margin is applied.\n\t\t *\n\t\t * @type {Box3}\n\t\t */\n\t\tthis.bounds = new Box3();\n\n\t\t/**\n\t\t * Can by used for layers configuration for refine testing.\n\t\t *\n\t\t * @type {Layers}\n\t\t */\n\t\tthis.layers = new Layers();\n\n\t\t/**\n\t\t * The number of triangles a leaf can store before it is split.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 8\n\t\t */\n\t\tthis.trianglesPerLeaf = 8;\n\n\t\t/**\n\t\t * The maximum level of the Octree. It defines the maximum\n\t\t * hierarchical depth of the data structure.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 16\n\t\t */\n\t\tthis.maxLevel = 16;\n\n\t\t// private\n\n\t\tthis.subTrees = [];\n\t\tthis.triangles = [];\n\n\t}\n\n\t/**\n\t * Adds the given triangle to the Octree. The triangle vertices are clamped if they exceed\n\t * the bounds of the Octree.\n\t *\n\t * @param {Triangle} triangle - The triangle to add.\n\t * @return {Octree} A reference to this Octree.\n\t */\n\taddTriangle( triangle ) {\n\n\t\tthis.bounds.min.x = Math.min( this.bounds.min.x, triangle.a.x, triangle.b.x, triangle.c.x );\n\t\tthis.bounds.min.y = Math.min( this.bounds.min.y, triangle.a.y, triangle.b.y, triangle.c.y );\n\t\tthis.bounds.min.z = Math.min( this.bounds.min.z, triangle.a.z, triangle.b.z, triangle.c.z );\n\t\tthis.bounds.max.x = Math.max( this.bounds.max.x, triangle.a.x, triangle.b.x, triangle.c.x );\n\t\tthis.bounds.max.y = Math.max( this.bounds.max.y, triangle.a.y, triangle.b.y, triangle.c.y );\n\t\tthis.bounds.max.z = Math.max( this.bounds.max.z, triangle.a.z, triangle.b.z, triangle.c.z );\n\n\t\tthis.triangles.push( triangle );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Prepares {@link Octree#box} for the build.\n\t *\n\t * @return {Octree} A reference to this Octree.\n\t */\n\tcalcBox() {\n\n\t\tthis.box = this.bounds.clone();\n\n\t\t// offset small amount to account for regular grid\n\t\tthis.box.min.x -= 0.01;\n\t\tthis.box.min.y -= 0.01;\n\t\tthis.box.min.z -= 0.01;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Splits the Octree. This method is used recursively when\n\t * building the Octree.\n\t *\n\t * @param {number} level - The current level.\n\t * @return {Octree} A reference to this Octree.\n\t */\n\tsplit( level ) {\n\n\t\tif ( ! this.box ) return;\n\n\t\tconst subTrees = [];\n\t\tconst halfsize = _v2.copy( this.box.max ).sub( this.box.min ).multiplyScalar( 0.5 );\n\n\t\tfor ( let x = 0; x < 2; x ++ ) {\n\n\t\t\tfor ( let y = 0; y < 2; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z < 2; z ++ ) {\n\n\t\t\t\t\tconst box = new Box3();\n\t\t\t\t\tconst v = _v1.set( x, y, z );\n\n\t\t\t\t\tbox.min.copy( this.box.min ).add( v.multiply( halfsize ) );\n\t\t\t\t\tbox.max.copy( box.min ).add( halfsize );\n\n\t\t\t\t\tsubTrees.push( new Octree( box ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet triangle;\n\n\t\twhile ( triangle = this.triangles.pop() ) {\n\n\t\t\tfor ( let i = 0; i < subTrees.length; i ++ ) {\n\n\t\t\t\tif ( subTrees[ i ].box.intersectsTriangle( triangle ) ) {\n\n\t\t\t\t\tsubTrees[ i ].triangles.push( triangle );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < subTrees.length; i ++ ) {\n\n\t\t\tconst len = subTrees[ i ].triangles.length;\n\n\t\t\tif ( len > this.trianglesPerLeaf && level < this.maxLevel ) {\n\n\t\t\t\tsubTrees[ i ].split( level + 1 );\n\n\t\t\t}\n\n\t\t\tif ( len !== 0 ) {\n\n\t\t\t\tthis.subTrees.push( subTrees[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Builds the Octree.\n\t *\n\t * @return {Octree} A reference to this Octree.\n\t */\n\tbuild() {\n\n\t\tthis.calcBox();\n\t\tthis.split( 0 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes the triangles that potentially intersect with the given ray.\n\t *\n\t * @param {Ray} ray - The ray to test.\n\t * @param {Array<Triangle>} triangles - The target array that holds the triangles.\n\t */\n\tgetRayTriangles( ray, triangles ) {\n\n\t\tfor ( let i = 0; i < this.subTrees.length; i ++ ) {\n\n\t\t\tconst subTree = this.subTrees[ i ];\n\t\t\tif ( ! ray.intersectsBox( subTree.box ) ) continue;\n\n\t\t\tif ( subTree.triangles.length > 0 ) {\n\n\t\t\t\tfor ( let j = 0; j < subTree.triangles.length; j ++ ) {\n\n\t\t\t\t\tif ( triangles.indexOf( subTree.triangles[ j ] ) === - 1 ) triangles.push( subTree.triangles[ j ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tsubTree.getRayTriangles( ray, triangles );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Computes the intersection between the given capsule and triangle.\n\t *\n\t * @param {Capsule} capsule - The capsule to test.\n\t * @param {Triangle} triangle - The triangle to test.\n\t * @return {Object|false} The intersection object. If no intersection\n\t * is detected, the method returns `false`.\n\t */\n\ttriangleCapsuleIntersect( capsule, triangle ) {\n\n\t\ttriangle.getPlane( _plane );\n\n\t\tconst d1 = _plane.distanceToPoint( capsule.start ) - capsule.radius;\n\t\tconst d2 = _plane.distanceToPoint( capsule.end ) - capsule.radius;\n\n\t\tif ( ( d1 > 0 && d2 > 0 ) || ( d1 < - capsule.radius && d2 < - capsule.radius ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst delta = Math.abs( d1 / ( Math.abs( d1 ) + Math.abs( d2 ) ) );\n\t\tconst intersectPoint = _v1.copy( capsule.start ).lerp( capsule.end, delta );\n\n\t\tif ( triangle.containsPoint( intersectPoint ) ) {\n\n\t\t\treturn { normal: _plane.normal.clone(), point: intersectPoint.clone(), depth: Math.abs( Math.min( d1, d2 ) ) };\n\n\t\t}\n\n\t\tconst r2 = capsule.radius * capsule.radius;\n\n\t\tconst line1 = _line1.set( capsule.start, capsule.end );\n\n\t\tconst lines = [\n\t\t\t[ triangle.a, triangle.b ],\n\t\t\t[ triangle.b, triangle.c ],\n\t\t\t[ triangle.c, triangle.a ]\n\t\t];\n\n\t\tfor ( let i = 0; i < lines.length; i ++ ) {\n\n\t\t\tconst line2 = _line2.set( lines[ i ][ 0 ], lines[ i ][ 1 ] );\n\n\t\t\tlineToLineClosestPoints( line1, line2, _point1, _point2 );\n\n\t\t\tif ( _point1.distanceToSquared( _point2 ) < r2 ) {\n\n\t\t\t\treturn {\n\t\t\t\t\tnormal: _point1.clone().sub( _point2 ).normalize(),\n\t\t\t\t\tpoint: _point2.clone(),\n\t\t\t\t\tdepth: capsule.radius - _point1.distanceTo( _point2 )\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Computes the intersection between the given sphere and triangle.\n\t *\n\t * @param {Sphere} sphere - The sphere to test.\n\t * @param {Triangle} triangle - The triangle to test.\n\t * @return {Object|false} The intersection object. If no intersection\n\t * is detected, the method returns `false`.\n\t */\n\ttriangleSphereIntersect( sphere, triangle ) {\n\n\t\ttriangle.getPlane( _plane );\n\n\t\tif ( ! sphere.intersectsPlane( _plane ) ) return false;\n\n\t\tconst depth = Math.abs( _plane.distanceToSphere( sphere ) );\n\t\tconst r2 = sphere.radius * sphere.radius - depth * depth;\n\n\t\tconst plainPoint = _plane.projectPoint( sphere.center, _v1 );\n\n\t\tif ( triangle.containsPoint( sphere.center ) ) {\n\n\t\t\treturn { normal: _plane.normal.clone(), point: plainPoint.clone(), depth: Math.abs( _plane.distanceToSphere( sphere ) ) };\n\n\t\t}\n\n\t\tconst lines = [\n\t\t\t[ triangle.a, triangle.b ],\n\t\t\t[ triangle.b, triangle.c ],\n\t\t\t[ triangle.c, triangle.a ]\n\t\t];\n\n\t\tfor ( let i = 0; i < lines.length; i ++ ) {\n\n\t\t\t_line1.set( lines[ i ][ 0 ], lines[ i ][ 1 ] );\n\t\t\t_line1.closestPointToPoint( plainPoint, true, _v2 );\n\n\t\t\tconst d = _v2.distanceToSquared( sphere.center );\n\n\t\t\tif ( d < r2 ) {\n\n\t\t\t\treturn { normal: sphere.center.clone().sub( _v2 ).normalize(), point: _v2.clone(), depth: sphere.radius - Math.sqrt( d ) };\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Computes the triangles that potentially intersect with the given bounding sphere.\n\t *\n\t * @param {Sphere} sphere - The sphere to test.\n\t * @param {Array<Triangle>} triangles - The target array that holds the triangles.\n\t */\n\tgetSphereTriangles( sphere, triangles ) {\n\n\t\tfor ( let i = 0; i < this.subTrees.length; i ++ ) {\n\n\t\t\tconst subTree = this.subTrees[ i ];\n\n\t\t\tif ( ! sphere.intersectsBox( subTree.box ) ) continue;\n\n\t\t\tif ( subTree.triangles.length > 0 ) {\n\n\t\t\t\tfor ( let j = 0; j < subTree.triangles.length; j ++ ) {\n\n\t\t\t\t\tif ( triangles.indexOf( subTree.triangles[ j ] ) === - 1 ) triangles.push( subTree.triangles[ j ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tsubTree.getSphereTriangles( sphere, triangles );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Computes the triangles that potentially intersect with the given capsule.\n\t *\n\t * @param {Capsule} capsule - The capsule to test.\n\t * @param {Array<Triangle>} triangles - The target array that holds the triangles.\n\t */\n\tgetCapsuleTriangles( capsule, triangles ) {\n\n\t\tfor ( let i = 0; i < this.subTrees.length; i ++ ) {\n\n\t\t\tconst subTree = this.subTrees[ i ];\n\n\t\t\tif ( ! capsule.intersectsBox( subTree.box ) ) continue;\n\n\t\t\tif ( subTree.triangles.length > 0 ) {\n\n\t\t\t\tfor ( let j = 0; j < subTree.triangles.length; j ++ ) {\n\n\t\t\t\t\tif ( triangles.indexOf( subTree.triangles[ j ] ) === - 1 ) triangles.push( subTree.triangles[ j ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tsubTree.getCapsuleTriangles( capsule, triangles );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Performs a bounding sphere intersection test with this Octree.\n\t *\n\t * @param {Sphere} sphere - The bounding sphere to test.\n\t * @return {Object|boolean} The intersection object. If no intersection\n\t * is detected, the method returns `false`.\n\t */\n\tsphereIntersect( sphere ) {\n\n\t\t_sphere.copy( sphere );\n\n\t\tconst triangles = [];\n\t\tlet result, hit = false;\n\n\t\tthis.getSphereTriangles( sphere, triangles );\n\n\t\tfor ( let i = 0; i < triangles.length; i ++ ) {\n\n\t\t\tif ( result = this.triangleSphereIntersect( _sphere, triangles[ i ] ) ) {\n\n\t\t\t\thit = true;\n\n\t\t\t\t_sphere.center.add( result.normal.multiplyScalar( result.depth ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hit ) {\n\n\t\t\tconst collisionVector = _sphere.center.clone().sub( sphere.center );\n\t\t\tconst depth = collisionVector.length();\n\n\t\t\treturn { normal: collisionVector.normalize(), depth: depth };\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Performs a capsule intersection test with this Octree.\n\t *\n\t * @param {Capsule} capsule - The capsule to test.\n\t * @return {Object|boolean} The intersection object. If no intersection\n\t * is detected, the method returns `false`.\n\t */\n\tcapsuleIntersect( capsule ) {\n\n\t\t_capsule.copy( capsule );\n\n\t\tconst triangles = [];\n\t\tlet result, hit = false;\n\n\t\tthis.getCapsuleTriangles( _capsule, triangles );\n\n\t\tfor ( let i = 0; i < triangles.length; i ++ ) {\n\n\t\t\tif ( result = this.triangleCapsuleIntersect( _capsule, triangles[ i ] ) ) {\n\n\t\t\t\thit = true;\n\n\t\t\t\t_capsule.translate( result.normal.multiplyScalar( result.depth ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hit ) {\n\n\t\t\tconst collisionVector = _capsule.getCenter( new Vector3() ).sub( capsule.getCenter( _v1 ) );\n\t\t\tconst depth = collisionVector.length();\n\n\t\t\treturn { normal: collisionVector.normalize(), depth: depth };\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Performs a ray intersection test with this Octree.\n\t *\n\t * @param {Ray} ray - The ray to test.\n\t * @return {Object|boolean} The nearest intersection object. If no intersection\n\t * is detected, the method returns `false`.\n\t */\n\trayIntersect( ray ) {\n\n\t\tconst triangles = [];\n\t\tlet triangle, position, distance = 1e100;\n\n\t\tthis.getRayTriangles( ray, triangles );\n\n\t\tfor ( let i = 0; i < triangles.length; i ++ ) {\n\n\t\t\tconst result = ray.intersectTriangle( triangles[ i ].a, triangles[ i ].b, triangles[ i ].c, true, _v1 );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tconst newdistance = result.sub( ray.origin ).length();\n\n\t\t\t\tif ( distance > newdistance ) {\n\n\t\t\t\t\tposition = result.clone().add( ray.origin );\n\t\t\t\t\tdistance = newdistance;\n\t\t\t\t\ttriangle = triangles[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn distance < 1e100 ? { distance: distance, triangle: triangle, position: position } : false;\n\n\t}\n\n\t/**\n\t * Constructs the Octree from the given 3D object.\n\t *\n\t * @param {Object3D} group - The scene graph node.\n\t * @return {Octree} A reference to this Octree.\n\t */\n\tfromGraphNode( group ) {\n\n\t\tgroup.updateWorldMatrix( true, true );\n\n\t\tgroup.traverse( ( obj ) => {\n\n\t\t\tif ( obj.isMesh === true ) {\n\n\t\t\t\tif ( this.layers.test( obj.layers ) ) {\n\n\t\t\t\t\tlet geometry, isTemp = false;\n\n\t\t\t\t\tif ( obj.geometry.index !== null ) {\n\n\t\t\t\t\t\tisTemp = true;\n\t\t\t\t\t\tgeometry = obj.geometry.toNonIndexed();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgeometry = obj.geometry;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\t\t\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\t\t\t\tconst v1 = new Vector3().fromBufferAttribute( positionAttribute, i );\n\t\t\t\t\t\tconst v2 = new Vector3().fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\t\tconst v3 = new Vector3().fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\t\tv1.applyMatrix4( obj.matrixWorld );\n\t\t\t\t\t\tv2.applyMatrix4( obj.matrixWorld );\n\t\t\t\t\t\tv3.applyMatrix4( obj.matrixWorld );\n\n\t\t\t\t\t\tthis.addTriangle( new Triangle( v1, v2, v3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( isTemp ) {\n\n\t\t\t\t\t\tgeometry.dispose();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.build();\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Clears the Octree by making it empty.\n\t *\n\t * @return {Octree} A reference to this Octree.\n\t */\n\tclear() {\n\n\t\tthis.box = null;\n\t\tthis.bounds.makeEmpty();\n\n\t\tthis.subTrees.length = 0;\n\t\tthis.triangles.length = 0;\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { Octree };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}