{"ast":null,"code":"import { Object3D, Sphere, Box3 } from 'three';\nimport { XRHandMeshModel } from './XRHandMeshModel.js';\nconst TOUCH_RADIUS = 0.01;\nconst POINTING_JOINT = 'index-finger-tip';\n\n/**\n * Represents an Oculus hand model.\n *\n * @augments Object3D\n * @three_import import { OculusHandModel } from 'three/addons/webxr/OculusHandModel.js';\n */\nclass OculusHandModel extends Object3D {\n  /**\n   * Constructs a new Oculus hand model.\n   *\n   * @param {Group} controller - The hand controller.\n   * @param {?Loader} [loader=null] - A loader that is used to load hand models.\n   * @param {?Function} [onLoad=null] - A callback that is executed when a hand model has been loaded.\n   */\n  constructor(controller, loader = null, onLoad = null) {\n    super();\n\n    /**\n     * The hand controller.\n     *\n     * @type {Group}\n     */\n    this.controller = controller;\n\n    /**\n     * The motion controller.\n     *\n     * @type {?MotionController}\n     * @default null\n     */\n    this.motionController = null;\n\n    /**\n     * The model's environment map.\n     *\n     * @type {?Texture}\n     * @default null\n     */\n    this.envMap = null;\n\n    /**\n     * A loader that is used to load hand models.\n     *\n     * @type {?Loader}\n     * @default null\n     */\n    this.loader = loader;\n\n    /**\n     * A callback that is executed when a hand model has been loaded.\n     *\n     * @type {?Function}\n     * @default null\n     */\n    this.onLoad = onLoad;\n\n    /**\n     * The path to the model repository.\n     *\n     * @type {?string}\n     * @default null\n     */\n    this.path = null;\n\n    /**\n     * The model mesh.\n     *\n     * @type {Mesh}\n     * @default null\n     */\n    this.mesh = null;\n    controller.addEventListener('connected', event => {\n      const xrInputSource = event.data;\n      if (xrInputSource.hand && !this.motionController) {\n        this.xrInputSource = xrInputSource;\n        this.motionController = new XRHandMeshModel(this, controller, this.path, xrInputSource.handedness, this.loader, this.onLoad);\n      }\n    });\n    controller.addEventListener('disconnected', () => {\n      this.clear();\n      this.motionController = null;\n    });\n  }\n\n  /**\n   * Overwritten with a custom implementation. Makes sure the motion controller updates the mesh.\n   *\n   * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even\n   * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.\n   */\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n    if (this.motionController) {\n      this.motionController.updateMesh();\n    }\n  }\n\n  /**\n   * Returns the pointer position which is the position of the index finger tip.\n   *\n   * @return {Vector3|null} The pointer position. Returns `null` if not index finger tip joint was found.\n   */\n  getPointerPosition() {\n    const indexFingerTip = this.controller.joints[POINTING_JOINT];\n    if (indexFingerTip) {\n      return indexFingerTip.position;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Returns `true` if the current pointer position (the index finger tip) intersections\n   * with the given box object.\n   *\n   *  @param {Mesh} boxObject - The box object.\n   * @return {boolean} Whether an intersection was found or not.\n   */\n  intersectBoxObject(boxObject) {\n    const pointerPosition = this.getPointerPosition();\n    if (pointerPosition) {\n      const indexSphere = new Sphere(pointerPosition, TOUCH_RADIUS);\n      const box = new Box3().setFromObject(boxObject);\n      return indexSphere.intersectsBox(box);\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Executed actions depending on the interaction state with\n   * the given button.\n   *\n   *  @param {Object} button - The button.\n   */\n  checkButton(button) {\n    if (this.intersectBoxObject(button)) {\n      button.onPress();\n    } else {\n      button.onClear();\n    }\n    if (button.isPressed()) {\n      button.whilePressed();\n    }\n  }\n}\nexport { OculusHandModel };","map":{"version":3,"names":["Object3D","Sphere","Box3","XRHandMeshModel","TOUCH_RADIUS","POINTING_JOINT","OculusHandModel","constructor","controller","loader","onLoad","motionController","envMap","path","mesh","addEventListener","event","xrInputSource","data","hand","handedness","clear","updateMatrixWorld","force","updateMesh","getPointerPosition","indexFingerTip","joints","position","intersectBoxObject","boxObject","pointerPosition","indexSphere","box","setFromObject","intersectsBox","checkButton","button","onPress","onClear","isPressed","whilePressed"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/webxr/OculusHandModel.js"],"sourcesContent":["import { Object3D, Sphere, Box3 } from 'three';\nimport { XRHandMeshModel } from './XRHandMeshModel.js';\n\nconst TOUCH_RADIUS = 0.01;\nconst POINTING_JOINT = 'index-finger-tip';\n\n/**\n * Represents an Oculus hand model.\n *\n * @augments Object3D\n * @three_import import { OculusHandModel } from 'three/addons/webxr/OculusHandModel.js';\n */\nclass OculusHandModel extends Object3D {\n\n\t/**\n\t * Constructs a new Oculus hand model.\n\t *\n\t * @param {Group} controller - The hand controller.\n\t * @param {?Loader} [loader=null] - A loader that is used to load hand models.\n\t * @param {?Function} [onLoad=null] - A callback that is executed when a hand model has been loaded.\n\t */\n\tconstructor( controller, loader = null, onLoad = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The hand controller.\n\t\t *\n\t\t * @type {Group}\n\t\t */\n\t\tthis.controller = controller;\n\n\t\t/**\n\t\t * The motion controller.\n\t\t *\n\t\t * @type {?MotionController}\n\t\t * @default null\n\t\t */\n\t\tthis.motionController = null;\n\n\t\t/**\n\t\t * The model's environment map.\n\t\t *\n\t\t * @type {?Texture}\n\t\t * @default null\n\t\t */\n\t\tthis.envMap = null;\n\n\t\t/**\n\t\t * A loader that is used to load hand models.\n\t\t *\n\t\t * @type {?Loader}\n\t\t * @default null\n\t\t */\n\t\tthis.loader = loader;\n\n\t\t/**\n\t\t * A callback that is executed when a hand model has been loaded.\n\t\t *\n\t\t * @type {?Function}\n\t\t * @default null\n\t\t */\n\t\tthis.onLoad = onLoad;\n\n\t\t/**\n\t\t * The path to the model repository.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.path = null;\n\n\t\t/**\n\t\t * The model mesh.\n\t\t *\n\t\t * @type {Mesh}\n\t\t * @default null\n\t\t */\n\t\tthis.mesh = null;\n\n\t\tcontroller.addEventListener( 'connected', ( event ) => {\n\n\t\t\tconst xrInputSource = event.data;\n\n\t\t\tif ( xrInputSource.hand && ! this.motionController ) {\n\n\t\t\t\tthis.xrInputSource = xrInputSource;\n\n\t\t\t\tthis.motionController = new XRHandMeshModel( this, controller, this.path, xrInputSource.handedness, this.loader, this.onLoad );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tcontroller.addEventListener( 'disconnected', () => {\n\n\t\t\tthis.clear();\n\t\t\tthis.motionController = null;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Overwritten with a custom implementation. Makes sure the motion controller updates the mesh.\n\t *\n\t * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even\n\t * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.\n\t */\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( this.motionController ) {\n\n\t\t\tthis.motionController.updateMesh();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the pointer position which is the position of the index finger tip.\n\t *\n\t * @return {Vector3|null} The pointer position. Returns `null` if not index finger tip joint was found.\n\t */\n\tgetPointerPosition() {\n\n\t\tconst indexFingerTip = this.controller.joints[ POINTING_JOINT ];\n\t\tif ( indexFingerTip ) {\n\n\t\t\treturn indexFingerTip.position;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` if the current pointer position (the index finger tip) intersections\n\t * with the given box object.\n\t *\n\t *  @param {Mesh} boxObject - The box object.\n\t * @return {boolean} Whether an intersection was found or not.\n\t */\n\tintersectBoxObject( boxObject ) {\n\n\t\tconst pointerPosition = this.getPointerPosition();\n\t\tif ( pointerPosition ) {\n\n\t\t\tconst indexSphere = new Sphere( pointerPosition, TOUCH_RADIUS );\n\t\t\tconst box = new Box3().setFromObject( boxObject );\n\t\t\treturn indexSphere.intersectsBox( box );\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Executed actions depending on the interaction state with\n\t * the given button.\n\t *\n\t *  @param {Object} button - The button.\n\t */\n\tcheckButton( button ) {\n\n\t\tif ( this.intersectBoxObject( button ) ) {\n\n\t\t\tbutton.onPress();\n\n\t\t} else {\n\n\t\t\tbutton.onClear();\n\n\t\t}\n\n\t\tif ( button.isPressed() ) {\n\n\t\t\tbutton.whilePressed();\n\n\t\t}\n\n\t}\n\n}\n\nexport { OculusHandModel };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}