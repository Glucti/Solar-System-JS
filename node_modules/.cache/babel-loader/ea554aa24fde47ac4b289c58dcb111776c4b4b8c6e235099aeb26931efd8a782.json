{"ast":null,"code":"import { BufferAttribute, BufferGeometry, ClampToEdgeWrapping, FileLoader, Group, NoColorSpace, Loader, Mesh, MeshPhysicalMaterial, MirroredRepeatWrapping, RepeatWrapping, SRGBColorSpace, TextureLoader, Object3D, Vector2 } from 'three';\nimport * as fflate from '../libs/fflate.module.js';\nclass USDAParser {\n  parse(text) {\n    const data = {};\n    const lines = text.split('\\n');\n    let string = null;\n    let target = data;\n    const stack = [data];\n\n    // debugger;\n\n    for (const line of lines) {\n      // console.log( line );\n\n      if (line.includes('=')) {\n        const assignment = line.split('=');\n        const lhs = assignment[0].trim();\n        const rhs = assignment[1].trim();\n        if (rhs.endsWith('{')) {\n          const group = {};\n          stack.push(group);\n          target[lhs] = group;\n          target = group;\n        } else if (rhs.endsWith('(')) {\n          // see #28631\n\n          const values = rhs.slice(0, -1);\n          target[lhs] = values;\n          const meta = {};\n          stack.push(meta);\n          target = meta;\n        } else {\n          target[lhs] = rhs;\n        }\n      } else if (line.endsWith('{')) {\n        const group = target[string] || {};\n        stack.push(group);\n        target[string] = group;\n        target = group;\n      } else if (line.endsWith('}')) {\n        stack.pop();\n        if (stack.length === 0) continue;\n        target = stack[stack.length - 1];\n      } else if (line.endsWith('(')) {\n        const meta = {};\n        stack.push(meta);\n        string = line.split('(')[0].trim() || string;\n        target[string] = meta;\n        target = meta;\n      } else if (line.endsWith(')')) {\n        stack.pop();\n        target = stack[stack.length - 1];\n      } else {\n        string = line.trim();\n      }\n    }\n    return data;\n  }\n}\n\n/**\n * A loader for the USDZ format.\n *\n * USDZ files that use USDC internally are not yet supported, only USDA.\n *\n * ```js\n * const loader = new USDZLoader();\n * const model = await loader.loadAsync( 'saeukkang.usdz' );\n * scene.add( model );\n * ```\n *\n * @augments Loader\n * @three_import import { USDZLoader } from 'three/addons/loaders/USDZLoader.js';\n */\nclass USDZLoader extends Loader {\n  /**\n   * Constructs a new USDZ loader.\n   *\n   * @param {LoadingManager} [manager] - The loading manager.\n   */\n  constructor(manager) {\n    super(manager);\n  }\n\n  /**\n   * Starts loading from the given URL and passes the loaded USDZ asset\n   * to the `onLoad()` callback.\n   *\n   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n   * @param {function(Group)} onLoad - Executed when the loading process has been finished.\n   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n   * @param {onErrorCallback} onError - Executed when errors occur.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  /**\n   * Parses the given USDZ data and returns the resulting group.\n   *\n   * @param {ArrayBuffer} buffer - The raw USDZ data as an array buffer.\n   * @return {Group} The parsed asset as a group.\n   */\n  parse(buffer) {\n    const parser = new USDAParser();\n    function parseAssets(zip) {\n      const data = {};\n      const loader = new FileLoader();\n      loader.setResponseType('arraybuffer');\n      for (const filename in zip) {\n        if (filename.endsWith('png')) {\n          const blob = new Blob([zip[filename]], {\n            type: 'image/png'\n          });\n          data[filename] = URL.createObjectURL(blob);\n        }\n        if (filename.endsWith('usd') || filename.endsWith('usda')) {\n          if (isCrateFile(zip[filename])) {\n            throw Error('THREE.USDZLoader: Crate files (.usdc or binary .usd) are not supported.');\n          }\n          const text = fflate.strFromU8(zip[filename]);\n          data[filename] = parser.parse(text);\n        }\n      }\n      return data;\n    }\n    function isCrateFile(buffer) {\n      // Check if this a crate file. First 7 bytes of a crate file are \"PXR-USDC\".\n      const fileHeader = buffer.slice(0, 7);\n      const crateHeader = new Uint8Array([0x50, 0x58, 0x52, 0x2D, 0x55, 0x53, 0x44, 0x43]);\n\n      // If this is not a crate file, we assume it is a plain USDA file.\n      return fileHeader.every((value, index) => value === crateHeader[index]);\n    }\n    function findUSD(zip) {\n      if (zip.length < 1) return undefined;\n      const firstFileName = Object.keys(zip)[0];\n      let isCrate = false;\n\n      // As per the USD specification, the first entry in the zip archive is used as the main file (\"UsdStage\").\n      // ASCII files can end in either .usda or .usd.\n      // See https://openusd.org/release/spec_usdz.html#layout\n      if (firstFileName.endsWith('usda')) return zip[firstFileName];\n      if (firstFileName.endsWith('usdc')) {\n        isCrate = true;\n      } else if (firstFileName.endsWith('usd')) {\n        // If this is not a crate file, we assume it is a plain USDA file.\n        if (!isCrateFile(zip[firstFileName])) {\n          return zip[firstFileName];\n        } else {\n          isCrate = true;\n        }\n      }\n      if (isCrate) {\n        throw Error('THREE.USDZLoader: Crate files (.usdc or binary .usd) are not supported.');\n      }\n    }\n    const zip = fflate.unzipSync(new Uint8Array(buffer));\n\n    // console.log( zip );\n\n    const assets = parseAssets(zip);\n\n    // console.log( assets )\n\n    const file = findUSD(zip);\n\n    // Parse file\n\n    const text = fflate.strFromU8(file);\n    const root = parser.parse(text);\n\n    // Build scene\n\n    function findMeshGeometry(data) {\n      if (!data) return undefined;\n      if ('prepend references' in data) {\n        const reference = data['prepend references'];\n        const parts = reference.split('@');\n        const path = parts[1].replace(/^.\\//, '');\n        const id = parts[2].replace(/^<\\//, '').replace(/>$/, '');\n        return findGeometry(assets[path], id);\n      }\n      return findGeometry(data);\n    }\n    function findGeometry(data, id) {\n      if (!data) return undefined;\n      if (id !== undefined) {\n        const def = `def Mesh \"${id}\"`;\n        if (def in data) {\n          return data[def];\n        }\n      }\n      for (const name in data) {\n        const object = data[name];\n        if (name.startsWith('def Mesh')) {\n          return object;\n        }\n        if (typeof object === 'object') {\n          const geometry = findGeometry(object);\n          if (geometry) return geometry;\n        }\n      }\n    }\n    function buildGeometry(data) {\n      if (!data) return undefined;\n      const geometry = new BufferGeometry();\n      let indices = null;\n      let counts = null;\n      let uvs = null;\n      let positionsLength = -1;\n\n      // index\n\n      if ('int[] faceVertexIndices' in data) {\n        indices = JSON.parse(data['int[] faceVertexIndices']);\n      }\n\n      // face count\n\n      if ('int[] faceVertexCounts' in data) {\n        counts = JSON.parse(data['int[] faceVertexCounts']);\n        indices = toTriangleIndices(indices, counts);\n      }\n\n      // position\n\n      if ('point3f[] points' in data) {\n        const positions = JSON.parse(data['point3f[] points'].replace(/[()]*/g, ''));\n        positionsLength = positions.length;\n        let attribute = new BufferAttribute(new Float32Array(positions), 3);\n        if (indices !== null) attribute = toFlatBufferAttribute(attribute, indices);\n        geometry.setAttribute('position', attribute);\n      }\n\n      // uv\n\n      if ('float2[] primvars:st' in data) {\n        data['texCoord2f[] primvars:st'] = data['float2[] primvars:st'];\n      }\n      if ('texCoord2f[] primvars:st' in data) {\n        uvs = JSON.parse(data['texCoord2f[] primvars:st'].replace(/[()]*/g, ''));\n        let attribute = new BufferAttribute(new Float32Array(uvs), 2);\n        if (indices !== null) attribute = toFlatBufferAttribute(attribute, indices);\n        geometry.setAttribute('uv', attribute);\n      }\n      if ('int[] primvars:st:indices' in data && uvs !== null) {\n        // custom uv index, overwrite uvs with new data\n\n        const attribute = new BufferAttribute(new Float32Array(uvs), 2);\n        let indices = JSON.parse(data['int[] primvars:st:indices']);\n        indices = toTriangleIndices(indices, counts);\n        geometry.setAttribute('uv', toFlatBufferAttribute(attribute, indices));\n      }\n\n      // normal\n\n      if ('normal3f[] normals' in data) {\n        const normals = JSON.parse(data['normal3f[] normals'].replace(/[()]*/g, ''));\n        let attribute = new BufferAttribute(new Float32Array(normals), 3);\n\n        // normals require a special treatment in USD\n\n        if (normals.length === positionsLength) {\n          // raw normal and position data have equal length (like produced by USDZExporter)\n\n          if (indices !== null) attribute = toFlatBufferAttribute(attribute, indices);\n        } else {\n          // unequal length, normals are independent of faceVertexIndices\n\n          let indices = Array.from(Array(normals.length / 3).keys()); // [ 0, 1, 2, 3 ... ]\n          indices = toTriangleIndices(indices, counts);\n          attribute = toFlatBufferAttribute(attribute, indices);\n        }\n        geometry.setAttribute('normal', attribute);\n      } else {\n        // compute flat vertex normals\n\n        geometry.computeVertexNormals();\n      }\n      return geometry;\n    }\n    function toTriangleIndices(rawIndices, counts) {\n      const indices = [];\n      for (let i = 0; i < counts.length; i++) {\n        const count = counts[i];\n        const stride = i * count;\n        if (count === 3) {\n          const a = rawIndices[stride + 0];\n          const b = rawIndices[stride + 1];\n          const c = rawIndices[stride + 2];\n          indices.push(a, b, c);\n        } else if (count === 4) {\n          const a = rawIndices[stride + 0];\n          const b = rawIndices[stride + 1];\n          const c = rawIndices[stride + 2];\n          const d = rawIndices[stride + 3];\n          indices.push(a, b, c);\n          indices.push(a, c, d);\n        } else {\n          console.warn('THREE.USDZLoader: Face vertex count of %s unsupported.', count);\n        }\n      }\n      return indices;\n    }\n    function toFlatBufferAttribute(attribute, indices) {\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      const array2 = new array.constructor(indices.length * itemSize);\n      let index = 0,\n        index2 = 0;\n      for (let i = 0, l = indices.length; i < l; i++) {\n        index = indices[i] * itemSize;\n        for (let j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++];\n        }\n      }\n      return new BufferAttribute(array2, itemSize);\n    }\n    function findMeshMaterial(data) {\n      if (!data) return undefined;\n      if ('rel material:binding' in data) {\n        const reference = data['rel material:binding'];\n        const id = reference.replace(/^<\\//, '').replace(/>$/, '');\n        const parts = id.split('/');\n        return findMaterial(root, ` \"${parts[1]}\"`);\n      }\n      return findMaterial(data);\n    }\n    function findMaterial(data, id = '') {\n      for (const name in data) {\n        const object = data[name];\n        if (name.startsWith('def Material' + id)) {\n          return object;\n        }\n        if (typeof object === 'object') {\n          const material = findMaterial(object, id);\n          if (material) return material;\n        }\n      }\n    }\n    function setTextureParams(map, data_value) {\n      // rotation, scale and translation\n\n      if (data_value['float inputs:rotation']) {\n        map.rotation = parseFloat(data_value['float inputs:rotation']);\n      }\n      if (data_value['float2 inputs:scale']) {\n        map.repeat = new Vector2().fromArray(JSON.parse('[' + data_value['float2 inputs:scale'].replace(/[()]*/g, '') + ']'));\n      }\n      if (data_value['float2 inputs:translation']) {\n        map.offset = new Vector2().fromArray(JSON.parse('[' + data_value['float2 inputs:translation'].replace(/[()]*/g, '') + ']'));\n      }\n    }\n    function buildMaterial(data) {\n      const material = new MeshPhysicalMaterial();\n      if (data !== undefined) {\n        const surfaceConnection = data['token outputs:surface.connect'];\n        const surfaceName = /(\\w+).output/.exec(surfaceConnection)[1];\n        const surface = data[`def Shader \"${surfaceName}\"`];\n        if (surface !== undefined) {\n          if ('color3f inputs:diffuseColor.connect' in surface) {\n            const path = surface['color3f inputs:diffuseColor.connect'];\n            const sampler = findTexture(root, /(\\w+).output/.exec(path)[1]);\n            material.map = buildTexture(sampler);\n            material.map.colorSpace = SRGBColorSpace;\n            if ('def Shader \"Transform2d_diffuse\"' in data) {\n              setTextureParams(material.map, data['def Shader \"Transform2d_diffuse\"']);\n            }\n          } else if ('color3f inputs:diffuseColor' in surface) {\n            const color = surface['color3f inputs:diffuseColor'].replace(/[()]*/g, '');\n            material.color.fromArray(JSON.parse('[' + color + ']'));\n          }\n          if ('color3f inputs:emissiveColor.connect' in surface) {\n            const path = surface['color3f inputs:emissiveColor.connect'];\n            const sampler = findTexture(root, /(\\w+).output/.exec(path)[1]);\n            material.emissiveMap = buildTexture(sampler);\n            material.emissiveMap.colorSpace = SRGBColorSpace;\n            material.emissive.set(0xffffff);\n            if ('def Shader \"Transform2d_emissive\"' in data) {\n              setTextureParams(material.emissiveMap, data['def Shader \"Transform2d_emissive\"']);\n            }\n          } else if ('color3f inputs:emissiveColor' in surface) {\n            const color = surface['color3f inputs:emissiveColor'].replace(/[()]*/g, '');\n            material.emissive.fromArray(JSON.parse('[' + color + ']'));\n          }\n          if ('normal3f inputs:normal.connect' in surface) {\n            const path = surface['normal3f inputs:normal.connect'];\n            const sampler = findTexture(root, /(\\w+).output/.exec(path)[1]);\n            material.normalMap = buildTexture(sampler);\n            material.normalMap.colorSpace = NoColorSpace;\n            if ('def Shader \"Transform2d_normal\"' in data) {\n              setTextureParams(material.normalMap, data['def Shader \"Transform2d_normal\"']);\n            }\n          }\n          if ('float inputs:roughness.connect' in surface) {\n            const path = surface['float inputs:roughness.connect'];\n            const sampler = findTexture(root, /(\\w+).output/.exec(path)[1]);\n            material.roughness = 1.0;\n            material.roughnessMap = buildTexture(sampler);\n            material.roughnessMap.colorSpace = NoColorSpace;\n            if ('def Shader \"Transform2d_roughness\"' in data) {\n              setTextureParams(material.roughnessMap, data['def Shader \"Transform2d_roughness\"']);\n            }\n          } else if ('float inputs:roughness' in surface) {\n            material.roughness = parseFloat(surface['float inputs:roughness']);\n          }\n          if ('float inputs:metallic.connect' in surface) {\n            const path = surface['float inputs:metallic.connect'];\n            const sampler = findTexture(root, /(\\w+).output/.exec(path)[1]);\n            material.metalness = 1.0;\n            material.metalnessMap = buildTexture(sampler);\n            material.metalnessMap.colorSpace = NoColorSpace;\n            if ('def Shader \"Transform2d_metallic\"' in data) {\n              setTextureParams(material.metalnessMap, data['def Shader \"Transform2d_metallic\"']);\n            }\n          } else if ('float inputs:metallic' in surface) {\n            material.metalness = parseFloat(surface['float inputs:metallic']);\n          }\n          if ('float inputs:clearcoat.connect' in surface) {\n            const path = surface['float inputs:clearcoat.connect'];\n            const sampler = findTexture(root, /(\\w+).output/.exec(path)[1]);\n            material.clearcoat = 1.0;\n            material.clearcoatMap = buildTexture(sampler);\n            material.clearcoatMap.colorSpace = NoColorSpace;\n            if ('def Shader \"Transform2d_clearcoat\"' in data) {\n              setTextureParams(material.clearcoatMap, data['def Shader \"Transform2d_clearcoat\"']);\n            }\n          } else if ('float inputs:clearcoat' in surface) {\n            material.clearcoat = parseFloat(surface['float inputs:clearcoat']);\n          }\n          if ('float inputs:clearcoatRoughness.connect' in surface) {\n            const path = surface['float inputs:clearcoatRoughness.connect'];\n            const sampler = findTexture(root, /(\\w+).output/.exec(path)[1]);\n            material.clearcoatRoughness = 1.0;\n            material.clearcoatRoughnessMap = buildTexture(sampler);\n            material.clearcoatRoughnessMap.colorSpace = NoColorSpace;\n            if ('def Shader \"Transform2d_clearcoatRoughness\"' in data) {\n              setTextureParams(material.clearcoatRoughnessMap, data['def Shader \"Transform2d_clearcoatRoughness\"']);\n            }\n          } else if ('float inputs:clearcoatRoughness' in surface) {\n            material.clearcoatRoughness = parseFloat(surface['float inputs:clearcoatRoughness']);\n          }\n          if ('float inputs:ior' in surface) {\n            material.ior = parseFloat(surface['float inputs:ior']);\n          }\n          if ('float inputs:occlusion.connect' in surface) {\n            const path = surface['float inputs:occlusion.connect'];\n            const sampler = findTexture(root, /(\\w+).output/.exec(path)[1]);\n            material.aoMap = buildTexture(sampler);\n            material.aoMap.colorSpace = NoColorSpace;\n            if ('def Shader \"Transform2d_occlusion\"' in data) {\n              setTextureParams(material.aoMap, data['def Shader \"Transform2d_occlusion\"']);\n            }\n          }\n        }\n      }\n      return material;\n    }\n    function findTexture(data, id) {\n      for (const name in data) {\n        const object = data[name];\n        if (name.startsWith(`def Shader \"${id}\"`)) {\n          return object;\n        }\n        if (typeof object === 'object') {\n          const texture = findTexture(object, id);\n          if (texture) return texture;\n        }\n      }\n    }\n    function buildTexture(data) {\n      if ('asset inputs:file' in data) {\n        const path = data['asset inputs:file'].replace(/@*/g, '').trim();\n        const loader = new TextureLoader();\n        const texture = loader.load(assets[path]);\n        const map = {\n          '\"clamp\"': ClampToEdgeWrapping,\n          '\"mirror\"': MirroredRepeatWrapping,\n          '\"repeat\"': RepeatWrapping\n        };\n        if ('token inputs:wrapS' in data) {\n          texture.wrapS = map[data['token inputs:wrapS']];\n        }\n        if ('token inputs:wrapT' in data) {\n          texture.wrapT = map[data['token inputs:wrapT']];\n        }\n        return texture;\n      }\n      return null;\n    }\n    function buildObject(data) {\n      const geometry = buildGeometry(findMeshGeometry(data));\n      const material = buildMaterial(findMeshMaterial(data));\n      const mesh = geometry ? new Mesh(geometry, material) : new Object3D();\n      if ('matrix4d xformOp:transform' in data) {\n        const array = JSON.parse('[' + data['matrix4d xformOp:transform'].replace(/[()]*/g, '') + ']');\n        mesh.matrix.fromArray(array);\n        mesh.matrix.decompose(mesh.position, mesh.quaternion, mesh.scale);\n      }\n      return mesh;\n    }\n    function buildHierarchy(data, group) {\n      for (const name in data) {\n        if (name.startsWith('def Scope')) {\n          buildHierarchy(data[name], group);\n        } else if (name.startsWith('def Xform')) {\n          const mesh = buildObject(data[name]);\n          if (/def Xform \"(\\w+)\"/.test(name)) {\n            mesh.name = /def Xform \"(\\w+)\"/.exec(name)[1];\n          }\n          group.add(mesh);\n          buildHierarchy(data[name], mesh);\n        }\n      }\n    }\n    const group = new Group();\n    buildHierarchy(root, group);\n    return group;\n  }\n}\nexport { USDZLoader };","map":{"version":3,"names":["BufferAttribute","BufferGeometry","ClampToEdgeWrapping","FileLoader","Group","NoColorSpace","Loader","Mesh","MeshPhysicalMaterial","MirroredRepeatWrapping","RepeatWrapping","SRGBColorSpace","TextureLoader","Object3D","Vector2","fflate","USDAParser","parse","text","data","lines","split","string","target","stack","line","includes","assignment","lhs","trim","rhs","endsWith","group","push","values","slice","meta","pop","length","USDZLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","e","console","error","itemError","buffer","parser","parseAssets","zip","filename","blob","Blob","type","URL","createObjectURL","isCrateFile","Error","strFromU8","fileHeader","crateHeader","Uint8Array","every","value","index","findUSD","undefined","firstFileName","Object","keys","isCrate","unzipSync","assets","file","root","findMeshGeometry","reference","parts","replace","id","findGeometry","def","name","object","startsWith","geometry","buildGeometry","indices","counts","uvs","positionsLength","JSON","toTriangleIndices","positions","attribute","Float32Array","toFlatBufferAttribute","setAttribute","normals","Array","from","computeVertexNormals","rawIndices","i","count","stride","a","b","c","d","warn","array","itemSize","array2","index2","l","j","findMeshMaterial","findMaterial","material","setTextureParams","map","data_value","rotation","parseFloat","repeat","fromArray","offset","buildMaterial","surfaceConnection","surfaceName","exec","surface","sampler","findTexture","buildTexture","colorSpace","color","emissiveMap","emissive","set","normalMap","roughness","roughnessMap","metalness","metalnessMap","clearcoat","clearcoatMap","clearcoatRoughness","clearcoatRoughnessMap","ior","aoMap","texture","wrapS","wrapT","buildObject","mesh","matrix","decompose","position","quaternion","scale","buildHierarchy","test","add"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/loaders/USDZLoader.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tFileLoader,\n\tGroup,\n\tNoColorSpace,\n\tLoader,\n\tMesh,\n\tMeshPhysicalMaterial,\n\tMirroredRepeatWrapping,\n\tRepeatWrapping,\n\tSRGBColorSpace,\n\tTextureLoader,\n\tObject3D,\n\tVector2\n} from 'three';\n\nimport * as fflate from '../libs/fflate.module.js';\n\nclass USDAParser {\n\n\tparse( text ) {\n\n\t\tconst data = {};\n\n\t\tconst lines = text.split( '\\n' );\n\n\t\tlet string = null;\n\t\tlet target = data;\n\n\t\tconst stack = [ data ];\n\n\t\t// debugger;\n\n\t\tfor ( const line of lines ) {\n\n\t\t\t// console.log( line );\n\n\t\t\tif ( line.includes( '=' ) ) {\n\n\t\t\t\tconst assignment = line.split( '=' );\n\n\t\t\t\tconst lhs = assignment[ 0 ].trim();\n\t\t\t\tconst rhs = assignment[ 1 ].trim();\n\n\t\t\t\tif ( rhs.endsWith( '{' ) ) {\n\n\t\t\t\t\tconst group = {};\n\t\t\t\t\tstack.push( group );\n\n\t\t\t\t\ttarget[ lhs ] = group;\n\t\t\t\t\ttarget = group;\n\n\t\t\t\t} else if ( rhs.endsWith( '(' ) ) {\n\n\t\t\t\t\t// see #28631\n\n\t\t\t\t\tconst values = rhs.slice( 0, - 1 );\n\t\t\t\t\ttarget[ lhs ] = values;\n\n\t\t\t\t\tconst meta = {};\n\t\t\t\t\tstack.push( meta );\n\n\t\t\t\t\ttarget = meta;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget[ lhs ] = rhs;\n\n\t\t\t\t}\n\n\t\t\t} else if ( line.endsWith( '{' ) ) {\n\n\t\t\t\tconst group = target[ string ] || {};\n\t\t\t\tstack.push( group );\n\n\t\t\t\ttarget[ string ] = group;\n\t\t\t\ttarget = group;\n\n\t\t\t} else if ( line.endsWith( '}' ) ) {\n\n\t\t\t\tstack.pop();\n\n\t\t\t\tif ( stack.length === 0 ) continue;\n\n\t\t\t\ttarget = stack[ stack.length - 1 ];\n\n\t\t\t} else if ( line.endsWith( '(' ) ) {\n\n\t\t\t\tconst meta = {};\n\t\t\t\tstack.push( meta );\n\n\t\t\t\tstring = line.split( '(' )[ 0 ].trim() || string;\n\n\t\t\t\ttarget[ string ] = meta;\n\t\t\t\ttarget = meta;\n\n\t\t\t} else if ( line.endsWith( ')' ) ) {\n\n\t\t\t\tstack.pop();\n\n\t\t\t\ttarget = stack[ stack.length - 1 ];\n\n\t\t\t} else {\n\n\t\t\t\tstring = line.trim();\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\n/**\n * A loader for the USDZ format.\n *\n * USDZ files that use USDC internally are not yet supported, only USDA.\n *\n * ```js\n * const loader = new USDZLoader();\n * const model = await loader.loadAsync( 'saeukkang.usdz' );\n * scene.add( model );\n * ```\n *\n * @augments Loader\n * @three_import import { USDZLoader } from 'three/addons/loaders/USDZLoader.js';\n */\nclass USDZLoader extends Loader {\n\n\t/**\n\t * Constructs a new USDZ loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded USDZ asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(Group)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given USDZ data and returns the resulting group.\n\t *\n\t * @param {ArrayBuffer} buffer - The raw USDZ data as an array buffer.\n\t * @return {Group} The parsed asset as a group.\n\t */\n\tparse( buffer ) {\n\n\t\tconst parser = new USDAParser();\n\n\t\tfunction parseAssets( zip ) {\n\n\t\t\tconst data = {};\n\t\t\tconst loader = new FileLoader();\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\tfor ( const filename in zip ) {\n\n\t\t\t\tif ( filename.endsWith( 'png' ) ) {\n\n\t\t\t\t\tconst blob = new Blob( [ zip[ filename ] ], { type: 'image/png' } );\n\t\t\t\t\tdata[ filename ] = URL.createObjectURL( blob );\n\n\t\t\t\t}\n\n\t\t\t\tif ( filename.endsWith( 'usd' ) || filename.endsWith( 'usda' ) ) {\n\n\t\t\t\t\tif ( isCrateFile( zip[ filename ] ) ) {\n\n\t\t\t\t\t\tthrow Error( 'THREE.USDZLoader: Crate files (.usdc or binary .usd) are not supported.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst text = fflate.strFromU8( zip[ filename ] );\n\t\t\t\t\tdata[ filename ] = parser.parse( text );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction isCrateFile( buffer ) {\n\n\t\t\t// Check if this a crate file. First 7 bytes of a crate file are \"PXR-USDC\".\n\t\t\tconst fileHeader = buffer.slice( 0, 7 );\n\t\t\tconst crateHeader = new Uint8Array( [ 0x50, 0x58, 0x52, 0x2D, 0x55, 0x53, 0x44, 0x43 ] );\n\n\t\t\t// If this is not a crate file, we assume it is a plain USDA file.\n\t\t\treturn fileHeader.every( ( value, index ) => value === crateHeader[ index ] );\n\n\t\t}\n\n\t\tfunction findUSD( zip ) {\n\n\t\t\tif ( zip.length < 1 ) return undefined;\n\n\t\t\tconst firstFileName = Object.keys( zip )[ 0 ];\n\t\t\tlet isCrate = false;\n\n\t\t\t// As per the USD specification, the first entry in the zip archive is used as the main file (\"UsdStage\").\n\t\t\t// ASCII files can end in either .usda or .usd.\n\t\t\t// See https://openusd.org/release/spec_usdz.html#layout\n\t\t\tif ( firstFileName.endsWith( 'usda' ) ) return zip[ firstFileName ];\n\n\t\t\tif ( firstFileName.endsWith( 'usdc' ) ) {\n\n\t\t\t\tisCrate = true;\n\n\t\t\t} else if ( firstFileName.endsWith( 'usd' ) ) {\n\n\t\t\t\t// If this is not a crate file, we assume it is a plain USDA file.\n\t\t\t\tif ( ! isCrateFile( zip[ firstFileName ] ) ) {\n\n\t\t\t\t\treturn zip[ firstFileName ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tisCrate = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( isCrate ) {\n\n\t\t\t\tthrow Error( 'THREE.USDZLoader: Crate files (.usdc or binary .usd) are not supported.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst zip = fflate.unzipSync( new Uint8Array( buffer ) );\n\n\t\t// console.log( zip );\n\n\t\tconst assets = parseAssets( zip );\n\n\t\t// console.log( assets )\n\n\t\tconst file = findUSD( zip );\n\n\t\t// Parse file\n\n\t\tconst text = fflate.strFromU8( file );\n\t\tconst root = parser.parse( text );\n\n\t\t// Build scene\n\n\t\tfunction findMeshGeometry( data ) {\n\n\t\t\tif ( ! data ) return undefined;\n\n\t\t\tif ( 'prepend references' in data ) {\n\n\t\t\t\tconst reference = data[ 'prepend references' ];\n\t\t\t\tconst parts = reference.split( '@' );\n\t\t\t\tconst path = parts[ 1 ].replace( /^.\\//, '' );\n\t\t\t\tconst id = parts[ 2 ].replace( /^<\\//, '' ).replace( />$/, '' );\n\n\t\t\t\treturn findGeometry( assets[ path ], id );\n\n\t\t\t}\n\n\t\t\treturn findGeometry( data );\n\n\t\t}\n\n\t\tfunction findGeometry( data, id ) {\n\n\t\t\tif ( ! data ) return undefined;\n\n\t\t\tif ( id !== undefined ) {\n\n\t\t\t\tconst def = `def Mesh \"${id}\"`;\n\n\t\t\t\tif ( def in data ) {\n\n\t\t\t\t\treturn data[ def ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( const name in data ) {\n\n\t\t\t\tconst object = data[ name ];\n\n\t\t\t\tif ( name.startsWith( 'def Mesh' ) ) {\n\n\t\t\t\t\treturn object;\n\n\t\t\t\t}\n\n\n\t\t\t\tif ( typeof object === 'object' ) {\n\n\t\t\t\t\tconst geometry = findGeometry( object );\n\n\t\t\t\t\tif ( geometry ) return geometry;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildGeometry( data ) {\n\n\t\t\tif ( ! data ) return undefined;\n\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tlet indices = null;\n\t\t\tlet counts = null;\n\t\t\tlet uvs = null;\n\n\t\t\tlet positionsLength = - 1;\n\n\t\t\t// index\n\n\t\t\tif ( 'int[] faceVertexIndices' in data ) {\n\n\t\t\t\tindices = JSON.parse( data[ 'int[] faceVertexIndices' ] );\n\n\t\t\t}\n\n\t\t\t// face count\n\n\t\t\tif ( 'int[] faceVertexCounts' in data ) {\n\n\t\t\t\tcounts = JSON.parse( data[ 'int[] faceVertexCounts' ] );\n\t\t\t\tindices = toTriangleIndices( indices, counts );\n\n\t\t\t}\n\n\t\t\t// position\n\n\t\t\tif ( 'point3f[] points' in data ) {\n\n\t\t\t\tconst positions = JSON.parse( data[ 'point3f[] points' ].replace( /[()]*/g, '' ) );\n\t\t\t\tpositionsLength = positions.length;\n\t\t\t\tlet attribute = new BufferAttribute( new Float32Array( positions ), 3 );\n\n\t\t\t\tif ( indices !== null ) attribute = toFlatBufferAttribute( attribute, indices );\n\n\t\t\t\tgeometry.setAttribute( 'position', attribute );\n\n\t\t\t}\n\n\t\t\t// uv\n\n\t\t\tif ( 'float2[] primvars:st' in data ) {\n\n\t\t\t\tdata[ 'texCoord2f[] primvars:st' ] = data[ 'float2[] primvars:st' ];\n\n\t\t\t}\n\n\t\t\tif ( 'texCoord2f[] primvars:st' in data ) {\n\n\t\t\t\tuvs = JSON.parse( data[ 'texCoord2f[] primvars:st' ].replace( /[()]*/g, '' ) );\n\t\t\t\tlet attribute = new BufferAttribute( new Float32Array( uvs ), 2 );\n\n\t\t\t\tif ( indices !== null ) attribute = toFlatBufferAttribute( attribute, indices );\n\n\t\t\t\tgeometry.setAttribute( 'uv', attribute );\n\n\t\t\t}\n\n\t\t\tif ( 'int[] primvars:st:indices' in data && uvs !== null ) {\n\n\t\t\t\t// custom uv index, overwrite uvs with new data\n\n\t\t\t\tconst attribute = new BufferAttribute( new Float32Array( uvs ), 2 );\n\t\t\t\tlet indices = JSON.parse( data[ 'int[] primvars:st:indices' ] );\n\t\t\t\tindices = toTriangleIndices( indices, counts );\n\t\t\t\tgeometry.setAttribute( 'uv', toFlatBufferAttribute( attribute, indices ) );\n\n\t\t\t}\n\n\t\t\t// normal\n\n\t\t\tif ( 'normal3f[] normals' in data ) {\n\n\t\t\t\tconst normals = JSON.parse( data[ 'normal3f[] normals' ].replace( /[()]*/g, '' ) );\n\t\t\t\tlet attribute = new BufferAttribute( new Float32Array( normals ), 3 );\n\n\t\t\t\t// normals require a special treatment in USD\n\n\t\t\t\tif ( normals.length === positionsLength ) {\n\n\t\t\t\t\t// raw normal and position data have equal length (like produced by USDZExporter)\n\n\t\t\t\t\tif ( indices !== null ) attribute = toFlatBufferAttribute( attribute, indices );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// unequal length, normals are independent of faceVertexIndices\n\n\t\t\t\t\tlet indices = Array.from( Array( normals.length / 3 ).keys() ); // [ 0, 1, 2, 3 ... ]\n\t\t\t\t\tindices = toTriangleIndices( indices, counts );\n\t\t\t\t\tattribute = toFlatBufferAttribute( attribute, indices );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'normal', attribute );\n\n\t\t\t} else {\n\n\t\t\t\t// compute flat vertex normals\n\n\t\t\t\tgeometry.computeVertexNormals();\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction toTriangleIndices( rawIndices, counts ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tfor ( let i = 0; i < counts.length; i ++ ) {\n\n\t\t\t\tconst count = counts[ i ];\n\n\t\t\t\tconst stride = i * count;\n\n\t\t\t\tif ( count === 3 ) {\n\n\t\t\t\t\tconst a = rawIndices[ stride + 0 ];\n\t\t\t\t\tconst b = rawIndices[ stride + 1 ];\n\t\t\t\t\tconst c = rawIndices[ stride + 2 ];\n\n\t\t\t\t\tindices.push( a, b, c );\n\n\t\t\t\t} else if ( count === 4 ) {\n\n\t\t\t\t\tconst a = rawIndices[ stride + 0 ];\n\t\t\t\t\tconst b = rawIndices[ stride + 1 ];\n\t\t\t\t\tconst c = rawIndices[ stride + 2 ];\n\t\t\t\t\tconst d = rawIndices[ stride + 3 ];\n\n\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\tindices.push( a, c, d );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.USDZLoader: Face vertex count of %s unsupported.', count );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn indices;\n\n\t\t}\n\n\t\tfunction toFlatBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize );\n\n\t\t}\n\n\t\tfunction findMeshMaterial( data ) {\n\n\t\t\tif ( ! data ) return undefined;\n\n\t\t\tif ( 'rel material:binding' in data ) {\n\n\t\t\t\tconst reference = data[ 'rel material:binding' ];\n\t\t\t\tconst id = reference.replace( /^<\\//, '' ).replace( />$/, '' );\n\t\t\t\tconst parts = id.split( '/' );\n\n\t\t\t\treturn findMaterial( root, ` \"${ parts[ 1 ] }\"` );\n\n\t\t\t}\n\n\t\t\treturn findMaterial( data );\n\n\t\t}\n\n\t\tfunction findMaterial( data, id = '' ) {\n\n\t\t\tfor ( const name in data ) {\n\n\t\t\t\tconst object = data[ name ];\n\n\t\t\t\tif ( name.startsWith( 'def Material' + id ) ) {\n\n\t\t\t\t\treturn object;\n\n\t\t\t\t}\n\n\t\t\t\tif ( typeof object === 'object' ) {\n\n\t\t\t\t\tconst material = findMaterial( object, id );\n\n\t\t\t\t\tif ( material ) return material;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setTextureParams( map, data_value ) {\n\n\t\t\t// rotation, scale and translation\n\n\t\t\tif ( data_value[ 'float inputs:rotation' ] ) {\n\n\t\t\t\tmap.rotation = parseFloat( data_value[ 'float inputs:rotation' ] );\n\n\t\t\t}\n\n\t\t\tif ( data_value[ 'float2 inputs:scale' ] ) {\n\n\t\t\t\tmap.repeat = new Vector2().fromArray( JSON.parse( '[' + data_value[ 'float2 inputs:scale' ].replace( /[()]*/g, '' ) + ']' ) );\n\n\t\t\t}\n\n\t\t\tif ( data_value[ 'float2 inputs:translation' ] ) {\n\n\t\t\t\tmap.offset = new Vector2().fromArray( JSON.parse( '[' + data_value[ 'float2 inputs:translation' ].replace( /[()]*/g, '' ) + ']' ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildMaterial( data ) {\n\n\t\t\tconst material = new MeshPhysicalMaterial();\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\tconst surfaceConnection = data[ 'token outputs:surface.connect' ];\n\t\t\t\tconst surfaceName = /(\\w+).output/.exec( surfaceConnection )[ 1 ];\n\t\t\t\tconst surface = data[ `def Shader \"${surfaceName}\"` ];\n\n\t\t\t\tif ( surface !== undefined ) {\n\n\t\t\t\t\tif ( 'color3f inputs:diffuseColor.connect' in surface ) {\n\n\t\t\t\t\t\tconst path = surface[ 'color3f inputs:diffuseColor.connect' ];\n\t\t\t\t\t\tconst sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] );\n\n\t\t\t\t\t\tmaterial.map = buildTexture( sampler );\n\t\t\t\t\t\tmaterial.map.colorSpace = SRGBColorSpace;\n\n\t\t\t\t\t\tif ( 'def Shader \"Transform2d_diffuse\"' in data ) {\n\n\t\t\t\t\t\t\tsetTextureParams( material.map, data[ 'def Shader \"Transform2d_diffuse\"' ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( 'color3f inputs:diffuseColor' in surface ) {\n\n\t\t\t\t\t\tconst color = surface[ 'color3f inputs:diffuseColor' ].replace( /[()]*/g, '' );\n\t\t\t\t\t\tmaterial.color.fromArray( JSON.parse( '[' + color + ']' ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'color3f inputs:emissiveColor.connect' in surface ) {\n\n\t\t\t\t\t\tconst path = surface[ 'color3f inputs:emissiveColor.connect' ];\n\t\t\t\t\t\tconst sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] );\n\n\t\t\t\t\t\tmaterial.emissiveMap = buildTexture( sampler );\n\t\t\t\t\t\tmaterial.emissiveMap.colorSpace = SRGBColorSpace;\n\t\t\t\t\t\tmaterial.emissive.set( 0xffffff );\n\n\t\t\t\t\t\tif ( 'def Shader \"Transform2d_emissive\"' in data ) {\n\n\t\t\t\t\t\t\tsetTextureParams( material.emissiveMap, data[ 'def Shader \"Transform2d_emissive\"' ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( 'color3f inputs:emissiveColor' in surface ) {\n\n\t\t\t\t\t\tconst color = surface[ 'color3f inputs:emissiveColor' ].replace( /[()]*/g, '' );\n\t\t\t\t\t\tmaterial.emissive.fromArray( JSON.parse( '[' + color + ']' ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'normal3f inputs:normal.connect' in surface ) {\n\n\t\t\t\t\t\tconst path = surface[ 'normal3f inputs:normal.connect' ];\n\t\t\t\t\t\tconst sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] );\n\n\t\t\t\t\t\tmaterial.normalMap = buildTexture( sampler );\n\t\t\t\t\t\tmaterial.normalMap.colorSpace = NoColorSpace;\n\n\t\t\t\t\t\tif ( 'def Shader \"Transform2d_normal\"' in data ) {\n\n\t\t\t\t\t\t\tsetTextureParams( material.normalMap, data[ 'def Shader \"Transform2d_normal\"' ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'float inputs:roughness.connect' in surface ) {\n\n\t\t\t\t\t\tconst path = surface[ 'float inputs:roughness.connect' ];\n\t\t\t\t\t\tconst sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] );\n\n\t\t\t\t\t\tmaterial.roughness = 1.0;\n\t\t\t\t\t\tmaterial.roughnessMap = buildTexture( sampler );\n\t\t\t\t\t\tmaterial.roughnessMap.colorSpace = NoColorSpace;\n\n\t\t\t\t\t\tif ( 'def Shader \"Transform2d_roughness\"' in data ) {\n\n\t\t\t\t\t\t\tsetTextureParams( material.roughnessMap, data[ 'def Shader \"Transform2d_roughness\"' ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( 'float inputs:roughness' in surface ) {\n\n\t\t\t\t\t\tmaterial.roughness = parseFloat( surface[ 'float inputs:roughness' ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'float inputs:metallic.connect' in surface ) {\n\n\t\t\t\t\t\tconst path = surface[ 'float inputs:metallic.connect' ];\n\t\t\t\t\t\tconst sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] );\n\n\t\t\t\t\t\tmaterial.metalness = 1.0;\n\t\t\t\t\t\tmaterial.metalnessMap = buildTexture( sampler );\n\t\t\t\t\t\tmaterial.metalnessMap.colorSpace = NoColorSpace;\n\n\t\t\t\t\t\tif ( 'def Shader \"Transform2d_metallic\"' in data ) {\n\n\t\t\t\t\t\t\tsetTextureParams( material.metalnessMap, data[ 'def Shader \"Transform2d_metallic\"' ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( 'float inputs:metallic' in surface ) {\n\n\t\t\t\t\t\tmaterial.metalness = parseFloat( surface[ 'float inputs:metallic' ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'float inputs:clearcoat.connect' in surface ) {\n\n\t\t\t\t\t\tconst path = surface[ 'float inputs:clearcoat.connect' ];\n\t\t\t\t\t\tconst sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] );\n\n\t\t\t\t\t\tmaterial.clearcoat = 1.0;\n\t\t\t\t\t\tmaterial.clearcoatMap = buildTexture( sampler );\n\t\t\t\t\t\tmaterial.clearcoatMap.colorSpace = NoColorSpace;\n\n\t\t\t\t\t\tif ( 'def Shader \"Transform2d_clearcoat\"' in data ) {\n\n\t\t\t\t\t\t\tsetTextureParams( material.clearcoatMap, data[ 'def Shader \"Transform2d_clearcoat\"' ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( 'float inputs:clearcoat' in surface ) {\n\n\t\t\t\t\t\tmaterial.clearcoat = parseFloat( surface[ 'float inputs:clearcoat' ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'float inputs:clearcoatRoughness.connect' in surface ) {\n\n\t\t\t\t\t\tconst path = surface[ 'float inputs:clearcoatRoughness.connect' ];\n\t\t\t\t\t\tconst sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] );\n\n\t\t\t\t\t\tmaterial.clearcoatRoughness = 1.0;\n\t\t\t\t\t\tmaterial.clearcoatRoughnessMap = buildTexture( sampler );\n\t\t\t\t\t\tmaterial.clearcoatRoughnessMap.colorSpace = NoColorSpace;\n\n\t\t\t\t\t\tif ( 'def Shader \"Transform2d_clearcoatRoughness\"' in data ) {\n\n\t\t\t\t\t\t\tsetTextureParams( material.clearcoatRoughnessMap, data[ 'def Shader \"Transform2d_clearcoatRoughness\"' ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( 'float inputs:clearcoatRoughness' in surface ) {\n\n\t\t\t\t\t\tmaterial.clearcoatRoughness = parseFloat( surface[ 'float inputs:clearcoatRoughness' ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'float inputs:ior' in surface ) {\n\n\t\t\t\t\t\tmaterial.ior = parseFloat( surface[ 'float inputs:ior' ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'float inputs:occlusion.connect' in surface ) {\n\n\t\t\t\t\t\tconst path = surface[ 'float inputs:occlusion.connect' ];\n\t\t\t\t\t\tconst sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] );\n\n\t\t\t\t\t\tmaterial.aoMap = buildTexture( sampler );\n\t\t\t\t\t\tmaterial.aoMap.colorSpace = NoColorSpace;\n\n\t\t\t\t\t\tif ( 'def Shader \"Transform2d_occlusion\"' in data ) {\n\n\t\t\t\t\t\t\tsetTextureParams( material.aoMap, data[ 'def Shader \"Transform2d_occlusion\"' ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tfunction findTexture( data, id ) {\n\n\t\t\tfor ( const name in data ) {\n\n\t\t\t\tconst object = data[ name ];\n\n\t\t\t\tif ( name.startsWith( `def Shader \"${ id }\"` ) ) {\n\n\t\t\t\t\treturn object;\n\n\t\t\t\t}\n\n\t\t\t\tif ( typeof object === 'object' ) {\n\n\t\t\t\t\tconst texture = findTexture( object, id );\n\n\t\t\t\t\tif ( texture ) return texture;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildTexture( data ) {\n\n\t\t\tif ( 'asset inputs:file' in data ) {\n\n\t\t\t\tconst path = data[ 'asset inputs:file' ].replace( /@*/g, '' ).trim();\n\n\t\t\t\tconst loader = new TextureLoader();\n\n\t\t\t\tconst texture = loader.load( assets[ path ] );\n\n\t\t\t\tconst map = {\n\t\t\t\t\t'\"clamp\"': ClampToEdgeWrapping,\n\t\t\t\t\t'\"mirror\"': MirroredRepeatWrapping,\n\t\t\t\t\t'\"repeat\"': RepeatWrapping\n\t\t\t\t};\n\n\t\t\t\tif ( 'token inputs:wrapS' in data ) {\n\n\t\t\t\t\ttexture.wrapS = map[ data[ 'token inputs:wrapS' ] ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( 'token inputs:wrapT' in data ) {\n\n\t\t\t\t\ttexture.wrapT = map[ data[ 'token inputs:wrapT' ] ];\n\n\t\t\t\t}\n\n\t\t\t\treturn texture;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfunction buildObject( data ) {\n\n\t\t\tconst geometry = buildGeometry( findMeshGeometry( data ) );\n\t\t\tconst material = buildMaterial( findMeshMaterial( data ) );\n\n\t\t\tconst mesh = geometry ? new Mesh( geometry, material ) : new Object3D();\n\n\t\t\tif ( 'matrix4d xformOp:transform' in data ) {\n\n\t\t\t\tconst array = JSON.parse( '[' + data[ 'matrix4d xformOp:transform' ].replace( /[()]*/g, '' ) + ']' );\n\n\t\t\t\tmesh.matrix.fromArray( array );\n\t\t\t\tmesh.matrix.decompose( mesh.position, mesh.quaternion, mesh.scale );\n\n\t\t\t}\n\n\t\t\treturn mesh;\n\n\t\t}\n\n\t\tfunction buildHierarchy( data, group ) {\n\n\t\t\tfor ( const name in data ) {\n\n\t\t\t\tif ( name.startsWith( 'def Scope' ) ) {\n\n\t\t\t\t\tbuildHierarchy( data[ name ], group );\n\n\t\t\t\t} else if ( name.startsWith( 'def Xform' ) ) {\n\n\t\t\t\t\tconst mesh = buildObject( data[ name ] );\n\n\t\t\t\t\tif ( /def Xform \"(\\w+)\"/.test( name ) ) {\n\n\t\t\t\t\t\tmesh.name = /def Xform \"(\\w+)\"/.exec( name )[ 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t\tbuildHierarchy( data[ name ], mesh );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst group = new Group();\n\n\t\tbuildHierarchy( root, group );\n\n\t\treturn group;\n\n\t}\n\n}\n\nexport { USDZLoader };\n"],"mappings":"AAAA,SACCA,eAAe,EACfC,cAAc,EACdC,mBAAmB,EACnBC,UAAU,EACVC,KAAK,EACLC,YAAY,EACZC,MAAM,EACNC,IAAI,EACJC,oBAAoB,EACpBC,sBAAsB,EACtBC,cAAc,EACdC,cAAc,EACdC,aAAa,EACbC,QAAQ,EACRC,OAAO,QACD,OAAO;AAEd,OAAO,KAAKC,MAAM,MAAM,0BAA0B;AAElD,MAAMC,UAAU,CAAC;EAEhBC,KAAKA,CAAEC,IAAI,EAAG;IAEb,MAAMC,IAAI,GAAG,CAAC,CAAC;IAEf,MAAMC,KAAK,GAAGF,IAAI,CAACG,KAAK,CAAE,IAAK,CAAC;IAEhC,IAAIC,MAAM,GAAG,IAAI;IACjB,IAAIC,MAAM,GAAGJ,IAAI;IAEjB,MAAMK,KAAK,GAAG,CAAEL,IAAI,CAAE;;IAEtB;;IAEA,KAAM,MAAMM,IAAI,IAAIL,KAAK,EAAG;MAE3B;;MAEA,IAAKK,IAAI,CAACC,QAAQ,CAAE,GAAI,CAAC,EAAG;QAE3B,MAAMC,UAAU,GAAGF,IAAI,CAACJ,KAAK,CAAE,GAAI,CAAC;QAEpC,MAAMO,GAAG,GAAGD,UAAU,CAAE,CAAC,CAAE,CAACE,IAAI,CAAC,CAAC;QAClC,MAAMC,GAAG,GAAGH,UAAU,CAAE,CAAC,CAAE,CAACE,IAAI,CAAC,CAAC;QAElC,IAAKC,GAAG,CAACC,QAAQ,CAAE,GAAI,CAAC,EAAG;UAE1B,MAAMC,KAAK,GAAG,CAAC,CAAC;UAChBR,KAAK,CAACS,IAAI,CAAED,KAAM,CAAC;UAEnBT,MAAM,CAAEK,GAAG,CAAE,GAAGI,KAAK;UACrBT,MAAM,GAAGS,KAAK;QAEf,CAAC,MAAM,IAAKF,GAAG,CAACC,QAAQ,CAAE,GAAI,CAAC,EAAG;UAEjC;;UAEA,MAAMG,MAAM,GAAGJ,GAAG,CAACK,KAAK,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC;UAClCZ,MAAM,CAAEK,GAAG,CAAE,GAAGM,MAAM;UAEtB,MAAME,IAAI,GAAG,CAAC,CAAC;UACfZ,KAAK,CAACS,IAAI,CAAEG,IAAK,CAAC;UAElBb,MAAM,GAAGa,IAAI;QAEd,CAAC,MAAM;UAENb,MAAM,CAAEK,GAAG,CAAE,GAAGE,GAAG;QAEpB;MAED,CAAC,MAAM,IAAKL,IAAI,CAACM,QAAQ,CAAE,GAAI,CAAC,EAAG;QAElC,MAAMC,KAAK,GAAGT,MAAM,CAAED,MAAM,CAAE,IAAI,CAAC,CAAC;QACpCE,KAAK,CAACS,IAAI,CAAED,KAAM,CAAC;QAEnBT,MAAM,CAAED,MAAM,CAAE,GAAGU,KAAK;QACxBT,MAAM,GAAGS,KAAK;MAEf,CAAC,MAAM,IAAKP,IAAI,CAACM,QAAQ,CAAE,GAAI,CAAC,EAAG;QAElCP,KAAK,CAACa,GAAG,CAAC,CAAC;QAEX,IAAKb,KAAK,CAACc,MAAM,KAAK,CAAC,EAAG;QAE1Bf,MAAM,GAAGC,KAAK,CAAEA,KAAK,CAACc,MAAM,GAAG,CAAC,CAAE;MAEnC,CAAC,MAAM,IAAKb,IAAI,CAACM,QAAQ,CAAE,GAAI,CAAC,EAAG;QAElC,MAAMK,IAAI,GAAG,CAAC,CAAC;QACfZ,KAAK,CAACS,IAAI,CAAEG,IAAK,CAAC;QAElBd,MAAM,GAAGG,IAAI,CAACJ,KAAK,CAAE,GAAI,CAAC,CAAE,CAAC,CAAE,CAACQ,IAAI,CAAC,CAAC,IAAIP,MAAM;QAEhDC,MAAM,CAAED,MAAM,CAAE,GAAGc,IAAI;QACvBb,MAAM,GAAGa,IAAI;MAEd,CAAC,MAAM,IAAKX,IAAI,CAACM,QAAQ,CAAE,GAAI,CAAC,EAAG;QAElCP,KAAK,CAACa,GAAG,CAAC,CAAC;QAEXd,MAAM,GAAGC,KAAK,CAAEA,KAAK,CAACc,MAAM,GAAG,CAAC,CAAE;MAEnC,CAAC,MAAM;QAENhB,MAAM,GAAGG,IAAI,CAACI,IAAI,CAAC,CAAC;MAErB;IAED;IAEA,OAAOV,IAAI;EAEZ;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMoB,UAAU,SAASjC,MAAM,CAAC;EAE/B;AACD;AACA;AACA;AACA;EACCkC,WAAWA,CAAEC,OAAO,EAAG;IAEtB,KAAK,CAAEA,OAAQ,CAAC;EAEjB;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCC,IAAIA,CAAEC,GAAG,EAAEC,MAAM,EAAEC,UAAU,EAAEC,OAAO,EAAG;IAExC,MAAMC,KAAK,GAAG,IAAI;IAElB,MAAMC,MAAM,GAAG,IAAI7C,UAAU,CAAE4C,KAAK,CAACN,OAAQ,CAAC;IAC9CO,MAAM,CAACC,OAAO,CAAEF,KAAK,CAACG,IAAK,CAAC;IAC5BF,MAAM,CAACG,eAAe,CAAE,aAAc,CAAC;IACvCH,MAAM,CAACI,gBAAgB,CAAEL,KAAK,CAACM,aAAc,CAAC;IAC9CL,MAAM,CAACM,kBAAkB,CAAEP,KAAK,CAACQ,eAAgB,CAAC;IAClDP,MAAM,CAACN,IAAI,CAAEC,GAAG,EAAE,UAAWzB,IAAI,EAAG;MAEnC,IAAI;QAEH0B,MAAM,CAAEG,KAAK,CAAC9B,KAAK,CAAEC,IAAK,CAAE,CAAC;MAE9B,CAAC,CAAC,OAAQsC,CAAC,EAAG;QAEb,IAAKV,OAAO,EAAG;UAEdA,OAAO,CAAEU,CAAE,CAAC;QAEb,CAAC,MAAM;UAENC,OAAO,CAACC,KAAK,CAAEF,CAAE,CAAC;QAEnB;QAEAT,KAAK,CAACN,OAAO,CAACkB,SAAS,CAAEhB,GAAI,CAAC;MAE/B;IAED,CAAC,EAAEE,UAAU,EAAEC,OAAQ,CAAC;EAEzB;;EAEA;AACD;AACA;AACA;AACA;AACA;EACC7B,KAAKA,CAAE2C,MAAM,EAAG;IAEf,MAAMC,MAAM,GAAG,IAAI7C,UAAU,CAAC,CAAC;IAE/B,SAAS8C,WAAWA,CAAEC,GAAG,EAAG;MAE3B,MAAM5C,IAAI,GAAG,CAAC,CAAC;MACf,MAAM6B,MAAM,GAAG,IAAI7C,UAAU,CAAC,CAAC;MAC/B6C,MAAM,CAACG,eAAe,CAAE,aAAc,CAAC;MAEvC,KAAM,MAAMa,QAAQ,IAAID,GAAG,EAAG;QAE7B,IAAKC,QAAQ,CAACjC,QAAQ,CAAE,KAAM,CAAC,EAAG;UAEjC,MAAMkC,IAAI,GAAG,IAAIC,IAAI,CAAE,CAAEH,GAAG,CAAEC,QAAQ,CAAE,CAAE,EAAE;YAAEG,IAAI,EAAE;UAAY,CAAE,CAAC;UACnEhD,IAAI,CAAE6C,QAAQ,CAAE,GAAGI,GAAG,CAACC,eAAe,CAAEJ,IAAK,CAAC;QAE/C;QAEA,IAAKD,QAAQ,CAACjC,QAAQ,CAAE,KAAM,CAAC,IAAIiC,QAAQ,CAACjC,QAAQ,CAAE,MAAO,CAAC,EAAG;UAEhE,IAAKuC,WAAW,CAAEP,GAAG,CAAEC,QAAQ,CAAG,CAAC,EAAG;YAErC,MAAMO,KAAK,CAAE,yEAA0E,CAAC;UAEzF;UAEA,MAAMrD,IAAI,GAAGH,MAAM,CAACyD,SAAS,CAAET,GAAG,CAAEC,QAAQ,CAAG,CAAC;UAChD7C,IAAI,CAAE6C,QAAQ,CAAE,GAAGH,MAAM,CAAC5C,KAAK,CAAEC,IAAK,CAAC;QAExC;MAED;MAEA,OAAOC,IAAI;IAEZ;IAEA,SAASmD,WAAWA,CAAEV,MAAM,EAAG;MAE9B;MACA,MAAMa,UAAU,GAAGb,MAAM,CAACzB,KAAK,CAAE,CAAC,EAAE,CAAE,CAAC;MACvC,MAAMuC,WAAW,GAAG,IAAIC,UAAU,CAAE,CAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAG,CAAC;;MAExF;MACA,OAAOF,UAAU,CAACG,KAAK,CAAE,CAAEC,KAAK,EAAEC,KAAK,KAAMD,KAAK,KAAKH,WAAW,CAAEI,KAAK,CAAG,CAAC;IAE9E;IAEA,SAASC,OAAOA,CAAEhB,GAAG,EAAG;MAEvB,IAAKA,GAAG,CAACzB,MAAM,GAAG,CAAC,EAAG,OAAO0C,SAAS;MAEtC,MAAMC,aAAa,GAAGC,MAAM,CAACC,IAAI,CAAEpB,GAAI,CAAC,CAAE,CAAC,CAAE;MAC7C,IAAIqB,OAAO,GAAG,KAAK;;MAEnB;MACA;MACA;MACA,IAAKH,aAAa,CAAClD,QAAQ,CAAE,MAAO,CAAC,EAAG,OAAOgC,GAAG,CAAEkB,aAAa,CAAE;MAEnE,IAAKA,aAAa,CAAClD,QAAQ,CAAE,MAAO,CAAC,EAAG;QAEvCqD,OAAO,GAAG,IAAI;MAEf,CAAC,MAAM,IAAKH,aAAa,CAAClD,QAAQ,CAAE,KAAM,CAAC,EAAG;QAE7C;QACA,IAAK,CAAEuC,WAAW,CAAEP,GAAG,CAAEkB,aAAa,CAAG,CAAC,EAAG;UAE5C,OAAOlB,GAAG,CAAEkB,aAAa,CAAE;QAE5B,CAAC,MAAM;UAENG,OAAO,GAAG,IAAI;QAEf;MAED;MAEA,IAAKA,OAAO,EAAG;QAEd,MAAMb,KAAK,CAAE,yEAA0E,CAAC;MAEzF;IAED;IAEA,MAAMR,GAAG,GAAGhD,MAAM,CAACsE,SAAS,CAAE,IAAIV,UAAU,CAAEf,MAAO,CAAE,CAAC;;IAExD;;IAEA,MAAM0B,MAAM,GAAGxB,WAAW,CAAEC,GAAI,CAAC;;IAEjC;;IAEA,MAAMwB,IAAI,GAAGR,OAAO,CAAEhB,GAAI,CAAC;;IAE3B;;IAEA,MAAM7C,IAAI,GAAGH,MAAM,CAACyD,SAAS,CAAEe,IAAK,CAAC;IACrC,MAAMC,IAAI,GAAG3B,MAAM,CAAC5C,KAAK,CAAEC,IAAK,CAAC;;IAEjC;;IAEA,SAASuE,gBAAgBA,CAAEtE,IAAI,EAAG;MAEjC,IAAK,CAAEA,IAAI,EAAG,OAAO6D,SAAS;MAE9B,IAAK,oBAAoB,IAAI7D,IAAI,EAAG;QAEnC,MAAMuE,SAAS,GAAGvE,IAAI,CAAE,oBAAoB,CAAE;QAC9C,MAAMwE,KAAK,GAAGD,SAAS,CAACrE,KAAK,CAAE,GAAI,CAAC;QACpC,MAAM6B,IAAI,GAAGyC,KAAK,CAAE,CAAC,CAAE,CAACC,OAAO,CAAE,MAAM,EAAE,EAAG,CAAC;QAC7C,MAAMC,EAAE,GAAGF,KAAK,CAAE,CAAC,CAAE,CAACC,OAAO,CAAE,MAAM,EAAE,EAAG,CAAC,CAACA,OAAO,CAAE,IAAI,EAAE,EAAG,CAAC;QAE/D,OAAOE,YAAY,CAAER,MAAM,CAAEpC,IAAI,CAAE,EAAE2C,EAAG,CAAC;MAE1C;MAEA,OAAOC,YAAY,CAAE3E,IAAK,CAAC;IAE5B;IAEA,SAAS2E,YAAYA,CAAE3E,IAAI,EAAE0E,EAAE,EAAG;MAEjC,IAAK,CAAE1E,IAAI,EAAG,OAAO6D,SAAS;MAE9B,IAAKa,EAAE,KAAKb,SAAS,EAAG;QAEvB,MAAMe,GAAG,GAAG,aAAaF,EAAE,GAAG;QAE9B,IAAKE,GAAG,IAAI5E,IAAI,EAAG;UAElB,OAAOA,IAAI,CAAE4E,GAAG,CAAE;QAEnB;MAED;MAEA,KAAM,MAAMC,IAAI,IAAI7E,IAAI,EAAG;QAE1B,MAAM8E,MAAM,GAAG9E,IAAI,CAAE6E,IAAI,CAAE;QAE3B,IAAKA,IAAI,CAACE,UAAU,CAAE,UAAW,CAAC,EAAG;UAEpC,OAAOD,MAAM;QAEd;QAGA,IAAK,OAAOA,MAAM,KAAK,QAAQ,EAAG;UAEjC,MAAME,QAAQ,GAAGL,YAAY,CAAEG,MAAO,CAAC;UAEvC,IAAKE,QAAQ,EAAG,OAAOA,QAAQ;QAEhC;MAED;IAED;IAEA,SAASC,aAAaA,CAAEjF,IAAI,EAAG;MAE9B,IAAK,CAAEA,IAAI,EAAG,OAAO6D,SAAS;MAE9B,MAAMmB,QAAQ,GAAG,IAAIlG,cAAc,CAAC,CAAC;MACrC,IAAIoG,OAAO,GAAG,IAAI;MAClB,IAAIC,MAAM,GAAG,IAAI;MACjB,IAAIC,GAAG,GAAG,IAAI;MAEd,IAAIC,eAAe,GAAG,CAAE,CAAC;;MAEzB;;MAEA,IAAK,yBAAyB,IAAIrF,IAAI,EAAG;QAExCkF,OAAO,GAAGI,IAAI,CAACxF,KAAK,CAAEE,IAAI,CAAE,yBAAyB,CAAG,CAAC;MAE1D;;MAEA;;MAEA,IAAK,wBAAwB,IAAIA,IAAI,EAAG;QAEvCmF,MAAM,GAAGG,IAAI,CAACxF,KAAK,CAAEE,IAAI,CAAE,wBAAwB,CAAG,CAAC;QACvDkF,OAAO,GAAGK,iBAAiB,CAAEL,OAAO,EAAEC,MAAO,CAAC;MAE/C;;MAEA;;MAEA,IAAK,kBAAkB,IAAInF,IAAI,EAAG;QAEjC,MAAMwF,SAAS,GAAGF,IAAI,CAACxF,KAAK,CAAEE,IAAI,CAAE,kBAAkB,CAAE,CAACyE,OAAO,CAAE,QAAQ,EAAE,EAAG,CAAE,CAAC;QAClFY,eAAe,GAAGG,SAAS,CAACrE,MAAM;QAClC,IAAIsE,SAAS,GAAG,IAAI5G,eAAe,CAAE,IAAI6G,YAAY,CAAEF,SAAU,CAAC,EAAE,CAAE,CAAC;QAEvE,IAAKN,OAAO,KAAK,IAAI,EAAGO,SAAS,GAAGE,qBAAqB,CAAEF,SAAS,EAAEP,OAAQ,CAAC;QAE/EF,QAAQ,CAACY,YAAY,CAAE,UAAU,EAAEH,SAAU,CAAC;MAE/C;;MAEA;;MAEA,IAAK,sBAAsB,IAAIzF,IAAI,EAAG;QAErCA,IAAI,CAAE,0BAA0B,CAAE,GAAGA,IAAI,CAAE,sBAAsB,CAAE;MAEpE;MAEA,IAAK,0BAA0B,IAAIA,IAAI,EAAG;QAEzCoF,GAAG,GAAGE,IAAI,CAACxF,KAAK,CAAEE,IAAI,CAAE,0BAA0B,CAAE,CAACyE,OAAO,CAAE,QAAQ,EAAE,EAAG,CAAE,CAAC;QAC9E,IAAIgB,SAAS,GAAG,IAAI5G,eAAe,CAAE,IAAI6G,YAAY,CAAEN,GAAI,CAAC,EAAE,CAAE,CAAC;QAEjE,IAAKF,OAAO,KAAK,IAAI,EAAGO,SAAS,GAAGE,qBAAqB,CAAEF,SAAS,EAAEP,OAAQ,CAAC;QAE/EF,QAAQ,CAACY,YAAY,CAAE,IAAI,EAAEH,SAAU,CAAC;MAEzC;MAEA,IAAK,2BAA2B,IAAIzF,IAAI,IAAIoF,GAAG,KAAK,IAAI,EAAG;QAE1D;;QAEA,MAAMK,SAAS,GAAG,IAAI5G,eAAe,CAAE,IAAI6G,YAAY,CAAEN,GAAI,CAAC,EAAE,CAAE,CAAC;QACnE,IAAIF,OAAO,GAAGI,IAAI,CAACxF,KAAK,CAAEE,IAAI,CAAE,2BAA2B,CAAG,CAAC;QAC/DkF,OAAO,GAAGK,iBAAiB,CAAEL,OAAO,EAAEC,MAAO,CAAC;QAC9CH,QAAQ,CAACY,YAAY,CAAE,IAAI,EAAED,qBAAqB,CAAEF,SAAS,EAAEP,OAAQ,CAAE,CAAC;MAE3E;;MAEA;;MAEA,IAAK,oBAAoB,IAAIlF,IAAI,EAAG;QAEnC,MAAM6F,OAAO,GAAGP,IAAI,CAACxF,KAAK,CAAEE,IAAI,CAAE,oBAAoB,CAAE,CAACyE,OAAO,CAAE,QAAQ,EAAE,EAAG,CAAE,CAAC;QAClF,IAAIgB,SAAS,GAAG,IAAI5G,eAAe,CAAE,IAAI6G,YAAY,CAAEG,OAAQ,CAAC,EAAE,CAAE,CAAC;;QAErE;;QAEA,IAAKA,OAAO,CAAC1E,MAAM,KAAKkE,eAAe,EAAG;UAEzC;;UAEA,IAAKH,OAAO,KAAK,IAAI,EAAGO,SAAS,GAAGE,qBAAqB,CAAEF,SAAS,EAAEP,OAAQ,CAAC;QAEhF,CAAC,MAAM;UAEN;;UAEA,IAAIA,OAAO,GAAGY,KAAK,CAACC,IAAI,CAAED,KAAK,CAAED,OAAO,CAAC1E,MAAM,GAAG,CAAE,CAAC,CAAC6C,IAAI,CAAC,CAAE,CAAC,CAAC,CAAC;UAChEkB,OAAO,GAAGK,iBAAiB,CAAEL,OAAO,EAAEC,MAAO,CAAC;UAC9CM,SAAS,GAAGE,qBAAqB,CAAEF,SAAS,EAAEP,OAAQ,CAAC;QAExD;QAEAF,QAAQ,CAACY,YAAY,CAAE,QAAQ,EAAEH,SAAU,CAAC;MAE7C,CAAC,MAAM;QAEN;;QAEAT,QAAQ,CAACgB,oBAAoB,CAAC,CAAC;MAEhC;MAEA,OAAOhB,QAAQ;IAEhB;IAEA,SAASO,iBAAiBA,CAAEU,UAAU,EAAEd,MAAM,EAAG;MAEhD,MAAMD,OAAO,GAAG,EAAE;MAElB,KAAM,IAAIgB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGf,MAAM,CAAChE,MAAM,EAAE+E,CAAC,EAAG,EAAG;QAE1C,MAAMC,KAAK,GAAGhB,MAAM,CAAEe,CAAC,CAAE;QAEzB,MAAME,MAAM,GAAGF,CAAC,GAAGC,KAAK;QAExB,IAAKA,KAAK,KAAK,CAAC,EAAG;UAElB,MAAME,CAAC,GAAGJ,UAAU,CAAEG,MAAM,GAAG,CAAC,CAAE;UAClC,MAAME,CAAC,GAAGL,UAAU,CAAEG,MAAM,GAAG,CAAC,CAAE;UAClC,MAAMG,CAAC,GAAGN,UAAU,CAAEG,MAAM,GAAG,CAAC,CAAE;UAElClB,OAAO,CAACpE,IAAI,CAAEuF,CAAC,EAAEC,CAAC,EAAEC,CAAE,CAAC;QAExB,CAAC,MAAM,IAAKJ,KAAK,KAAK,CAAC,EAAG;UAEzB,MAAME,CAAC,GAAGJ,UAAU,CAAEG,MAAM,GAAG,CAAC,CAAE;UAClC,MAAME,CAAC,GAAGL,UAAU,CAAEG,MAAM,GAAG,CAAC,CAAE;UAClC,MAAMG,CAAC,GAAGN,UAAU,CAAEG,MAAM,GAAG,CAAC,CAAE;UAClC,MAAMI,CAAC,GAAGP,UAAU,CAAEG,MAAM,GAAG,CAAC,CAAE;UAElClB,OAAO,CAACpE,IAAI,CAAEuF,CAAC,EAAEC,CAAC,EAAEC,CAAE,CAAC;UACvBrB,OAAO,CAACpE,IAAI,CAAEuF,CAAC,EAAEE,CAAC,EAAEC,CAAE,CAAC;QAExB,CAAC,MAAM;UAENlE,OAAO,CAACmE,IAAI,CAAE,wDAAwD,EAAEN,KAAM,CAAC;QAEhF;MAED;MAEA,OAAOjB,OAAO;IAEf;IAEA,SAASS,qBAAqBA,CAAEF,SAAS,EAAEP,OAAO,EAAG;MAEpD,MAAMwB,KAAK,GAAGjB,SAAS,CAACiB,KAAK;MAC7B,MAAMC,QAAQ,GAAGlB,SAAS,CAACkB,QAAQ;MAEnC,MAAMC,MAAM,GAAG,IAAIF,KAAK,CAACrF,WAAW,CAAE6D,OAAO,CAAC/D,MAAM,GAAGwF,QAAS,CAAC;MAEjE,IAAIhD,KAAK,GAAG,CAAC;QAAEkD,MAAM,GAAG,CAAC;MAEzB,KAAM,IAAIX,CAAC,GAAG,CAAC,EAAEY,CAAC,GAAG5B,OAAO,CAAC/D,MAAM,EAAE+E,CAAC,GAAGY,CAAC,EAAEZ,CAAC,EAAG,EAAG;QAElDvC,KAAK,GAAGuB,OAAO,CAAEgB,CAAC,CAAE,GAAGS,QAAQ;QAE/B,KAAM,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,QAAQ,EAAEI,CAAC,EAAG,EAAG;UAErCH,MAAM,CAAEC,MAAM,EAAG,CAAE,GAAGH,KAAK,CAAE/C,KAAK,EAAG,CAAE;QAExC;MAED;MAEA,OAAO,IAAI9E,eAAe,CAAE+H,MAAM,EAAED,QAAS,CAAC;IAE/C;IAEA,SAASK,gBAAgBA,CAAEhH,IAAI,EAAG;MAEjC,IAAK,CAAEA,IAAI,EAAG,OAAO6D,SAAS;MAE9B,IAAK,sBAAsB,IAAI7D,IAAI,EAAG;QAErC,MAAMuE,SAAS,GAAGvE,IAAI,CAAE,sBAAsB,CAAE;QAChD,MAAM0E,EAAE,GAAGH,SAAS,CAACE,OAAO,CAAE,MAAM,EAAE,EAAG,CAAC,CAACA,OAAO,CAAE,IAAI,EAAE,EAAG,CAAC;QAC9D,MAAMD,KAAK,GAAGE,EAAE,CAACxE,KAAK,CAAE,GAAI,CAAC;QAE7B,OAAO+G,YAAY,CAAE5C,IAAI,EAAE,KAAMG,KAAK,CAAE,CAAC,CAAE,GAAK,CAAC;MAElD;MAEA,OAAOyC,YAAY,CAAEjH,IAAK,CAAC;IAE5B;IAEA,SAASiH,YAAYA,CAAEjH,IAAI,EAAE0E,EAAE,GAAG,EAAE,EAAG;MAEtC,KAAM,MAAMG,IAAI,IAAI7E,IAAI,EAAG;QAE1B,MAAM8E,MAAM,GAAG9E,IAAI,CAAE6E,IAAI,CAAE;QAE3B,IAAKA,IAAI,CAACE,UAAU,CAAE,cAAc,GAAGL,EAAG,CAAC,EAAG;UAE7C,OAAOI,MAAM;QAEd;QAEA,IAAK,OAAOA,MAAM,KAAK,QAAQ,EAAG;UAEjC,MAAMoC,QAAQ,GAAGD,YAAY,CAAEnC,MAAM,EAAEJ,EAAG,CAAC;UAE3C,IAAKwC,QAAQ,EAAG,OAAOA,QAAQ;QAEhC;MAED;IAED;IAEA,SAASC,gBAAgBA,CAAEC,GAAG,EAAEC,UAAU,EAAG;MAE5C;;MAEA,IAAKA,UAAU,CAAE,uBAAuB,CAAE,EAAG;QAE5CD,GAAG,CAACE,QAAQ,GAAGC,UAAU,CAAEF,UAAU,CAAE,uBAAuB,CAAG,CAAC;MAEnE;MAEA,IAAKA,UAAU,CAAE,qBAAqB,CAAE,EAAG;QAE1CD,GAAG,CAACI,MAAM,GAAG,IAAI7H,OAAO,CAAC,CAAC,CAAC8H,SAAS,CAAEnC,IAAI,CAACxF,KAAK,CAAE,GAAG,GAAGuH,UAAU,CAAE,qBAAqB,CAAE,CAAC5C,OAAO,CAAE,QAAQ,EAAE,EAAG,CAAC,GAAG,GAAI,CAAE,CAAC;MAE9H;MAEA,IAAK4C,UAAU,CAAE,2BAA2B,CAAE,EAAG;QAEhDD,GAAG,CAACM,MAAM,GAAG,IAAI/H,OAAO,CAAC,CAAC,CAAC8H,SAAS,CAAEnC,IAAI,CAACxF,KAAK,CAAE,GAAG,GAAGuH,UAAU,CAAE,2BAA2B,CAAE,CAAC5C,OAAO,CAAE,QAAQ,EAAE,EAAG,CAAC,GAAG,GAAI,CAAE,CAAC;MAEpI;IAED;IAEA,SAASkD,aAAaA,CAAE3H,IAAI,EAAG;MAE9B,MAAMkH,QAAQ,GAAG,IAAI7H,oBAAoB,CAAC,CAAC;MAE3C,IAAKW,IAAI,KAAK6D,SAAS,EAAG;QAEzB,MAAM+D,iBAAiB,GAAG5H,IAAI,CAAE,+BAA+B,CAAE;QACjE,MAAM6H,WAAW,GAAG,cAAc,CAACC,IAAI,CAAEF,iBAAkB,CAAC,CAAE,CAAC,CAAE;QACjE,MAAMG,OAAO,GAAG/H,IAAI,CAAE,eAAe6H,WAAW,GAAG,CAAE;QAErD,IAAKE,OAAO,KAAKlE,SAAS,EAAG;UAE5B,IAAK,qCAAqC,IAAIkE,OAAO,EAAG;YAEvD,MAAMhG,IAAI,GAAGgG,OAAO,CAAE,qCAAqC,CAAE;YAC7D,MAAMC,OAAO,GAAGC,WAAW,CAAE5D,IAAI,EAAE,cAAc,CAACyD,IAAI,CAAE/F,IAAK,CAAC,CAAE,CAAC,CAAG,CAAC;YAErEmF,QAAQ,CAACE,GAAG,GAAGc,YAAY,CAAEF,OAAQ,CAAC;YACtCd,QAAQ,CAACE,GAAG,CAACe,UAAU,GAAG3I,cAAc;YAExC,IAAK,kCAAkC,IAAIQ,IAAI,EAAG;cAEjDmH,gBAAgB,CAAED,QAAQ,CAACE,GAAG,EAAEpH,IAAI,CAAE,kCAAkC,CAAG,CAAC;YAE7E;UAED,CAAC,MAAM,IAAK,6BAA6B,IAAI+H,OAAO,EAAG;YAEtD,MAAMK,KAAK,GAAGL,OAAO,CAAE,6BAA6B,CAAE,CAACtD,OAAO,CAAE,QAAQ,EAAE,EAAG,CAAC;YAC9EyC,QAAQ,CAACkB,KAAK,CAACX,SAAS,CAAEnC,IAAI,CAACxF,KAAK,CAAE,GAAG,GAAGsI,KAAK,GAAG,GAAI,CAAE,CAAC;UAE5D;UAEA,IAAK,sCAAsC,IAAIL,OAAO,EAAG;YAExD,MAAMhG,IAAI,GAAGgG,OAAO,CAAE,sCAAsC,CAAE;YAC9D,MAAMC,OAAO,GAAGC,WAAW,CAAE5D,IAAI,EAAE,cAAc,CAACyD,IAAI,CAAE/F,IAAK,CAAC,CAAE,CAAC,CAAG,CAAC;YAErEmF,QAAQ,CAACmB,WAAW,GAAGH,YAAY,CAAEF,OAAQ,CAAC;YAC9Cd,QAAQ,CAACmB,WAAW,CAACF,UAAU,GAAG3I,cAAc;YAChD0H,QAAQ,CAACoB,QAAQ,CAACC,GAAG,CAAE,QAAS,CAAC;YAEjC,IAAK,mCAAmC,IAAIvI,IAAI,EAAG;cAElDmH,gBAAgB,CAAED,QAAQ,CAACmB,WAAW,EAAErI,IAAI,CAAE,mCAAmC,CAAG,CAAC;YAEtF;UAED,CAAC,MAAM,IAAK,8BAA8B,IAAI+H,OAAO,EAAG;YAEvD,MAAMK,KAAK,GAAGL,OAAO,CAAE,8BAA8B,CAAE,CAACtD,OAAO,CAAE,QAAQ,EAAE,EAAG,CAAC;YAC/EyC,QAAQ,CAACoB,QAAQ,CAACb,SAAS,CAAEnC,IAAI,CAACxF,KAAK,CAAE,GAAG,GAAGsI,KAAK,GAAG,GAAI,CAAE,CAAC;UAE/D;UAEA,IAAK,gCAAgC,IAAIL,OAAO,EAAG;YAElD,MAAMhG,IAAI,GAAGgG,OAAO,CAAE,gCAAgC,CAAE;YACxD,MAAMC,OAAO,GAAGC,WAAW,CAAE5D,IAAI,EAAE,cAAc,CAACyD,IAAI,CAAE/F,IAAK,CAAC,CAAE,CAAC,CAAG,CAAC;YAErEmF,QAAQ,CAACsB,SAAS,GAAGN,YAAY,CAAEF,OAAQ,CAAC;YAC5Cd,QAAQ,CAACsB,SAAS,CAACL,UAAU,GAAGjJ,YAAY;YAE5C,IAAK,iCAAiC,IAAIc,IAAI,EAAG;cAEhDmH,gBAAgB,CAAED,QAAQ,CAACsB,SAAS,EAAExI,IAAI,CAAE,iCAAiC,CAAG,CAAC;YAElF;UAED;UAEA,IAAK,gCAAgC,IAAI+H,OAAO,EAAG;YAElD,MAAMhG,IAAI,GAAGgG,OAAO,CAAE,gCAAgC,CAAE;YACxD,MAAMC,OAAO,GAAGC,WAAW,CAAE5D,IAAI,EAAE,cAAc,CAACyD,IAAI,CAAE/F,IAAK,CAAC,CAAE,CAAC,CAAG,CAAC;YAErEmF,QAAQ,CAACuB,SAAS,GAAG,GAAG;YACxBvB,QAAQ,CAACwB,YAAY,GAAGR,YAAY,CAAEF,OAAQ,CAAC;YAC/Cd,QAAQ,CAACwB,YAAY,CAACP,UAAU,GAAGjJ,YAAY;YAE/C,IAAK,oCAAoC,IAAIc,IAAI,EAAG;cAEnDmH,gBAAgB,CAAED,QAAQ,CAACwB,YAAY,EAAE1I,IAAI,CAAE,oCAAoC,CAAG,CAAC;YAExF;UAED,CAAC,MAAM,IAAK,wBAAwB,IAAI+H,OAAO,EAAG;YAEjDb,QAAQ,CAACuB,SAAS,GAAGlB,UAAU,CAAEQ,OAAO,CAAE,wBAAwB,CAAG,CAAC;UAEvE;UAEA,IAAK,+BAA+B,IAAIA,OAAO,EAAG;YAEjD,MAAMhG,IAAI,GAAGgG,OAAO,CAAE,+BAA+B,CAAE;YACvD,MAAMC,OAAO,GAAGC,WAAW,CAAE5D,IAAI,EAAE,cAAc,CAACyD,IAAI,CAAE/F,IAAK,CAAC,CAAE,CAAC,CAAG,CAAC;YAErEmF,QAAQ,CAACyB,SAAS,GAAG,GAAG;YACxBzB,QAAQ,CAAC0B,YAAY,GAAGV,YAAY,CAAEF,OAAQ,CAAC;YAC/Cd,QAAQ,CAAC0B,YAAY,CAACT,UAAU,GAAGjJ,YAAY;YAE/C,IAAK,mCAAmC,IAAIc,IAAI,EAAG;cAElDmH,gBAAgB,CAAED,QAAQ,CAAC0B,YAAY,EAAE5I,IAAI,CAAE,mCAAmC,CAAG,CAAC;YAEvF;UAED,CAAC,MAAM,IAAK,uBAAuB,IAAI+H,OAAO,EAAG;YAEhDb,QAAQ,CAACyB,SAAS,GAAGpB,UAAU,CAAEQ,OAAO,CAAE,uBAAuB,CAAG,CAAC;UAEtE;UAEA,IAAK,gCAAgC,IAAIA,OAAO,EAAG;YAElD,MAAMhG,IAAI,GAAGgG,OAAO,CAAE,gCAAgC,CAAE;YACxD,MAAMC,OAAO,GAAGC,WAAW,CAAE5D,IAAI,EAAE,cAAc,CAACyD,IAAI,CAAE/F,IAAK,CAAC,CAAE,CAAC,CAAG,CAAC;YAErEmF,QAAQ,CAAC2B,SAAS,GAAG,GAAG;YACxB3B,QAAQ,CAAC4B,YAAY,GAAGZ,YAAY,CAAEF,OAAQ,CAAC;YAC/Cd,QAAQ,CAAC4B,YAAY,CAACX,UAAU,GAAGjJ,YAAY;YAE/C,IAAK,oCAAoC,IAAIc,IAAI,EAAG;cAEnDmH,gBAAgB,CAAED,QAAQ,CAAC4B,YAAY,EAAE9I,IAAI,CAAE,oCAAoC,CAAG,CAAC;YAExF;UAED,CAAC,MAAM,IAAK,wBAAwB,IAAI+H,OAAO,EAAG;YAEjDb,QAAQ,CAAC2B,SAAS,GAAGtB,UAAU,CAAEQ,OAAO,CAAE,wBAAwB,CAAG,CAAC;UAEvE;UAEA,IAAK,yCAAyC,IAAIA,OAAO,EAAG;YAE3D,MAAMhG,IAAI,GAAGgG,OAAO,CAAE,yCAAyC,CAAE;YACjE,MAAMC,OAAO,GAAGC,WAAW,CAAE5D,IAAI,EAAE,cAAc,CAACyD,IAAI,CAAE/F,IAAK,CAAC,CAAE,CAAC,CAAG,CAAC;YAErEmF,QAAQ,CAAC6B,kBAAkB,GAAG,GAAG;YACjC7B,QAAQ,CAAC8B,qBAAqB,GAAGd,YAAY,CAAEF,OAAQ,CAAC;YACxDd,QAAQ,CAAC8B,qBAAqB,CAACb,UAAU,GAAGjJ,YAAY;YAExD,IAAK,6CAA6C,IAAIc,IAAI,EAAG;cAE5DmH,gBAAgB,CAAED,QAAQ,CAAC8B,qBAAqB,EAAEhJ,IAAI,CAAE,6CAA6C,CAAG,CAAC;YAE1G;UAED,CAAC,MAAM,IAAK,iCAAiC,IAAI+H,OAAO,EAAG;YAE1Db,QAAQ,CAAC6B,kBAAkB,GAAGxB,UAAU,CAAEQ,OAAO,CAAE,iCAAiC,CAAG,CAAC;UAEzF;UAEA,IAAK,kBAAkB,IAAIA,OAAO,EAAG;YAEpCb,QAAQ,CAAC+B,GAAG,GAAG1B,UAAU,CAAEQ,OAAO,CAAE,kBAAkB,CAAG,CAAC;UAE3D;UAEA,IAAK,gCAAgC,IAAIA,OAAO,EAAG;YAElD,MAAMhG,IAAI,GAAGgG,OAAO,CAAE,gCAAgC,CAAE;YACxD,MAAMC,OAAO,GAAGC,WAAW,CAAE5D,IAAI,EAAE,cAAc,CAACyD,IAAI,CAAE/F,IAAK,CAAC,CAAE,CAAC,CAAG,CAAC;YAErEmF,QAAQ,CAACgC,KAAK,GAAGhB,YAAY,CAAEF,OAAQ,CAAC;YACxCd,QAAQ,CAACgC,KAAK,CAACf,UAAU,GAAGjJ,YAAY;YAExC,IAAK,oCAAoC,IAAIc,IAAI,EAAG;cAEnDmH,gBAAgB,CAAED,QAAQ,CAACgC,KAAK,EAAElJ,IAAI,CAAE,oCAAoC,CAAG,CAAC;YAEjF;UAED;QAED;MAED;MAEA,OAAOkH,QAAQ;IAEhB;IAEA,SAASe,WAAWA,CAAEjI,IAAI,EAAE0E,EAAE,EAAG;MAEhC,KAAM,MAAMG,IAAI,IAAI7E,IAAI,EAAG;QAE1B,MAAM8E,MAAM,GAAG9E,IAAI,CAAE6E,IAAI,CAAE;QAE3B,IAAKA,IAAI,CAACE,UAAU,CAAE,eAAgBL,EAAE,GAAK,CAAC,EAAG;UAEhD,OAAOI,MAAM;QAEd;QAEA,IAAK,OAAOA,MAAM,KAAK,QAAQ,EAAG;UAEjC,MAAMqE,OAAO,GAAGlB,WAAW,CAAEnD,MAAM,EAAEJ,EAAG,CAAC;UAEzC,IAAKyE,OAAO,EAAG,OAAOA,OAAO;QAE9B;MAED;IAED;IAEA,SAASjB,YAAYA,CAAElI,IAAI,EAAG;MAE7B,IAAK,mBAAmB,IAAIA,IAAI,EAAG;QAElC,MAAM+B,IAAI,GAAG/B,IAAI,CAAE,mBAAmB,CAAE,CAACyE,OAAO,CAAE,KAAK,EAAE,EAAG,CAAC,CAAC/D,IAAI,CAAC,CAAC;QAEpE,MAAMmB,MAAM,GAAG,IAAIpC,aAAa,CAAC,CAAC;QAElC,MAAM0J,OAAO,GAAGtH,MAAM,CAACN,IAAI,CAAE4C,MAAM,CAAEpC,IAAI,CAAG,CAAC;QAE7C,MAAMqF,GAAG,GAAG;UACX,SAAS,EAAErI,mBAAmB;UAC9B,UAAU,EAAEO,sBAAsB;UAClC,UAAU,EAAEC;QACb,CAAC;QAED,IAAK,oBAAoB,IAAIS,IAAI,EAAG;UAEnCmJ,OAAO,CAACC,KAAK,GAAGhC,GAAG,CAAEpH,IAAI,CAAE,oBAAoB,CAAE,CAAE;QAEpD;QAEA,IAAK,oBAAoB,IAAIA,IAAI,EAAG;UAEnCmJ,OAAO,CAACE,KAAK,GAAGjC,GAAG,CAAEpH,IAAI,CAAE,oBAAoB,CAAE,CAAE;QAEpD;QAEA,OAAOmJ,OAAO;MAEf;MAEA,OAAO,IAAI;IAEZ;IAEA,SAASG,WAAWA,CAAEtJ,IAAI,EAAG;MAE5B,MAAMgF,QAAQ,GAAGC,aAAa,CAAEX,gBAAgB,CAAEtE,IAAK,CAAE,CAAC;MAC1D,MAAMkH,QAAQ,GAAGS,aAAa,CAAEX,gBAAgB,CAAEhH,IAAK,CAAE,CAAC;MAE1D,MAAMuJ,IAAI,GAAGvE,QAAQ,GAAG,IAAI5F,IAAI,CAAE4F,QAAQ,EAAEkC,QAAS,CAAC,GAAG,IAAIxH,QAAQ,CAAC,CAAC;MAEvE,IAAK,4BAA4B,IAAIM,IAAI,EAAG;QAE3C,MAAM0G,KAAK,GAAGpB,IAAI,CAACxF,KAAK,CAAE,GAAG,GAAGE,IAAI,CAAE,4BAA4B,CAAE,CAACyE,OAAO,CAAE,QAAQ,EAAE,EAAG,CAAC,GAAG,GAAI,CAAC;QAEpG8E,IAAI,CAACC,MAAM,CAAC/B,SAAS,CAAEf,KAAM,CAAC;QAC9B6C,IAAI,CAACC,MAAM,CAACC,SAAS,CAAEF,IAAI,CAACG,QAAQ,EAAEH,IAAI,CAACI,UAAU,EAAEJ,IAAI,CAACK,KAAM,CAAC;MAEpE;MAEA,OAAOL,IAAI;IAEZ;IAEA,SAASM,cAAcA,CAAE7J,IAAI,EAAEa,KAAK,EAAG;MAEtC,KAAM,MAAMgE,IAAI,IAAI7E,IAAI,EAAG;QAE1B,IAAK6E,IAAI,CAACE,UAAU,CAAE,WAAY,CAAC,EAAG;UAErC8E,cAAc,CAAE7J,IAAI,CAAE6E,IAAI,CAAE,EAAEhE,KAAM,CAAC;QAEtC,CAAC,MAAM,IAAKgE,IAAI,CAACE,UAAU,CAAE,WAAY,CAAC,EAAG;UAE5C,MAAMwE,IAAI,GAAGD,WAAW,CAAEtJ,IAAI,CAAE6E,IAAI,CAAG,CAAC;UAExC,IAAK,mBAAmB,CAACiF,IAAI,CAAEjF,IAAK,CAAC,EAAG;YAEvC0E,IAAI,CAAC1E,IAAI,GAAG,mBAAmB,CAACiD,IAAI,CAAEjD,IAAK,CAAC,CAAE,CAAC,CAAE;UAElD;UAEAhE,KAAK,CAACkJ,GAAG,CAAER,IAAK,CAAC;UAEjBM,cAAc,CAAE7J,IAAI,CAAE6E,IAAI,CAAE,EAAE0E,IAAK,CAAC;QAErC;MAED;IAED;IAEA,MAAM1I,KAAK,GAAG,IAAI5B,KAAK,CAAC,CAAC;IAEzB4K,cAAc,CAAExF,IAAI,EAAExD,KAAM,CAAC;IAE7B,OAAOA,KAAK;EAEb;AAED;AAEA,SAASO,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}