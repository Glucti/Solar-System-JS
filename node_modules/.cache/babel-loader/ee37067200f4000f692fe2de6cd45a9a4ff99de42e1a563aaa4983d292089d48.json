{"ast":null,"code":"import { Vector2 } from 'three';\n\n/**\n * @module DepthLimitedBlurShader\n * @three_import import { DepthLimitedBlurShader, BlurShaderUtils } from 'three/addons/shaders/DepthLimitedBlurShader.js';\n */\n\n/**\n * TODO\n *\n * Used by {@link SAOPass}.\n *\n * @constant\n * @type {ShaderMaterial~Shader}\n */\nconst DepthLimitedBlurShader = {\n  name: 'DepthLimitedBlurShader',\n  defines: {\n    'KERNEL_RADIUS': 4,\n    'DEPTH_PACKING': 1,\n    'PERSPECTIVE_CAMERA': 1\n  },\n  uniforms: {\n    'tDiffuse': {\n      value: null\n    },\n    'size': {\n      value: new Vector2(512, 512)\n    },\n    'sampleUvOffsets': {\n      value: [new Vector2(0, 0)]\n    },\n    'sampleWeights': {\n      value: [1.0]\n    },\n    'tDepth': {\n      value: null\n    },\n    'cameraNear': {\n      value: 10\n    },\n    'cameraFar': {\n      value: 1000\n    },\n    'depthCutoff': {\n      value: 10\n    }\n  },\n  vertexShader: /* glsl */`\n\n\t\t#include <common>\n\n\t\tuniform vec2 size;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec2 vInvSize;\n\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tvInvSize = 1.0 / size;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}`,\n  fragmentShader: /* glsl */`\n\n\t\t#include <common>\n\t\t#include <packing>\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tuniform float depthCutoff;\n\n\t\tuniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\n\t\tuniform float sampleWeights[ KERNEL_RADIUS + 1 ];\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec2 vInvSize;\n\n\t\tfloat getDepth( const in vec2 screenPosition ) {\n\t\t\t#if DEPTH_PACKING == 1\n\t\t\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n\t\t\t#else\n\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\t\t\t#endif\n\t\t}\n\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#else\n\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#endif\n\t\t}\n\n\t\tvoid main() {\n\t\t\tfloat depth = getDepth( vUv );\n\t\t\tif( depth >= ( 1.0 - EPSILON ) ) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t\tfloat centerViewZ = -getViewZ( depth );\n\t\t\tbool rBreak = false, lBreak = false;\n\n\t\t\tfloat weightSum = sampleWeights[0];\n\t\t\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\n\n\t\t\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\n\n\t\t\t\tfloat sampleWeight = sampleWeights[i];\n\t\t\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\n\n\t\t\t\tvec2 sampleUv = vUv + sampleUvOffset;\n\t\t\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\n\n\t\t\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\n\n\t\t\t\tif( ! rBreak ) {\n\t\t\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\n\t\t\t\t\tweightSum += sampleWeight;\n\t\t\t\t}\n\n\t\t\t\tsampleUv = vUv - sampleUvOffset;\n\t\t\t\tviewZ = -getViewZ( getDepth( sampleUv ) );\n\n\t\t\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\n\n\t\t\t\tif( ! lBreak ) {\n\t\t\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\n\t\t\t\t\tweightSum += sampleWeight;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgl_FragColor = diffuseSum / weightSum;\n\t\t}`\n};\nconst BlurShaderUtils = {\n  createSampleWeights: function (kernelRadius, stdDev) {\n    const weights = [];\n    for (let i = 0; i <= kernelRadius; i++) {\n      weights.push(gaussian(i, stdDev));\n    }\n    return weights;\n  },\n  createSampleOffsets: function (kernelRadius, uvIncrement) {\n    const offsets = [];\n    for (let i = 0; i <= kernelRadius; i++) {\n      offsets.push(uvIncrement.clone().multiplyScalar(i));\n    }\n    return offsets;\n  },\n  configure: function (material, kernelRadius, stdDev, uvIncrement) {\n    material.defines['KERNEL_RADIUS'] = kernelRadius;\n    material.uniforms['sampleUvOffsets'].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\n    material.uniforms['sampleWeights'].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\n    material.needsUpdate = true;\n  }\n};\nfunction gaussian(x, stdDev) {\n  return Math.exp(-(x * x) / (2.0 * (stdDev * stdDev))) / (Math.sqrt(2.0 * Math.PI) * stdDev);\n}\nexport { DepthLimitedBlurShader, BlurShaderUtils };","map":{"version":3,"names":["Vector2","DepthLimitedBlurShader","name","defines","uniforms","value","vertexShader","fragmentShader","BlurShaderUtils","createSampleWeights","kernelRadius","stdDev","weights","i","push","gaussian","createSampleOffsets","uvIncrement","offsets","clone","multiplyScalar","configure","material","needsUpdate","x","Math","exp","sqrt","PI"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/shaders/DepthLimitedBlurShader.js"],"sourcesContent":["import {\n\tVector2\n} from 'three';\n\n/**\n * @module DepthLimitedBlurShader\n * @three_import import { DepthLimitedBlurShader, BlurShaderUtils } from 'three/addons/shaders/DepthLimitedBlurShader.js';\n */\n\n/**\n * TODO\n *\n * Used by {@link SAOPass}.\n *\n * @constant\n * @type {ShaderMaterial~Shader}\n */\nconst DepthLimitedBlurShader = {\n\n\tname: 'DepthLimitedBlurShader',\n\n\tdefines: {\n\t\t'KERNEL_RADIUS': 4,\n\t\t'DEPTH_PACKING': 1,\n\t\t'PERSPECTIVE_CAMERA': 1\n\t},\n\n\tuniforms: {\n\t\t'tDiffuse': { value: null },\n\t\t'size': { value: new Vector2( 512, 512 ) },\n\t\t'sampleUvOffsets': { value: [ new Vector2( 0, 0 ) ] },\n\t\t'sampleWeights': { value: [ 1.0 ] },\n\t\t'tDepth': { value: null },\n\t\t'cameraNear': { value: 10 },\n\t\t'cameraFar': { value: 1000 },\n\t\t'depthCutoff': { value: 10 },\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\t#include <common>\n\n\t\tuniform vec2 size;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec2 vInvSize;\n\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tvInvSize = 1.0 / size;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\t#include <common>\n\t\t#include <packing>\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tuniform float depthCutoff;\n\n\t\tuniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\n\t\tuniform float sampleWeights[ KERNEL_RADIUS + 1 ];\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec2 vInvSize;\n\n\t\tfloat getDepth( const in vec2 screenPosition ) {\n\t\t\t#if DEPTH_PACKING == 1\n\t\t\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n\t\t\t#else\n\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\t\t\t#endif\n\t\t}\n\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#else\n\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#endif\n\t\t}\n\n\t\tvoid main() {\n\t\t\tfloat depth = getDepth( vUv );\n\t\t\tif( depth >= ( 1.0 - EPSILON ) ) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t\tfloat centerViewZ = -getViewZ( depth );\n\t\t\tbool rBreak = false, lBreak = false;\n\n\t\t\tfloat weightSum = sampleWeights[0];\n\t\t\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\n\n\t\t\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\n\n\t\t\t\tfloat sampleWeight = sampleWeights[i];\n\t\t\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\n\n\t\t\t\tvec2 sampleUv = vUv + sampleUvOffset;\n\t\t\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\n\n\t\t\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\n\n\t\t\t\tif( ! rBreak ) {\n\t\t\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\n\t\t\t\t\tweightSum += sampleWeight;\n\t\t\t\t}\n\n\t\t\t\tsampleUv = vUv - sampleUvOffset;\n\t\t\t\tviewZ = -getViewZ( getDepth( sampleUv ) );\n\n\t\t\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\n\n\t\t\t\tif( ! lBreak ) {\n\t\t\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\n\t\t\t\t\tweightSum += sampleWeight;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgl_FragColor = diffuseSum / weightSum;\n\t\t}`\n\n};\n\nconst BlurShaderUtils = {\n\n\tcreateSampleWeights: function ( kernelRadius, stdDev ) {\n\n\t\tconst weights = [];\n\n\t\tfor ( let i = 0; i <= kernelRadius; i ++ ) {\n\n\t\t\tweights.push( gaussian( i, stdDev ) );\n\n\t\t}\n\n\t\treturn weights;\n\n\t},\n\n\tcreateSampleOffsets: function ( kernelRadius, uvIncrement ) {\n\n\t\tconst offsets = [];\n\n\t\tfor ( let i = 0; i <= kernelRadius; i ++ ) {\n\n\t\t\toffsets.push( uvIncrement.clone().multiplyScalar( i ) );\n\n\t\t}\n\n\t\treturn offsets;\n\n\t},\n\n\tconfigure: function ( material, kernelRadius, stdDev, uvIncrement ) {\n\n\t\tmaterial.defines[ 'KERNEL_RADIUS' ] = kernelRadius;\n\t\tmaterial.uniforms[ 'sampleUvOffsets' ].value = BlurShaderUtils.createSampleOffsets( kernelRadius, uvIncrement );\n\t\tmaterial.uniforms[ 'sampleWeights' ].value = BlurShaderUtils.createSampleWeights( kernelRadius, stdDev );\n\t\tmaterial.needsUpdate = true;\n\n\t}\n\n};\n\nfunction gaussian( x, stdDev ) {\n\n\treturn Math.exp( - ( x * x ) / ( 2.0 * ( stdDev * stdDev ) ) ) / ( Math.sqrt( 2.0 * Math.PI ) * stdDev );\n\n}\n\nexport { DepthLimitedBlurShader, BlurShaderUtils };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}