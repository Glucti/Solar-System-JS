{"ast":null,"code":"import { AdditiveBlending, Color, DoubleSide, HalfFloatType, Matrix4, MeshDepthMaterial, NoBlending, RGBADepthPacking, ShaderMaterial, UniformsUtils, Vector2, Vector3, WebGLRenderTarget } from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\n/**\n * A pass for rendering outlines around selected objects.\n *\n * ```js\n * const resolution = new THREE.Vector2( window.innerWidth, window.innerHeight );\n * const outlinePass = new OutlinePass( resolution, scene, camera );\n * composer.addPass( outlinePass );\n * ```\n *\n * @augments Pass\n * @three_import import { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js';\n */\nclass OutlinePass extends Pass {\n  /**\n   * Constructs a new outline pass.\n   *\n   * @param {Vector2} [resolution] - The effect's resolution.\n   * @param {Scene} scene - The scene to render.\n   * @param {Camera} camera - The camera.\n   * @param {Array<Object3D>} [selectedObjects] - The selected 3D objects that should receive an outline.\n   *\n   */\n  constructor(resolution, scene, camera, selectedObjects) {\n    super();\n\n    /**\n     * The scene to render.\n     *\n     * @type {Object}\n     */\n    this.renderScene = scene;\n\n    /**\n     * The camera.\n     *\n     * @type {Object}\n     */\n    this.renderCamera = camera;\n\n    /**\n     * The selected 3D objects that should receive an outline.\n     *\n     * @type {Array<Object3D>}\n     */\n    this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\n\n    /**\n     * The visible edge color.\n     *\n     * @type {Color}\n     * @default (1,1,1)\n     */\n    this.visibleEdgeColor = new Color(1, 1, 1);\n\n    /**\n     * The hidden edge color.\n     *\n     * @type {Color}\n     * @default (0.1,0.04,0.02)\n     */\n    this.hiddenEdgeColor = new Color(0.1, 0.04, 0.02);\n\n    /**\n     * Can be used for an animated glow/pulse effect.\n     *\n     * @type {number}\n     * @default 0\n     */\n    this.edgeGlow = 0.0;\n\n    /**\n     * Whether to use a pattern texture for to highlight selected\n     * 3D objects or not.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    this.usePatternTexture = false;\n\n    /**\n     * Can be used to highlight selected 3D objects. Requires to set\n     * {@link OutlinePass#usePatternTexture} to `true`.\n     *\n     * @type {?Texture}\n     * @default null\n     */\n    this.patternTexture = null;\n\n    /**\n     * The edge thickness.\n     *\n     * @type {number}\n     * @default 1\n     */\n    this.edgeThickness = 1.0;\n\n    /**\n     * The edge strength.\n     *\n     * @type {number}\n     * @default 3\n     */\n    this.edgeStrength = 3.0;\n\n    /**\n     * The downsample ratio. The effect can be rendered in a much\n     * lower resolution than the beauty pass.\n     *\n     * @type {number}\n     * @default 2\n     */\n    this.downSampleRatio = 2;\n\n    /**\n     * The pulse period.\n     *\n     * @type {number}\n     * @default 0\n     */\n    this.pulsePeriod = 0;\n    this._visibilityCache = new Map();\n    this._selectionCache = new Set();\n\n    /**\n     * The effect's resolution.\n     *\n     * @type {Vector2}\n     * @default (256,256)\n     */\n    this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\n    const resx = Math.round(this.resolution.x / this.downSampleRatio);\n    const resy = Math.round(this.resolution.y / this.downSampleRatio);\n    this.renderTargetMaskBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y);\n    this.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';\n    this.renderTargetMaskBuffer.texture.generateMipmaps = false;\n    this.depthMaterial = new MeshDepthMaterial();\n    this.depthMaterial.side = DoubleSide;\n    this.depthMaterial.depthPacking = RGBADepthPacking;\n    this.depthMaterial.blending = NoBlending;\n    this.prepareMaskMaterial = this._getPrepareMaskMaterial();\n    this.prepareMaskMaterial.side = DoubleSide;\n    this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(this.prepareMaskMaterial.fragmentShader, this.renderCamera);\n    this.renderTargetDepthBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y, {\n      type: HalfFloatType\n    });\n    this.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';\n    this.renderTargetDepthBuffer.texture.generateMipmaps = false;\n    this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget(resx, resy, {\n      type: HalfFloatType\n    });\n    this.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';\n    this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n    this.renderTargetBlurBuffer1 = new WebGLRenderTarget(resx, resy, {\n      type: HalfFloatType\n    });\n    this.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';\n    this.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n    this.renderTargetBlurBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), {\n      type: HalfFloatType\n    });\n    this.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';\n    this.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n    this.edgeDetectionMaterial = this._getEdgeDetectionMaterial();\n    this.renderTargetEdgeBuffer1 = new WebGLRenderTarget(resx, resy, {\n      type: HalfFloatType\n    });\n    this.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';\n    this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n    this.renderTargetEdgeBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), {\n      type: HalfFloatType\n    });\n    this.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';\n    this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n    const MAX_EDGE_THICKNESS = 4;\n    const MAX_EDGE_GLOW = 4;\n    this.separableBlurMaterial1 = this._getSeparableBlurMaterial(MAX_EDGE_THICKNESS);\n    this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\n    this.separableBlurMaterial1.uniforms['kernelRadius'].value = 1;\n    this.separableBlurMaterial2 = this._getSeparableBlurMaterial(MAX_EDGE_GLOW);\n    this.separableBlurMaterial2.uniforms['texSize'].value.set(Math.round(resx / 2), Math.round(resy / 2));\n    this.separableBlurMaterial2.uniforms['kernelRadius'].value = MAX_EDGE_GLOW;\n\n    // Overlay material\n    this.overlayMaterial = this._getOverlayMaterial();\n\n    // copy material\n\n    const copyShader = CopyShader;\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    this.materialCopy = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false\n    });\n    this.enabled = true;\n    this.needsSwap = false;\n    this._oldClearColor = new Color();\n    this.oldClearAlpha = 1;\n    this._fsQuad = new FullScreenQuad(null);\n    this.tempPulseColor1 = new Color();\n    this.tempPulseColor2 = new Color();\n    this.textureMatrix = new Matrix4();\n    function replaceDepthToViewZ(string, camera) {\n      const type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\n      return string.replace(/DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ');\n    }\n  }\n\n  /**\n   * Frees the GPU-related resources allocated by this instance. Call this\n   * method whenever the pass is no longer used in your app.\n   */\n  dispose() {\n    this.renderTargetMaskBuffer.dispose();\n    this.renderTargetDepthBuffer.dispose();\n    this.renderTargetMaskDownSampleBuffer.dispose();\n    this.renderTargetBlurBuffer1.dispose();\n    this.renderTargetBlurBuffer2.dispose();\n    this.renderTargetEdgeBuffer1.dispose();\n    this.renderTargetEdgeBuffer2.dispose();\n    this.depthMaterial.dispose();\n    this.prepareMaskMaterial.dispose();\n    this.edgeDetectionMaterial.dispose();\n    this.separableBlurMaterial1.dispose();\n    this.separableBlurMaterial2.dispose();\n    this.overlayMaterial.dispose();\n    this.materialCopy.dispose();\n    this._fsQuad.dispose();\n  }\n\n  /**\n   * Sets the size of the pass.\n   *\n   * @param {number} width - The width to set.\n   * @param {number} height - The height to set.\n   */\n  setSize(width, height) {\n    this.renderTargetMaskBuffer.setSize(width, height);\n    this.renderTargetDepthBuffer.setSize(width, height);\n    let resx = Math.round(width / this.downSampleRatio);\n    let resy = Math.round(height / this.downSampleRatio);\n    this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);\n    this.renderTargetBlurBuffer1.setSize(resx, resy);\n    this.renderTargetEdgeBuffer1.setSize(resx, resy);\n    this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n    this.renderTargetBlurBuffer2.setSize(resx, resy);\n    this.renderTargetEdgeBuffer2.setSize(resx, resy);\n    this.separableBlurMaterial2.uniforms['texSize'].value.set(resx, resy);\n  }\n\n  /**\n   * Performs the Outline pass.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n   * destination for the pass.\n   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n   * previous pass from this buffer.\n   * @param {number} deltaTime - The delta time in seconds.\n   * @param {boolean} maskActive - Whether masking is active or not.\n   */\n  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    if (this.selectedObjects.length > 0) {\n      renderer.getClearColor(this._oldClearColor);\n      this.oldClearAlpha = renderer.getClearAlpha();\n      const oldAutoClear = renderer.autoClear;\n      renderer.autoClear = false;\n      if (maskActive) renderer.state.buffers.stencil.setTest(false);\n      renderer.setClearColor(0xffffff, 1);\n      this._updateSelectionCache();\n\n      // Make selected objects invisible\n      this._changeVisibilityOfSelectedObjects(false);\n      const currentBackground = this.renderScene.background;\n      const currentOverrideMaterial = this.renderScene.overrideMaterial;\n      this.renderScene.background = null;\n\n      // 1. Draw Non Selected objects in the depth buffer\n      this.renderScene.overrideMaterial = this.depthMaterial;\n      renderer.setRenderTarget(this.renderTargetDepthBuffer);\n      renderer.clear();\n      renderer.render(this.renderScene, this.renderCamera);\n\n      // Make selected objects visible\n      this._changeVisibilityOfSelectedObjects(true);\n      this._visibilityCache.clear();\n\n      // Update Texture Matrix for Depth compare\n      this._updateTextureMatrix();\n\n      // Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\n      this._changeVisibilityOfNonSelectedObjects(false);\n      this.renderScene.overrideMaterial = this.prepareMaskMaterial;\n      this.prepareMaskMaterial.uniforms['cameraNearFar'].value.set(this.renderCamera.near, this.renderCamera.far);\n      this.prepareMaskMaterial.uniforms['depthTexture'].value = this.renderTargetDepthBuffer.texture;\n      this.prepareMaskMaterial.uniforms['textureMatrix'].value = this.textureMatrix;\n      renderer.setRenderTarget(this.renderTargetMaskBuffer);\n      renderer.clear();\n      renderer.render(this.renderScene, this.renderCamera);\n      this._changeVisibilityOfNonSelectedObjects(true);\n      this._visibilityCache.clear();\n      this._selectionCache.clear();\n      this.renderScene.background = currentBackground;\n      this.renderScene.overrideMaterial = currentOverrideMaterial;\n\n      // 2. Downsample to Half resolution\n      this._fsQuad.material = this.materialCopy;\n      this.copyUniforms['tDiffuse'].value = this.renderTargetMaskBuffer.texture;\n      renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);\n      renderer.clear();\n      this._fsQuad.render(renderer);\n      this.tempPulseColor1.copy(this.visibleEdgeColor);\n      this.tempPulseColor2.copy(this.hiddenEdgeColor);\n      if (this.pulsePeriod > 0) {\n        const scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1.0 - 0.25) / 2;\n        this.tempPulseColor1.multiplyScalar(scalar);\n        this.tempPulseColor2.multiplyScalar(scalar);\n      }\n\n      // 3. Apply Edge Detection Pass\n      this._fsQuad.material = this.edgeDetectionMaterial;\n      this.edgeDetectionMaterial.uniforms['maskTexture'].value = this.renderTargetMaskDownSampleBuffer.texture;\n      this.edgeDetectionMaterial.uniforms['texSize'].value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);\n      this.edgeDetectionMaterial.uniforms['visibleEdgeColor'].value = this.tempPulseColor1;\n      this.edgeDetectionMaterial.uniforms['hiddenEdgeColor'].value = this.tempPulseColor2;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n      renderer.clear();\n      this._fsQuad.render(renderer);\n\n      // 4. Apply Blur on Half res\n      this._fsQuad.material = this.separableBlurMaterial1;\n      this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\n      this.separableBlurMaterial1.uniforms['direction'].value = OutlinePass.BlurDirectionX;\n      this.separableBlurMaterial1.uniforms['kernelRadius'].value = this.edgeThickness;\n      renderer.setRenderTarget(this.renderTargetBlurBuffer1);\n      renderer.clear();\n      this._fsQuad.render(renderer);\n      this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetBlurBuffer1.texture;\n      this.separableBlurMaterial1.uniforms['direction'].value = OutlinePass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n      renderer.clear();\n      this._fsQuad.render(renderer);\n\n      // Apply Blur on quarter res\n      this._fsQuad.material = this.separableBlurMaterial2;\n      this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\n      this.separableBlurMaterial2.uniforms['direction'].value = OutlinePass.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetBlurBuffer2);\n      renderer.clear();\n      this._fsQuad.render(renderer);\n      this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetBlurBuffer2.texture;\n      this.separableBlurMaterial2.uniforms['direction'].value = OutlinePass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer2);\n      renderer.clear();\n      this._fsQuad.render(renderer);\n\n      // Blend it additively over the input texture\n      this._fsQuad.material = this.overlayMaterial;\n      this.overlayMaterial.uniforms['maskTexture'].value = this.renderTargetMaskBuffer.texture;\n      this.overlayMaterial.uniforms['edgeTexture1'].value = this.renderTargetEdgeBuffer1.texture;\n      this.overlayMaterial.uniforms['edgeTexture2'].value = this.renderTargetEdgeBuffer2.texture;\n      this.overlayMaterial.uniforms['patternTexture'].value = this.patternTexture;\n      this.overlayMaterial.uniforms['edgeStrength'].value = this.edgeStrength;\n      this.overlayMaterial.uniforms['edgeGlow'].value = this.edgeGlow;\n      this.overlayMaterial.uniforms['usePatternTexture'].value = this.usePatternTexture;\n      if (maskActive) renderer.state.buffers.stencil.setTest(true);\n      renderer.setRenderTarget(readBuffer);\n      this._fsQuad.render(renderer);\n      renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n      renderer.autoClear = oldAutoClear;\n    }\n    if (this.renderToScreen) {\n      this._fsQuad.material = this.materialCopy;\n      this.copyUniforms['tDiffuse'].value = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      this._fsQuad.render(renderer);\n    }\n  }\n\n  // internals\n\n  _updateSelectionCache() {\n    const cache = this._selectionCache;\n    function gatherSelectedMeshesCallBack(object) {\n      if (object.isMesh) cache.add(object);\n    }\n    cache.clear();\n    for (let i = 0; i < this.selectedObjects.length; i++) {\n      const selectedObject = this.selectedObjects[i];\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\n    }\n  }\n  _changeVisibilityOfSelectedObjects(bVisible) {\n    const cache = this._visibilityCache;\n    for (const mesh of this._selectionCache) {\n      if (bVisible === true) {\n        mesh.visible = cache.get(mesh);\n      } else {\n        cache.set(mesh, mesh.visible);\n        mesh.visible = bVisible;\n      }\n    }\n  }\n  _changeVisibilityOfNonSelectedObjects(bVisible) {\n    const visibilityCache = this._visibilityCache;\n    const selectionCache = this._selectionCache;\n    function VisibilityChangeCallBack(object) {\n      if (object.isMesh || object.isSprite) {\n        // only meshes and sprites are supported by OutlinePass\n\n        if (!selectionCache.has(object)) {\n          const visibility = object.visible;\n          if (bVisible === false || visibilityCache.get(object) === true) {\n            object.visible = bVisible;\n          }\n          visibilityCache.set(object, visibility);\n        }\n      } else if (object.isPoints || object.isLine) {\n        // the visibility of points and lines is always set to false in order to\n        // not affect the outline computation\n\n        if (bVisible === true) {\n          object.visible = visibilityCache.get(object); // restore\n        } else {\n          visibilityCache.set(object, object.visible);\n          object.visible = bVisible;\n        }\n      }\n    }\n    this.renderScene.traverse(VisibilityChangeCallBack);\n  }\n  _updateTextureMatrix() {\n    this.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    this.textureMatrix.multiply(this.renderCamera.projectionMatrix);\n    this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);\n  }\n  _getPrepareMaskMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        'depthTexture': {\n          value: null\n        },\n        'cameraNearFar': {\n          value: new Vector2(0.5, 0.5)\n        },\n        'textureMatrix': {\n          value: null\n        }\n      },\n      vertexShader: `#include <batching_pars_vertex>\n\t\t\t\t#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tuniform mat4 textureMatrix;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <batching_vertex>\n\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t#include <skinning_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t\tvPosition = mvPosition;\n\n\t\t\t\t\tvec4 worldPosition = vec4( transformed, 1.0 );\n\n\t\t\t\t\t#ifdef USE_INSTANCING\n\n\t\t\t\t\t\tworldPosition = instanceMatrix * worldPosition;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tworldPosition = modelMatrix * worldPosition;\n\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\n\n\t\t\t\t}`,\n      fragmentShader: `#include <packing>\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tuniform sampler2D depthTexture;\n\t\t\t\tuniform vec2 cameraNearFar;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\n\t\t\t\t}`\n    });\n  }\n  _getEdgeDetectionMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        'maskTexture': {\n          value: null\n        },\n        'texSize': {\n          value: new Vector2(0.5, 0.5)\n        },\n        'visibleEdgeColor': {\n          value: new Vector3(1.0, 1.0, 1.0)\n        },\n        'hiddenEdgeColor': {\n          value: new Vector3(1.0, 1.0, 1.0)\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 visibleEdgeColor;\n\t\t\t\tuniform vec3 hiddenEdgeColor;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n\t\t\t\t}`\n    });\n  }\n  _getSeparableBlurMaterial(maxRadius) {\n    return new ShaderMaterial({\n      defines: {\n        'MAX_RADIUS': maxRadius\n      },\n      uniforms: {\n        'colorTexture': {\n          value: null\n        },\n        'texSize': {\n          value: new Vector2(0.5, 0.5)\n        },\n        'direction': {\n          value: new Vector2(0.5, 0.5)\n        },\n        'kernelRadius': {\n          value: 1.0\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat sigma = kernelRadius/2.0;\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, sigma);\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n\t\t\t\t\tvec2 uvOffset = delta;\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = kernelRadius * float(i) / float(MAX_RADIUS);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, sigma);\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\t\t\tuvOffset += delta;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\n\t\t\t\t}`\n    });\n  }\n  _getOverlayMaterial() {\n    return new ShaderMaterial({\n      uniforms: {\n        'maskTexture': {\n          value: null\n        },\n        'edgeTexture1': {\n          value: null\n        },\n        'edgeTexture2': {\n          value: null\n        },\n        'patternTexture': {\n          value: null\n        },\n        'edgeStrength': {\n          value: 1.0\n        },\n        'edgeGlow': {\n          value: 1.0\n        },\n        'usePatternTexture': {\n          value: 0.0\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture1;\n\t\t\t\tuniform sampler2D edgeTexture2;\n\t\t\t\tuniform sampler2D patternTexture;\n\t\t\t\tuniform float edgeStrength;\n\t\t\t\tuniform float edgeGlow;\n\t\t\t\tuniform bool usePatternTexture;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\n\t\t\t\t\tif(usePatternTexture)\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n\t\t\t\t\tgl_FragColor = finalColor;\n\t\t\t\t}`,\n      blending: AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n  }\n}\nOutlinePass.BlurDirectionX = new Vector2(1.0, 0.0);\nOutlinePass.BlurDirectionY = new Vector2(0.0, 1.0);\nexport { OutlinePass };","map":{"version":3,"names":["AdditiveBlending","Color","DoubleSide","HalfFloatType","Matrix4","MeshDepthMaterial","NoBlending","RGBADepthPacking","ShaderMaterial","UniformsUtils","Vector2","Vector3","WebGLRenderTarget","Pass","FullScreenQuad","CopyShader","OutlinePass","constructor","resolution","scene","camera","selectedObjects","renderScene","renderCamera","undefined","visibleEdgeColor","hiddenEdgeColor","edgeGlow","usePatternTexture","patternTexture","edgeThickness","edgeStrength","downSampleRatio","pulsePeriod","_visibilityCache","Map","_selectionCache","Set","x","y","resx","Math","round","resy","renderTargetMaskBuffer","texture","name","generateMipmaps","depthMaterial","side","depthPacking","blending","prepareMaskMaterial","_getPrepareMaskMaterial","fragmentShader","replaceDepthToViewZ","renderTargetDepthBuffer","type","renderTargetMaskDownSampleBuffer","renderTargetBlurBuffer1","renderTargetBlurBuffer2","edgeDetectionMaterial","_getEdgeDetectionMaterial","renderTargetEdgeBuffer1","renderTargetEdgeBuffer2","MAX_EDGE_THICKNESS","MAX_EDGE_GLOW","separableBlurMaterial1","_getSeparableBlurMaterial","uniforms","value","set","separableBlurMaterial2","overlayMaterial","_getOverlayMaterial","copyShader","copyUniforms","clone","materialCopy","vertexShader","depthTest","depthWrite","enabled","needsSwap","_oldClearColor","oldClearAlpha","_fsQuad","tempPulseColor1","tempPulseColor2","textureMatrix","string","isPerspectiveCamera","replace","dispose","setSize","width","height","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","length","getClearColor","getClearAlpha","oldAutoClear","autoClear","state","buffers","stencil","setTest","setClearColor","_updateSelectionCache","_changeVisibilityOfSelectedObjects","currentBackground","background","currentOverrideMaterial","overrideMaterial","setRenderTarget","clear","_updateTextureMatrix","_changeVisibilityOfNonSelectedObjects","near","far","material","copy","scalar","cos","performance","now","multiplyScalar","BlurDirectionX","BlurDirectionY","renderToScreen","cache","gatherSelectedMeshesCallBack","object","isMesh","add","i","selectedObject","traverse","bVisible","mesh","visible","get","visibilityCache","selectionCache","VisibilityChangeCallBack","isSprite","has","visibility","isPoints","isLine","multiply","projectionMatrix","matrixWorldInverse","maxRadius","defines","transparent"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/postprocessing/OutlinePass.js"],"sourcesContent":["import {\n\tAdditiveBlending,\n\tColor,\n\tDoubleSide,\n\tHalfFloatType,\n\tMatrix4,\n\tMeshDepthMaterial,\n\tNoBlending,\n\tRGBADepthPacking,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector2,\n\tVector3,\n\tWebGLRenderTarget\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\n/**\n * A pass for rendering outlines around selected objects.\n *\n * ```js\n * const resolution = new THREE.Vector2( window.innerWidth, window.innerHeight );\n * const outlinePass = new OutlinePass( resolution, scene, camera );\n * composer.addPass( outlinePass );\n * ```\n *\n * @augments Pass\n * @three_import import { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js';\n */\nclass OutlinePass extends Pass {\n\n\t/**\n\t * Constructs a new outline pass.\n\t *\n\t * @param {Vector2} [resolution] - The effect's resolution.\n\t * @param {Scene} scene - The scene to render.\n\t * @param {Camera} camera - The camera.\n\t * @param {Array<Object3D>} [selectedObjects] - The selected 3D objects that should receive an outline.\n\t *\n\t */\n\tconstructor( resolution, scene, camera, selectedObjects ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The scene to render.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.renderScene = scene;\n\n\t\t/**\n\t\t * The camera.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.renderCamera = camera;\n\n\t\t/**\n\t\t * The selected 3D objects that should receive an outline.\n\t\t *\n\t\t * @type {Array<Object3D>}\n\t\t */\n\t\tthis.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\n\n\t\t/**\n\t\t * The visible edge color.\n\t\t *\n\t\t * @type {Color}\n\t\t * @default (1,1,1)\n\t\t */\n\t\tthis.visibleEdgeColor = new Color( 1, 1, 1 );\n\n\t\t/**\n\t\t * The hidden edge color.\n\t\t *\n\t\t * @type {Color}\n\t\t * @default (0.1,0.04,0.02)\n\t\t */\n\t\tthis.hiddenEdgeColor = new Color( 0.1, 0.04, 0.02 );\n\n\t\t/**\n\t\t * Can be used for an animated glow/pulse effect.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.edgeGlow = 0.0;\n\n\t\t/**\n\t\t * Whether to use a pattern texture for to highlight selected\n\t\t * 3D objects or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.usePatternTexture = false;\n\n\t\t/**\n\t\t * Can be used to highlight selected 3D objects. Requires to set\n\t\t * {@link OutlinePass#usePatternTexture} to `true`.\n\t\t *\n\t\t * @type {?Texture}\n\t\t * @default null\n\t\t */\n\t\tthis.patternTexture = null;\n\n\t\t/**\n\t\t * The edge thickness.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.edgeThickness = 1.0;\n\n\t\t/**\n\t\t * The edge strength.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 3\n\t\t */\n\t\tthis.edgeStrength = 3.0;\n\n\t\t/**\n\t\t * The downsample ratio. The effect can be rendered in a much\n\t\t * lower resolution than the beauty pass.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 2\n\t\t */\n\t\tthis.downSampleRatio = 2;\n\n\t\t/**\n\t\t * The pulse period.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.pulsePeriod = 0;\n\n\t\tthis._visibilityCache = new Map();\n\t\tthis._selectionCache = new Set();\n\n\t\t/**\n\t\t * The effect's resolution.\n\t\t *\n\t\t * @type {Vector2}\n\t\t * @default (256,256)\n\t\t */\n\t\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\n\n\t\tconst resx = Math.round( this.resolution.x / this.downSampleRatio );\n\t\tconst resy = Math.round( this.resolution.y / this.downSampleRatio );\n\n\t\tthis.renderTargetMaskBuffer = new WebGLRenderTarget( this.resolution.x, this.resolution.y );\n\t\tthis.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';\n\t\tthis.renderTargetMaskBuffer.texture.generateMipmaps = false;\n\n\t\tthis.depthMaterial = new MeshDepthMaterial();\n\t\tthis.depthMaterial.side = DoubleSide;\n\t\tthis.depthMaterial.depthPacking = RGBADepthPacking;\n\t\tthis.depthMaterial.blending = NoBlending;\n\n\t\tthis.prepareMaskMaterial = this._getPrepareMaskMaterial();\n\t\tthis.prepareMaskMaterial.side = DoubleSide;\n\t\tthis.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ( this.prepareMaskMaterial.fragmentShader, this.renderCamera );\n\n\t\tthis.renderTargetDepthBuffer = new WebGLRenderTarget( this.resolution.x, this.resolution.y, { type: HalfFloatType } );\n\t\tthis.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';\n\t\tthis.renderTargetDepthBuffer.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\n\t\tthis.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';\n\t\tthis.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetBlurBuffer1 = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\n\t\tthis.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';\n\t\tthis.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n\t\tthis.renderTargetBlurBuffer2 = new WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ), { type: HalfFloatType } );\n\t\tthis.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';\n\t\tthis.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n\n\t\tthis.edgeDetectionMaterial = this._getEdgeDetectionMaterial();\n\t\tthis.renderTargetEdgeBuffer1 = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\n\t\tthis.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';\n\t\tthis.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n\t\tthis.renderTargetEdgeBuffer2 = new WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ), { type: HalfFloatType } );\n\t\tthis.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';\n\t\tthis.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n\n\t\tconst MAX_EDGE_THICKNESS = 4;\n\t\tconst MAX_EDGE_GLOW = 4;\n\n\t\tthis.separableBlurMaterial1 = this._getSeparableBlurMaterial( MAX_EDGE_THICKNESS );\n\t\tthis.separableBlurMaterial1.uniforms[ 'texSize' ].value.set( resx, resy );\n\t\tthis.separableBlurMaterial1.uniforms[ 'kernelRadius' ].value = 1;\n\t\tthis.separableBlurMaterial2 = this._getSeparableBlurMaterial( MAX_EDGE_GLOW );\n\t\tthis.separableBlurMaterial2.uniforms[ 'texSize' ].value.set( Math.round( resx / 2 ), Math.round( resy / 2 ) );\n\t\tthis.separableBlurMaterial2.uniforms[ 'kernelRadius' ].value = MAX_EDGE_GLOW;\n\n\t\t// Overlay material\n\t\tthis.overlayMaterial = this._getOverlayMaterial();\n\n\t\t// copy material\n\n\t\tconst copyShader = CopyShader;\n\n\t\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\n\n\t\tthis.materialCopy = new ShaderMaterial( {\n\t\t\tuniforms: this.copyUniforms,\n\t\t\tvertexShader: copyShader.vertexShader,\n\t\t\tfragmentShader: copyShader.fragmentShader,\n\t\t\tblending: NoBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false\n\t\t} );\n\n\t\tthis.enabled = true;\n\t\tthis.needsSwap = false;\n\n\t\tthis._oldClearColor = new Color();\n\t\tthis.oldClearAlpha = 1;\n\n\t\tthis._fsQuad = new FullScreenQuad( null );\n\n\t\tthis.tempPulseColor1 = new Color();\n\t\tthis.tempPulseColor2 = new Color();\n\t\tthis.textureMatrix = new Matrix4();\n\n\t\tfunction replaceDepthToViewZ( string, camera ) {\n\n\t\t\tconst type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\n\n\t\t\treturn string.replace( /DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the pass is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis.renderTargetMaskBuffer.dispose();\n\t\tthis.renderTargetDepthBuffer.dispose();\n\t\tthis.renderTargetMaskDownSampleBuffer.dispose();\n\t\tthis.renderTargetBlurBuffer1.dispose();\n\t\tthis.renderTargetBlurBuffer2.dispose();\n\t\tthis.renderTargetEdgeBuffer1.dispose();\n\t\tthis.renderTargetEdgeBuffer2.dispose();\n\n\t\tthis.depthMaterial.dispose();\n\t\tthis.prepareMaskMaterial.dispose();\n\t\tthis.edgeDetectionMaterial.dispose();\n\t\tthis.separableBlurMaterial1.dispose();\n\t\tthis.separableBlurMaterial2.dispose();\n\t\tthis.overlayMaterial.dispose();\n\t\tthis.materialCopy.dispose();\n\n\t\tthis._fsQuad.dispose();\n\n\t}\n\n\t/**\n\t * Sets the size of the pass.\n\t *\n\t * @param {number} width - The width to set.\n\t * @param {number} height - The height to set.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis.renderTargetMaskBuffer.setSize( width, height );\n\t\tthis.renderTargetDepthBuffer.setSize( width, height );\n\n\t\tlet resx = Math.round( width / this.downSampleRatio );\n\t\tlet resy = Math.round( height / this.downSampleRatio );\n\t\tthis.renderTargetMaskDownSampleBuffer.setSize( resx, resy );\n\t\tthis.renderTargetBlurBuffer1.setSize( resx, resy );\n\t\tthis.renderTargetEdgeBuffer1.setSize( resx, resy );\n\t\tthis.separableBlurMaterial1.uniforms[ 'texSize' ].value.set( resx, resy );\n\n\t\tresx = Math.round( resx / 2 );\n\t\tresy = Math.round( resy / 2 );\n\n\t\tthis.renderTargetBlurBuffer2.setSize( resx, resy );\n\t\tthis.renderTargetEdgeBuffer2.setSize( resx, resy );\n\n\t\tthis.separableBlurMaterial2.uniforms[ 'texSize' ].value.set( resx, resy );\n\n\t}\n\n\t/**\n\t * Performs the Outline pass.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\n\n\t\tif ( this.selectedObjects.length > 0 ) {\n\n\t\t\trenderer.getClearColor( this._oldClearColor );\n\t\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\t\tconst oldAutoClear = renderer.autoClear;\n\n\t\t\trenderer.autoClear = false;\n\n\t\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\n\n\t\t\trenderer.setClearColor( 0xffffff, 1 );\n\n\t\t\tthis._updateSelectionCache();\n\n\t\t\t// Make selected objects invisible\n\t\t\tthis._changeVisibilityOfSelectedObjects( false );\n\n\t\t\tconst currentBackground = this.renderScene.background;\n\t\t\tconst currentOverrideMaterial = this.renderScene.overrideMaterial;\n\t\t\tthis.renderScene.background = null;\n\n\t\t\t// 1. Draw Non Selected objects in the depth buffer\n\t\t\tthis.renderScene.overrideMaterial = this.depthMaterial;\n\t\t\trenderer.setRenderTarget( this.renderTargetDepthBuffer );\n\t\t\trenderer.clear();\n\t\t\trenderer.render( this.renderScene, this.renderCamera );\n\n\t\t\t// Make selected objects visible\n\t\t\tthis._changeVisibilityOfSelectedObjects( true );\n\t\t\tthis._visibilityCache.clear();\n\n\t\t\t// Update Texture Matrix for Depth compare\n\t\t\tthis._updateTextureMatrix();\n\n\t\t\t// Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\n\t\t\tthis._changeVisibilityOfNonSelectedObjects( false );\n\t\t\tthis.renderScene.overrideMaterial = this.prepareMaskMaterial;\n\t\t\tthis.prepareMaskMaterial.uniforms[ 'cameraNearFar' ].value.set( this.renderCamera.near, this.renderCamera.far );\n\t\t\tthis.prepareMaskMaterial.uniforms[ 'depthTexture' ].value = this.renderTargetDepthBuffer.texture;\n\t\t\tthis.prepareMaskMaterial.uniforms[ 'textureMatrix' ].value = this.textureMatrix;\n\t\t\trenderer.setRenderTarget( this.renderTargetMaskBuffer );\n\t\t\trenderer.clear();\n\t\t\trenderer.render( this.renderScene, this.renderCamera );\n\t\t\tthis._changeVisibilityOfNonSelectedObjects( true );\n\t\t\tthis._visibilityCache.clear();\n\t\t\tthis._selectionCache.clear();\n\n\t\t\tthis.renderScene.background = currentBackground;\n\t\t\tthis.renderScene.overrideMaterial = currentOverrideMaterial;\n\n\t\t\t// 2. Downsample to Half resolution\n\t\t\tthis._fsQuad.material = this.materialCopy;\n\t\t\tthis.copyUniforms[ 'tDiffuse' ].value = this.renderTargetMaskBuffer.texture;\n\t\t\trenderer.setRenderTarget( this.renderTargetMaskDownSampleBuffer );\n\t\t\trenderer.clear();\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t\tthis.tempPulseColor1.copy( this.visibleEdgeColor );\n\t\t\tthis.tempPulseColor2.copy( this.hiddenEdgeColor );\n\n\t\t\tif ( this.pulsePeriod > 0 ) {\n\n\t\t\t\tconst scalar = ( 1 + 0.25 ) / 2 + Math.cos( performance.now() * 0.01 / this.pulsePeriod ) * ( 1.0 - 0.25 ) / 2;\n\t\t\t\tthis.tempPulseColor1.multiplyScalar( scalar );\n\t\t\t\tthis.tempPulseColor2.multiplyScalar( scalar );\n\n\t\t\t}\n\n\t\t\t// 3. Apply Edge Detection Pass\n\t\t\tthis._fsQuad.material = this.edgeDetectionMaterial;\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'maskTexture' ].value = this.renderTargetMaskDownSampleBuffer.texture;\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'texSize' ].value.set( this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height );\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'visibleEdgeColor' ].value = this.tempPulseColor1;\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'hiddenEdgeColor' ].value = this.tempPulseColor2;\n\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer1 );\n\t\t\trenderer.clear();\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t\t// 4. Apply Blur on Half res\n\t\t\tthis._fsQuad.material = this.separableBlurMaterial1;\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'colorTexture' ].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionX;\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'kernelRadius' ].value = this.edgeThickness;\n\t\t\trenderer.setRenderTarget( this.renderTargetBlurBuffer1 );\n\t\t\trenderer.clear();\n\t\t\tthis._fsQuad.render( renderer );\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'colorTexture' ].value = this.renderTargetBlurBuffer1.texture;\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer1 );\n\t\t\trenderer.clear();\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t\t// Apply Blur on quarter res\n\t\t\tthis._fsQuad.material = this.separableBlurMaterial2;\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'colorTexture' ].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionX;\n\t\t\trenderer.setRenderTarget( this.renderTargetBlurBuffer2 );\n\t\t\trenderer.clear();\n\t\t\tthis._fsQuad.render( renderer );\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'colorTexture' ].value = this.renderTargetBlurBuffer2.texture;\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer2 );\n\t\t\trenderer.clear();\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t\t// Blend it additively over the input texture\n\t\t\tthis._fsQuad.material = this.overlayMaterial;\n\t\t\tthis.overlayMaterial.uniforms[ 'maskTexture' ].value = this.renderTargetMaskBuffer.texture;\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeTexture1' ].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeTexture2' ].value = this.renderTargetEdgeBuffer2.texture;\n\t\t\tthis.overlayMaterial.uniforms[ 'patternTexture' ].value = this.patternTexture;\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeStrength' ].value = this.edgeStrength;\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeGlow' ].value = this.edgeGlow;\n\t\t\tthis.overlayMaterial.uniforms[ 'usePatternTexture' ].value = this.usePatternTexture;\n\n\n\t\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\n\n\t\t\trenderer.setRenderTarget( readBuffer );\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t\trenderer.setClearColor( this._oldClearColor, this.oldClearAlpha );\n\t\t\trenderer.autoClear = oldAutoClear;\n\n\t\t}\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\tthis._fsQuad.material = this.materialCopy;\n\t\t\tthis.copyUniforms[ 'tDiffuse' ].value = readBuffer.texture;\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t}\n\n\t}\n\n\t// internals\n\n\t_updateSelectionCache() {\n\n\t\tconst cache = this._selectionCache;\n\n\t\tfunction gatherSelectedMeshesCallBack( object ) {\n\n\t\t\tif ( object.isMesh ) cache.add( object );\n\n\t\t}\n\n\t\tcache.clear();\n\n\t\tfor ( let i = 0; i < this.selectedObjects.length; i ++ ) {\n\n\t\t\tconst selectedObject = this.selectedObjects[ i ];\n\t\t\tselectedObject.traverse( gatherSelectedMeshesCallBack );\n\n\t\t}\n\n\t}\n\n\t_changeVisibilityOfSelectedObjects( bVisible ) {\n\n\t\tconst cache = this._visibilityCache;\n\n\t\tfor ( const mesh of this._selectionCache ) {\n\n\t\t\tif ( bVisible === true ) {\n\n\t\t\t\tmesh.visible = cache.get( mesh );\n\n\t\t\t} else {\n\n\t\t\t\tcache.set( mesh, mesh.visible );\n\t\t\t\tmesh.visible = bVisible;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_changeVisibilityOfNonSelectedObjects( bVisible ) {\n\n\t\tconst visibilityCache = this._visibilityCache;\n\t\tconst selectionCache = this._selectionCache;\n\n\t\tfunction VisibilityChangeCallBack( object ) {\n\n\t\t\tif ( object.isMesh || object.isSprite ) {\n\n\t\t\t\t// only meshes and sprites are supported by OutlinePass\n\n\t\t\t\tif ( ! selectionCache.has( object ) ) {\n\n\t\t\t\t\tconst visibility = object.visible;\n\n\t\t\t\t\tif ( bVisible === false || visibilityCache.get( object ) === true ) {\n\n\t\t\t\t\t\tobject.visible = bVisible;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvisibilityCache.set( object, visibility );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isPoints || object.isLine ) {\n\n\t\t\t\t// the visibility of points and lines is always set to false in order to\n\t\t\t\t// not affect the outline computation\n\n\t\t\t\tif ( bVisible === true ) {\n\n\t\t\t\t\tobject.visible = visibilityCache.get( object ); // restore\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvisibilityCache.set( object, object.visible );\n\t\t\t\t\tobject.visible = bVisible;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.renderScene.traverse( VisibilityChangeCallBack );\n\n\t}\n\n\t_updateTextureMatrix() {\n\n\t\tthis.textureMatrix.set( 0.5, 0.0, 0.0, 0.5,\n\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t0.0, 0.0, 0.0, 1.0 );\n\t\tthis.textureMatrix.multiply( this.renderCamera.projectionMatrix );\n\t\tthis.textureMatrix.multiply( this.renderCamera.matrixWorldInverse );\n\n\t}\n\n\t_getPrepareMaskMaterial() {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tuniforms: {\n\t\t\t\t'depthTexture': { value: null },\n\t\t\t\t'cameraNearFar': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'textureMatrix': { value: null }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`#include <batching_pars_vertex>\n\t\t\t\t#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tuniform mat4 textureMatrix;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <batching_vertex>\n\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t#include <skinning_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t\tvPosition = mvPosition;\n\n\t\t\t\t\tvec4 worldPosition = vec4( transformed, 1.0 );\n\n\t\t\t\t\t#ifdef USE_INSTANCING\n\n\t\t\t\t\t\tworldPosition = instanceMatrix * worldPosition;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tworldPosition = modelMatrix * worldPosition;\n\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\n\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`#include <packing>\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tuniform sampler2D depthTexture;\n\t\t\t\tuniform vec2 cameraNearFar;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\n\t\t\t\t}`\n\n\t\t} );\n\n\t}\n\n\t_getEdgeDetectionMaterial() {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tuniforms: {\n\t\t\t\t'maskTexture': { value: null },\n\t\t\t\t'texSize': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'visibleEdgeColor': { value: new Vector3( 1.0, 1.0, 1.0 ) },\n\t\t\t\t'hiddenEdgeColor': { value: new Vector3( 1.0, 1.0, 1.0 ) },\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 visibleEdgeColor;\n\t\t\t\tuniform vec3 hiddenEdgeColor;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n\t_getSeparableBlurMaterial( maxRadius ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'MAX_RADIUS': maxRadius,\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'colorTexture': { value: null },\n\t\t\t\t'texSize': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'direction': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'kernelRadius': { value: 1.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat sigma = kernelRadius/2.0;\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, sigma);\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n\t\t\t\t\tvec2 uvOffset = delta;\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = kernelRadius * float(i) / float(MAX_RADIUS);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, sigma);\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\t\t\tuvOffset += delta;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n\t_getOverlayMaterial() {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tuniforms: {\n\t\t\t\t'maskTexture': { value: null },\n\t\t\t\t'edgeTexture1': { value: null },\n\t\t\t\t'edgeTexture2': { value: null },\n\t\t\t\t'patternTexture': { value: null },\n\t\t\t\t'edgeStrength': { value: 1.0 },\n\t\t\t\t'edgeGlow': { value: 1.0 },\n\t\t\t\t'usePatternTexture': { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture1;\n\t\t\t\tuniform sampler2D edgeTexture2;\n\t\t\t\tuniform sampler2D patternTexture;\n\t\t\t\tuniform float edgeStrength;\n\t\t\t\tuniform float edgeGlow;\n\t\t\t\tuniform bool usePatternTexture;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\n\t\t\t\t\tif(usePatternTexture)\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n\t\t\t\t\tgl_FragColor = finalColor;\n\t\t\t\t}`,\n\t\t\tblending: AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t}\n\n}\n\nOutlinePass.BlurDirectionX = new Vector2( 1.0, 0.0 );\nOutlinePass.BlurDirectionY = new Vector2( 0.0, 1.0 );\n\nexport { OutlinePass };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}