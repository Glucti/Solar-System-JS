{"ast":null,"code":"import { Matrix3, Vector3, Color, ColorManagement, SRGBColorSpace } from 'three';\n\n/**\n * An exporter for PLY.\n *\n * PLY (Polygon or Stanford Triangle Format) is a file format for efficient delivery and\n * loading of simple, static 3D content in a dense format. Both binary and ascii formats are\n * supported. PLY can store vertex positions, colors, normals and uv coordinates. No textures\n * or texture references are saved.\n *\n * ```js\n * const exporter = new PLYExporter();\n * const data = exporter.parse( scene, options );\n * ```\n *\n * @three_import import { PLYExporter } from 'three/addons/exporters/PLYExporter.js';\n */\nclass PLYExporter {\n  /**\n   * Parses the given 3D object and generates the PLY output.\n   *\n   * If the 3D object is composed of multiple children and geometry, they are merged into a single mesh in the file.\n   *\n   * @param {Object3D} object - The 3D object to export.\n   * @param {PLYExporter~OnDone} onDone - A callback function that is executed when the export has finished.\n   * @param {PLYExporter~Options} options - The export options.\n   * @return {?string|ArrayBuffer} The exported PLY.\n   */\n  parse(object, onDone, options = {}) {\n    // reference https://github.com/gkjohnson/ply-exporter-js\n\n    // Iterate over the valid meshes in the object\n    function traverseMeshes(cb) {\n      object.traverse(function (child) {\n        if (child.isMesh === true || child.isPoints) {\n          const mesh = child;\n          const geometry = mesh.geometry;\n          if (geometry.hasAttribute('position') === true) {\n            cb(mesh, geometry);\n          }\n        }\n      });\n    }\n\n    // Default options\n    const defaultOptions = {\n      binary: false,\n      excludeAttributes: [],\n      // normal, uv, color, index\n      littleEndian: false\n    };\n    options = Object.assign(defaultOptions, options);\n    const excludeAttributes = options.excludeAttributes;\n    let includeIndices = true;\n    let includeNormals = false;\n    let includeColors = false;\n    let includeUVs = false;\n\n    // count the vertices, check which properties are used,\n    // and cache the BufferGeometry\n    let vertexCount = 0;\n    let faceCount = 0;\n    object.traverse(function (child) {\n      if (child.isMesh === true) {\n        const mesh = child;\n        const geometry = mesh.geometry;\n        const vertices = geometry.getAttribute('position');\n        const normals = geometry.getAttribute('normal');\n        const uvs = geometry.getAttribute('uv');\n        const colors = geometry.getAttribute('color');\n        const indices = geometry.getIndex();\n        if (vertices === undefined) {\n          return;\n        }\n        vertexCount += vertices.count;\n        faceCount += indices ? indices.count / 3 : vertices.count / 3;\n        if (normals !== undefined) includeNormals = true;\n        if (uvs !== undefined) includeUVs = true;\n        if (colors !== undefined) includeColors = true;\n      } else if (child.isPoints) {\n        const mesh = child;\n        const geometry = mesh.geometry;\n        const vertices = geometry.getAttribute('position');\n        const normals = geometry.getAttribute('normal');\n        const colors = geometry.getAttribute('color');\n        vertexCount += vertices.count;\n        if (normals !== undefined) includeNormals = true;\n        if (colors !== undefined) includeColors = true;\n        includeIndices = false;\n      }\n    });\n    const tempColor = new Color();\n    includeIndices = includeIndices && excludeAttributes.indexOf('index') === -1;\n    includeNormals = includeNormals && excludeAttributes.indexOf('normal') === -1;\n    includeColors = includeColors && excludeAttributes.indexOf('color') === -1;\n    includeUVs = includeUVs && excludeAttributes.indexOf('uv') === -1;\n    if (includeIndices && faceCount !== Math.floor(faceCount)) {\n      // point cloud meshes will not have an index array and may not have a\n      // number of vertices that is divisible by 3 (and therefore representable\n      // as triangles)\n      console.error('PLYExporter: Failed to generate a valid PLY file with triangle indices because the ' + 'number of indices is not divisible by 3.');\n      return null;\n    }\n    const indexByteCount = 4;\n    let header = 'ply\\n' + `format ${options.binary ? options.littleEndian ? 'binary_little_endian' : 'binary_big_endian' : 'ascii'} 1.0\\n` + `element vertex ${vertexCount}\\n` +\n    // position\n    'property float x\\n' + 'property float y\\n' + 'property float z\\n';\n    if (includeNormals === true) {\n      // normal\n      header += 'property float nx\\n' + 'property float ny\\n' + 'property float nz\\n';\n    }\n    if (includeUVs === true) {\n      // uvs\n      header += 'property float s\\n' + 'property float t\\n';\n    }\n    if (includeColors === true) {\n      // colors\n      header += 'property uchar red\\n' + 'property uchar green\\n' + 'property uchar blue\\n';\n    }\n    if (includeIndices === true) {\n      // faces\n      header += `element face ${faceCount}\\n` + 'property list uchar int vertex_index\\n';\n    }\n    header += 'end_header\\n';\n\n    // Generate attribute data\n    const vertex = new Vector3();\n    const normalMatrixWorld = new Matrix3();\n    let result = null;\n    if (options.binary === true) {\n      // Binary File Generation\n      const headerBin = new TextEncoder().encode(header);\n\n      // 3 position values at 4 bytes\n      // 3 normal values at 4 bytes\n      // 3 color channels with 1 byte\n      // 2 uv values at 4 bytes\n      const vertexListLength = vertexCount * (4 * 3 + (includeNormals ? 4 * 3 : 0) + (includeColors ? 3 : 0) + (includeUVs ? 4 * 2 : 0));\n\n      // 1 byte shape descriptor\n      // 3 vertex indices at ${indexByteCount} bytes\n      const faceListLength = includeIndices ? faceCount * (indexByteCount * 3 + 1) : 0;\n      const output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength));\n      new Uint8Array(output.buffer).set(headerBin, 0);\n      let vOffset = headerBin.length;\n      let fOffset = headerBin.length + vertexListLength;\n      let writtenVertices = 0;\n      traverseMeshes(function (mesh, geometry) {\n        const vertices = geometry.getAttribute('position');\n        const normals = geometry.getAttribute('normal');\n        const uvs = geometry.getAttribute('uv');\n        const colors = geometry.getAttribute('color');\n        const indices = geometry.getIndex();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.fromBufferAttribute(vertices, i);\n          vertex.applyMatrix4(mesh.matrixWorld);\n\n          // Position information\n          output.setFloat32(vOffset, vertex.x, options.littleEndian);\n          vOffset += 4;\n          output.setFloat32(vOffset, vertex.y, options.littleEndian);\n          vOffset += 4;\n          output.setFloat32(vOffset, vertex.z, options.littleEndian);\n          vOffset += 4;\n\n          // Normal information\n          if (includeNormals === true) {\n            if (normals != null) {\n              vertex.fromBufferAttribute(normals, i);\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\n              output.setFloat32(vOffset, vertex.x, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, vertex.y, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, vertex.z, options.littleEndian);\n              vOffset += 4;\n            } else {\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n            }\n          }\n\n          // UV information\n          if (includeUVs === true) {\n            if (uvs != null) {\n              output.setFloat32(vOffset, uvs.getX(i), options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, uvs.getY(i), options.littleEndian);\n              vOffset += 4;\n            } else {\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n            }\n          }\n\n          // Color information\n          if (includeColors === true) {\n            if (colors != null) {\n              tempColor.fromBufferAttribute(colors, i);\n              ColorManagement.workingToColorSpace(tempColor, SRGBColorSpace);\n              output.setUint8(vOffset, Math.floor(tempColor.r * 255));\n              vOffset += 1;\n              output.setUint8(vOffset, Math.floor(tempColor.g * 255));\n              vOffset += 1;\n              output.setUint8(vOffset, Math.floor(tempColor.b * 255));\n              vOffset += 1;\n            } else {\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n            }\n          }\n        }\n        if (includeIndices === true) {\n          // Create the face list\n\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3);\n              fOffset += 1;\n              output.setUint32(fOffset, indices.getX(i + 0) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, indices.getX(i + 1) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, indices.getX(i + 2) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3);\n              fOffset += 1;\n              output.setUint32(fOffset, writtenVertices + i, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, writtenVertices + i + 1, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, writtenVertices + i + 2, options.littleEndian);\n              fOffset += indexByteCount;\n            }\n          }\n        }\n\n        // Save the amount of verts we've already written so we can offset\n        // the face index on the next mesh\n        writtenVertices += vertices.count;\n      });\n      result = output.buffer;\n    } else {\n      // Ascii File Generation\n      // count the number of vertices\n      let writtenVertices = 0;\n      let vertexList = '';\n      let faceList = '';\n      traverseMeshes(function (mesh, geometry) {\n        const vertices = geometry.getAttribute('position');\n        const normals = geometry.getAttribute('normal');\n        const uvs = geometry.getAttribute('uv');\n        const colors = geometry.getAttribute('color');\n        const indices = geometry.getIndex();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n\n        // form each line\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.fromBufferAttribute(vertices, i);\n          vertex.applyMatrix4(mesh.matrixWorld);\n\n          // Position information\n          let line = vertex.x + ' ' + vertex.y + ' ' + vertex.z;\n\n          // Normal information\n          if (includeNormals === true) {\n            if (normals != null) {\n              vertex.fromBufferAttribute(normals, i);\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\n              line += ' ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z;\n            } else {\n              line += ' 0 0 0';\n            }\n          }\n\n          // UV information\n          if (includeUVs === true) {\n            if (uvs != null) {\n              line += ' ' + uvs.getX(i) + ' ' + uvs.getY(i);\n            } else {\n              line += ' 0 0';\n            }\n          }\n\n          // Color information\n          if (includeColors === true) {\n            if (colors != null) {\n              tempColor.fromBufferAttribute(colors, i);\n              ColorManagement.workingToColorSpace(tempColor, SRGBColorSpace);\n              line += ' ' + Math.floor(tempColor.r * 255) + ' ' + Math.floor(tempColor.g * 255) + ' ' + Math.floor(tempColor.b * 255);\n            } else {\n              line += ' 255 255 255';\n            }\n          }\n          vertexList += line + '\\n';\n        }\n\n        // Create the face list\n        if (includeIndices === true) {\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              faceList += `3 ${indices.getX(i + 0) + writtenVertices}`;\n              faceList += ` ${indices.getX(i + 1) + writtenVertices}`;\n              faceList += ` ${indices.getX(i + 2) + writtenVertices}\\n`;\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              faceList += `3 ${writtenVertices + i} ${writtenVertices + i + 1} ${writtenVertices + i + 2}\\n`;\n            }\n          }\n          faceCount += indices ? indices.count / 3 : vertices.count / 3;\n        }\n        writtenVertices += vertices.count;\n      });\n      result = `${header}${vertexList}${includeIndices ? `${faceList}\\n` : '\\n'}`;\n    }\n    if (typeof onDone === 'function') requestAnimationFrame(() => onDone(result));\n    return result;\n  }\n}\n\n/**\n * Export options of `PLYExporter`.\n *\n * @typedef {Object} PLYExporter~Options\n * @property {boolean} [binary=false] - Whether to export in binary format or ASCII.\n * @property {Array<string>} [excludeAttributes] - Which properties to explicitly exclude from\n * the exported PLY file. Valid values are `'color'`, `'normal'`, `'uv'`, and `'index'`. If triangle\n * indices are excluded, then a point cloud is exported.\n * @property {boolean} [littleEndian=false] - Whether the binary export uses little or big endian.\n **/\n\n/**\n * onDone callback of `PLYExporter`.\n *\n * @callback PLYExporter~OnDone\n * @param {string|ArrayBuffer} result - The generated PLY ascii or binary.\n */\n\nexport { PLYExporter };","map":{"version":3,"names":["Matrix3","Vector3","Color","ColorManagement","SRGBColorSpace","PLYExporter","parse","object","onDone","options","traverseMeshes","cb","traverse","child","isMesh","isPoints","mesh","geometry","hasAttribute","defaultOptions","binary","excludeAttributes","littleEndian","Object","assign","includeIndices","includeNormals","includeColors","includeUVs","vertexCount","faceCount","vertices","getAttribute","normals","uvs","colors","indices","getIndex","undefined","count","tempColor","indexOf","Math","floor","console","error","indexByteCount","header","vertex","normalMatrixWorld","result","headerBin","TextEncoder","encode","vertexListLength","faceListLength","output","DataView","ArrayBuffer","length","Uint8Array","buffer","set","vOffset","fOffset","writtenVertices","getNormalMatrix","matrixWorld","i","l","fromBufferAttribute","applyMatrix4","setFloat32","x","y","z","applyMatrix3","normalize","getX","getY","workingToColorSpace","setUint8","r","g","b","setUint32","vertexList","faceList","line","requestAnimationFrame"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/exporters/PLYExporter.js"],"sourcesContent":["import {\n\tMatrix3,\n\tVector3,\n\tColor,\n\tColorManagement,\n\tSRGBColorSpace\n} from 'three';\n\n/**\n * An exporter for PLY.\n *\n * PLY (Polygon or Stanford Triangle Format) is a file format for efficient delivery and\n * loading of simple, static 3D content in a dense format. Both binary and ascii formats are\n * supported. PLY can store vertex positions, colors, normals and uv coordinates. No textures\n * or texture references are saved.\n *\n * ```js\n * const exporter = new PLYExporter();\n * const data = exporter.parse( scene, options );\n * ```\n *\n * @three_import import { PLYExporter } from 'three/addons/exporters/PLYExporter.js';\n */\nclass PLYExporter {\n\n\t/**\n\t * Parses the given 3D object and generates the PLY output.\n\t *\n\t * If the 3D object is composed of multiple children and geometry, they are merged into a single mesh in the file.\n\t *\n\t * @param {Object3D} object - The 3D object to export.\n\t * @param {PLYExporter~OnDone} onDone - A callback function that is executed when the export has finished.\n\t * @param {PLYExporter~Options} options - The export options.\n\t * @return {?string|ArrayBuffer} The exported PLY.\n\t */\n\tparse( object, onDone, options = {} ) {\n\n\t\t// reference https://github.com/gkjohnson/ply-exporter-js\n\n\t\t// Iterate over the valid meshes in the object\n\t\tfunction traverseMeshes( cb ) {\n\n\t\t\tobject.traverse( function ( child ) {\n\n\t\t\t\tif ( child.isMesh === true || child.isPoints ) {\n\n\t\t\t\t\tconst mesh = child;\n\t\t\t\t\tconst geometry = mesh.geometry;\n\n\t\t\t\t\tif ( geometry.hasAttribute( 'position' ) === true ) {\n\n\t\t\t\t\t\tcb( mesh, geometry );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// Default options\n\t\tconst defaultOptions = {\n\t\t\tbinary: false,\n\t\t\texcludeAttributes: [], // normal, uv, color, index\n\t\t\tlittleEndian: false\n\t\t};\n\n\t\toptions = Object.assign( defaultOptions, options );\n\n\t\tconst excludeAttributes = options.excludeAttributes;\n\t\tlet includeIndices = true;\n\t\tlet includeNormals = false;\n\t\tlet includeColors = false;\n\t\tlet includeUVs = false;\n\n\t\t// count the vertices, check which properties are used,\n\t\t// and cache the BufferGeometry\n\t\tlet vertexCount = 0;\n\t\tlet faceCount = 0;\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isMesh === true ) {\n\n\t\t\t\tconst mesh = child;\n\t\t\t\tconst geometry = mesh.geometry;\n\n\t\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\t\tconst normals = geometry.getAttribute( 'normal' );\n\t\t\t\tconst uvs = geometry.getAttribute( 'uv' );\n\t\t\t\tconst colors = geometry.getAttribute( 'color' );\n\t\t\t\tconst indices = geometry.getIndex();\n\n\t\t\t\tif ( vertices === undefined ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tvertexCount += vertices.count;\n\t\t\t\tfaceCount += indices ? indices.count / 3 : vertices.count / 3;\n\n\t\t\t\tif ( normals !== undefined ) includeNormals = true;\n\n\t\t\t\tif ( uvs !== undefined ) includeUVs = true;\n\n\t\t\t\tif ( colors !== undefined ) includeColors = true;\n\n\t\t\t} else if ( child.isPoints ) {\n\n\t\t\t\tconst mesh = child;\n\t\t\t\tconst geometry = mesh.geometry;\n\n\t\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\t\tconst normals = geometry.getAttribute( 'normal' );\n\t\t\t\tconst colors = geometry.getAttribute( 'color' );\n\n\t\t\t\tvertexCount += vertices.count;\n\n\t\t\t\tif ( normals !== undefined ) includeNormals = true;\n\n\t\t\t\tif ( colors !== undefined ) includeColors = true;\n\n\t\t\t\tincludeIndices = false;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst tempColor = new Color();\n\t\tincludeIndices = includeIndices && excludeAttributes.indexOf( 'index' ) === - 1;\n\t\tincludeNormals = includeNormals && excludeAttributes.indexOf( 'normal' ) === - 1;\n\t\tincludeColors = includeColors && excludeAttributes.indexOf( 'color' ) === - 1;\n\t\tincludeUVs = includeUVs && excludeAttributes.indexOf( 'uv' ) === - 1;\n\n\n\t\tif ( includeIndices && faceCount !== Math.floor( faceCount ) ) {\n\n\t\t\t// point cloud meshes will not have an index array and may not have a\n\t\t\t// number of vertices that is divisible by 3 (and therefore representable\n\t\t\t// as triangles)\n\t\t\tconsole.error(\n\n\t\t\t\t'PLYExporter: Failed to generate a valid PLY file with triangle indices because the ' +\n\t\t\t\t'number of indices is not divisible by 3.'\n\n\t\t\t);\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst indexByteCount = 4;\n\n\t\tlet header =\n\t\t\t'ply\\n' +\n\t\t\t`format ${ options.binary ? ( options.littleEndian ? 'binary_little_endian' : 'binary_big_endian' ) : 'ascii' } 1.0\\n` +\n\t\t\t`element vertex ${vertexCount}\\n` +\n\n\t\t\t// position\n\t\t\t'property float x\\n' +\n\t\t\t'property float y\\n' +\n\t\t\t'property float z\\n';\n\n\t\tif ( includeNormals === true ) {\n\n\t\t\t// normal\n\t\t\theader +=\n\t\t\t\t'property float nx\\n' +\n\t\t\t\t'property float ny\\n' +\n\t\t\t\t'property float nz\\n';\n\n\t\t}\n\n\t\tif ( includeUVs === true ) {\n\n\t\t\t// uvs\n\t\t\theader +=\n\t\t\t\t'property float s\\n' +\n\t\t\t\t'property float t\\n';\n\n\t\t}\n\n\t\tif ( includeColors === true ) {\n\n\t\t\t// colors\n\t\t\theader +=\n\t\t\t\t'property uchar red\\n' +\n\t\t\t\t'property uchar green\\n' +\n\t\t\t\t'property uchar blue\\n';\n\n\t\t}\n\n\t\tif ( includeIndices === true ) {\n\n\t\t\t// faces\n\t\t\theader +=\n\t\t\t\t`element face ${faceCount}\\n` +\n\t\t\t\t'property list uchar int vertex_index\\n';\n\n\t\t}\n\n\t\theader += 'end_header\\n';\n\n\n\t\t// Generate attribute data\n\t\tconst vertex = new Vector3();\n\t\tconst normalMatrixWorld = new Matrix3();\n\t\tlet result = null;\n\n\t\tif ( options.binary === true ) {\n\n\t\t\t// Binary File Generation\n\t\t\tconst headerBin = new TextEncoder().encode( header );\n\n\t\t\t// 3 position values at 4 bytes\n\t\t\t// 3 normal values at 4 bytes\n\t\t\t// 3 color channels with 1 byte\n\t\t\t// 2 uv values at 4 bytes\n\t\t\tconst vertexListLength = vertexCount * ( 4 * 3 + ( includeNormals ? 4 * 3 : 0 ) + ( includeColors ? 3 : 0 ) + ( includeUVs ? 4 * 2 : 0 ) );\n\n\t\t\t// 1 byte shape descriptor\n\t\t\t// 3 vertex indices at ${indexByteCount} bytes\n\t\t\tconst faceListLength = includeIndices ? faceCount * ( indexByteCount * 3 + 1 ) : 0;\n\t\t\tconst output = new DataView( new ArrayBuffer( headerBin.length + vertexListLength + faceListLength ) );\n\t\t\tnew Uint8Array( output.buffer ).set( headerBin, 0 );\n\n\n\t\t\tlet vOffset = headerBin.length;\n\t\t\tlet fOffset = headerBin.length + vertexListLength;\n\t\t\tlet writtenVertices = 0;\n\t\t\ttraverseMeshes( function ( mesh, geometry ) {\n\n\t\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\t\tconst normals = geometry.getAttribute( 'normal' );\n\t\t\t\tconst uvs = geometry.getAttribute( 'uv' );\n\t\t\t\tconst colors = geometry.getAttribute( 'color' );\n\t\t\t\tconst indices = geometry.getIndex();\n\n\t\t\t\tnormalMatrixWorld.getNormalMatrix( mesh.matrixWorld );\n\n\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i ++ ) {\n\n\t\t\t\t\tvertex.fromBufferAttribute( vertices, i );\n\n\t\t\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\n\n\n\t\t\t\t\t// Position information\n\t\t\t\t\toutput.setFloat32( vOffset, vertex.x, options.littleEndian );\n\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\toutput.setFloat32( vOffset, vertex.y, options.littleEndian );\n\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\toutput.setFloat32( vOffset, vertex.z, options.littleEndian );\n\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t// Normal information\n\t\t\t\t\tif ( includeNormals === true ) {\n\n\t\t\t\t\t\tif ( normals != null ) {\n\n\t\t\t\t\t\t\tvertex.fromBufferAttribute( normals, i );\n\n\t\t\t\t\t\t\tvertex.applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.x, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.y, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.z, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// UV information\n\t\t\t\t\tif ( includeUVs === true ) {\n\n\t\t\t\t\t\tif ( uvs != null ) {\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, uvs.getX( i ), options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, uvs.getY( i ), options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Color information\n\t\t\t\t\tif ( includeColors === true ) {\n\n\t\t\t\t\t\tif ( colors != null ) {\n\n\t\t\t\t\t\t\ttempColor.fromBufferAttribute( colors, i );\n\n\t\t\t\t\t\t\tColorManagement.workingToColorSpace( tempColor, SRGBColorSpace );\n\n\t\t\t\t\t\t\toutput.setUint8( vOffset, Math.floor( tempColor.r * 255 ) );\n\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\toutput.setUint8( vOffset, Math.floor( tempColor.g * 255 ) );\n\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\toutput.setUint8( vOffset, Math.floor( tempColor.b * 255 ) );\n\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\toutput.setUint8( vOffset, 255 );\n\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\toutput.setUint8( vOffset, 255 );\n\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\toutput.setUint8( vOffset, 255 );\n\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( includeIndices === true ) {\n\n\t\t\t\t\t// Create the face list\n\n\t\t\t\t\tif ( indices !== null ) {\n\n\t\t\t\t\t\tfor ( let i = 0, l = indices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\toutput.setUint8( fOffset, 3 );\n\t\t\t\t\t\t\tfOffset += 1;\n\n\t\t\t\t\t\t\toutput.setUint32( fOffset, indices.getX( i + 0 ) + writtenVertices, options.littleEndian );\n\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\toutput.setUint32( fOffset, indices.getX( i + 1 ) + writtenVertices, options.littleEndian );\n\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\toutput.setUint32( fOffset, indices.getX( i + 2 ) + writtenVertices, options.littleEndian );\n\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\toutput.setUint8( fOffset, 3 );\n\t\t\t\t\t\t\tfOffset += 1;\n\n\t\t\t\t\t\t\toutput.setUint32( fOffset, writtenVertices + i, options.littleEndian );\n\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\toutput.setUint32( fOffset, writtenVertices + i + 1, options.littleEndian );\n\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\toutput.setUint32( fOffset, writtenVertices + i + 2, options.littleEndian );\n\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\t// Save the amount of verts we've already written so we can offset\n\t\t\t\t// the face index on the next mesh\n\t\t\t\twrittenVertices += vertices.count;\n\n\t\t\t} );\n\n\t\t\tresult = output.buffer;\n\n\t\t} else {\n\n\t\t\t// Ascii File Generation\n\t\t\t// count the number of vertices\n\t\t\tlet writtenVertices = 0;\n\t\t\tlet vertexList = '';\n\t\t\tlet faceList = '';\n\n\t\t\ttraverseMeshes( function ( mesh, geometry ) {\n\n\t\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\t\tconst normals = geometry.getAttribute( 'normal' );\n\t\t\t\tconst uvs = geometry.getAttribute( 'uv' );\n\t\t\t\tconst colors = geometry.getAttribute( 'color' );\n\t\t\t\tconst indices = geometry.getIndex();\n\n\t\t\t\tnormalMatrixWorld.getNormalMatrix( mesh.matrixWorld );\n\n\t\t\t\t// form each line\n\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i ++ ) {\n\n\t\t\t\t\tvertex.fromBufferAttribute( vertices, i );\n\n\t\t\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\n\n\n\t\t\t\t\t// Position information\n\t\t\t\t\tlet line =\n\t\t\t\t\t\tvertex.x + ' ' +\n\t\t\t\t\t\tvertex.y + ' ' +\n\t\t\t\t\t\tvertex.z;\n\n\t\t\t\t\t// Normal information\n\t\t\t\t\tif ( includeNormals === true ) {\n\n\t\t\t\t\t\tif ( normals != null ) {\n\n\t\t\t\t\t\t\tvertex.fromBufferAttribute( normals, i );\n\n\t\t\t\t\t\t\tvertex.applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t\t\tline += ' ' +\n\t\t\t\t\t\t\t\tvertex.x + ' ' +\n\t\t\t\t\t\t\t\tvertex.y + ' ' +\n\t\t\t\t\t\t\t\tvertex.z;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tline += ' 0 0 0';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// UV information\n\t\t\t\t\tif ( includeUVs === true ) {\n\n\t\t\t\t\t\tif ( uvs != null ) {\n\n\t\t\t\t\t\t\tline += ' ' +\n\t\t\t\t\t\t\t\tuvs.getX( i ) + ' ' +\n\t\t\t\t\t\t\t\tuvs.getY( i );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tline += ' 0 0';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Color information\n\t\t\t\t\tif ( includeColors === true ) {\n\n\t\t\t\t\t\tif ( colors != null ) {\n\n\t\t\t\t\t\t\ttempColor.fromBufferAttribute( colors, i );\n\n\t\t\t\t\t\t\tColorManagement.workingToColorSpace( tempColor, SRGBColorSpace );\n\n\t\t\t\t\t\t\tline += ' ' +\n\t\t\t\t\t\t\t\tMath.floor( tempColor.r * 255 ) + ' ' +\n\t\t\t\t\t\t\t\tMath.floor( tempColor.g * 255 ) + ' ' +\n\t\t\t\t\t\t\t\tMath.floor( tempColor.b * 255 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tline += ' 255 255 255';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvertexList += line + '\\n';\n\n\t\t\t\t}\n\n\t\t\t\t// Create the face list\n\t\t\t\tif ( includeIndices === true ) {\n\n\t\t\t\t\tif ( indices !== null ) {\n\n\t\t\t\t\t\tfor ( let i = 0, l = indices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\tfaceList += `3 ${ indices.getX( i + 0 ) + writtenVertices }`;\n\t\t\t\t\t\t\tfaceList += ` ${ indices.getX( i + 1 ) + writtenVertices }`;\n\t\t\t\t\t\t\tfaceList += ` ${ indices.getX( i + 2 ) + writtenVertices }\\n`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\tfaceList += `3 ${ writtenVertices + i } ${ writtenVertices + i + 1 } ${ writtenVertices + i + 2 }\\n`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceCount += indices ? indices.count / 3 : vertices.count / 3;\n\n\t\t\t\t}\n\n\t\t\t\twrittenVertices += vertices.count;\n\n\t\t\t} );\n\n\t\t\tresult = `${ header }${vertexList}${ includeIndices ? `${faceList}\\n` : '\\n' }`;\n\n\t\t}\n\n\t\tif ( typeof onDone === 'function' ) requestAnimationFrame( () => onDone( result ) );\n\n\t\treturn result;\n\n\t}\n\n}\n\n/**\n * Export options of `PLYExporter`.\n *\n * @typedef {Object} PLYExporter~Options\n * @property {boolean} [binary=false] - Whether to export in binary format or ASCII.\n * @property {Array<string>} [excludeAttributes] - Which properties to explicitly exclude from\n * the exported PLY file. Valid values are `'color'`, `'normal'`, `'uv'`, and `'index'`. If triangle\n * indices are excluded, then a point cloud is exported.\n * @property {boolean} [littleEndian=false] - Whether the binary export uses little or big endian.\n **/\n\n/**\n * onDone callback of `PLYExporter`.\n *\n * @callback PLYExporter~OnDone\n * @param {string|ArrayBuffer} result - The generated PLY ascii or binary.\n */\n\nexport { PLYExporter };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}