{"ast":null,"code":"/**\n * MeshGouraudMaterial\n *\n * Lambert illumination model with Gouraud (per-vertex) shading\n *\n */\n\nimport { UniformsUtils, UniformsLib, ShaderMaterial, Color, MultiplyOperation } from 'three';\nconst GouraudShader = {\n  name: 'GouraudShader',\n  uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {\n    emissive: {\n      value: new Color(0x000000)\n    }\n  }]),\n  vertexShader: /* glsl */`\n\n\t\t#define GOURAUD\n\n\t\tvarying vec3 vLightFront;\n\t\tvarying vec3 vIndirectFront;\n\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvarying vec3 vLightBack;\n\t\t\tvarying vec3 vIndirectBack;\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <uv_pars_vertex>\n\t\t#include <envmap_pars_vertex>\n\t\t#include <bsdfs>\n\t\t#include <lights_pars_begin>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <morphtarget_pars_vertex>\n\t\t#include <skinning_pars_vertex>\n\t\t#include <shadowmap_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\t#include <uv_vertex>\n\t\t\t#include <color_vertex>\n\t\t\t#include <morphcolor_vertex>\n\n\t\t\t#include <beginnormal_vertex>\n\t\t\t#include <morphnormal_vertex>\n\t\t\t#include <skinbase_vertex>\n\t\t\t#include <skinnormal_vertex>\n\t\t\t#include <defaultnormal_vertex>\n\n\t\t\t#include <begin_vertex>\n\t\t\t#include <morphtarget_vertex>\n\t\t\t#include <skinning_vertex>\n\t\t\t#include <project_vertex>\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\n\t\t\t#include <worldpos_vertex>\n\t\t\t#include <envmap_vertex>\n\n\t\t\t// inlining legacy <lights_lambert_vertex>\n\n\t\t\tvec3 diffuse = vec3( 1.0 );\n\n\t\t\tvec3 geometryPosition = mvPosition.xyz;\n\t\t\tvec3 geometryNormal = normalize( transformedNormal );\n\t\t\tvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\n\n\t\t\tvec3 backGeometryNormal = - geometryNormal;\n\n\t\t\tvLightFront = vec3( 0.0 );\n\t\t\tvIndirectFront = vec3( 0.0 );\n\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\tvLightBack = vec3( 0.0 );\n\t\t\t\tvIndirectBack = vec3( 0.0 );\n\t\t\t#endif\n\n\t\t\tIncidentLight directLight;\n\t\t\tfloat dotNL;\n\t\t\tvec3 directLightColor_Diffuse;\n\n\t\t\tvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\n\n\t\t\t#if defined( USE_LIGHT_PROBES )\n\n\t\t\t\tvIndirectFront += getLightProbeIrradiance( lightProbe, geometryNormal );\n\n\t\t\t#endif\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\n\t\t\t\t#if defined( USE_LIGHT_PROBES )\n\n\t\t\t\t\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometryNormal );\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\t#if NUM_POINT_LIGHTS > 0\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\t\t\t\tgetPointLightInfo( pointLights[ i ], geometryPosition, directLight );\n\n\t\t\t\t\tdotNL = dot( geometryNormal, directLight.direction );\n\t\t\t\t\tdirectLightColor_Diffuse = directLight.color;\n\n\t\t\t\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t#endif\n\n\t\t\t#if NUM_SPOT_LIGHTS > 0\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\t\t\t\tgetSpotLightInfo( spotLights[ i ], geometryPosition, directLight );\n\n\t\t\t\t\tdotNL = dot( geometryNormal, directLight.direction );\n\t\t\t\t\tdirectLightColor_Diffuse = directLight.color;\n\n\t\t\t\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\n\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t#endif\n\n\t\t\t#if NUM_DIR_LIGHTS > 0\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\t\t\tgetDirectionalLightInfo( directionalLights[ i ], directLight );\n\n\t\t\t\t\tdotNL = dot( geometryNormal, directLight.direction );\n\t\t\t\t\tdirectLightColor_Diffuse = directLight.color;\n\n\t\t\t\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t#endif\n\n\t\t\t#if NUM_HEMI_LIGHTS > 0\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\t\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\n\t\t\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometryNormal );\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t#endif\n\n\t\t\t#include <shadowmap_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}`,\n  fragmentShader: /* glsl */`\n\n\t\t#define GOURAUD\n\n\t\tuniform vec3 diffuse;\n\t\tuniform vec3 emissive;\n\t\tuniform float opacity;\n\n\t\tvarying vec3 vLightFront;\n\t\tvarying vec3 vIndirectFront;\n\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvarying vec3 vLightBack;\n\t\t\tvarying vec3 vIndirectBack;\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <packing>\n\t\t#include <dithering_pars_fragment>\n\t\t#include <color_pars_fragment>\n\t\t#include <uv_pars_fragment>\n\t\t#include <map_pars_fragment>\n\t\t#include <alphamap_pars_fragment>\n\t\t#include <alphatest_pars_fragment>\n\t\t#include <aomap_pars_fragment>\n\t\t#include <lightmap_pars_fragment>\n\t\t#include <emissivemap_pars_fragment>\n\t\t#include <envmap_common_pars_fragment>\n\t\t#include <envmap_pars_fragment>\n\t\t#include <bsdfs>\n\t\t#include <lights_pars_begin>\n\t\t#include <fog_pars_fragment>\n\t\t#include <shadowmap_pars_fragment>\n\t\t#include <shadowmask_pars_fragment>\n\t\t#include <specularmap_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t\t\tvec3 totalEmissiveRadiance = emissive;\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <map_fragment>\n\t\t\t#include <color_fragment>\n\t\t\t#include <alphamap_fragment>\n\t\t\t#include <alphatest_fragment>\n\t\t\t#include <specularmap_fragment>\n\t\t\t#include <emissivemap_fragment>\n\n\t\t\t// accumulation\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\n\t\t\t#else\n\n\t\t\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_LIGHTMAP\n\n\t\t\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\t\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\t\t\treflectedLight.indirectDiffuse += lightMapIrradiance;\n\n\t\t\t#endif\n\n\t\t\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\n\t\t\t#else\n\n\t\t\t\treflectedLight.directDiffuse = vLightFront;\n\n\t\t\t#endif\n\n\t\t\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\n\t\t\t// modulation\n\n\t\t\t#include <aomap_fragment>\n\n\t\t\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n\t\t\t#include <envmap_fragment>\n\n\t\t\t#include <opaque_fragment>\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t#include <dithering_fragment>\n\n\t\t}`\n};\n\n//\n\nclass MeshGouraudMaterial extends ShaderMaterial {\n  constructor(parameters) {\n    super();\n    console.warn('THREE.MeshGouraudMaterial: MeshGouraudMaterial has been deprecated and will be removed with r183. Use THREE.MeshLambertMaterial instead.'); // @deprecated r173\n\n    this.isMeshGouraudMaterial = true;\n    this.type = 'MeshGouraudMaterial';\n\n    //this.color = new THREE.Color( 0xffffff ); // diffuse\n\n    //this.map = null;\n\n    //this.lightMap = null;\n    //this.lightMapIntensity = 1.0;\n\n    //this.aoMap = null;\n    //this.aoMapIntensity = 1.0;\n\n    //this.emissive = new THREE.Color( 0x000000 );\n    //this.emissiveIntensity = 1.0;\n    //this.emissiveMap = null;\n\n    //this.specularMap = null;\n\n    //this.alphaMap = null;\n\n    //this.envMap = null;\n    this.combine = MultiplyOperation; // combine has no uniform\n    //this.reflectivity = 1;\n    //this.refractionRatio = 0.98;\n\n    this.fog = false; // set to use scene fog\n    this.lights = true; // set to use scene lights\n    this.clipping = false; // set to use user-defined clipping planes\n\n    const shader = GouraudShader;\n    this.defines = Object.assign({}, shader.defines);\n    this.uniforms = UniformsUtils.clone(shader.uniforms);\n    this.vertexShader = shader.vertexShader;\n    this.fragmentShader = shader.fragmentShader;\n    const exposePropertyNames = ['map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'specularMap', 'alphaMap', 'envMap', 'reflectivity', 'refractionRatio', 'opacity', 'diffuse'];\n    for (const propertyName of exposePropertyNames) {\n      Object.defineProperty(this, propertyName, {\n        get: function () {\n          return this.uniforms[propertyName].value;\n        },\n        set: function (value) {\n          this.uniforms[propertyName].value = value;\n        }\n      });\n    }\n    Object.defineProperty(this, 'color', Object.getOwnPropertyDescriptor(this, 'diffuse'));\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.map = source.map;\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n    this.emissive.copy(source.emissive);\n    this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n    this.specularMap = source.specularMap;\n    this.alphaMap = source.alphaMap;\n    this.envMap = source.envMap;\n    this.combine = source.combine;\n    this.reflectivity = source.reflectivity;\n    this.refractionRatio = source.refractionRatio;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n    this.fog = source.fog;\n    return this;\n  }\n}\nexport { MeshGouraudMaterial };","map":{"version":3,"names":["UniformsUtils","UniformsLib","ShaderMaterial","Color","MultiplyOperation","GouraudShader","name","uniforms","merge","common","specularmap","envmap","aomap","lightmap","emissivemap","fog","lights","emissive","value","vertexShader","fragmentShader","MeshGouraudMaterial","constructor","parameters","console","warn","isMeshGouraudMaterial","type","combine","clipping","shader","defines","Object","assign","clone","exposePropertyNames","propertyName","defineProperty","get","set","getOwnPropertyDescriptor","setValues","copy","source","color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissiveMap","emissiveIntensity","specularMap","alphaMap","envMap","reflectivity","refractionRatio","wireframe","wireframeLinewidth","wireframeLinecap","wireframeLinejoin"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/materials/MeshGouraudMaterial.js"],"sourcesContent":["/**\n * MeshGouraudMaterial\n *\n * Lambert illumination model with Gouraud (per-vertex) shading\n *\n */\n\nimport { UniformsUtils, UniformsLib, ShaderMaterial, Color, MultiplyOperation } from 'three';\n\nconst GouraudShader = {\n\n\tname: 'GouraudShader',\n\n\tuniforms: UniformsUtils.merge( [\n\t\tUniformsLib.common,\n\t\tUniformsLib.specularmap,\n\t\tUniformsLib.envmap,\n\t\tUniformsLib.aomap,\n\t\tUniformsLib.lightmap,\n\t\tUniformsLib.emissivemap,\n\t\tUniformsLib.fog,\n\t\tUniformsLib.lights,\n\t\t{\n\t\t\temissive: { value: new Color( 0x000000 ) }\n\t\t}\n\t] ),\n\n\tvertexShader: /* glsl */`\n\n\t\t#define GOURAUD\n\n\t\tvarying vec3 vLightFront;\n\t\tvarying vec3 vIndirectFront;\n\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvarying vec3 vLightBack;\n\t\t\tvarying vec3 vIndirectBack;\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <uv_pars_vertex>\n\t\t#include <envmap_pars_vertex>\n\t\t#include <bsdfs>\n\t\t#include <lights_pars_begin>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <morphtarget_pars_vertex>\n\t\t#include <skinning_pars_vertex>\n\t\t#include <shadowmap_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\t#include <uv_vertex>\n\t\t\t#include <color_vertex>\n\t\t\t#include <morphcolor_vertex>\n\n\t\t\t#include <beginnormal_vertex>\n\t\t\t#include <morphnormal_vertex>\n\t\t\t#include <skinbase_vertex>\n\t\t\t#include <skinnormal_vertex>\n\t\t\t#include <defaultnormal_vertex>\n\n\t\t\t#include <begin_vertex>\n\t\t\t#include <morphtarget_vertex>\n\t\t\t#include <skinning_vertex>\n\t\t\t#include <project_vertex>\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\n\t\t\t#include <worldpos_vertex>\n\t\t\t#include <envmap_vertex>\n\n\t\t\t// inlining legacy <lights_lambert_vertex>\n\n\t\t\tvec3 diffuse = vec3( 1.0 );\n\n\t\t\tvec3 geometryPosition = mvPosition.xyz;\n\t\t\tvec3 geometryNormal = normalize( transformedNormal );\n\t\t\tvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\n\n\t\t\tvec3 backGeometryNormal = - geometryNormal;\n\n\t\t\tvLightFront = vec3( 0.0 );\n\t\t\tvIndirectFront = vec3( 0.0 );\n\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\tvLightBack = vec3( 0.0 );\n\t\t\t\tvIndirectBack = vec3( 0.0 );\n\t\t\t#endif\n\n\t\t\tIncidentLight directLight;\n\t\t\tfloat dotNL;\n\t\t\tvec3 directLightColor_Diffuse;\n\n\t\t\tvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\n\n\t\t\t#if defined( USE_LIGHT_PROBES )\n\n\t\t\t\tvIndirectFront += getLightProbeIrradiance( lightProbe, geometryNormal );\n\n\t\t\t#endif\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\n\t\t\t\t#if defined( USE_LIGHT_PROBES )\n\n\t\t\t\t\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometryNormal );\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\t#if NUM_POINT_LIGHTS > 0\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\t\t\t\tgetPointLightInfo( pointLights[ i ], geometryPosition, directLight );\n\n\t\t\t\t\tdotNL = dot( geometryNormal, directLight.direction );\n\t\t\t\t\tdirectLightColor_Diffuse = directLight.color;\n\n\t\t\t\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t#endif\n\n\t\t\t#if NUM_SPOT_LIGHTS > 0\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\t\t\t\tgetSpotLightInfo( spotLights[ i ], geometryPosition, directLight );\n\n\t\t\t\t\tdotNL = dot( geometryNormal, directLight.direction );\n\t\t\t\t\tdirectLightColor_Diffuse = directLight.color;\n\n\t\t\t\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\n\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t#endif\n\n\t\t\t#if NUM_DIR_LIGHTS > 0\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\t\t\tgetDirectionalLightInfo( directionalLights[ i ], directLight );\n\n\t\t\t\t\tdotNL = dot( geometryNormal, directLight.direction );\n\t\t\t\t\tdirectLightColor_Diffuse = directLight.color;\n\n\t\t\t\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t#endif\n\n\t\t\t#if NUM_HEMI_LIGHTS > 0\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\t\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\n\t\t\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometryNormal );\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t#endif\n\n\t\t\t#include <shadowmap_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\t#define GOURAUD\n\n\t\tuniform vec3 diffuse;\n\t\tuniform vec3 emissive;\n\t\tuniform float opacity;\n\n\t\tvarying vec3 vLightFront;\n\t\tvarying vec3 vIndirectFront;\n\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvarying vec3 vLightBack;\n\t\t\tvarying vec3 vIndirectBack;\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <packing>\n\t\t#include <dithering_pars_fragment>\n\t\t#include <color_pars_fragment>\n\t\t#include <uv_pars_fragment>\n\t\t#include <map_pars_fragment>\n\t\t#include <alphamap_pars_fragment>\n\t\t#include <alphatest_pars_fragment>\n\t\t#include <aomap_pars_fragment>\n\t\t#include <lightmap_pars_fragment>\n\t\t#include <emissivemap_pars_fragment>\n\t\t#include <envmap_common_pars_fragment>\n\t\t#include <envmap_pars_fragment>\n\t\t#include <bsdfs>\n\t\t#include <lights_pars_begin>\n\t\t#include <fog_pars_fragment>\n\t\t#include <shadowmap_pars_fragment>\n\t\t#include <shadowmask_pars_fragment>\n\t\t#include <specularmap_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t\t\tvec3 totalEmissiveRadiance = emissive;\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <map_fragment>\n\t\t\t#include <color_fragment>\n\t\t\t#include <alphamap_fragment>\n\t\t\t#include <alphatest_fragment>\n\t\t\t#include <specularmap_fragment>\n\t\t\t#include <emissivemap_fragment>\n\n\t\t\t// accumulation\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\n\t\t\t#else\n\n\t\t\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_LIGHTMAP\n\n\t\t\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\t\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\t\t\treflectedLight.indirectDiffuse += lightMapIrradiance;\n\n\t\t\t#endif\n\n\t\t\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\n\t\t\t#else\n\n\t\t\t\treflectedLight.directDiffuse = vLightFront;\n\n\t\t\t#endif\n\n\t\t\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\n\t\t\t// modulation\n\n\t\t\t#include <aomap_fragment>\n\n\t\t\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n\t\t\t#include <envmap_fragment>\n\n\t\t\t#include <opaque_fragment>\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t#include <dithering_fragment>\n\n\t\t}`\n\n};\n\n//\n\nclass MeshGouraudMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tconsole.warn( 'THREE.MeshGouraudMaterial: MeshGouraudMaterial has been deprecated and will be removed with r183. Use THREE.MeshLambertMaterial instead.' ); // @deprecated r173\n\n\t\tthis.isMeshGouraudMaterial = true;\n\n\t\tthis.type = 'MeshGouraudMaterial';\n\n\t\t//this.color = new THREE.Color( 0xffffff ); // diffuse\n\n\t\t//this.map = null;\n\n\t\t//this.lightMap = null;\n\t\t//this.lightMapIntensity = 1.0;\n\n\t\t//this.aoMap = null;\n\t\t//this.aoMapIntensity = 1.0;\n\n\t\t//this.emissive = new THREE.Color( 0x000000 );\n\t\t//this.emissiveIntensity = 1.0;\n\t\t//this.emissiveMap = null;\n\n\t\t//this.specularMap = null;\n\n\t\t//this.alphaMap = null;\n\n\t\t//this.envMap = null;\n\t\tthis.combine = MultiplyOperation; // combine has no uniform\n\t\t//this.reflectivity = 1;\n\t\t//this.refractionRatio = 0.98;\n\n\t\tthis.fog = false; // set to use scene fog\n\t\tthis.lights = true; // set to use scene lights\n\t\tthis.clipping = false; // set to use user-defined clipping planes\n\n\t\tconst shader = GouraudShader;\n\n\t\tthis.defines = Object.assign( {}, shader.defines );\n\t\tthis.uniforms = UniformsUtils.clone( shader.uniforms );\n\t\tthis.vertexShader = shader.vertexShader;\n\t\tthis.fragmentShader = shader.fragmentShader;\n\n\t\tconst exposePropertyNames = [\n\t\t\t'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity',\n\t\t\t'emissive', 'emissiveIntensity', 'emissiveMap', 'specularMap', 'alphaMap',\n\t\t\t'envMap', 'reflectivity', 'refractionRatio', 'opacity', 'diffuse'\n\t\t];\n\n\t\tfor ( const propertyName of exposePropertyNames ) {\n\n\t\t\tObject.defineProperty( this, propertyName, {\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms[ propertyName ].value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms[ propertyName ].value = value;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\tObject.defineProperty( this, 'color', Object.getOwnPropertyDescriptor( this, 'diffuse' ) );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { MeshGouraudMaterial };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,aAAa,EAAEC,WAAW,EAAEC,cAAc,EAAEC,KAAK,EAAEC,iBAAiB,QAAQ,OAAO;AAE5F,MAAMC,aAAa,GAAG;EAErBC,IAAI,EAAE,eAAe;EAErBC,QAAQ,EAAEP,aAAa,CAACQ,KAAK,CAAE,CAC9BP,WAAW,CAACQ,MAAM,EAClBR,WAAW,CAACS,WAAW,EACvBT,WAAW,CAACU,MAAM,EAClBV,WAAW,CAACW,KAAK,EACjBX,WAAW,CAACY,QAAQ,EACpBZ,WAAW,CAACa,WAAW,EACvBb,WAAW,CAACc,GAAG,EACfd,WAAW,CAACe,MAAM,EAClB;IACCC,QAAQ,EAAE;MAAEC,KAAK,EAAE,IAAIf,KAAK,CAAE,QAAS;IAAE;EAC1C,CAAC,CACA,CAAC;EAEHgB,YAAY,EAAE,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;EAEHC,cAAc,EAAE,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,CAAC;;AAED;;AAEA,MAAMC,mBAAmB,SAASnB,cAAc,CAAC;EAEhDoB,WAAWA,CAAEC,UAAU,EAAG;IAEzB,KAAK,CAAC,CAAC;IAEPC,OAAO,CAACC,IAAI,CAAE,0IAA2I,CAAC,CAAC,CAAC;;IAE5J,IAAI,CAACC,qBAAqB,GAAG,IAAI;IAEjC,IAAI,CAACC,IAAI,GAAG,qBAAqB;;IAEjC;;IAEA;;IAEA;IACA;;IAEA;IACA;;IAEA;IACA;IACA;;IAEA;;IAEA;;IAEA;IACA,IAAI,CAACC,OAAO,GAAGxB,iBAAiB,CAAC,CAAC;IAClC;IACA;;IAEA,IAAI,CAACW,GAAG,GAAG,KAAK,CAAC,CAAC;IAClB,IAAI,CAACC,MAAM,GAAG,IAAI,CAAC,CAAC;IACpB,IAAI,CAACa,QAAQ,GAAG,KAAK,CAAC,CAAC;;IAEvB,MAAMC,MAAM,GAAGzB,aAAa;IAE5B,IAAI,CAAC0B,OAAO,GAAGC,MAAM,CAACC,MAAM,CAAE,CAAC,CAAC,EAAEH,MAAM,CAACC,OAAQ,CAAC;IAClD,IAAI,CAACxB,QAAQ,GAAGP,aAAa,CAACkC,KAAK,CAAEJ,MAAM,CAACvB,QAAS,CAAC;IACtD,IAAI,CAACY,YAAY,GAAGW,MAAM,CAACX,YAAY;IACvC,IAAI,CAACC,cAAc,GAAGU,MAAM,CAACV,cAAc;IAE3C,MAAMe,mBAAmB,GAAG,CAC3B,KAAK,EAAE,UAAU,EAAE,mBAAmB,EAAE,OAAO,EAAE,gBAAgB,EACjE,UAAU,EAAE,mBAAmB,EAAE,aAAa,EAAE,aAAa,EAAE,UAAU,EACzE,QAAQ,EAAE,cAAc,EAAE,iBAAiB,EAAE,SAAS,EAAE,SAAS,CACjE;IAED,KAAM,MAAMC,YAAY,IAAID,mBAAmB,EAAG;MAEjDH,MAAM,CAACK,cAAc,CAAE,IAAI,EAAED,YAAY,EAAE;QAE1CE,GAAG,EAAE,SAAAA,CAAA,EAAY;UAEhB,OAAO,IAAI,CAAC/B,QAAQ,CAAE6B,YAAY,CAAE,CAAClB,KAAK;QAE3C,CAAC;QAEDqB,GAAG,EAAE,SAAAA,CAAWrB,KAAK,EAAG;UAEvB,IAAI,CAACX,QAAQ,CAAE6B,YAAY,CAAE,CAAClB,KAAK,GAAGA,KAAK;QAE5C;MAED,CAAE,CAAC;IAEJ;IAEAc,MAAM,CAACK,cAAc,CAAE,IAAI,EAAE,OAAO,EAAEL,MAAM,CAACQ,wBAAwB,CAAE,IAAI,EAAE,SAAU,CAAE,CAAC;IAE1F,IAAI,CAACC,SAAS,CAAElB,UAAW,CAAC;EAE7B;EAEAmB,IAAIA,CAAEC,MAAM,EAAG;IAEd,KAAK,CAACD,IAAI,CAAEC,MAAO,CAAC;IAEpB,IAAI,CAACC,KAAK,CAACF,IAAI,CAAEC,MAAM,CAACC,KAAM,CAAC;IAE/B,IAAI,CAACC,GAAG,GAAGF,MAAM,CAACE,GAAG;IAErB,IAAI,CAACC,QAAQ,GAAGH,MAAM,CAACG,QAAQ;IAC/B,IAAI,CAACC,iBAAiB,GAAGJ,MAAM,CAACI,iBAAiB;IAEjD,IAAI,CAACC,KAAK,GAAGL,MAAM,CAACK,KAAK;IACzB,IAAI,CAACC,cAAc,GAAGN,MAAM,CAACM,cAAc;IAE3C,IAAI,CAAChC,QAAQ,CAACyB,IAAI,CAAEC,MAAM,CAAC1B,QAAS,CAAC;IACrC,IAAI,CAACiC,WAAW,GAAGP,MAAM,CAACO,WAAW;IACrC,IAAI,CAACC,iBAAiB,GAAGR,MAAM,CAACQ,iBAAiB;IAEjD,IAAI,CAACC,WAAW,GAAGT,MAAM,CAACS,WAAW;IAErC,IAAI,CAACC,QAAQ,GAAGV,MAAM,CAACU,QAAQ;IAE/B,IAAI,CAACC,MAAM,GAAGX,MAAM,CAACW,MAAM;IAC3B,IAAI,CAAC1B,OAAO,GAAGe,MAAM,CAACf,OAAO;IAC7B,IAAI,CAAC2B,YAAY,GAAGZ,MAAM,CAACY,YAAY;IACvC,IAAI,CAACC,eAAe,GAAGb,MAAM,CAACa,eAAe;IAE7C,IAAI,CAACC,SAAS,GAAGd,MAAM,CAACc,SAAS;IACjC,IAAI,CAACC,kBAAkB,GAAGf,MAAM,CAACe,kBAAkB;IACnD,IAAI,CAACC,gBAAgB,GAAGhB,MAAM,CAACgB,gBAAgB;IAC/C,IAAI,CAACC,iBAAiB,GAAGjB,MAAM,CAACiB,iBAAiB;IAEjD,IAAI,CAAC7C,GAAG,GAAG4B,MAAM,CAAC5B,GAAG;IAErB,OAAO,IAAI;EAEZ;AAED;AAEA,SAASM,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}