{"ast":null,"code":"import { BufferGeometry, FileLoader, Float32BufferAttribute, Loader, Color, SRGBColorSpace } from 'three';\nconst _color = new Color();\n\n/**\n * A loader for PLY the PLY format (known as the Polygon\n * File Format or the Stanford Triangle Format).\n *\n * Limitations:\n *  - ASCII decoding assumes file is UTF-8.\n *\n * ```js\n * const loader = new PLYLoader();\n * const geometry = await loader.loadAsync( './models/ply/ascii/dolphins.ply' );\n * scene.add( new THREE.Mesh( geometry ) );\n * ```\n *\n * @augments Loader\n * @three_import import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';\n */\nclass PLYLoader extends Loader {\n  /**\n   * Constructs a new PLY loader.\n   *\n   * @param {LoadingManager} [manager] - The loading manager.\n   */\n  constructor(manager) {\n    super(manager);\n\n    // internals\n\n    this.propertyNameMapping = {};\n    this.customPropertyMapping = {};\n  }\n\n  /**\n   * Starts loading from the given URL and passes the loaded PLY asset\n   * to the `onLoad()` callback.\n   *\n   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n   * @param {function(BufferGeometry)} onLoad - Executed when the loading process has been finished.\n   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n   * @param {onErrorCallback} onError - Executed when errors occur.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  /**\n   * Sets a property name mapping that maps default property names\n   * to custom ones. For example, the following maps the properties\n   * “diffuse_(red|green|blue)” in the file to standard color names.\n   *\n   * ```js\n   * loader.setPropertyNameMapping( {\n   * \tdiffuse_red: 'red',\n   * \tdiffuse_green: 'green',\n   * \tdiffuse_blue: 'blue'\n   * } );\n   * ```\n   *\n   * @param {Object} mapping - The mapping dictionary.\n   */\n  setPropertyNameMapping(mapping) {\n    this.propertyNameMapping = mapping;\n  }\n\n  /**\n   * Custom properties outside of the defaults for position, uv, normal\n   * and color attributes can be added using the setCustomPropertyNameMapping method.\n   * For example, the following maps the element properties “custom_property_a”\n   * and “custom_property_b” to an attribute “customAttribute” with an item size of 2.\n   * Attribute item sizes are set from the number of element properties in the property array.\n   *\n   * ```js\n   * loader.setCustomPropertyNameMapping( {\n   *\tcustomAttribute: ['custom_property_a', 'custom_property_b'],\n   * } );\n   * ```\n   * @param {Object} mapping - The mapping dictionary.\n   */\n  setCustomPropertyNameMapping(mapping) {\n    this.customPropertyMapping = mapping;\n  }\n\n  /**\n   * Parses the given PLY data and returns the resulting geometry.\n   *\n   * @param {ArrayBuffer} data - The raw PLY data as an array buffer.\n   * @return {BufferGeometry} The parsed geometry.\n   */\n  parse(data) {\n    function parseHeader(data, headerLength = 0) {\n      const patternHeader = /^ply([\\s\\S]*)end_header(\\r\\n|\\r|\\n)/;\n      let headerText = '';\n      const result = patternHeader.exec(data);\n      if (result !== null) {\n        headerText = result[1];\n      }\n      const header = {\n        comments: [],\n        elements: [],\n        headerLength: headerLength,\n        objInfo: ''\n      };\n      const lines = headerText.split(/\\r\\n|\\r|\\n/);\n      let currentElement;\n      function make_ply_element_property(propertyValues, propertyNameMapping) {\n        const property = {\n          type: propertyValues[0]\n        };\n        if (property.type === 'list') {\n          property.name = propertyValues[3];\n          property.countType = propertyValues[1];\n          property.itemType = propertyValues[2];\n        } else {\n          property.name = propertyValues[1];\n        }\n        if (property.name in propertyNameMapping) {\n          property.name = propertyNameMapping[property.name];\n        }\n        return property;\n      }\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i];\n        line = line.trim();\n        if (line === '') continue;\n        const lineValues = line.split(/\\s+/);\n        const lineType = lineValues.shift();\n        line = lineValues.join(' ');\n        switch (lineType) {\n          case 'format':\n            header.format = lineValues[0];\n            header.version = lineValues[1];\n            break;\n          case 'comment':\n            header.comments.push(line);\n            break;\n          case 'element':\n            if (currentElement !== undefined) {\n              header.elements.push(currentElement);\n            }\n            currentElement = {};\n            currentElement.name = lineValues[0];\n            currentElement.count = parseInt(lineValues[1]);\n            currentElement.properties = [];\n            break;\n          case 'property':\n            currentElement.properties.push(make_ply_element_property(lineValues, scope.propertyNameMapping));\n            break;\n          case 'obj_info':\n            header.objInfo = line;\n            break;\n          default:\n            console.log('unhandled', lineType, lineValues);\n        }\n      }\n      if (currentElement !== undefined) {\n        header.elements.push(currentElement);\n      }\n      return header;\n    }\n    function parseASCIINumber(n, type) {\n      switch (type) {\n        case 'char':\n        case 'uchar':\n        case 'short':\n        case 'ushort':\n        case 'int':\n        case 'uint':\n        case 'int8':\n        case 'uint8':\n        case 'int16':\n        case 'uint16':\n        case 'int32':\n        case 'uint32':\n          return parseInt(n);\n        case 'float':\n        case 'double':\n        case 'float32':\n        case 'float64':\n          return parseFloat(n);\n      }\n    }\n    function parseASCIIElement(properties, tokens) {\n      const element = {};\n      for (let i = 0; i < properties.length; i++) {\n        if (tokens.empty()) return null;\n        if (properties[i].type === 'list') {\n          const list = [];\n          const n = parseASCIINumber(tokens.next(), properties[i].countType);\n          for (let j = 0; j < n; j++) {\n            if (tokens.empty()) return null;\n            list.push(parseASCIINumber(tokens.next(), properties[i].itemType));\n          }\n          element[properties[i].name] = list;\n        } else {\n          element[properties[i].name] = parseASCIINumber(tokens.next(), properties[i].type);\n        }\n      }\n      return element;\n    }\n    function createBuffer() {\n      const buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: [],\n        faceVertexColors: []\n      };\n      for (const customProperty of Object.keys(scope.customPropertyMapping)) {\n        buffer[customProperty] = [];\n      }\n      return buffer;\n    }\n    function mapElementAttributes(properties) {\n      const elementNames = properties.map(property => {\n        return property.name;\n      });\n      function findAttrName(names) {\n        for (let i = 0, l = names.length; i < l; i++) {\n          const name = names[i];\n          if (elementNames.includes(name)) return name;\n        }\n        return null;\n      }\n      return {\n        attrX: findAttrName(['x', 'px', 'posx']) || 'x',\n        attrY: findAttrName(['y', 'py', 'posy']) || 'y',\n        attrZ: findAttrName(['z', 'pz', 'posz']) || 'z',\n        attrNX: findAttrName(['nx', 'normalx']),\n        attrNY: findAttrName(['ny', 'normaly']),\n        attrNZ: findAttrName(['nz', 'normalz']),\n        attrS: findAttrName(['s', 'u', 'texture_u', 'tx']),\n        attrT: findAttrName(['t', 'v', 'texture_v', 'ty']),\n        attrR: findAttrName(['red', 'diffuse_red', 'r', 'diffuse_r']),\n        attrG: findAttrName(['green', 'diffuse_green', 'g', 'diffuse_g']),\n        attrB: findAttrName(['blue', 'diffuse_blue', 'b', 'diffuse_b'])\n      };\n    }\n    function parseASCII(data, header) {\n      // PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n\n      const buffer = createBuffer();\n      const patternBody = /end_header\\s+(\\S[\\s\\S]*\\S|\\S)\\s*$/;\n      let body, matches;\n      if ((matches = patternBody.exec(data)) !== null) {\n        body = matches[1].split(/\\s+/);\n      } else {\n        body = [];\n      }\n      const tokens = new ArrayStream(body);\n      loop: for (let i = 0; i < header.elements.length; i++) {\n        const elementDesc = header.elements[i];\n        const attributeMap = mapElementAttributes(elementDesc.properties);\n        for (let j = 0; j < elementDesc.count; j++) {\n          const element = parseASCIIElement(elementDesc.properties, tokens);\n          if (!element) break loop;\n          handleElement(buffer, elementDesc.name, element, attributeMap);\n        }\n      }\n      return postProcess(buffer);\n    }\n    function postProcess(buffer) {\n      let geometry = new BufferGeometry();\n\n      // mandatory buffer data\n\n      if (buffer.indices.length > 0) {\n        geometry.setIndex(buffer.indices);\n      }\n      geometry.setAttribute('position', new Float32BufferAttribute(buffer.vertices, 3));\n\n      // optional buffer data\n\n      if (buffer.normals.length > 0) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(buffer.normals, 3));\n      }\n      if (buffer.uvs.length > 0) {\n        geometry.setAttribute('uv', new Float32BufferAttribute(buffer.uvs, 2));\n      }\n      if (buffer.colors.length > 0) {\n        geometry.setAttribute('color', new Float32BufferAttribute(buffer.colors, 3));\n      }\n      if (buffer.faceVertexUvs.length > 0 || buffer.faceVertexColors.length > 0) {\n        geometry = geometry.toNonIndexed();\n        if (buffer.faceVertexUvs.length > 0) geometry.setAttribute('uv', new Float32BufferAttribute(buffer.faceVertexUvs, 2));\n        if (buffer.faceVertexColors.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(buffer.faceVertexColors, 3));\n      }\n\n      // custom buffer data\n\n      for (const customProperty of Object.keys(scope.customPropertyMapping)) {\n        if (buffer[customProperty].length > 0) {\n          geometry.setAttribute(customProperty, new Float32BufferAttribute(buffer[customProperty], scope.customPropertyMapping[customProperty].length));\n        }\n      }\n      geometry.computeBoundingSphere();\n      return geometry;\n    }\n    function handleElement(buffer, elementName, element, cacheEntry) {\n      if (elementName === 'vertex') {\n        buffer.vertices.push(element[cacheEntry.attrX], element[cacheEntry.attrY], element[cacheEntry.attrZ]);\n        if (cacheEntry.attrNX !== null && cacheEntry.attrNY !== null && cacheEntry.attrNZ !== null) {\n          buffer.normals.push(element[cacheEntry.attrNX], element[cacheEntry.attrNY], element[cacheEntry.attrNZ]);\n        }\n        if (cacheEntry.attrS !== null && cacheEntry.attrT !== null) {\n          buffer.uvs.push(element[cacheEntry.attrS], element[cacheEntry.attrT]);\n        }\n        if (cacheEntry.attrR !== null && cacheEntry.attrG !== null && cacheEntry.attrB !== null) {\n          _color.setRGB(element[cacheEntry.attrR] / 255.0, element[cacheEntry.attrG] / 255.0, element[cacheEntry.attrB] / 255.0, SRGBColorSpace);\n          buffer.colors.push(_color.r, _color.g, _color.b);\n        }\n        for (const customProperty of Object.keys(scope.customPropertyMapping)) {\n          for (const elementProperty of scope.customPropertyMapping[customProperty]) {\n            buffer[customProperty].push(element[elementProperty]);\n          }\n        }\n      } else if (elementName === 'face') {\n        const vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338\n        const texcoord = element.texcoord;\n        if (vertex_indices.length === 3) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2]);\n          if (texcoord && texcoord.length === 6) {\n            buffer.faceVertexUvs.push(texcoord[0], texcoord[1]);\n            buffer.faceVertexUvs.push(texcoord[2], texcoord[3]);\n            buffer.faceVertexUvs.push(texcoord[4], texcoord[5]);\n          }\n        } else if (vertex_indices.length === 4) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3]);\n          buffer.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3]);\n        }\n\n        // face colors\n\n        if (cacheEntry.attrR !== null && cacheEntry.attrG !== null && cacheEntry.attrB !== null) {\n          _color.setRGB(element[cacheEntry.attrR] / 255.0, element[cacheEntry.attrG] / 255.0, element[cacheEntry.attrB] / 255.0, SRGBColorSpace);\n          buffer.faceVertexColors.push(_color.r, _color.g, _color.b);\n          buffer.faceVertexColors.push(_color.r, _color.g, _color.b);\n          buffer.faceVertexColors.push(_color.r, _color.g, _color.b);\n        }\n      }\n    }\n    function binaryReadElement(at, properties) {\n      const element = {};\n      let read = 0;\n      for (let i = 0; i < properties.length; i++) {\n        const property = properties[i];\n        const valueReader = property.valueReader;\n        if (property.type === 'list') {\n          const list = [];\n          const n = property.countReader.read(at + read);\n          read += property.countReader.size;\n          for (let j = 0; j < n; j++) {\n            list.push(valueReader.read(at + read));\n            read += valueReader.size;\n          }\n          element[property.name] = list;\n        } else {\n          element[property.name] = valueReader.read(at + read);\n          read += valueReader.size;\n        }\n      }\n      return [element, read];\n    }\n    function setPropertyBinaryReaders(properties, body, little_endian) {\n      function getBinaryReader(dataview, type, little_endian) {\n        switch (type) {\n          // correspondences for non-specific length types here match rply:\n          case 'int8':\n          case 'char':\n            return {\n              read: at => {\n                return dataview.getInt8(at);\n              },\n              size: 1\n            };\n          case 'uint8':\n          case 'uchar':\n            return {\n              read: at => {\n                return dataview.getUint8(at);\n              },\n              size: 1\n            };\n          case 'int16':\n          case 'short':\n            return {\n              read: at => {\n                return dataview.getInt16(at, little_endian);\n              },\n              size: 2\n            };\n          case 'uint16':\n          case 'ushort':\n            return {\n              read: at => {\n                return dataview.getUint16(at, little_endian);\n              },\n              size: 2\n            };\n          case 'int32':\n          case 'int':\n            return {\n              read: at => {\n                return dataview.getInt32(at, little_endian);\n              },\n              size: 4\n            };\n          case 'uint32':\n          case 'uint':\n            return {\n              read: at => {\n                return dataview.getUint32(at, little_endian);\n              },\n              size: 4\n            };\n          case 'float32':\n          case 'float':\n            return {\n              read: at => {\n                return dataview.getFloat32(at, little_endian);\n              },\n              size: 4\n            };\n          case 'float64':\n          case 'double':\n            return {\n              read: at => {\n                return dataview.getFloat64(at, little_endian);\n              },\n              size: 8\n            };\n        }\n      }\n      for (let i = 0, l = properties.length; i < l; i++) {\n        const property = properties[i];\n        if (property.type === 'list') {\n          property.countReader = getBinaryReader(body, property.countType, little_endian);\n          property.valueReader = getBinaryReader(body, property.itemType, little_endian);\n        } else {\n          property.valueReader = getBinaryReader(body, property.type, little_endian);\n        }\n      }\n    }\n    function parseBinary(data, header) {\n      const buffer = createBuffer();\n      const little_endian = header.format === 'binary_little_endian';\n      const body = new DataView(data, header.headerLength);\n      let result,\n        loc = 0;\n      for (let currentElement = 0; currentElement < header.elements.length; currentElement++) {\n        const elementDesc = header.elements[currentElement];\n        const properties = elementDesc.properties;\n        const attributeMap = mapElementAttributes(properties);\n        setPropertyBinaryReaders(properties, body, little_endian);\n        for (let currentElementCount = 0; currentElementCount < elementDesc.count; currentElementCount++) {\n          result = binaryReadElement(loc, properties);\n          loc += result[1];\n          const element = result[0];\n          handleElement(buffer, elementDesc.name, element, attributeMap);\n        }\n      }\n      return postProcess(buffer);\n    }\n    function extractHeaderText(bytes) {\n      let i = 0;\n      let cont = true;\n      let line = '';\n      const lines = [];\n      const startLine = new TextDecoder().decode(bytes.subarray(0, 5));\n      const hasCRNL = /^ply\\r\\n/.test(startLine);\n      do {\n        const c = String.fromCharCode(bytes[i++]);\n        if (c !== '\\n' && c !== '\\r') {\n          line += c;\n        } else {\n          if (line === 'end_header') cont = false;\n          if (line !== '') {\n            lines.push(line);\n            line = '';\n          }\n        }\n      } while (cont && i < bytes.length);\n\n      // ascii section using \\r\\n as line endings\n      if (hasCRNL === true) i++;\n      return {\n        headerText: lines.join('\\r') + '\\r',\n        headerLength: i\n      };\n    }\n\n    //\n\n    let geometry;\n    const scope = this;\n    if (data instanceof ArrayBuffer) {\n      const bytes = new Uint8Array(data);\n      const {\n        headerText,\n        headerLength\n      } = extractHeaderText(bytes);\n      const header = parseHeader(headerText, headerLength);\n      if (header.format === 'ascii') {\n        const text = new TextDecoder().decode(bytes);\n        geometry = parseASCII(text, header);\n      } else {\n        geometry = parseBinary(data, header);\n      }\n    } else {\n      geometry = parseASCII(data, parseHeader(data));\n    }\n    return geometry;\n  }\n}\nclass ArrayStream {\n  constructor(arr) {\n    this.arr = arr;\n    this.i = 0;\n  }\n  empty() {\n    return this.i >= this.arr.length;\n  }\n  next() {\n    return this.arr[this.i++];\n  }\n}\nexport { PLYLoader };","map":{"version":3,"names":["BufferGeometry","FileLoader","Float32BufferAttribute","Loader","Color","SRGBColorSpace","_color","PLYLoader","constructor","manager","propertyNameMapping","customPropertyMapping","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","setPropertyNameMapping","mapping","setCustomPropertyNameMapping","data","parseHeader","headerLength","patternHeader","headerText","result","exec","header","comments","elements","objInfo","lines","split","currentElement","make_ply_element_property","propertyValues","property","type","name","countType","itemType","i","length","line","trim","lineValues","lineType","shift","join","format","version","push","undefined","count","parseInt","properties","log","parseASCIINumber","n","parseFloat","parseASCIIElement","tokens","element","empty","list","next","j","createBuffer","buffer","indices","vertices","normals","uvs","faceVertexUvs","colors","faceVertexColors","customProperty","Object","keys","mapElementAttributes","elementNames","map","findAttrName","names","l","includes","attrX","attrY","attrZ","attrNX","attrNY","attrNZ","attrS","attrT","attrR","attrG","attrB","parseASCII","patternBody","body","matches","ArrayStream","loop","elementDesc","attributeMap","handleElement","postProcess","geometry","setIndex","setAttribute","toNonIndexed","computeBoundingSphere","elementName","cacheEntry","setRGB","r","g","b","elementProperty","vertex_indices","vertex_index","texcoord","binaryReadElement","at","read","valueReader","countReader","size","setPropertyBinaryReaders","little_endian","getBinaryReader","dataview","getInt8","getUint8","getInt16","getUint16","getInt32","getUint32","getFloat32","getFloat64","parseBinary","DataView","loc","currentElementCount","extractHeaderText","bytes","cont","startLine","TextDecoder","decode","subarray","hasCRNL","test","c","String","fromCharCode","ArrayBuffer","Uint8Array","arr"],"sources":["/home/powqy/Desktop/Design/solar-system-orbits/node_modules/three/examples/jsm/loaders/PLYLoader.js"],"sourcesContent":["import {\n\tBufferGeometry,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tLoader,\n\tColor,\n\tSRGBColorSpace\n} from 'three';\n\nconst _color = new Color();\n\n/**\n * A loader for PLY the PLY format (known as the Polygon\n * File Format or the Stanford Triangle Format).\n *\n * Limitations:\n *  - ASCII decoding assumes file is UTF-8.\n *\n * ```js\n * const loader = new PLYLoader();\n * const geometry = await loader.loadAsync( './models/ply/ascii/dolphins.ply' );\n * scene.add( new THREE.Mesh( geometry ) );\n * ```\n *\n * @augments Loader\n * @three_import import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';\n */\nclass PLYLoader extends Loader {\n\n\t/**\n\t * Constructs a new PLY loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t// internals\n\n\t\tthis.propertyNameMapping = {};\n\t\tthis.customPropertyMapping = {};\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded PLY asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(BufferGeometry)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Sets a property name mapping that maps default property names\n\t * to custom ones. For example, the following maps the properties\n\t * “diffuse_(red|green|blue)” in the file to standard color names.\n\t *\n\t * ```js\n\t * loader.setPropertyNameMapping( {\n\t * \tdiffuse_red: 'red',\n\t * \tdiffuse_green: 'green',\n\t * \tdiffuse_blue: 'blue'\n\t * } );\n\t * ```\n\t *\n\t * @param {Object} mapping - The mapping dictionary.\n\t */\n\tsetPropertyNameMapping( mapping ) {\n\n\t\tthis.propertyNameMapping = mapping;\n\n\t}\n\n\t/**\n\t * Custom properties outside of the defaults for position, uv, normal\n\t * and color attributes can be added using the setCustomPropertyNameMapping method.\n\t * For example, the following maps the element properties “custom_property_a”\n\t * and “custom_property_b” to an attribute “customAttribute” with an item size of 2.\n\t * Attribute item sizes are set from the number of element properties in the property array.\n\t *\n\t * ```js\n\t * loader.setCustomPropertyNameMapping( {\n\t *\tcustomAttribute: ['custom_property_a', 'custom_property_b'],\n\t * } );\n\t * ```\n\t * @param {Object} mapping - The mapping dictionary.\n\t */\n\tsetCustomPropertyNameMapping( mapping ) {\n\n\t\tthis.customPropertyMapping = mapping;\n\n\t}\n\n\t/**\n\t * Parses the given PLY data and returns the resulting geometry.\n\t *\n\t * @param {ArrayBuffer} data - The raw PLY data as an array buffer.\n\t * @return {BufferGeometry} The parsed geometry.\n\t */\n\tparse( data ) {\n\n\t\tfunction parseHeader( data, headerLength = 0 ) {\n\n\t\t\tconst patternHeader = /^ply([\\s\\S]*)end_header(\\r\\n|\\r|\\n)/;\n\t\t\tlet headerText = '';\n\t\t\tconst result = patternHeader.exec( data );\n\n\t\t\tif ( result !== null ) {\n\n\t\t\t\theaderText = result[ 1 ];\n\n\t\t\t}\n\n\t\t\tconst header = {\n\t\t\t\tcomments: [],\n\t\t\t\telements: [],\n\t\t\t\theaderLength: headerLength,\n\t\t\t\tobjInfo: ''\n\t\t\t};\n\n\t\t\tconst lines = headerText.split( /\\r\\n|\\r|\\n/ );\n\t\t\tlet currentElement;\n\n\t\t\tfunction make_ply_element_property( propertyValues, propertyNameMapping ) {\n\n\t\t\t\tconst property = { type: propertyValues[ 0 ] };\n\n\t\t\t\tif ( property.type === 'list' ) {\n\n\t\t\t\t\tproperty.name = propertyValues[ 3 ];\n\t\t\t\t\tproperty.countType = propertyValues[ 1 ];\n\t\t\t\t\tproperty.itemType = propertyValues[ 2 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tproperty.name = propertyValues[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( property.name in propertyNameMapping ) {\n\n\t\t\t\t\tproperty.name = propertyNameMapping[ property.name ];\n\n\t\t\t\t}\n\n\t\t\t\treturn property;\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\tlet line = lines[ i ];\n\t\t\t\tline = line.trim();\n\n\t\t\t\tif ( line === '' ) continue;\n\n\t\t\t\tconst lineValues = line.split( /\\s+/ );\n\t\t\t\tconst lineType = lineValues.shift();\n\t\t\t\tline = lineValues.join( ' ' );\n\n\t\t\t\tswitch ( lineType ) {\n\n\t\t\t\t\tcase 'format':\n\n\t\t\t\t\t\theader.format = lineValues[ 0 ];\n\t\t\t\t\t\theader.version = lineValues[ 1 ];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'comment':\n\n\t\t\t\t\t\theader.comments.push( line );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'element':\n\n\t\t\t\t\t\tif ( currentElement !== undefined ) {\n\n\t\t\t\t\t\t\theader.elements.push( currentElement );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentElement = {};\n\t\t\t\t\t\tcurrentElement.name = lineValues[ 0 ];\n\t\t\t\t\t\tcurrentElement.count = parseInt( lineValues[ 1 ] );\n\t\t\t\t\t\tcurrentElement.properties = [];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'property':\n\n\t\t\t\t\t\tcurrentElement.properties.push( make_ply_element_property( lineValues, scope.propertyNameMapping ) );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'obj_info':\n\n\t\t\t\t\t\theader.objInfo = line;\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.log( 'unhandled', lineType, lineValues );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( currentElement !== undefined ) {\n\n\t\t\t\theader.elements.push( currentElement );\n\n\t\t\t}\n\n\t\t\treturn header;\n\n\t\t}\n\n\t\tfunction parseASCIINumber( n, type ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'char': case 'uchar': case 'short': case 'ushort': case 'int': case 'uint':\n\t\t\t\tcase 'int8': case 'uint8': case 'int16': case 'uint16': case 'int32': case 'uint32':\n\n\t\t\t\t\treturn parseInt( n );\n\n\t\t\t\tcase 'float': case 'double': case 'float32': case 'float64':\n\n\t\t\t\t\treturn parseFloat( n );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseASCIIElement( properties, tokens ) {\n\n\t\t\tconst element = {};\n\n\t\t\tfor ( let i = 0; i < properties.length; i ++ ) {\n\n\t\t\t\tif ( tokens.empty() ) return null;\n\n\t\t\t\tif ( properties[ i ].type === 'list' ) {\n\n\t\t\t\t\tconst list = [];\n\t\t\t\t\tconst n = parseASCIINumber( tokens.next(), properties[ i ].countType );\n\n\t\t\t\t\tfor ( let j = 0; j < n; j ++ ) {\n\n\t\t\t\t\t\tif ( tokens.empty() ) return null;\n\n\t\t\t\t\t\tlist.push( parseASCIINumber( tokens.next(), properties[ i ].itemType ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\telement[ properties[ i ].name ] = list;\n\n\t\t\t\t} else {\n\n\t\t\t\t\telement[ properties[ i ].name ] = parseASCIINumber( tokens.next(), properties[ i ].type );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn element;\n\n\t\t}\n\n\t\tfunction createBuffer() {\n\n\t\t\tconst buffer = {\n\t\t\t  indices: [],\n\t\t\t  vertices: [],\n\t\t\t  normals: [],\n\t\t\t  uvs: [],\n\t\t\t  faceVertexUvs: [],\n\t\t\t  colors: [],\n\t\t\t  faceVertexColors: []\n\t\t\t};\n\n\t\t\tfor ( const customProperty of Object.keys( scope.customPropertyMapping ) ) {\n\n\t\t\t  buffer[ customProperty ] = [];\n\n\t\t\t}\n\n\t\t\treturn buffer;\n\n\t\t}\n\n\t\tfunction mapElementAttributes( properties ) {\n\n\t\t\tconst elementNames = properties.map( property => {\n\n\t\t\t\treturn property.name;\n\n\t\t\t} );\n\n\t\t\tfunction findAttrName( names ) {\n\n\t\t\t\tfor ( let i = 0, l = names.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst name = names[ i ];\n\n\t\t\t\t\tif ( elementNames.includes( name ) ) return name;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tattrX: findAttrName( [ 'x', 'px', 'posx' ] ) || 'x',\n\t\t\t\tattrY: findAttrName( [ 'y', 'py', 'posy' ] ) || 'y',\n\t\t\t\tattrZ: findAttrName( [ 'z', 'pz', 'posz' ] ) || 'z',\n\t\t\t\tattrNX: findAttrName( [ 'nx', 'normalx' ] ),\n\t\t\t\tattrNY: findAttrName( [ 'ny', 'normaly' ] ),\n\t\t\t\tattrNZ: findAttrName( [ 'nz', 'normalz' ] ),\n\t\t\t\tattrS: findAttrName( [ 's', 'u', 'texture_u', 'tx' ] ),\n\t\t\t\tattrT: findAttrName( [ 't', 'v', 'texture_v', 'ty' ] ),\n\t\t\t\tattrR: findAttrName( [ 'red', 'diffuse_red', 'r', 'diffuse_r' ] ),\n\t\t\t\tattrG: findAttrName( [ 'green', 'diffuse_green', 'g', 'diffuse_g' ] ),\n\t\t\t\tattrB: findAttrName( [ 'blue', 'diffuse_blue', 'b', 'diffuse_b' ] ),\n\t\t\t};\n\n\t\t}\n\n\t\tfunction parseASCII( data, header ) {\n\n\t\t\t// PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n\n\t\t\tconst buffer = createBuffer();\n\n\t\t\tconst patternBody = /end_header\\s+(\\S[\\s\\S]*\\S|\\S)\\s*$/;\n\t\t\tlet body, matches;\n\n\t\t\tif ( ( matches = patternBody.exec( data ) ) !== null ) {\n\n\t\t\t\tbody = matches[ 1 ].split( /\\s+/ );\n\n\t\t\t} else {\n\n\t\t\t\tbody = [ ];\n\n\t\t\t}\n\n\t\t\tconst tokens = new ArrayStream( body );\n\n\t\t\tloop: for ( let i = 0; i < header.elements.length; i ++ ) {\n\n\t\t\t\tconst elementDesc = header.elements[ i ];\n\t\t\t\tconst attributeMap = mapElementAttributes( elementDesc.properties );\n\n\t\t\t\tfor ( let j = 0; j < elementDesc.count; j ++ ) {\n\n\t\t\t\t\tconst element = parseASCIIElement( elementDesc.properties, tokens );\n\n\t\t\t\t\tif ( ! element ) break loop;\n\n\t\t\t\t\thandleElement( buffer, elementDesc.name, element, attributeMap );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn postProcess( buffer );\n\n\t\t}\n\n\t\tfunction postProcess( buffer ) {\n\n\t\t\tlet geometry = new BufferGeometry();\n\n\t\t\t// mandatory buffer data\n\n\t\t\tif ( buffer.indices.length > 0 ) {\n\n\t\t\t\tgeometry.setIndex( buffer.indices );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( buffer.vertices, 3 ) );\n\n\t\t\t// optional buffer data\n\n\t\t\tif ( buffer.normals.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( buffer.normals, 3 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.uvs.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( buffer.uvs, 2 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.colors.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( buffer.colors, 3 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.faceVertexUvs.length > 0 || buffer.faceVertexColors.length > 0 ) {\n\n\t\t\t\tgeometry = geometry.toNonIndexed();\n\n\t\t\t\tif ( buffer.faceVertexUvs.length > 0 ) geometry.setAttribute( 'uv', new Float32BufferAttribute( buffer.faceVertexUvs, 2 ) );\n\t\t\t\tif ( buffer.faceVertexColors.length > 0 ) geometry.setAttribute( 'color', new Float32BufferAttribute( buffer.faceVertexColors, 3 ) );\n\n\t\t\t}\n\n\t\t\t// custom buffer data\n\n\t\t\tfor ( const customProperty of Object.keys( scope.customPropertyMapping ) ) {\n\n\t\t\t\tif ( buffer[ customProperty ].length > 0 ) {\n\n\t\t\t\t  \tgeometry.setAttribute(\n\t\t\t\t\t\tcustomProperty,\n\t\t\t\t\t\tnew Float32BufferAttribute(\n\t\t\t\t\t  \t\tbuffer[ customProperty ],\n\t\t\t\t\t  \t\tscope.customPropertyMapping[ customProperty ].length\n\t\t\t\t\t\t)\n\t\t\t\t  \t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction handleElement( buffer, elementName, element, cacheEntry ) {\n\n\t\t\tif ( elementName === 'vertex' ) {\n\n\t\t\t\tbuffer.vertices.push( element[ cacheEntry.attrX ], element[ cacheEntry.attrY ], element[ cacheEntry.attrZ ] );\n\n\t\t\t\tif ( cacheEntry.attrNX !== null && cacheEntry.attrNY !== null && cacheEntry.attrNZ !== null ) {\n\n\t\t\t\t\tbuffer.normals.push( element[ cacheEntry.attrNX ], element[ cacheEntry.attrNY ], element[ cacheEntry.attrNZ ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( cacheEntry.attrS !== null && cacheEntry.attrT !== null ) {\n\n\t\t\t\t\tbuffer.uvs.push( element[ cacheEntry.attrS ], element[ cacheEntry.attrT ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( cacheEntry.attrR !== null && cacheEntry.attrG !== null && cacheEntry.attrB !== null ) {\n\n\t\t\t\t\t_color.setRGB(\n\t\t\t\t\t\telement[ cacheEntry.attrR ] / 255.0,\n\t\t\t\t\t\telement[ cacheEntry.attrG ] / 255.0,\n\t\t\t\t\t\telement[ cacheEntry.attrB ] / 255.0,\n\t\t\t\t\t\tSRGBColorSpace\n\t\t\t\t\t);\n\n\t\t\t\t\tbuffer.colors.push( _color.r, _color.g, _color.b );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( const customProperty of Object.keys( scope.customPropertyMapping ) ) {\n\n\t\t\t\t\tfor ( const elementProperty of scope.customPropertyMapping[ customProperty ] ) {\n\n\t\t\t\t\t  buffer[ customProperty ].push( element[ elementProperty ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( elementName === 'face' ) {\n\n\t\t\t\tconst vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338\n\t\t\t\tconst texcoord = element.texcoord;\n\n\t\t\t\tif ( vertex_indices.length === 3 ) {\n\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 2 ] );\n\n\t\t\t\t\tif ( texcoord && texcoord.length === 6 ) {\n\n\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 0 ], texcoord[ 1 ] );\n\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 2 ], texcoord[ 3 ] );\n\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 4 ], texcoord[ 5 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( vertex_indices.length === 4 ) {\n\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 3 ] );\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 1 ], vertex_indices[ 2 ], vertex_indices[ 3 ] );\n\n\t\t\t\t}\n\n\t\t\t\t// face colors\n\n\t\t\t\tif ( cacheEntry.attrR !== null && cacheEntry.attrG !== null && cacheEntry.attrB !== null ) {\n\n\t\t\t\t\t_color.setRGB(\n\t\t\t\t\t\telement[ cacheEntry.attrR ] / 255.0,\n\t\t\t\t\t\telement[ cacheEntry.attrG ] / 255.0,\n\t\t\t\t\t\telement[ cacheEntry.attrB ] / 255.0,\n\t\t\t\t\t\tSRGBColorSpace\n\t\t\t\t\t);\n\t\t\t\t\tbuffer.faceVertexColors.push( _color.r, _color.g, _color.b );\n\t\t\t\t\tbuffer.faceVertexColors.push( _color.r, _color.g, _color.b );\n\t\t\t\t\tbuffer.faceVertexColors.push( _color.r, _color.g, _color.b );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction binaryReadElement( at, properties ) {\n\n\t\t\tconst element = {};\n\t\t\tlet read = 0;\n\n\t\t\tfor ( let i = 0; i < properties.length; i ++ ) {\n\n\t\t\t\tconst property = properties[ i ];\n\t\t\t\tconst valueReader = property.valueReader;\n\n\t\t\t\tif ( property.type === 'list' ) {\n\n\t\t\t\t\tconst list = [];\n\n\t\t\t\t\tconst n = property.countReader.read( at + read );\n\t\t\t\t\tread += property.countReader.size;\n\n\t\t\t\t\tfor ( let j = 0; j < n; j ++ ) {\n\n\t\t\t\t\t\tlist.push( valueReader.read( at + read ) );\n\t\t\t\t\t\tread += valueReader.size;\n\n\t\t\t\t\t}\n\n\t\t\t\t\telement[ property.name ] = list;\n\n\t\t\t\t} else {\n\n\t\t\t\t\telement[ property.name ] = valueReader.read( at + read );\n\t\t\t\t\tread += valueReader.size;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn [ element, read ];\n\n\t\t}\n\n\t\tfunction setPropertyBinaryReaders( properties, body, little_endian ) {\n\n\t\t\tfunction getBinaryReader( dataview, type, little_endian ) {\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t// correspondences for non-specific length types here match rply:\n\t\t\t\t\tcase 'int8':\tcase 'char':\treturn { read: ( at ) => {\n\n\t\t\t\t\t\treturn dataview.getInt8( at );\n\n\t\t\t\t\t}, size: 1 };\n\t\t\t\t\tcase 'uint8':\tcase 'uchar':\treturn { read: ( at ) => {\n\n\t\t\t\t\t\treturn dataview.getUint8( at );\n\n\t\t\t\t\t}, size: 1 };\n\t\t\t\t\tcase 'int16':\tcase 'short':\treturn { read: ( at ) => {\n\n\t\t\t\t\t\treturn dataview.getInt16( at, little_endian );\n\n\t\t\t\t\t}, size: 2 };\n\t\t\t\t\tcase 'uint16':\tcase 'ushort':\treturn { read: ( at ) => {\n\n\t\t\t\t\t\treturn dataview.getUint16( at, little_endian );\n\n\t\t\t\t\t}, size: 2 };\n\t\t\t\t\tcase 'int32':\tcase 'int':\t\treturn { read: ( at ) => {\n\n\t\t\t\t\t\treturn dataview.getInt32( at, little_endian );\n\n\t\t\t\t\t}, size: 4 };\n\t\t\t\t\tcase 'uint32':\tcase 'uint':\treturn { read: ( at ) => {\n\n\t\t\t\t\t\treturn dataview.getUint32( at, little_endian );\n\n\t\t\t\t\t}, size: 4 };\n\t\t\t\t\tcase 'float32': case 'float':\treturn { read: ( at ) => {\n\n\t\t\t\t\t\treturn dataview.getFloat32( at, little_endian );\n\n\t\t\t\t\t}, size: 4 };\n\t\t\t\t\tcase 'float64': case 'double':\treturn { read: ( at ) => {\n\n\t\t\t\t\t\treturn dataview.getFloat64( at, little_endian );\n\n\t\t\t\t\t}, size: 8 };\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = properties.length; i < l; i ++ ) {\n\n\t\t\t\tconst property = properties[ i ];\n\n\t\t\t\tif ( property.type === 'list' ) {\n\n\t\t\t\t\tproperty.countReader = getBinaryReader( body, property.countType, little_endian );\n\t\t\t\t\tproperty.valueReader = getBinaryReader( body, property.itemType, little_endian );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tproperty.valueReader = getBinaryReader( body, property.type, little_endian );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseBinary( data, header ) {\n\n\t\t\tconst buffer = createBuffer();\n\n\t\t\tconst little_endian = ( header.format === 'binary_little_endian' );\n\t\t\tconst body = new DataView( data, header.headerLength );\n\t\t\tlet result, loc = 0;\n\n\t\t\tfor ( let currentElement = 0; currentElement < header.elements.length; currentElement ++ ) {\n\n\t\t\t\tconst elementDesc = header.elements[ currentElement ];\n\t\t\t\tconst properties = elementDesc.properties;\n\t\t\t\tconst attributeMap = mapElementAttributes( properties );\n\n\t\t\t\tsetPropertyBinaryReaders( properties, body, little_endian );\n\n\t\t\t\tfor ( let currentElementCount = 0; currentElementCount < elementDesc.count; currentElementCount ++ ) {\n\n\t\t\t\t\tresult = binaryReadElement( loc, properties );\n\t\t\t\t\tloc += result[ 1 ];\n\t\t\t\t\tconst element = result[ 0 ];\n\n\t\t\t\t\thandleElement( buffer, elementDesc.name, element, attributeMap );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn postProcess( buffer );\n\n\t\t}\n\n\t\tfunction extractHeaderText( bytes ) {\n\n\t\t\tlet i = 0;\n\t\t\tlet cont = true;\n\n\t\t\tlet line = '';\n\t\t\tconst lines = [];\n\n\t\t\tconst startLine = new TextDecoder().decode( bytes.subarray( 0, 5 ) );\n\t\t\tconst hasCRNL = /^ply\\r\\n/.test( startLine );\n\n\t\t\tdo {\n\n\t\t\t\tconst c = String.fromCharCode( bytes[ i ++ ] );\n\n\t\t\t\tif ( c !== '\\n' && c !== '\\r' ) {\n\n\t\t\t\t\tline += c;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( line === 'end_header' ) cont = false;\n\t\t\t\t\tif ( line !== '' ) {\n\n\t\t\t\t\t\tlines.push( line );\n\t\t\t\t\t\tline = '';\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} while ( cont && i < bytes.length );\n\n\t\t\t// ascii section using \\r\\n as line endings\n\t\t\tif ( hasCRNL === true ) i ++;\n\n\t\t\treturn { headerText: lines.join( '\\r' ) + '\\r', headerLength: i };\n\n\t\t}\n\n\t\t//\n\n\t\tlet geometry;\n\t\tconst scope = this;\n\n\t\tif ( data instanceof ArrayBuffer ) {\n\n\t\t\tconst bytes = new Uint8Array( data );\n\t\t\tconst { headerText, headerLength } = extractHeaderText( bytes );\n\t\t\tconst header = parseHeader( headerText, headerLength );\n\n\t\t\tif ( header.format === 'ascii' ) {\n\n\t\t\t\tconst text = new TextDecoder().decode( bytes );\n\n\t\t\t\tgeometry = parseASCII( text, header );\n\n\t\t\t} else {\n\n\t\t\t\tgeometry = parseBinary( data, header );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tgeometry = parseASCII( data, parseHeader( data ) );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n}\n\nclass ArrayStream {\n\n\tconstructor( arr ) {\n\n\t\tthis.arr = arr;\n\t\tthis.i = 0;\n\n\t}\n\n\tempty() {\n\n\t\treturn this.i >= this.arr.length;\n\n\t}\n\n\tnext() {\n\n\t\treturn this.arr[ this.i ++ ];\n\n\t}\n\n}\n\nexport { PLYLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}